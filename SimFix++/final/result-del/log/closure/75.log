=================================================
Project : closure_75	start : 18/01/15 19:12
Current failed test : com.google.javascript.jscomp.PeepholeFoldConstantsTest::testIEString | 18/01/15 19:13
Mon Jan 15 19:27:42 AEDT 2018 com.google.javascript.rhino.Node,1371
Mon Jan 15 19:28:10 AEDT 2018 com.google.javascript.rhino.Node,1400
Mon Jan 15 19:28:22 AEDT 2018 com.google.javascript.rhino.Node,1413
Mon Jan 15 19:28:33 AEDT 2018 Mon Jan 15 19:28:33 AEDT 2018 : com.google.javascript.rhino.Node,2247=>Find no block
Mon Jan 15 19:28:38 AEDT 2018 com.google.javascript.rhino.Node,2248
Mon Jan 15 19:28:50 AEDT 2018 com.google.javascript.rhino.Node,2249
Mon Jan 15 19:28:55 AEDT 2018 Mon Jan 15 19:28:55 AEDT 2018 : com.google.javascript.rhino.Node,2250=>Find no block
Mon Jan 15 19:28:59 AEDT 2018 com.google.javascript.jscomp.NodeUtil,375
Mon Jan 15 19:29:25 AEDT 2018 com.google.javascript.jscomp.NodeUtil,364
Mon Jan 15 19:34:04 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,355
Mon Jan 15 19:53:15 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,357
Mon Jan 15 19:53:20 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,358
Mon Jan 15 19:53:25 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,359
Mon Jan 15 19:53:30 AEDT 2018 com.google.javascript.jscomp.NodeUtil,301
Mon Jan 15 20:05:44 AEDT 2018 com.google.javascript.jscomp.NodeUtil,315
Mon Jan 15 20:09:23 AEDT 2018 com.google.javascript.jscomp.NodeUtil,317
Mon Jan 15 20:12:44 AEDT 2018 com.google.javascript.jscomp.NodeUtil,321
Mon Jan 15 20:18:43 AEDT 2018 com.google.javascript.jscomp.NodeUtil,332
Mon Jan 15 20:24:27 AEDT 2018 com.google.javascript.jscomp.NodeUtil,342
Mon Jan 15 20:32:24 AEDT 2018 com.google.javascript.jscomp.NodeUtil,349
Mon Jan 15 20:40:09 AEDT 2018 com.google.javascript.jscomp.NodeUtil,356
Mon Jan 15 21:23:03 AEDT 2018 com.google.javascript.jscomp.NodeUtil,357
Mon Jan 15 21:23:06 AEDT 2018 Mon Jan 15 21:23:06 AEDT 2018 : com.google.javascript.jscomp.NodeUtil,359=>Find no block
Mon Jan 15 21:23:10 AEDT 2018 Mon Jan 15 21:23:10 AEDT 2018 : com.google.javascript.jscomp.NodeUtil,363=>Find no block
Mon Jan 15 21:23:14 AEDT 2018 com.google.javascript.jscomp.NodeUtil,366
Mon Jan 15 21:23:19 AEDT 2018 Mon Jan 15 21:23:19 AEDT 2018 : com.google.javascript.jscomp.NodeUtil,373=>Find no block
Mon Jan 15 21:23:23 AEDT 2018 com.google.javascript.jscomp.NodeUtil,387
Mon Jan 15 21:24:28 AEDT 2018 com.google.javascript.jscomp.CodeGenerator,1019
Mon Jan 15 21:28:06 AEDT 2018 com.google.javascript.jscomp.CodeGenerator,1128
Mon Jan 15 21:28:19 AEDT 2018 Mon Jan 15 21:28:19 AEDT 2018 : com.google.javascript.jscomp.CodeGenerator,1132=>Find no block
Mon Jan 15 21:28:24 AEDT 2018 Mon Jan 15 21:28:24 AEDT 2018 : com.google.javascript.jscomp.CodeGenerator,1133=>Find no block
Mon Jan 15 21:28:28 AEDT 2018 com.google.javascript.jscomp.CodeGenerator,1145
Mon Jan 15 21:30:05 AEDT 2018 com.google.javascript.jscomp.CodeGenerator,1155
Mon Jan 15 21:36:37 AEDT 2018 Mon Jan 15 21:36:37 AEDT 2018 : com.google.javascript.jscomp.CodeGenerator,1160=>Find no block
Mon Jan 15 21:36:41 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,261

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.RETURN){
return ;
}
if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 21:45
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.RETURN){
return ;
}
if(value!=Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 21:49
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 21:56
----------------------------------------
Mon Jan 15 21:59:50 AEDT 2018 com.google.javascript.jscomp.NodeUtil,2141
Mon Jan 15 22:00:15 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,250

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(result!=null){
return ;
}
double value=result;
Node replacement;

Time : 18/01/15 22:02
----------------------------------------
Mon Jan 15 22:06:22 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,253

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 22:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.CALL){
return ;
}
if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 22:20
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 22:29
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.NAME){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 22:38
----------------------------------------
Mon Jan 15 22:44:03 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,255
Mon Jan 15 22:44:07 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,257
Mon Jan 15 22:44:12 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,264

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 22:48
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.RETURN){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 22:59
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.CALL){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:03
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(replacement.getType()!=Token.STRING){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:06
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.CALL){
return ;
}
if(n.getFirstChild().getType()!=Token.GETPROP){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.CALL){
return ;
}
if(replacement.getType()!=Token.STRING){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.CALL){
return ;
}
if(n.getFirstChild().getType()!=Token.GETPROP){
return ;
}
if(replacement.getType()!=Token.STRING){
return ;
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:17
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.NAME){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:22
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.CALL){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/15 23:29
----------------------------------------
Mon Jan 15 23:35:09 AEDT 2018 com.google.javascript.jscomp.PeepholeFoldConstants,265

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 23:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]

Time : 18/01/15 23:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Token.AND){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 23:45
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value!=Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 23:50
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(result==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/15 23:56
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(result==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/16 00:00
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(result==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(result==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/16 00:04
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
NodeUtil.redeclareVarsInsideBranch(n);
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}

Time : 18/01/16 00:15
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
n.getParent().replaceChild(n,replacement);
reportCodeChange();

Time : 18/01/16 00:20
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(n.getType()!=Token.FUNCTION){
return ;
}
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
n.getParent().replaceChild(n,replacement);

Time : 18/01/16 00:24
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(Double.isNaN(value)){
replacement=Node.newString(Token.NAME,"NaN");
}else if(value==Double.POSITIVE_INFINITY){
replacement=Node.newString(Token.NAME,"Infinity");
}else if(value==Double.NEGATIVE_INFINITY){
replacement=new Node(Token.NEG,Node.newString(Token.NAME,"Infinity"));
replacement.copyInformationFromForTree(n);
}else {
replacement=Node.newNumber(value);
}
if(n.getType()!=Token.RETURN){
return ;
}
n.getParent().replaceChild(n,replacement);
reportCodeChange();

Time : 18/01/16 00:27
----------------------------------------
Timeout time : 18/01/16 00:31
