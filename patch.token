{ super . setZoneRetainFields ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new JodaTimePermission ( STRING_CONSTANT ) ) ; }
{ return getAsText ( null ) ; }
public abstract DurationField getLeapDurationField ( ) ;
public abstract boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () , DateTimeZone.UTC ) ) ;
{ super ( instant ) ; }
{ super ( chronology ) ; }
public TimeOfDay () { super(); }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
return ( getMillis () < readableInstant . getMillis () ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
ReadablePartial instant
public abstract int getMaximumValue ( ReadablePartial instant ) ;
ReadablePartial instant
public abstract int getMinimumValue ( ReadablePartial instant ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
ReadablePartial partial
public DateTimeField getField () { return iYearMonthDay . getField ( iFieldIndex ) ; }
{ return getField () . getMaximumValue ( getReadablePartial () ) ; }
{ return getField () . getMinimumValue ( getReadablePartial () ) ; }
{ return getField () . getAsShortText ( getReadablePartial () , get () , locale ) ; }
{ return getField () . getAsText ( getReadablePartial () , get () , locale ) ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMaximumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { throw unsupported () ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial partial
ReadablePartial partial
{ test1 . millisOfSecond () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getReadablePartial () ) ;
{ test1 . secondOfMinute () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getReadablePartial () ) ;
{ test1 . minuteOfHour () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getReadablePartial () ) ;
{ test1 . hourOfDay () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public int getMinimumValue ( ReadablePartial instant ) { return NUMBER_CONSTANT ; }
ReadablePartial instant
void validate ( ReadablePartial instant ) ;
public DateTimeField getField () { return iTimeOfDay . getField ( iFieldIndex ) ; }
ReadablePartial instant
ReadablePartial instant
{ test1 . dayOfMonth () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getReadablePartial () ) ;
{ test1 . monthOfYear () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getReadablePartial () ) ;
{ test1 . year () . compareTo ( ( ReadablePartial ) null ) ; fail () ; }
assertSame ( test , test . year () . getReadablePartial () ) ;
assertEquals ( false , test1 . equals ( MockPartial.EMPTY_INSTANCE ) ) ;
public int getMaximumValue ( ReadablePartial instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( ReadablePartial instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( ReadablePartial instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( ReadablePartial instant ) { return iField . getMinimumValue ( instant ) ; }
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
ReadablePartial instant
public String getAsShortText ( ReadablePartial partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
ReadablePartial partial
public String getAsText ( ReadablePartial partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
ReadablePartial partial
ReadablePartial instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = selectChronology ( converter . getChronology ( instant , chronology ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant , zone ) ) ;
iChronology = selectChronology ( converter . getChronology ( instant ) ) ;
{ return DurationType . getMillisType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField millis () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField seconds () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField minutes () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField hours () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField days () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField weeks () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField months () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public DurationField years () { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
public abstract boolean isSupported ( ) ;
assertSame ( test , test . dayOfMonth () . getReadableInstant () ) ;
assertSame ( test , test . monthOfYear () . getReadableInstant () ) ;
assertSame ( test , test . year () . getReadableInstant () ) ;
assertSame ( test , test . yearOfCentury () . getReadableInstant () ) ;
assertSame ( test , test . centuryOfEra () . getReadableInstant () ) ;
assertSame ( test , test . yearOfEra () . getReadableInstant () ) ;
assertSame ( test , test . era () . getReadableInstant () ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getReadableInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
try { iChrono . era () . addWrapField ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = round ( converter . getInstantMillis ( instant , chronology ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant , zone ) , iChronology ) ;
iMillis = round ( converter . getInstantMillis ( instant ) , iChronology ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = round ( instant , iChronology ) ; }
{ setMillis ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
NullConverter.INSTANCE . setInto ( m , null ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
withUTC () . dayOfYear () . remainder ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateMidnightMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone4 ) ) ;
private DateTimeUtils () { super(); }
protected DateTimeUtils () { super(); }
int size () { return iConverters.length ; }
assertTrue ( set != result ) ;
catch ( IllegalStateException ex ) {}
assertEquals ( ( NUMBER_CONSTANT - NUMBER_CONSTANT ) * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( NUMBER_CONSTANT , type ) ;
public String toString () { return STRING_CONSTANT ; }
{ if ( chrono == getChronology () ) { return this ; } return MaskedType . mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearWeekType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getYearMonthType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAllType ( chrono ) ; }
{ if ( chrono == iChronology ) { return this ; } return DurationType . getAverageYearMonthType ( chrono ) ; }
if ( isPrecise () ) { return FieldUtils . safeAdd ( instant , getTotalMillis () * scalar ) ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
{ duration = duration . withDurationTypeUsingTotalMillis ( type ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( startInstant , endInstant , type , false ) ; }
{ super ( startInstant , endInstant , null , false ) ; }
{ super ( duration , type , false ) ; }
{ super ( duration , null , false ) ; }
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getAllType () , Duration.ZERO . getDurationType () ) ; }
YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
YearWeekType ( Chronology chrono ) { super ( chrono ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( null , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( id , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstance () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration , totalMillisMaster ) : type ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( type , type . withChronology ( ISOChronology . getInstance () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , type . getChronology () ) ;
ReadWritableTimePeriod duration
{ return ( ( ReadableDuration ) object ) . getMillis () ; }
{ return true ; }
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
{ try { new MutableTimePeriod ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableTimePeriod test = new MutableTimePeriod ( null , false ) ;
MutableTimePeriod test = new MutableTimePeriod ( null , true ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
public void setInto ( ReadWritableTimePeriod duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = TimePeriod.ZERO ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( DURATION_SIZE , array.length ) ; }
assertEquals ( DURATION_SIZE , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . toDurationMillis () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
PeriodType type
PeriodType type
{ return new TimePeriod ( toDurationMillis () , getPeriodType () ) ; }
PeriodType type
PeriodType type
PeriodType type
PeriodType type
suite . addTest ( TestPeriodType . suite () ) ;
{ add ( new TimePeriod ( duration , getPeriodType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getPeriodType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getPeriodType () ) ) ; } }
final PeriodType type = iType ;
PeriodType type
PeriodType type
PeriodType type
PeriodType type
int hash = getPeriodType () . hashCode () ;
PeriodType type = iType ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
public TestPeriodType ( String name ) { super ( name ) ; }
PeriodType type
PeriodType type
PeriodType type
PeriodType type
PeriodType type = period . getPeriodType () ;
PeriodType type
if ( ! mustParse && ! isSupported ( period . getPeriodType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getDayHourType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getPreciseAllType () , test . getPeriodType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
PeriodType type
PeriodType type
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getPeriodType () , str ) ; }
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( PeriodType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
assertEquals ( test . getPeriodType () , copy . getPeriodType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( PeriodType . getMillisType () ) ;
ReadablePeriod period
ReadablePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new Period ( PeriodType . getMillisType () ) ) ;
MutablePeriod result = test . toMutableTimePeriod () ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod () ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
Period test = new Period ( STRING_CONSTANT ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( dt1 , dt2 ) ;
Period test = new Period ( length , null ) ;
Period test = new Period ( length ) ;
Period test = new Period ( length ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( NUMBER_CONSTANT ) ;
ReadablePeriod period
ReadablePeriod period
public void testSetDuration_RD () { setPeriod ( ( ReadableDuration ) null ) ; }
Period test = new Period ( NUMBER_CONSTANT ) ;
Period test = new Period ( NUMBER_CONSTANT ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutablePeriod test = new MutablePeriod ( STRING_CONSTANT ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( dt1 , dt2 ) ;
MutablePeriod test = new MutablePeriod ( length , null ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod ( length ) ;
MutablePeriod test = new MutablePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iPeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadablePeriod period
ReadablePeriod period
Period duration ;
Class cls = ReadablePeriodConverter . class ;
public void testSetPeriod_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetPeriod_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD_1 () { setDuration ( null ) ; }
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearDayType ( chrono ) ; }
{ return PRECISE_ALL ; }
{ return PRECISE_YEAR_WEEK ; }
{ return PRECISE_YEAR_MONTH ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekTypeUTC () ; }
{ return YEAR_WEEK ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthTypeUTC () ; }
{ return YEAR_MONTH ; }
public static PeriodType getYearDayType () { return YEAR_DAY ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllTypeUTC () ; }
{ return ALL ; }
public static PeriodType getMillisType () { return MILLIS ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
public Duration ( long duration ) { super(); iMillis = duration ; }
protected AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getEndMillis () , - durationMillis ) ) ; }
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( dt1 , dt2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME2 ) ;
Object duration
public Duration ( long duration ) { super ( duration ) ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setEndMillis ( endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setStartMillis ( startMillis ) ; }
{ super . setStartMillis ( startInstant ) ; }
public void normalize () { setPeriod ( toDurationMillis () ) ; }
{ return new MutableDateTime ( getMillis () , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( getMillis () ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setMillis ( instant ) ; }
{ super ( partial , values ) ; }
{ super ( partial , values ) ; }
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
BaseGJChronology chronology
BaseGJChronology chronology
GJYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
BaseGJChronology chrono = iChronology ;
CopticYearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJWeekyearDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
NoWeekyearZeroField ( BaseGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
BaseGJChronology chronology
public static TestSuite suite () { return new TestSuite ( TestParseISO . class ) ; }
public static TestSuite suite () { return new TestSuite ( TestDateTimeConstants . class ) ; }
{ millis = getField ( i , chrono ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SimpleAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SimpleAffix ( text ) ) ; }
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix affix ;
PeriodFieldAffix suffix
int scan ( String periodStr , int position ) ;
int parse ( String periodStr , int position ) ;
PeriodFieldAffix suffix
PeriodFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) != Long.MAX_VALUE ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( SECONDS_OPTIONAL_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( SECONDS_MILLIS ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( SECONDS ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( MINUTES ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( HOURS ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( DAYS ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( WEEKS ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( MONTHS ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( YEARS ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( DateTimeFieldType . hourOfDay () , DateTimeFieldType . dayOfYear () ) ;
DateTimeFieldType lowerLimit
public static DateTimeComparator getInstance () { return ALL_INSTANCE ; }
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( DateTimeFieldType . millisOfSecond () , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
super ( gregorianField . getType () ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekOfWeekyear () , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , DateTimeFieldType . yearOfEra () ) ; }
{ super ( DateTimeFieldType . dayOfWeek () , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getType () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
super ( field . getType () ) ;
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfYear () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . dayOfMonth () , days ) ; iChronology = chronology ; }
{ super ( DateTimeFieldType . monthOfYear () , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . era () , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . centuryOfEra () , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfCentury () , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . yearOfEra () , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . year () , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . monthOfYear () , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekyear () , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . weekOfWeekyear () , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfYear () , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfMonth () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . dayOfWeek () , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfHalfday () , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfHalfday () , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . clockhourOfDay () , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . hourOfDay () , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfDay () , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . minuteOfHour () , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfDay () , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . secondOfMinute () , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfDay () , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . millisOfSecond () , millis () ) ; }
{ super ( yearField , DateTimeFieldType . yearOfEra () ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getType () ) ; iField = dateTimeField ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , halfdays () ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getType () ) ;
{ super ( DateTimeFieldType . year () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . millis () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . seconds () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . minutes () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . hours () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . days () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . weeks () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . months () ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( DurationFieldType . years () ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , DurationFieldType . months () , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , DurationFieldType . years () , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , chrono . millisPerMonth () , chrono ) ; }
public int size () { return NUMBER_CONSTANT ; }
int [] values = new int [ size () ] ;
int i = NUMBER_CONSTANT , isize = size ()
{ return getAsShortText ( partial , partial . get ( getType () ) , locale ) ; }
{ return getAsText ( partial , partial . get ( getType () ) , locale ) ; }
public int size () { return NUMBER_CONSTANT ; }
int size ( ) ;
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
partial . isSupported ( iField . getType () )
public int size () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA_TYPE ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA_TYPE ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA_TYPE ; }
public static DateTimeFieldType year () { return YEAR_TYPE ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR_TYPE ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY_TYPE ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR_TYPE ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR_TYPE ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR_TYPE ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH_TYPE ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK_TYPE ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY_TYPE ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY_TYPE ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY_TYPE ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR_TYPE ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY_TYPE ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE_TYPE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY_TYPE ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND_TYPE ; }
int otherValue = getFieldType () . getField ( chrono ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS_TYPE ; }
public static DurationFieldType centuries () { return CENTURIES_TYPE ; }
public static DurationFieldType years () { return YEARS_TYPE ; }
public static DurationFieldType months () { return MONTHS_TYPE ; }
public static DurationFieldType weekyears () { return WEEKYEARS_TYPE ; }
public static DurationFieldType weeks () { return WEEKS_TYPE ; }
public static DurationFieldType days () { return DAYS_TYPE ; }
public static DurationFieldType halfdays () { return HALFDAYS_TYPE ; }
public static DurationFieldType hours () { return HOURS_TYPE ; }
public static DurationFieldType minutes () { return MINUTES_TYPE ; }
public static DurationFieldType seconds () { return SECONDS_TYPE ; }
public static DurationFieldType millis () { return MILLIS_TYPE ; }
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isAfter ( ( ReadableInstant ) null ) ) ;
assertEquals ( false , test . isBefore ( ( ReadableInstant ) null ) ) ;
{ if ( instant == null ) { return isAfterNow () ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBeforeNow () ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return containsNow () ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . standard () ) ;
Period result = test . withPeriodType ( PeriodType . standard () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . standard () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . millis () ) ;
{ super . setField ( DurationFieldType . millis () , millis ) ; }
{ super . setField ( DurationFieldType . seconds () , seconds ) ; }
{ super . setField ( DurationFieldType . minutes () , minutes ) ; }
{ super . setField ( DurationFieldType . hours () , hours ) ; }
{ super . setField ( DurationFieldType . days () , days ) ; }
{ super . setField ( DurationFieldType . weeks () , weeks ) ; }
{ super . setField ( DurationFieldType . months () , months ) ; }
{ super . setField ( DurationFieldType . years () , years ) ; }
{ setPeriod ( duration , null ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type , null ) ; }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . dayTime () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . standard () , test . getPeriodType () ) ; }
{ super ( period , type , null ) ; }
{ super ( period , null , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
assertEquals ( PeriodType . standard () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( ( ReadableInstant ) null ) ; fail () ; }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( chrono . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( chrono . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
assertEquals ( PeriodType . standard () , test . getPeriodType () ) ;
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , millis } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , seconds , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , minutes , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , hours , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , days , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT , weeks , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
return new Period ( new int [] { NUMBER_CONSTANT , months , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () ) ;
new Period ( new int [] { years , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , PeriodType . standard () )
{ duration . setPeriod ( ( Period ) null ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
{ super . setInterval ( getStartMillis () , endInstant , getChronology () ) ; }
{ super . setInterval ( startInstant , getEndMillis () , getChronology () ) ; }
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( INTERVAL_SIZE , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( INTERVAL_SIZE , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . toDuration () ;
public long toDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
DateTime getEnd ( ) ;
DateTime getStart ( ) ;
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
Interval result = test . withEnd ( null ) ;
{ test . withEnd ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEnd ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStart ( null ) ;
{ test . withStart ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStart ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . toDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . toDurationMillis () ; }
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , millis ) ;
iValues = chronology . get ( this , instant ) ;
long resolved = chrono . set ( this , instantMillis ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return chrono . set ( this , baseInstant ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( period , getMillis () , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( period , iEndMillis , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( period , iStartMillis , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( period , getMillis () , scalar ) ;
{ if ( period == null ) { setValues ( new int [ size () ] ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( this , startMillis , NUMBER_CONSTANT ) ;
iValues = chrono . get ( this , startMillis , endMillis ) ;
{ setStartMillis ( getChronology () . add ( period , getEndMillis () , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( period , getStartMillis () , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { super . addPeriod ( period ) ; } }
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return withMillis ( getChronology () . set ( partial , getMillis () ) ) ; }
DateTime result = test . toDateTimeUsing ( null ) ;
{ long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ; printTo ( null , out , millis ) ; }
long millis = this . iChrono . withUTC () . set ( partial , NUMBER_CONSTANT ) ;
DateTime result = test . toDateTimeUsing ( null ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type , getChronology () ) ; }
{ return new Period ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () , getChronology () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant , getChronology () ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () , getChronology () ) ; }
{ test . set ( DateTimeFieldType . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( DateTimeFieldType . year () , NUMBER_CONSTANT ) ;
Object f
Object f
Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( DateTimeFieldType . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( DateTimeFieldType . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( DateTimeFieldType . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( DateTimeFieldType . halfdayOfDay () ) ; }
String text
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
public MutableDateTime parseMutableDateTime ( String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( String text ) { return mParser . parseMillis ( text ) ; }
public String print ( long instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
FParser ( DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( String text ) { throw unsupported () ; }
public DateTime parseDateTime ( String text ) { throw unsupported () ; }
public long parseMillis ( String text ) { throw unsupported () ; }
public String print ( long instant ) { return mPrinter . print ( instant ) ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( PARTIAL_SIZE , array.length ) ; }
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( PARTIAL_SIZE , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadablePartialConverter.INSTANCE , ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
throw new InternalError () ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , UnsupportedDurationField . getInstance ( getDurationType () ) ) ; }
throw new InternalError () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , - NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
{ return FieldUtils . safeMultiply ( value , getUnitMillis () ) ; }
{ return FieldUtils . safeMultiply ( value , iUnitMillis ) ; }
BaseDateTimeField field = new MockStandardBaseDateTimeField () ;
PreciseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance ( chrono ) . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( DateTimeZone . getDefault () , DateTimeUtils . getZone ( null ) ) ; }
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
{ convId = printTimeZone ( offset ) ; return fixedOffsetZone ( convId , offset ) ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iLocale ) ;
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ;
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
ParseBucket bucket = new ParseBucket ( NUMBER_CONSTANT , chrono ) ;
ParseBucket bucket = new ParseBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return true ; }
iFieldType >= SECONDS_MILLIS
{ return appendSeparator ( text , finalText , null , true , true ) ; }
{ return appendSeparator ( text , text , null , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId , ISOChronology . getInstance ( UTC ) ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id , ISOChronology . getInstance ( UTC ) ) ;
int itimeStyle = selectStyle ( timeStyle ) ;
DateTimeField field = iFieldType . getField ( chronoLocal ) ;
return printOffset ( getOffset ( instant ) ) ;
return printOffset ( getOffset ( instant ) ) ;
String id = printOffset ( offset ) ;
return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( ( ( DateTimeParser ) this ) . parseMillis ( text , chrono ) , chrono ) ; }
return ( ( DateTimePrinter ) this ) . print ( millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( out , millis , chrono ) ;
( ( DateTimePrinter ) this ) . printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return iParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return iParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return iParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return iParser . parseDateTime ( text , chrono ) ; }
{ return iParser . parseMillis ( text , instant , chrono ) ; }
{ return iParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return iPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return iPrinter . print ( instant , zone ) ; }
{ iPrinter . printTo ( out , instant , chrono ) ; }
{ iPrinter . printTo ( buf , instant , chrono ) ; }
{ iPrinter . printTo ( out , instant , zone ) ; }
{ iPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { iPrinter . printTo ( out , instant ) ; }
{ iPrinter . printTo ( out , instant ) ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
public int estimateParsedLength () { return iParsedLengthEstimate ; }
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
public int estimatePrintedLength () { return iPrintedLengthEstimate ; }
DateTimeFormatter [] printers
public int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimateParsedLength () { return iMaxDigits ; }
public int estimatePrintedLength () { return iMaxDigits ; }
public int estimateParsedLength () { return estimatePrintedLength () ; }
public int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return NUMBER_CONSTANT ; }
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimatePrintedLength () { return iMaxParsedDigits ; }
public int estimateParsedLength () { return iMaxParsedDigits ; }
DateTimeParserBucket bucket
public int estimateParsedLength () { return NUMBER_CONSTANT ; }
PeriodFormatter [] parsers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
PeriodFormatter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getMillis () ) ; }
{ return getField () . getMaximumValue ( getMillis () ) ; }
{ return getField () . getMinimumValue ( getMillis () ) ; }
{ return getField () . getLeapAmount ( getMillis () ) ; }
{ return getField () . isLeap ( getMillis () ) ; }
{ return getField () . getAsShortText ( getMillis () , locale ) ; }
{ return getField () . getAsText ( getMillis () , locale ) ; }
{ return getField () . get ( getMillis () ) ; }
if ( value == getValue ( index ) ) { return this ; }
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . forTimeZone ( cal . getTimeZone () ) ; }
DateTimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . forID ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . forID ( id ) ) ;
z = DateTimeZone . forID ( str ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . forID ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) TestGJChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , TestGJChronology.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . withChronology ( chrono ) . parseMillis ( str ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . withLocale ( locale ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . withZone ( iZone ) . print ( millis ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
parse ( ISODateTimeFormat . dateTimeParser () ) ;
DateTimeFormatter p
DateTimePrinter [] printers
{ return append0 ( new TimeZoneOffset ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
DateTimeFormatter p = ISODateTimeFormat . hourMinuteSecondFraction () ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
bucket . saveField ( iType , year ) ;
append0 ( field , field ) ;
append0 ( literal , literal ) ;
append0 ( formatter . getPrinter () , formatter . getParser () ) ;
PeriodFormatter formatter = toFormatter ( iElementPairs ) ;
public PeriodParser toParser () { return toFormatter () . getParser () ; }
public PeriodPrinter toPrinter () { return toFormatter () . getPrinter () ; }
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
f = ISOPeriodFormat . standard () ;
{ return ISOPeriodFormat . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . standard () ;
PeriodFormatter parser = ISOPeriodFormat . standard () ;
InputStream in = new ByteArrayInputStream ( data . getBytes ( STRING_CONSTANT ) ) ;
PeriodFormatter parser = PeriodFormat . getDefault () ;
Locale locale
Locale locale
Locale locale
Locale locale
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new GJYearDateTimeField ( this ) ;
fields.year = new CopticYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone , iPivotYear ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone , iPivotYear ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null , iPivotYear ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone , iPivotYear ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
assertEquals ( ISO_UTC , test . getChronology () ) ;
{ return appendTwoDigitWeekyear ( pivot , false ) ; }
{ return appendTwoDigitYear ( pivot , false ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalFieldValueException ( getType () , text ) ; }
FieldUtils . verifyValueBounds ( DateTimeFieldType . millisOfDay () , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ; } return instant ; }
throw new IllegalFieldValueException ( DateTimeFieldType . halfdayOfDay () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . dayOfWeek () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . monthOfYear () , text ) ;
throw new IllegalFieldValueException ( DateTimeFieldType . era () , text ) ;
suite . addTest ( TestIllegalFieldValueException . suite () ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( ( String ) null ) ) ;
public int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = DateTimeZone . forID ( STRING_CONSTANT ) ;
protected DateTimeFormat () { super(); }
protected PeriodFormat () { super(); }
protected ISOPeriodFormat () { super(); }
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT + getClass () . getName () ) ;
fields.era = ERA_FIELD ;
Period test = new Period ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( ISOChronology . getInstance () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
Chronology chrono = GJChronology . getInstanceUTC () ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( ISOChronology . getInstance () . seconds () ) ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( ISOChronology . getInstance () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == ISOChronology . getInstance () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( ISOChronology . getInstance () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( ISOChronology . getInstance () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = ISOChronology . getInstance ( ZONES [ i ] ) ;
Chronology chrono = GregorianChronology . getInstance () ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , ISOChronology . getInstance ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , ISOChronology . getInstance () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , ISOChronology . getInstance () ) , test ) ;
test . add ( ms , ISOChronology . getInstanceUTC () ) ;
test . add ( ms , ISOChronology . getInstance () ) ;
test . add ( NUMBER_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , ISOChronology . getInstance () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
try { type . getField ( CopticChronology . getInstanceUTC () ) ; fail () ; } catch ( InternalError ex ) {}
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , ISOChronology . getInstance () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , ISOChronology . getInstanceUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , ISOChronology . getInstance () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , CopticChronology . getInstance () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
iZone = zone ;
iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiply ( period . getValue ( i ) , scalar ) ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
if ( val < NUMBER_CONSTANT ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( convertToDate ( cal ) ) ;
cal . setTime ( convertToDate ( cal ) ) ;
{ out . write ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ buf . append ( print ( instant - displayOffset , displayZone , locale ) ) ; }
{ return ISOChronology . getInstance ( zone ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ISOChronology . getInstance () ; }
{ super ( ISOChronology . getInstance ( zone ) ) ; }
{ return ISOChronology . getInstance ( zone ) ; }
public Chronology getChronology () { return ISOChronology . getInstanceUTC () ; }
iMillis = converter . getInstantMillis ( instant , ISOChronology . getInstanceUTC () ) ;
{ super ( ISOChronology . getInstance ( zone ) ) ; }
return iChronology . getDaysInYearMax () ;
return iChronology . getDaysInYearMax () ;
FieldUtils . verifyValueBounds ( this , month , MIN , iMax ) ;
long difference = ( minuendYear - subtrahendYear ) * ( ( long ) iMax ) + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , iMax ) ) ; }
assertEquals ( false , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
assertEquals ( false , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
BasicChronology chronology
GJEraDateTimeField ( BasicChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
BasicChronology chronology
GJMonthOfYearDateTimeField ( BasicChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BasicChronology chronology
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
Constructor con = cls . getDeclaredConstructor ( ( Class [] ) null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { est = len ; } }
long instant = chronology . getDateTimeMillis ( NUMBER_CONSTANT , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN_LONDON ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN_LONDON ) ;
LocalTime test = LocalTime . now ( JULIAN_LONDON ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN_LONDON ) ;
assertEquals ( false , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnight () ;
DateTime test = base . toDateTimeAtCurrentTime () ;
DateTime test = base . toDateTimeAtMidnight () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate () ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
LocalDate test = new LocalDate ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = new LocalDate () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = new LocalDate () ;
DateTime test = base . toDateTimeToday () ;
long getApproxMillisAtEpochDividedByTwo () { return ( - MILLIS_YEAR_1 ) / NUMBER_CONSTANT ; }
long millis = bucket . computeMillis ( true , text ) ;
long millis = bucket . computeMillis ( true , text ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true , text ) ; } }
instant . setMillis ( bucket . computeMillis ( false , text ) ) ;
public long computeMillis () { return computeMillis ( false , null ) ; }
test = new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GREGORIAN_DEFAULT ) ) ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GREGORIAN_PARIS ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_PARIS , result . getChronology () ) ;
assertEquals ( ISO_DEFAULT , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . dateParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
long millis = converter . getInstantMillis ( instant , chronology , ISODateTimeFormat . timeParser () ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) , ISODateTimeFormat . timeParser () ) ; }
{ super ( instant , null , ISODateTimeFormat . timeParser () ) ; }
int index = ( ( dateStyle < < NUMBER_CONSTANT ) + dateStyle ) + timeStyle ;
public LocalDateTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
public LocalDate withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
{ return setCopy ( getMaximumValue () ) ; }
public LocalTime withMinimumValue () { return setCopy ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return setCopy ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . setCopy ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . setCopy ( STRING_CONSTANT ) ;
assertEquals ( false , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( false , interval33 . containsNow () ) ;
assertEquals ( false , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return FieldUtils . equals ( getChronology () , other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return new TreeSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value <= getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT , true ) ;
builder . writeTo ( STRING_CONSTANT , out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound , null ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
{ printTo ( out , instant , null ) ; }
{ printTo ( buf , instant , null ) ; }
DateTime now = new DateTime ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
( offsetLocal - offsetAdjusted ) < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtStartOfDay ( LONDON ) ;
DateTime start = base . toDateTimeAtStartOfDay ( TOKYO ) ;
DateTime start = base . toDateTimeAtStartOfDay () ;
DateFormatSymbols dfs = DateTimeUtils . getDateFormatSymbols ( locale ) ;
String [] [] zoneStrings = DateTimeUtils . getDateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id + STRING_CONSTANT ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateTimeAtStartOfDay () . toDate () , index ) ; }
ReadablePartial partial
ReadableInstant readableInstant
DurationField durationField
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
Collection < DateTimeFieldType > fields
List < Object > list
List < Object > elementPairs
List < Object > elementPairs
List < Object > pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList < Object > () ; } else { iElementPairs . clear () ; }
Map < String , RuleSet > ruleSets
{ iRules = new ArrayList < Rule > () ; iRules . add ( rule ) ; }
public int compareTo ( DurationField durationField ) { return iField . compareTo ( durationField ) ; }
Class < > type
Class < > type
iRules = new ArrayList < Rule > ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList < Rule > ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
ReadablePartial partial
f = cCache . get ( key ) ;
formatter = cPatternedCache . get ( pattern ) ;
ReadablePartial partial
Map < String , Object > zimap
iZoneInfoMap . put ( id , new SoftReference < DateTimeZone > ( tz ) ) ;
public int compareTo ( DurationField durationField ) { return NUMBER_CONSTANT ; }
List < Object > list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList < Object > () ; }
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
HashMap < Object , Object > converted
TreeMap < String , Integer > map
TreeMap < String , Integer > map
symbols = cCache . get ( locale ) ;
ReadableDuration obj
chrono = cCache . get ( zone ) ;
try { Single . between ( start , new LocalTime () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
assertEquals ( STRING_CONSTANT , f . withZoneUTC () . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZoneUTC () ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZoneUTC () ; } return ldp ; }
{ if ( value == null ) { return null ; } return new Instant ( value ) ; }
{ return org.joda.time.gwt.util.Arrays . copyOf ( iValues , iValues.length ) ; }
{ return Arrays . copyOf ( iValues , iValues.length ) ; }
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.JAPAN ) ; }
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
TimeZone . setDefault ( DateTimeZone . forID ( STRING_CONSTANT ) . toTimeZone () ) ;
Locale . setDefault ( Locale.JAPAN ) ;
Locale . setDefault ( Locale.JAPAN ) ;
public YearMonth getYearMonth () { return iBase ; }
protected ReadablePartial getReadablePartial () { return iBase ; }
public DateTimeField getField () { return iBase . getField ( iFieldIndex ) ; }
{ super(); iBase = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new ConcurrentHashMap < String , Object > () ;
DateTimeZone . setDefault ( PARIS ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false , instant ) ;
{ super ( duration ) ; }
{ super ( duration ) ; }
Object timestamp = StandardBasicTypes.STRING . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object value = StandardBasicTypes.LONG . nullSafeGet ( resultSet , name ) ;
Object value = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object timestamp = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.DATE . nullSafeGet ( resultSet , string ) ;
Object date = StandardBasicTypes.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = StandardBasicTypes.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
String s = ( String ) StandardBasicTypes.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { setValues ( addPeriodInto ( getValues () , period ) ) ; } }
{ if ( period != null ) { setValues ( mergePeriodInto ( getValues () , period ) ) ; } }
setValues ( newValues ) ;
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ integers [ i ] = Integer . valueOf ( i ) ; }
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
array = new Object [] { validValues , Integer . valueOf ( maxLength ) } ;
{ return withPivotYear ( Integer . valueOf ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateTime () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( DE ) ; }
convId = zone . getID () ;
catch ( ArrayIndexOutOfBoundsException ex ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException ex ) {} }
StringBuilder msg = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName ( null ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalInstantException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalInstantException ex ) { return true ; }
throw new IllegalInstantException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) { return this ; } return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
{ printTo ( appendable , instant , null ) ; }
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
InternalPrinter [] elements = iPrinters ;
InternalPrinter [] elements = iPrinters ;
{ printTo ( appendable , instant , chrono ) ; }
f instanceof InternalPrinter
InternalPrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
{ InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ; p . printTo ( appendable , partial , locale ) ; }
InternalPrinter p = getFormatter ( locale ) . getPrinter0 () ;
return ( ( StyleFormatter ) formatter . getPrinter0 () ) . getPattern ( locale ) ;
InternalPrinter printer = requirePrinter () ;
InternalPrinter printer = requirePrinter () ;
{ printTo ( ( Appendable ) out , instant ) ; }
InternalPrinter printer
catch ( IllegalArgumentException ex ) { assertMessageContains ( ex , STRING_CONSTANT ) ; }
{ return computeMillis ( resetFields , ( CharSequence ) null ) ; }
{ return computeMillis ( false , ( CharSequence ) null ) ; }
{ obtainSaveField () . init ( fieldType . getField ( iChrono ) , value ) ; }
{ obtainSaveField () . init ( field , value ) ; }
CharSequence text
f2 = new DateTimeFormatter ( ( DateTimePrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( DateTimeParserInternalParser . of ( parser ) , text ) ; }
CharSequence text
CharSequence text
CharSequence text
f instanceof InternalParser
InternalParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
{ checkParser ( parser ) ; return append0 ( null , DateTimeParserInternalParser . of ( parser ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser0 () ) ; }
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
InternalParser parser = requireParser () ;
public DateTimeParser getParser () { return InternalParserDateTimeParser . of ( iParser ) ; }
InternalParser parser
InternalParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , DateTimeParserInternalParser . of ( parser ) ) ; }
iMillis = FieldUtils . safeSubtract ( endMillis , startMillis ) ;
{ super(); iMillis = FieldUtils . safeSubtract ( endInstant , startInstant ) ; }
try { builder . appendSuffix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( NULL_STRING , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts . clone () ;
builder . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
builder . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( cDefaultLock ) { cDefault = zone ; }
{ return iZoneInfoKeys ; }
public Set < String > getAvailableIDs () { return AVAILABLE_IDS ; }
public static Set < String > getAvailableIDs () { return getProvider () . getAvailableIDs () ; }
DateTimeZone zone = getProvider () . getZone ( id ) ;
assertEquals ( zone , result ) ;
int curMonth0 = values [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ;
if ( ZoneInfoLogger . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
ZoneInfoLogger . set ( verbose ) ;
Interval interval = new Interval ( start , end , getChronology () ) ;
int compare = csCompare ( text , position , value ) ;
{ return FieldUtils . safeSubtract ( getEndMillis () , getStartMillis () ) ; }
{ millis = iField . setExtended ( millis , iValue ) ; }
str = str . toLowerCase ( Locale.ENGLISH ) ;
assertEquals ( STRING_CONSTANT , str . toUpperCase ( Locale.ENGLISH ) ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.ENGLISH ) ;
{ Provider provider = new ZoneInfoProvider ( DEFAULT_TZ_DATA_PATH ) ; return validateProvider ( provider ) ; }
{ return getCumPct ( Character . valueOf ( v ) ) ; }
{ return getCumFreq ( Character . valueOf ( v ) ) ; }
{ return getPct ( Character . valueOf ( v ) ) ; }
{ return getCount ( Character . valueOf ( v ) ) ; }
public IntegratorException ( final Throwable cause ) { super ( cause ) ; }
final double initialStepSize
final SecondOrderDifferentialEquations equations
public DerivativeException ( final Throwable cause ) { super ( cause ) ; }
super ( METHOD_NAME , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( METHOD_NAME , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( STRING_CONSTANT , c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new VariableHandler () ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( cm ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerStepHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new VariableStepHandler () ) ;
integ . addStepHandler ( new KeplerStepHandler ( pb ) ) ;
integrator . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new VariableHandler () ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( new KeplerHandler ( pb ) ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
integ . addStepHandler ( handler ) ;
stepHandlers = new ArrayList < StepHandler > () ;
ODEIntegrator integrator
createRegression () . newSampleData ( y , x , omega ) ;
createRegression () . newSampleData ( y , x , omega ) ;
CombinedEventsManager manager = addEndTimeChecker ( t0 , t , eventsHandlersManager ) ;
CombinedEventsManager manager = addEndTimeChecker ( t0 , t , eventsHandlersManager ) ;
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = Double.NaN ; }
CompositeFormat cf = new ComplexFormat () ;
CompositeFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
this . step = Math . abs ( step ) ;
stepSize = forward ? step : - step ;
this . step = Math . abs ( step ) ;
stepSize = forward ? step : - step ;
this . step = Math . abs ( step ) ;
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ index [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isNonSingular () ; fail ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
cachedQT == null
RealMatrix sse = u . transpose () . multiply ( getOmegaInverse () ) . multiply ( u ) ;
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return new LUDecompositionImpl ( XTX ) . getInverse () ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
if ( ! isNonSingular () ) { throw new RankDeficientMatrixException () ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( singular ) { throw new SingularMatrixException () ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! matrix . isSquare () ) { throw new NonSquareMatrixException ( matrix . getRowDimension () , matrix . getColumnDimension () ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
catch ( IndexOutOfBoundsException e ) { checkIndex ( index ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
{ return arguments . clone () ; }
{ super(); this . pattern = null ; this . arguments = null ; }
{ return arguments . clone () ; }
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , null ) ;
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
assertEquals ( NUMBER_CONSTANT , ex . getMessage ( Locale.FRENCH ) . length () ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , null ) ;
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
if ( o == null ) { throw new MathException ( STRING_CONSTANT , null ) ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( Exception e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
{ if ( qrt == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ if ( lu == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( ! loaded ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ i ] , NUMBER_CONSTANT ) ; }
transformer = null ;
ds = null ;
ds = null ;
{ copyIn ( d ) ; ds = null ; }
ds = null ;
public int [] getPivot ( ) throws IllegalStateException { return pivot ; }
{ return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { return eigenvalues . clone () ; }
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
public double getNorm ( ) throws InvalidMatrixException { return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { return singularValues . clone () ; }
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
EigenDecomposition ed = new EigenDecompositionImpl ( distinct , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) ;
public DescriptiveStatistics ( int window ) { setWindowSize ( window ) ; }
{ return stat . evaluate ( eDA . getInternalValues () , eDA . start () , eDA . getNumElements () ) ; }
final double [] [] in
final RealVectorImpl v
final double [] v
final RealMatrixImpl m
final RealMatrixImpl m
final RealMatrixImpl m
final double [] v
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
UnivariateRealSolver solver = factory . newSecantSolver () ;
UnivariateRealSolver solver = factory . newBrentSolver () ;
UnivariateRealSolver solver = factory . newNewtonSolver () ;
UnivariateRealSolver solver = factory . newBisectionSolver () ;
try { iterator . advance () ; fail ( STRING_CONSTANT ) ; } catch ( ConcurrentModificationException cme ) {}
RealMatrix m_outerProduct = v1 . outerProduct ( v2 ) ;
cachedV = transformer . getV () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
cachedU = transformer . getU () . multiply ( MatrixUtils . createRealMatrix ( iData ) ) ;
RealMatrix covRM = MatrixUtils . createRealMatrix ( cov ) ;
return MatrixUtils . createRealMatrix ( bp ) ;
return MatrixUtils . createRealMatrix ( dData ) ;
return MatrixUtils . createRealMatrix ( data ) ;
return MatrixUtils . createRealMatrix ( xData ) ;
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
RealMatrix matrix = MatrixUtils . createRealMatrix ( testSquare ) ;
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
RealMatrix matrix = MatrixUtils . createRealMatrix ( testData ) ;
return MatrixUtils . createRealMatrix ( invData ) ;
return MatrixUtils . createRealMatrix ( bp ) ;
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
@ Test ( expected = ArrayIndexOutOfBoundsException . class )
assertFalse ( solver . isNonSingular () ) ;
{ return solver . solve ( b ) ; }
{ this . solver = decomposition . getSolver () ; }
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
@ Test ( expected = IllegalArgumentException . class )
return new RealMatrixImpl ( data , false ) ;
boolean isSingular ( ) ;
return MatrixUtils . createRealMatrix ( data ) ;
{ this . solver = decomposition . getSolver () ; }
{ eigenvectors [ i ] = findEigenvector ( realEigenvalues [ i ] , d , l ) ; }
{ realEigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : realEigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ; } return cachedD ; }
double [] observed = ed . getRealEigenvalues () ;
double lambda = ed . getRealEigenvalue ( i ) ;
double [] eigenValues = ed . getRealEigenvalues () ;
double [] eigenValues = ed . getRealEigenvalues () ;
double [] eigenValues = ed . getRealEigenvalues () ;
assertEquals ( NUMBER_CONSTANT , ed . getRealEigenvalue ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
singularValues = eigenDecomposition . getRealEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , imagEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertTrue ( Double . isNaN ( map . remove ( NUMBER_CONSTANT ) ) ) ; }
this . entries = new OpenIntToDoubleHashMap ( NUMBER_CONSTANT ) ;
double previous = missingEntries ;
values [ index ] = missingEntries ;
return new LUDecompositionImpl ( XTX ) . getSolver () . getInverse () ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
rDiag = new double [ Math . min ( m , n ) ] ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
{ if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; } }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
if ( lu == null ) { lu = new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) . getSolver () ; }
private double getDeterminant ( RealMatrix m ) { return new LUDecompositionImpl ( m ) . getDeterminant () ; }
{ clearResult () ; return localMin ( min , max , relativeAccuracy , absoluteAccuracy , f ) ; }
TestUtils . assertSame ( Float.NaN , MathUtils . sign ( Float.NaN ) ) ;
{ vals [ i ] = values [ i ] . doubleValue () ; }
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( f.length ) ;
{ roots . computeOmega ( f.length ) ; return fft ( f ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { setEntry ( i , value ) ; } }
{ setEntry ( i , Math . log ( getEntry ( i ) ) ) ; }
{ setEntry ( i , Math . log10 ( getEntry ( i ) ) ) ; }
{ setEntry ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ setEntry ( i , getEntry ( i ) + d ) ; }
{ setEntry ( i , Math . acos ( getEntry ( i ) ) ) ; }
{ res . setEntry ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . setEntry ( virtualSize , d ) ; return res ; }
{ setSubVector ( index , v.data ) ; }
w . setEntry ( i , w . getEntry ( i ) / si ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m3 . multiply ( m4 ) , m5 , entryTolerance ) ;
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
final Object . . . parts
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( cause , NUMBER_CONSTANT , pattern , arguments ) ;
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , rows , columns ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
Object . . . arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( dme , STRING_CONSTANT ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
Object . . . parts
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
Object . . . arguments
Object . . . parts
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
final Object . . . arguments
{ return buildMessage ( locale , pattern , arguments ) ; }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
Object . . . arguments
MathException ex = new MathException ( cause , pattern , arguments ) ;
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
MathConfigurationException ex = new MathConfigurationException ( cause , pattern , arguments ) ;
Object . . . arguments
ConvergenceException ex = new ConvergenceException ( cause , pattern , arguments ) ;
{ return buildMessage ( locale , pattern , arguments ) ; }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
final Object . . . parts
final Object . . . arguments
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
final Object . . . parts
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( ! isSquare () ) { throw new NonSquareMatrixException ( getRowDimension () , getColumnDimension () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( de , STRING_CONSTANT ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) { return true ; } }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) { return true ; } }
if ( delta > max ) { max = delta ; }
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
epsilon = v . getEpsilon () ;
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { optimizer . setConvergenceChecker ( checker ) ; }
final ScalarOptimizer optimizer
final Comparator < ScalarPointValuePair > comparator
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { this . checker = checker ; }
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
final VectorialObjectiveFunction function
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalMinCost , null ) ; }
final double residual = residuals [ i ] ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( maxCostEval ) ;
++ jacobianEvaluations ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxIterations ( DEFAULT_MAX_ITERATIONS ) ; }
{ super ( cause , pattern , arguments ) ; this . argument = new double [] { argument } ; }
{ super ( cause ) ; this . argument = new double [] { argument } ; }
{ super ( pattern , arguments ) ; this . argument = new double [] { argument } ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
final MultivariateVectorialFunction function
public void setConvergenceChecker ( RealConvergenceChecker checker ) { this . checker = checker ; }
catch ( FunctionEvaluationException fe ) { assertTrue ( exceptionExpected ) ; }
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
public FractionFormat () {}
{ return subtract ( BigInteger . valueOf ( l ) ) ; }
{ return subtract ( BigInteger . valueOf ( i ) ) ; }
{ return multiply ( BigInteger . valueOf ( l ) ) ; }
{ return multiply ( BigInteger . valueOf ( i ) ) ; }
{ return add ( BigInteger . valueOf ( l ) ) ; }
{ return add ( BigInteger . valueOf ( i ) ) ; }
final ArrayList < BigFraction > coefficients
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double . longBitsToDouble ( NUMBER_CONSTANT ) ) . getNumeratorAsLong () ) ;
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected String getResourceName () { return STRING_CONSTANT ; }
@ Override protected Locale getLocale () { return Locale.US ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.FRENCH ; }
@ Override protected Locale getLocale () { return Locale.US ; }
UnivariateRealSolver solver = LazyHolder.FACTORY . newDefaultSolver () ;
{ setup ( f ) ; return LazyHolder.FACTORY . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( i ) ; }
double n0 = n ;
double n0 = n ;
{ return meanImpl . clone () ; }
{ return geoMeanImpl . clone () ; }
{ return sumLogImpl . clone () ; }
{ return maxImpl . clone () ; }
{ return minImpl . clone () ; }
{ return sumSqImpl . clone () ; }
{ return sumImpl . clone () ; }
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( n - NUMBER_CONSTANT ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
double n = length ;
{ dest.variance = source.variance . copy () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
{ dest.incMoment = source.incMoment ; dest.moment = source.moment . copy () ; }
double sampleSize = length ;
{ dest.moment = source.moment . copy () ; dest.incMoment = source.incMoment ; }
{ return map . get ( key ) ; }
{ return sumDifference ( sample1 , sample2 ) / sample1.length ; }
{ dest.sumOfLogs = source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ result [ i - NUMBER_CONSTANT ] = i * coefficients [ i ] ; }
double n0 = n ;
{ dest.moment = new ThirdMoment ( source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ return contents . clone () ; }
{ dest.moment = source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = length ;
{ super ( problem ) ; y = problem.y . clone () ; }
return Math . sqrt ( sum / v.length ) ;
{ super ( problem ) ; e = problem.e ; y = problem.y . clone () ; }
{ super ( problem ) ; y = problem.y . clone () ; }
{ dY [ i ] = y [ i ] ; }
{ dX [ i ] = x [ i ] ; }
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( asBigDecimal ( testVector ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . getTrace () . doubleValue () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( InvalidMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ super ( problem ) ; a = problem.a ; y = problem.y . clone () ; }
return sum / v.length ;
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextSecureInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextSecureLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { randomData . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false , NUMBER_CONSTANT ) ;
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
{ return ( sumY - slope * sumX ) / n ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / length ) ) / ( length - NUMBER_CONSTANT ) )
double degreesOfFreedom = n1 + n2 - NUMBER_CONSTANT ;
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelationMatrix ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovarianceMatrix ( matrix , biasCorrected ) ; }
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalStateException ex ) {}
{ try { vs . getNext () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) {} }
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
Iterator < > it = f . valuesIterator () ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( v.data ) ; }
super ( extractField ( v ) ) ;
super ( extractField ( d ) ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y , ! ( increasing ^ forward ) ) ;
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
return res ;
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( getEntry ( iter . key () ) ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkSubMatrixIndex ( this , row , endRow , column , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
{ this . Y = new RealVectorImpl ( y ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , sample2.length ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; } this . mean = mean ; }
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
MatrixUtils . checkColumnIndex ( this , col ) ;
MatrixUtils . checkColumnIndex ( this , col ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkColumnIndex ( this , column ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkRowIndex ( this , row ) ;
MatrixUtils . checkSubMatrixIndex ( this , selectedRows , selectedColumns ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkSubMatrixIndex ( this , selectedRows , selectedColumns ) ;
MatrixUtils . checkSubMatrixIndex ( this , startRow , endRow , startColumn , endColumn ) ;
MatrixUtils . checkMultiplicationCompatible ( this , m ) ;
MatrixUtils . checkSubtractionCompatible ( this , m ) ;
MatrixUtils . checkAdditionCompatible ( this , m ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Comparable < > obj1 = null ;
OpenMapRealVector v1 = new OpenMapRealVector ( vec1 ) ;
return new OpenMapRealVector ( out ) ;
{ assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final int dimension = ( currentState == null ) ? - NUMBER_CONSTANT : currentState.length ;
final StepInterpolator prototype
integrator = null ;
integrator = null ;
{ super(); yDotK = null ; integrator = null ; }
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
interpolator . reinitialize ( new DummyIntegrator ( interpolator ) , y , yDot , true ) ;
computeDerivatives ( t0 + h , y1 , yDot1 ) ;
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new BlockRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new BlockRealMatrix ( rowMatrix ) ) ;
assertEquals ( new BlockRealMatrix ( testData ) , MatrixUtils . createRealMatrix ( testData ) ) ;
RealMatrix mA = new BlockRealMatrix ( a ) ;
RealMatrix result = new BlockRealMatrix ( dimension , dimension ) ;
return new BlockRealMatrix ( matrixData ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new BlockRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
{ BlockRealMatrix m = new BlockRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
assertEquals ( new BlockRealMatrix ( reference ) , new BlockRealMatrix ( sub ) ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
assertEquals ( new BlockRealMatrix ( reference ) , sub ) ;
RealMatrix m = new BlockRealMatrix ( subTestData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( testData ) ;
RealMatrix m = new BlockRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this . factors = new BlockRealMatrix ( factors ) ; this . target = target ; }
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new BlockRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( nVars , nVars ) ;
return new BlockRealMatrix ( out ) ;
return new BlockRealMatrix ( out ) ;
{ this ( new BlockRealMatrix ( data ) ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
{ return computeCovarianceMatrix ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new BlockRealMatrix ( dimension , dimension ) ;
{ this ( new BlockRealMatrix ( data ) , biasCorrected ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
{ setColumn ( column , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ setRow ( row , ( ( ArrayRealVector ) vector ) . getDataRef () ) ; }
return new ArrayRealVector ( outData , false ) ;
{ return new ArrayRealVector ( getColumn ( column ) , false ) ; }
{ return new ArrayRealVector ( getRow ( row ) , false ) ; }
eigenvectors = new ArrayRealVector [ m ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
final ArrayRealVector v = eigenvectors [ i ] ;
final ArrayRealVector [] eigenvectors
{ this . X = new Array2DRowRealMatrix ( x ) ; }
{ this . Y = new ArrayRealVector ( y ) ; }
return new ArrayRealVector ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new ArrayRealVector ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
{ this ( new ArrayRealVector ( coefficients ) , constantTerm ) ; }
this . coefficients = new ArrayRealVector ( sub , false ) ;
{ this ( new ArrayRealVector ( coefficients ) , relationship , value ) ; }
return new Array2DRowRealMatrix ( matrixData ) ;
RealMatrix repeatedColumns = new Array2DRowRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
this . tableau = new Array2DRowRealMatrix ( matrix ) ;
this . tableau = new Array2DRowRealMatrix ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
nordsieck = new Array2DRowRealMatrix ( nData , false ) ;
{ setColumn ( column , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
{ setRow ( row , ( ( ArrayFieldVector < T > ) vector ) . getDataRef () ) ; }
return new ArrayFieldVector < T > ( outData , false ) ;
return new ArrayRealVector ( x ) ;
{ this . X = new Array2DRowRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
Array2DRowRealMatrix augI = new Array2DRowRealMatrix ( n , n ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowRealMatrix ( x , false ) ;
{ this . Omega = new Array2DRowRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ return new ArrayFieldVector < T > ( getColumn ( column ) , false ) ; }
{ return new ArrayFieldVector < T > ( getRow ( row ) , false ) ; }
return new ArrayRealVector ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
RealVector lhs = new ArrayRealVector ( numCoefficients ) ;
final RealMatrix matrix = new Array2DRowRealMatrix ( data , false ) ;
final RealVector vector = new ArrayRealVector ( data , false ) ;
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new Array2DRowRealMatrix ( data , false ) ; }
{ return new ArrayFieldVector < T > ( data , true ) ; }
{ return new ArrayRealVector ( data , true ) ; }
return new Array2DRowFieldMatrix < T > ( d , false ) ;
new Array2DRowFieldMatrix < T > ( data )
new Array2DRowFieldMatrix < T > ( field , rows , columns )
{ es . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
decompMatrix = new Array2DRowRealMatrix ( decomp ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new Array2DRowRealMatrix ( lowerTriangularMatrix ) ;
solver . solve ( new Array2DRowRealMatrix ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new Array2DRowRealMatrix ( m7 ) ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowRealMatrix ( bp , false ) ;
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new ArrayRealVectorTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new Array2DRowFieldMatrix < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new Array2DRowRealMatrix ( multistep , false ) ) ;
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
{ Arrays . fill ( after , NUMBER_CONSTANT ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps + NUMBER_CONSTANT ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final Array2DRowRealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = new Array2DRowRealMatrix ( interpolator.nordsieck . getDataRef () , true ) ; }
nordsieck = initializeHighOrderDerivatives ( scaled , multistep ) ;
TestProblem1 pb2 = pb1 . copy () ;
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
v instanceof SparseFieldVector < >
! ( original instanceof RandomKey < > )
if ( ! ( another instanceof RandomKey < > ) ) return false ;
{ addMeasurement ( new LocalMeasurement ( this , x , y , w ) ) ; }
{ measurements [ i ] = new MinpackMeasurement ( this , i ) ; }
Comparable < > v
Comparable < > v
Comparable < > v
final double curN = current . getN () ;
StatisticalSummary observed
StatisticalSummary aggregatedStats = AggregateSummaryStatistics . aggregate ( aggregate ) ;
optimizer . setConvergenceChecker ( new SimpleRealPointChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
final DescriptiveStatistics dstat = createDescriptiveStatistics () ;
DescriptiveStatistics stats = createDescriptiveStatistics () ;
DescriptiveStatistics stats = createDescriptiveStatistics () ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = createMultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; setCostAccuracy ( NUMBER_CONSTANT ) ; }
OpenMapRealVector res = copy () ;
OpenMapRealVector res = copy () ;
this . constraints = normalizeConstraints ( constraints ) ;
return FACTORIALS [ n ] ;
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new EulerStepInterpolator () , step ) ; }
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new MidpointStepInterpolator () , step ) ; }
{ return PERCENTILE . evaluate ( values , begin , length , p ) ; }
{ return PERCENTILE . evaluate ( values , p ) ; }
{ return MIN . evaluate ( values , begin , length ) ; }
{ return MIN . evaluate ( values ) ; }
{ return MAX . evaluate ( values , begin , length ) ; }
{ return MAX . evaluate ( values ) ; }
{ return VARIANCE . evaluate ( values , mean ) ; }
{ return VARIANCE . evaluate ( values , mean , begin , length ) ; }
{ return VARIANCE . evaluate ( values , begin , length ) ; }
{ return VARIANCE . evaluate ( values ) ; }
{ return GEOMETRIC_MEAN . evaluate ( values , begin , length ) ; }
{ return GEOMETRIC_MEAN . evaluate ( values ) ; }
{ return MEAN . evaluate ( values , begin , length ) ; }
{ return MEAN . evaluate ( values ) ; }
{ return SUM_OF_LOGS . evaluate ( values , begin , length ) ; }
{ return SUM_OF_LOGS . evaluate ( values ) ; }
{ return PRODUCT . evaluate ( values , begin , length ) ; }
{ return PRODUCT . evaluate ( values ) ; }
{ return SUM_OF_SQUARES . evaluate ( values , begin , length ) ; }
{ return SUM_OF_SQUARES . evaluate ( values ) ; }
{ return SUM . evaluate ( values , begin , length ) ; }
{ return SUM . evaluate ( values ) ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return CONTENTS . clone () ; }
{ super ( STRING_CONSTANT , STATIC_C , STATIC_A , STATIC_B , new GillStepInterpolator () , step ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
{ return row * columns + column ; }
@ Override public int getRowDimension () { return rows ; }
@ Override public int getColumnDimension () { return columns ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / residualsWeights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += residualsWeights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( residualsWeights [ i ] ) ;
catch ( NumberFormatException e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
UnivariateMatrixFunction derivative ( ) ;
UnivariateRealFunction derivative ( ) ;
double getMean ( ) ;
double getExponent ( ) ;
int getNumberOfElements ( ) ;
boolean isNaN ( ) ;
UnivariateVectorialFunction derivative ( ) ;
long getN ( ) ;
int getDimension ( ) ;
double fitness ( ) ;
int getDimension ( ) ;
int getDimension ( ) ;
int getSampleSize ( ) ;
int getPopulationSize ( ) ;
int getNumberOfSuccesses ( ) ;
double getSum ( ) ;
long getN ( ) ;
double getMin ( ) ;
double getMax ( ) ;
double getCurrentTime ( ) ;
double getPreviousTime ( ) ;
void resetRelativeAccuracy ( ) ;
double getRelativeAccuracy ( ) ;
void resetAbsoluteAccuracy ( ) ;
double getAbsoluteAccuracy ( ) ;
int getMaximalIterationCount ( ) ;
void reset ( ) ;
public static DummyStepHandler getInstance () { return LazyHolder.INSTANCE ; }
{ this . randomData = randomData ; }
final RandomGenerator generator
return anovaPValue ( categoryData ) < alpha ;
{ return internalArray ; }
{ return internalArray ; }
synchronized int getInternalLength () { return internalArray.length ; }
double dx = x2 - x1 ;
return isForward ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = n > NUMBER_CONSTANT ;
return stdDev ;
{ checkSignificanceLevel ( alpha ) ; return tTest ( sampleStats1 , sampleStats2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return homoscedasticTTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( sample1 , sample2 ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sampleStats ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return tTest ( mu , sample ) < alpha ; }
{ checkSignificanceLevel ( alpha ) ; return pairedTTest ( sample1 , sample2 ) < alpha ; }
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
increasing = gb >= ga ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = g0 >= NUMBER_CONSTANT ; }
final boolean forward = t > t0 ;
final boolean forward = t > t0 ;
{ sum += values [ i ] * weights [ i ] ; }
final boolean forward = t > t0 ;
{ return o1 . compareTo ( ( T ) o2 ) ; }
return chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ;
unequalCounts = countSum1 != countSum2 ;
return chiSquareTest ( counts ) < alpha ;
return chiSquareTest ( expected , observed ) < alpha ;
return stdDev ;
i < getRowDimension ()
{ correction += values [ i ] - xbar ; }
public boolean isSquare () { return getColumnDimension () == getRowDimension () ; }
return super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ;
final boolean forward = t > t0 ;
forward = interpolator . getCurrentTime () >= lastTime ;
final boolean forward = t > t0 ;
Complex N1 = new Complex ( n - NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
while ( ! tableau . isOptimal () ) { doIteration ( tableau ) ; }
Integer pivotRow = getPivotRow ( tableau , pivotCol ) ;
tableau . dropPhase1Objective () ;
Assert . assertTrue ( fitResidualSum < noisyResidualSum ) ;
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
super ( rootCause ) ;
super ( rootCause ) ;
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( MathUtils.TWO_PI * x )
double f = ( MathUtils.TWO_PI * x * ( n - x ) ) / n ;
double d = x - mu ;
flipAllIfWarranted ( deflatedEnd )
flipEveryOtherIfWarranted ( n ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
int negativeVarColumn = columnLabels . indexOf ( NEGATIVE_VAR_COLUMN_LABEL ) ;
if ( ! restrictToNonNegative ) { columnLabels . add ( NEGATIVE_VAR_COLUMN_LABEL ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
int value = decoded . get ( i ) ;
return mapDivide ( norm ) ;
public ArrayRealVector ( ArrayRealVector v ) { this ( v , true ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
! isDefaultValue ( value )
{ this ( values , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { data [ index ] = value ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
Iterator < Entry > it = iterator () ;
epsilon = DEFAULT_ZERO_TOLERANCE ;
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
this . epsilon = epsilon ;
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
{ return new BigReal ( d . divide ( a.d , scale , roundingMode ) ) ; }
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = source.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , solution . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
{ super ( interpolator ) ; currentDerivative = interpolator.currentDerivative . clone () ; }
{ super(); currentDerivative = null ; }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , new double [ y.length ] , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , new double [ y.length ] , true ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , yDotK [ stages - NUMBER_CONSTANT ] , forward ) ; }
{ interpolator = new DummyStepInterpolator ( y , yDot1 , forward ) ; }
{ handler . handleStep ( new StepInterpolatorWrapper ( interpolator , n , k ) , isLast ) ; }
final ODEWithJacobians ode
{ this ( mean , sd , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( defaultTolerance ) ; }
{ super ( f , DEFAULT_MAXIMUM_ITERATIONS , DEFAULT_ABSOLUTE_ACCURACY ) ; }
{ if ( p < NUMBER_CONSTANT ) { return mean ; } else { return Double.MAX_VALUE ; } }
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
{ return getUpperDomain ( sampleSize , numberOfSuccesses ) ; }
{ return getLowerDomain ( populationSize , numberOfSuccesses , sampleSize ) ; }
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
{ super(); setNumberOfSuccessesInternal ( r ) ; setProbabilityOfSuccessInternal ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = alpha * beta ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ super(); setAlphaInternal ( alpha ) ; setBetaInternal ( beta ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / scale , shape ) ) ; }
{ super(); setShapeInternal ( alpha ) ; setScaleInternal ( beta ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ return Double.MIN_VALUE * gamma . getBeta () ; }
{ return gamma . cumulativeProbability ( x ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= numberOfElements ) { return NUMBER_CONSTANT ; }
if ( x <= NUMBER_CONSTANT || x > numberOfElements ) { return NUMBER_CONSTANT ; }
{ setNumberOfElementsInternal ( numberOfElements ) ; setExponentInternal ( exponent ) ; }
double d = denominatorDegreesOfFreedom ;
{ super(); setNumeratorDegreesOfFreedomInternal ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedomInternal ( denominatorDegreesOfFreedom ) ; }
x < NUMBER_CONSTANT || x > numberOfTrials
{ return numberOfTrials ; }
{ super(); setNumberOfTrialsInternal ( trials ) ; setProbabilityOfSuccessInternal ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = mean ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = mean ; }
if ( p < NUMBER_CONSTANT ) { ret = median ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = median ; }
{ super(); setMedianInternal ( median ) ; setScaleInternal ( s ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
protected void setDistribution ( AbstractContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { this ( degreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( numeratorDegreesOfFreedom , denominatorDegreesOfFreedom , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( alpha , beta , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
public ExponentialDistributionImpl ( double mean ) { this ( mean , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ this ( median , s , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
final double [] row = AINV [ i ] ;
{ p = interpolator . interpolate ( xval , wyval , wzval ) ; Assert . fail ( STRING_CONSTANT ) ; }
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = TestUtils . eliminateZeroMassPoints ( densityPoints , densityValues ) ;
if ( ak2 < NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 <= qrRankingThreshold ) { rank = k ; return; }
assertFalse ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( residuals.length != observations.length ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , residuals.length , observations.length ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , observations.length , weights.length ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getLocalizablePattern () , e . getArguments () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ super ( LocalizedFormats.FRACTION_CONVERSION_OVERFLOW , value , p , q ) ; }
{ super ( LocalizedFormats.FAILED_FRACTION_CONVERSION , value , maxIterations ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
final Localizable specifier
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_COMPLEX_MODULE , r ) ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
Localizable specifier
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , sampleSize ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , LocalizedFormats.NO_DENSITY_FOR_THIS_DISTRIBUTION ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , successes ) ; } numberOfSuccesses = successes ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SHAPE , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
if ( observations.length < NUMBER_CONSTANT ) { throw new OptimizationException ( LocalizedFormats.INSUFFICIENT_OBSERVED_POINTS_IN_SAMPLE , observations.length , NUMBER_CONSTANT ) ; }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POWER_NEGATIVE_PARAMETERS , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_64_BITS , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.LCM_OVERFLOW_32_BITS , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FACTORIAL_NEGATIVE_PARAMETER , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_POLYNOMIAL_DEGREE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_POLYNOMIAL ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
if ( offset > NUMBER_CONSTANT ) { throw new EventException ( LocalizedFormats.EVALUATION_FAILED , t ) ; }
{ throw new DerivativeException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_FIRST_GUESS_HARMONIC_COEFFICIENTS ) ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( LocalizedFormats.EVALUATION_FAILED , argument ) ; this . argument = new double [] { argument } ; }
{ this ( cause , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
if ( target.length != weights.length ) { throw new OptimizationException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , target.length , weights.length ) ; }
if ( rows <= cols ) { throw new OptimizationException ( LocalizedFormats.NO_DEGREES_OF_FREEDOM , rows , cols ) ; }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
if ( objective.length != rows ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , objective.length , rows ) ; }
if ( jacobian.length != rows ) { throw new FunctionEvaluationException ( point , LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , jacobian.length , rows ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
{ super ( LocalizedFormats.DUPLICATED_ABSCISSA , abscissa , i1 , i2 ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , d , n ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
{ this ( new DummyLocalizable ( pattern ) , arguments ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ throw new IntegratorException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , Math . abs ( h ) ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_POLYNOMIALS_COEFFICIENTS_ARRAY ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , n ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.POSITION_SIZE_MISMATCH_INPUT_ARRAY , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_MUST_HAVE_AT_LEAST_ONE_ELEMENT ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , yMin , yMax ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , newMean ) ; } this . mean = newMean ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , getDimension () , n ) ; } }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_0TH_ROOT_OF_UNITY ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.ROOTS_OF_UNITY_NOT_COMPUTED_YET ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_NUMBER_OF_SAMPLES , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_EXPONENT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_DIMENSION , n , NUMBER_CONSTANT ) ; } this . numberOfElements = n ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EXPANSION_FACTOR_SMALLER_THAN_ONE , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SUBSTITUTE_ELEMENT_FROM_EMPTY_ARRAY ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_NUMERATOR_FORMAT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_DENOMINATOR_FORMAT ) ; } this . denominatorFormat = format ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_ONE_PREVIOUS_POINT , name ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? LocalizedFormats.CARDAN_ANGLES_SINGULARITY : LocalizedFormats.EULER_ANGLES_SINGULARITY ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , arrayDimension , expected ) ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EQUAL_VERTICES_IN_SIMPLEX , j , j + NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NON_POSITIVE_MICROSPHERE_ELEMENTS , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_BRIGHTNESS_EXPONENT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
throw new OptimizationException ( LocalizedFormats.UNABLE_TO_BRACKET_OPTIMUM_IN_LINE_SEARCH ) ;
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_COLUMN ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_MEAN , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_BOUND_NOT_BELOW_UPPER_BOUND , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_LENGTH , len ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_PERFORM_QR_DECOMPOSITION_ON_JACOBIAN , rows , cols ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_STANDARD_DEVIATION , sd ) ; } standardDeviation = sd ; }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_BETA , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ALPHA , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_DEGREES_OF_FREEDOM , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_ITERATIONS_LIMITS , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , f.length ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POPULATION_SIZE , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_SUCCESSES , num ) ; } numberOfSuccesses = num ; }
final Localizable pattern
if ( xval.length != yval.length ) { throw new MathException ( LocalizedFormats.MISMATCHED_LOESS_ABSCISSA_ORDINATE_ARRAYS , xval.length , yval.length ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SCALE , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
Localizable pattern
Localizable pattern
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_3D_VECTOR , obj . getClass () . getName () ) ;
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FUNCTION_NOT_DIFFERENTIABLE ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.AT_LEAST_ONE_ROW ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
{ throw new InvalidMatrixException ( LocalizedFormats.ASSYMETRIC_EIGEN_NOT_SUPPORTED ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_POISSON_MEAN , p ) ; }
throw new NotARotationMatrixException ( LocalizedFormats.UNABLE_TO_ORTHOGONOLIZE_MATRIX , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_DEFINING_VECTOR ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM_FOR_ROTATION_AXIS ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , min , max , y0 , y1 ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_OBJECT_TO_FRACTION ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_WHOLE_FORMAT ) ; } this . wholeFormat = format ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_NUMBER_OF_TRIALS , trials ) ; } numberOfTrials = trials ; }
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_INTERVAL_INITIAL_VALUE_PARAMETERS , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_RESULT_AVAILABLE ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.FIRST_ELEMENT_NOT_ZERO , f [ NUMBER_CONSTANT ] ) ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_REAL_FORMAT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_IMAGINARY_FORMAT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.EMPTY_STRING_FOR_IMAGINARY_CHARACTER ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_COMPLEX , obj . getClass () . getName () ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CLASS_DOESNT_IMPLEMENT_COMPARABLE , v . getClass () . getName () ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_COMPUTE_NTH_ROOT_FOR_NEGATIVE_N , n ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ super ( LocalizedFormats.NON_SQUARE_MATRIX , rows , columns ) ; }
final Localizable specifier
if ( m <= p ) { throw new EstimationException ( LocalizedFormats.NO_DEGREES_OF_FREEDOM , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( LocalizedFormats.UNABLE_TO_COMPUTE_COVARIANCE_SINGULAR_PROBLEM ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( LocalizedFormats.MAX_EVALUATIONS_EXCEEDED , maxCostEval ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.CANNOT_FORMAT_INSTANCE_AS_REAL_VECTOR , obj . getClass () . getName () ) ;
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( LocalizedFormats.NO_CONVERGENCE_WITH_ANY_START_POINT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.NO_OPTIMUM_COMPUTED_YET ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( LocalizedFormats.NO_SUCH_MATRIX_ENTRY , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( LocalizedFormats.DIMENSIONS_MISMATCH_2x2 , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , b.length , m ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_SAMPLE_SIZE , sampleSize ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_CANNOT_ACCESS_METHOD , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
{ throw MathRuntimeException . createArithmeticException ( LocalizedFormats.IDENTICAL_ABSCISSAS_DIVISION_BY_ZERO , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.RANDOMKEY_MUTATION_WRONG_CLASS , original . getClass () . getSimpleName () ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ARRAY_SUMS_TO_ZERO ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_RANGE_ROOT_OF_UNITY_INDEX , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_FRACTION_NUMBER , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_COMPLEX_NUMBER , source ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_REAL_VECTOR , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.PERCENTILE_IMPLEMENTATION_UNSUPPORTED_METHOD , percentileImpl . getClass () . getName () , SET_QUANTILE_METHOD_NAME ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , LocalizedFormats.UNPARSEABLE_3D_VECTOR , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw new NoDataException () ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NUMBER_OF_POINTS , x.length , NUMBER_CONSTANT , true ) ; }
if ( mean.length != standardDeviation.length ) { throw new DimensionMismatchException ( mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw new NotStrictlyPositiveException ( n ) ; }
{ return ( value == null ? null : value . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
final double [] scale = new double [ mainSetDimension ] ;
catch ( NoDataException ise ) {}
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
a [ i ] [ j ] [ k ] = aV [ i + N * ( j + N * k ) ]
{ return ( value == null ) ? null : value . clone () ; }
{ return ( point == null ) ? null : point . clone () ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
( startConfiguration == null ) || ( startConfiguration.length != startPoint.length )
{ return ( point == null ) ? null : point . clone () ; }
public GoalType getGoalType () { return optimizationGoal ; }
{ throw new MatrixIndexException ( LocalizedFormats.COLUMN_INDEX_OUT_OF_RANGE , column , NUMBER_CONSTANT , getColumnDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.ROW_INDEX_OUT_OF_RANGE , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( LocalizedFormats.INDEX_OUT_OF_RANGE , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( METHOD_NAME , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new NotPositiveException ( LocalizedFormats.POPULATION_LIMIT_NOT_POSITIVE , populationLimit ) ; }
{ ret = addAndCheck ( a , - b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_SUBTRACTION , x , y ) ; }
{ return addAndCheck ( a , b , LocalizedFormats.OVERFLOW_IN_ADDITION ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_ADDITION , x , y ) ; }
catch ( ArithmeticException ex ) { assertTrue ( ex . getMessage () . length () > NUMBER_CONSTANT ) ; }
{ checkOrder ( val , OrderDirection.INCREASING , true ) ; }
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
if ( t == NUMBER_CONSTANT && i >= j ) continue;
arguments = ArgUtils . flatten ( args ) ;
public void remove () { throw new MathUnsupportedOperationException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( observations == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; }
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroException () ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( fraction == null ) { throw new NullArgumentException ( LocalizedFormats.FRACTION ) ; }
if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
@ Test ( expected = ZeroException . class )
{ throw new DimensionMismatchException ( xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw new NullArgumentException ( LocalizedFormats.COVARIANCE_MATRIX ) ; }
{ if ( f == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; } }
if ( function == null ) { throw new NullArgumentException ( LocalizedFormats.FUNCTION ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new NullArgumentException ( LocalizedFormats.INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = weightedResidualJacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , arguments ) ; }
step *= FastMath . max ( NUMBER_CONSTANT , yA / yB )
return FastMath . sqrt ( sum / v.length ) ;
{ return FastMath . sqrt ( getChiSquare () / rows ) ; }
double wi = FastMath . sqrt ( residualsWeights [ i ] ) ;
{ this . h = FastMath . abs ( h ) ; this . handler = handler ; reset () ; }
double invR3 = NUMBER_CONSTANT / ( r2 * FastMath . sqrt ( r2 ) ) ;
double expected = FastMath . random () ;
double expected = FastMath . random () ;
return FastMath . sqrt ( sum2 ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double t = FastMath . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + FastMath . abs ( reference ) ) ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) )
return FastMath . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( FastMath . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
assertTrue ( FastMath . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ sumLog += FastMath . log ( values [ i ] ) ; }
{ value += FastMath . log ( d ) ; n ++ ; }
{ ret = - mean * FastMath . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - FastMath . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return FastMath . exp ( - x / mean ) / mean ; }
{ sum += FastMath . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( FastMath . exp ( x ) - FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) FastMath . pow ( NUMBER_CONSTANT , scale ) * sign ;
{ return FastMath . log ( x ) / FastMath . log ( base ) ; }
return FastMath . abs ( u ) + FastMath . abs ( v ) ;
return FastMath . abs ( u ) + FastMath . abs ( v ) ;
final boolean isEqual = FastMath . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( FastMath . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || FastMath . abs ( y - x ) <= eps ; }
{ return ( FastMath . exp ( x ) + FastMath . exp ( - x ) ) / NUMBER_CONSTANT ; }
return FastMath . floor ( result + NUMBER_CONSTANT ) ;
double sigma = NUMBER_CONSTANT + FastMath . random () ;
double mu = FastMath . random () ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / FastMath . sqrt ( NUMBER_CONSTANT ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ return FastMath . atan2 ( getImaginary () , getReal () ) ; }
FastMath . abs ( c ) < FastMath . abs ( d )
FastMath . abs ( dt ) <= FastMath . ulp ( stepStart )
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
assertEquals ( FastMath.PI , x , accuracy ) ;
{ double x = UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; assertEquals ( FastMath.PI , x , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , FastMath . ulp ( NUMBER_CONSTANT ) ) ;
{ singularValues [ i ] = FastMath . sqrt ( FastMath . abs ( singularValues [ i ] ) ) ; }
{ result [ i ] = FastMath . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
double fpos = FastMath . floor ( pos ) ;
final double dist = FastMath . abs ( z - x [ i ] ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( FastMath . pow ( NUMBER_CONSTANT , - exp ) ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double tolerance = FastMath . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
double sqrt = FastMath . sqrt ( c [ ir ] [ ir ] ) ;
int k = FastMath . max ( N , seed.length )
{ values [ i ] = FastMath . pow ( values [ i ] , d ) ; }
double t = FastMath . abs ( t ( m , mu , v , n ) ) ;
{ return ( m - mu ) / FastMath . sqrt ( v / n ) ; }
{ stepStart = Double.NaN ; stepSize = FastMath . sqrt ( minStep * maxStep ) ; }
{ assertEquals ( msg , expected , actual , FastMath . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( FastMath . pow ( NUMBER_CONSTANT , - n ) )
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
double absAi = FastMath . abs ( coefficients [ i ] ) ;
{ ret = median + scale * FastMath . tan ( FastMath.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / FastMath.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
Double pi = Double . valueOf ( FastMath.PI ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = FastMath . min ( pStart + BLOCK_SIZE , rows ) ;
{ stdDev [ i ] = FastMath . sqrt ( matrix . getEntry ( i , i ) ) ; }
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( FastMath . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
if ( value != i ) { res += FastMath . abs ( value - i ) ; }
{ value += NUMBER_CONSTANT / FastMath . pow ( k , m ) ; }
return ( NUMBER_CONSTANT / FastMath . pow ( x , exponent ) ) / generalizedHarmonic ( numberOfElements , exponent ) ;
widthSufficient = FastMath . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
return FastMath . sqrt ( criterion / wm.length ) ;
double factor = - FastMath . sqrt ( wm . getWeight () ) ;
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
public double end () { return FastMath . sqrt ( sum ) ; }
{ return FastMath . atan2 ( x , y ) ; }
{ return FastMath . pow ( x , y ) ; }
accum3 /= variance * FastMath . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * FastMath . sqrt ( variance ) * variance )
assertEquals ( FastMath . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
{ return FastMath . asin ( z / getNorm () ) ; }
{ return FastMath . atan2 ( y , x ) ; }
double x = FastMath . random () ;
assertTrue ( FastMath . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
{ return new HarmonicFunction ( a * omega , omega , phi + FastMath.PI / NUMBER_CONSTANT ) ; }
{ return a * FastMath . cos ( omega * x + phi ) ; }
Complex sqrtz = ComplexUtils . polar2Complex ( FastMath . sqrt ( r ) , theta / NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new Complex ( FastMath . acos ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) , Complex.ZERO . acos () , NUMBER_CONSTANT ) ;
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
long index = FastMath . round ( ( FastMath . random () ) * testArray.length ) ;
{ length = list . size () - FastMath . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
double c = t2 + NUMBER_CONSTANT * ( FastMath . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
double t = NUMBER_CONSTANT * FastMath.PI ;
double t = NUMBER_CONSTANT * FastMath.PI ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
error = FastMath . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
FastMath . log ( x ) - NUMBER_CONSTANT / x
double expected = FastMath . random () ;
double expected = FastMath . random () ;
final double power = FastMath . pow ( normalizedAbscissa , order ) ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( FastMath . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
{ return FastMath . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ Assert . assertEquals ( FastMath . pow ( NUMBER_CONSTANT , x ) , f . value ( x ) , NUMBER_CONSTANT ) ; }
this . convergence = FastMath . abs ( convergence ) ;
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
double fl = FastMath . floor ( x ) ;
{ return cumulativeProbability ( ( int ) FastMath . floor ( x ) ) ; }
{ assertTrue ( FastMath . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
{ double absError = FastMath . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
return - mean * FastMath . log ( unif ) ;
double sigma = FastMath . sqrt ( mean ) ;
if ( FastMath . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = FastMath . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return FastMath . sqrt ( res ) ;
return FastMath . sqrt ( res ) ;
{ return FastMath . abs ( value ) < epsilon ; }
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ assertTrue ( FastMath . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
new Fraction ( FastMath.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
max = FastMath . max ( max , FastMath . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += FastMath . abs ( delta ) ; }
sum += FastMath . abs ( delta ) ;
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( sum ) ;
for ( double a : data ) { max = FastMath . max ( max , FastMath . abs ( a ) ) ; }
for ( double a : data ) { sum += FastMath . abs ( a ) ; }
return FastMath . sqrt ( sum ) ;
{ data [ i ] = FastMath . ulp ( data [ i ] ) ; }
{ data [ i ] = FastMath . signum ( data [ i ] ) ; }
{ data [ i ] = FastMath . rint ( data [ i ] ) ; }
{ data [ i ] = FastMath . floor ( data [ i ] ) ; }
{ data [ i ] = FastMath . ceil ( data [ i ] ) ; }
{ data [ i ] = FastMath . cbrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . sqrt ( data [ i ] ) ; }
{ data [ i ] = FastMath . abs ( data [ i ] ) ; }
{ data [ i ] = FastMath . atan ( data [ i ] ) ; }
{ data [ i ] = FastMath . asin ( data [ i ] ) ; }
{ data [ i ] = FastMath . acos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tan ( data [ i ] ) ; }
{ data [ i ] = FastMath . sin ( data [ i ] ) ; }
{ data [ i ] = FastMath . cos ( data [ i ] ) ; }
{ data [ i ] = FastMath . tanh ( data [ i ] ) ; }
{ data [ i ] = FastMath . sinh ( data [ i ] ) ; }
{ data [ i ] = FastMath . cosh ( data [ i ] ) ; }
{ data [ i ] = FastMath . log1p ( data [ i ] ) ; }
{ data [ i ] = FastMath . log10 ( data [ i ] ) ; }
{ data [ i ] = FastMath . log ( data [ i ] ) ; }
{ data [ i ] = FastMath . expm1 ( data [ i ] ) ; }
{ data [ i ] = FastMath . exp ( data [ i ] ) ; }
{ data [ i ] = FastMath . pow ( data [ i ] , d ) ; }
i < FastMath . min ( rows , columns )
final double inv = NUMBER_CONSTANT / FastMath . sqrt ( norm2 ) ;
{ if ( FastMath . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
FastMath . abs ( dt ) <= FastMath . ulp ( stepStart )
this . step = FastMath . abs ( step ) ;
final int p = FastMath . min ( m , n ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( FastMath . sqrt ( p ) ) ;
if ( unequalCounts ) { weight = FastMath . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double s17 = FastMath . sqrt ( NUMBER_CONSTANT ) ;
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
{ norm = FastMath . max ( norm , FastMath . abs ( e . getValue () ) ) ; }
{ norm += FastMath . abs ( e . getValue () ) ; }
return FastMath . sqrt ( sum ) ;
return FastMath . sqrt ( d ) ;
return FastMath . sqrt ( dx * dx + dy * dy ) ;
assertEquals ( NUMBER_CONSTANT , FastMath . sqrt ( circle . getM () ) * rms , NUMBER_CONSTANT ) ;
return a * FastMath . cos ( omega * x + phi ) ;
final double f = NUMBER_CONSTANT / FastMath . sqrt ( normSq ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( FastMath . abs ( h ) < minStep ) ;
double maxStep = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = FastMath . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double [] y0 = { FastMath . sin ( a ) , FastMath . cos ( a ) } ;
new double [] { - FastMath . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( FastMath.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
if ( deltaNorm > NUMBER_CONSTANT * FastMath . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertEquals ( FastMath.PI , MathUtils . scalb ( FastMath.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , FastMath . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { FastMath . nextAfter ( FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { FastMath . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
ret = FastMath . exp ( p1 + p2 - p3 ) ;
{ return FastMath . min ( k , m ) ; }
{ return FastMath . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( FastMath . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return FastMath . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = FastMath . sqrt ( getRSquare () ) ;
if ( FastMath . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
@ Override public double value ( double d ) { return FastMath . ulp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . signum ( d ) ; }
@ Override public double value ( double d ) { return FastMath . rint ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cosh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . acos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cos ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log10 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . log ( d ) ; }
@ Override public double value ( double d ) { return FastMath . floor ( d ) ; }
@ Override public double value ( double d ) { return FastMath . ceil ( d ) ; }
@ Override public double value ( double d ) { return FastMath . cbrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tanh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . tan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . atan ( d ) ; }
@ Override public double value ( double d ) { return FastMath . asin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . expm1 ( d ) ; }
@ Override public double value ( double d ) { return FastMath . exp ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sinh ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sqrt ( d ) ; }
@ Override public double value ( double d ) { return FastMath . sin ( d ) ; }
@ Override public double value ( double d ) { return FastMath . abs ( d ) ; }
new BigFraction ( FastMath.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + FastMath . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double step = FastMath . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double c = FastMath . exp ( t0 - t ) ;
assertEquals ( NUMBER_CONSTANT , FastMath . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
{ product *= FastMath . pow ( values [ i ] , weights [ i ] ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
if ( FastMath . abs ( fn1 - fn ) <= threshold ) return o ;
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + FastMath . ulp ( NUMBER_CONSTANT ) } ) ) ;
FastMath . sin ( i * FastMath.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
double absTolerance = FastMath . pow ( NUMBER_CONSTANT , i ) ;
FastMath . abs ( max - min ) <= absoluteAccuracy
assertEquals ( ci , l40 [ i ] , FastMath . abs ( ci ) * NUMBER_CONSTANT ) ;
FastMath . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
double tmp2 = FastMath . exp ( tmp1 ) ;
double tmp2 = FastMath . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + FastMath . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , FastMath . sqrt ( m ) * rms , threshold ) ;
{ assertTrue ( FastMath . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
final int capacity = ( int ) FastMath . ceil ( expectedSize / LOAD_FACTOR ) ;
{ return FastMath . sqrt ( variance . evaluate ( values , mean ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values , mean , begin , length ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values , begin , length ) ) ; }
{ return FastMath . sqrt ( variance . evaluate ( values ) ) ; }
@ Override public double getResult () { return FastMath . sqrt ( variance . getResult () ) ; }
minor < FastMath . min ( m , n )
j < FastMath . min ( i + NUMBER_CONSTANT , n )
int row = FastMath . min ( m , n ) - NUMBER_CONSTANT
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
catch ( ConvergenceException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
ConvergenceChecker < RealPointValuePair > convergenceChecker
public GoalType getGoalType () { return goal ; }
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
catch ( ConvergenceException ee ) {}
assertEquals ( NUMBER_CONSTANT , sum . getResult () , NUMBER_CONSTANT ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public SumOfSquares () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
assertEquals ( NUMBER_CONSTANT , sumSq . getResult () , NUMBER_CONSTANT ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public Sum () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
checkClearValue ( statistic ) ;
checkClearValue ( statistic ) ;
@ Override public void clear () { value = NUMBER_CONSTANT ; n = NUMBER_CONSTANT ; }
public Product () { n = NUMBER_CONSTANT ; value = NUMBER_CONSTANT ; }
assertEquals ( NUMBER_CONSTANT , product . getResult () , NUMBER_CONSTANT ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + Arrays . hashCode ( mant ) ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length + NUMBER_CONSTANT ; }
final boolean isMinim = getGoalType () == GoalType.MINIMIZE ;
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b () { super ( K , M1 , M2 , M3 ) ; }
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c () { super ( K , M1 , M2 , M3 ) ; }
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
v [ indexRm2 ] &= NUMBER_CONSTANT ;
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw new DimensionMismatchException ( v.length , rows ) ; }
if ( v.length != columns ) { throw new DimensionMismatchException ( v.length , columns ) ; }
if ( length != columns ) { throw new DimensionMismatchException ( columns , length ) ; }
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ;
{ this ( p , DEFAULT_EPSILON , DEFAULT_MAX_ITERATIONS ) ; }
distribution = new ChiSquaredDistributionImpl ( df ) ;
{ distribution = new ChiSquaredDistributionImpl ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
double density ( double x ) ;
( FastMath . max ( FastMath . abs ( mij ) , FastMath . abs ( mji ) ) * eps )
protected AbstractContinuousDistribution () {}
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution = new TDistributionImpl ( n - NUMBER_CONSTANT ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () { randomGenerator = null ; }
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , Dfp.INFINITE ) ; }
protected AbstractIntegerDistribution () {}
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
AbstractMultipleLinearRegression regression = createRegression () ;
{ try { new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
{ realVectorFormat . parseObject ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ UnivariateRealSolverUtils . solve ( sin , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += za - temp2 ;
if ( v . getDimension () != nRows ) { throw new DimensionMismatchException ( v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw new DimensionMismatchException ( v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw new DimensionMismatchException ( v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw new DimensionMismatchException ( v.length , nCols ) ; }
{ setQuantile ( p ) ; cachedPivots = null ; }
if ( isDefaultValue ( norm ) ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
{ this ( n , NUMBER_CONSTANT ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , NUMBER_CONSTANT ) ; }
catch ( DimensionMismatchException ee ) { assertTrue ( shouldFail ) ; }
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( SingularMatrixException ime ) {}
catch ( DimensionMismatchException oe ) {}
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NonPositiveDefiniteMatrixException . class )
@ Test ( expected = NonPositiveDefiniteMatrixException . class )
@ Test ( expected = NonSymmetricMatrixException . class )
catch ( NonSquareMatrixException ime ) {}
catch ( NonSquareMatrixException ime ) {}
catch ( NonPositiveDefiniteMatrixException e ) { fail ( STRING_CONSTANT ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ return MessageFactory . buildMessage ( locale , specific , general , arguments ) ; }
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
assertEquals ( pattern , ex . getGeneralPattern () ) ;
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException fe ) { assertTrue ( exceptionExpected ) ; }
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( MathUserException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( MathUserException e ) { throw new IllegalArgumentException ( e ) ; } }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
catch ( MathUserException de ) { fail ( STRING_CONSTANT ) ; }
{ return f . value ( x , y ) ; }
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
CircleVectorial circle = new CircleVectorial () ;
NumberIsTooLargeException ex
assertEquals ( NUMBER_CONSTANT , handler . getMaximalValueError () , NUMBER_CONSTANT ) ;
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( new Power ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( FunctionUtils . fix2ndArgument ( new Add () , d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxCountExceededException ( maxIterations ) ) ; } }
throw new MaxCountExceededException ( maximalIterationCount ) ;
{ throw new MaxCountExceededException ( maxIterations ) ; }
if ( n >= maxIterations ) { throw new MaxCountExceededException ( LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , maxIterations , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw new NumberIsTooLargeException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] , true ) ; }
{ return solve ( DEFAULT_MAX_EVALUATIONS , f , startValue ) ; }
StringBuilder buffer
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder out = new StringBuilder ( msg ) ;
StringBuilder messageBuffer = new StringBuilder () ;
StringBuilder s = new StringBuilder () ;
final StringBuilder buff = new StringBuilder ( STRING_CONSTANT ) ;
StringBuilder msgBuffer = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
StringBuilder outBuffer = new StringBuilder () ;
Assert . assertEquals ( FastMath.PI , solver . solve ( NUMBER_CONSTANT , f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
result = solver . solve ( NUMBER_CONSTANT , f , min , max ) ;
{ this ( new SimpleVectorialValueChecker () ) ; }
{ this ( new SimpleScalarValueChecker () ) ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x1 , x0 , true ) ; }
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
catch ( NullArgumentException ex ) {}
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new MathArithmeticException ( msg ) ; } }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalStateException ise ) {}
{ if ( numerator == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
catch ( MathIllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {} }
{ try { UnivariateRealSolverUtils . solve ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail () ; } catch ( MathIllegalArgumentException ex ) {} }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
if ( begin + length > values.length ) { throw new NumberIsTooLargeException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END , begin + length , values.length , true ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ NumberFormat f = CompositeFormat . getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , CompositeFormat . getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ( new ComplexFormat () ) . format ( z ) ) ; }
CompositeFormat . formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( CompositeFormat . getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
Class < > type
{ this ( imaginaryCharacter , format , format ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw new MathArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw new MathInternalError ( ex ) ; }
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsStates . isEmpty () ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , y , yDot , t ) ;
final double temp = sinEpsA * HEX_40000000 ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * HEX_40000000 ;
if ( x >= TWO_POWER_52 || x <= - TWO_POWER_52 ) { return x ; }
if ( y >= TWO_POWER_52 || y <= - TWO_POWER_52 ) { return pow ( - x , y ) ; }
final double epsilon = xa - EIGHTHS [ idx ] ;
final double epsilon = xa - EIGHTHS [ idx ] ;
final boolean fatal = true ;
final boolean fatal = false ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return copySign ( Math.PI , y ) ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? copySign ( Math.PI , xa ) : xa ; }
@ Ignore
{ return ( int ) floor ( x + NUMBER_CONSTANT ) ; }
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
{ return ONE_WAY_ANANOVA . anovaTest ( categoryData , alpha ) ; }
{ return ONE_WAY_ANANOVA . anovaPValue ( categoryData ) ; }
{ return ONE_WAY_ANANOVA . anovaFValue ( categoryData ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return UNKNOWN_DISTRIBUTION_CHI_SQUARE_TEST . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( counts , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed ) ; }
{ return CHI_SQUARE_TEST . chiSquareTest ( expected , observed , alpha ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( counts ) ; }
{ return CHI_SQUARE_TEST . chiSquare ( expected , observed ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return T_TEST . tTest ( sample1 , sample2 ) ; }
{ return T_TEST . tTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . tTest ( mu , sampleStats ) ; }
{ return T_TEST . tTest ( mu , sampleStats , alpha ) ; }
{ return T_TEST . tTest ( mu , sample ) ; }
{ return T_TEST . tTest ( mu , sample , alpha ) ; }
{ return T_TEST . t ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . t ( sample1 , sample2 ) ; }
{ return T_TEST . t ( mu , sampleStats ) ; }
{ return T_TEST . t ( mu , observed ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 ) ; }
{ return T_TEST . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . pairedT ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return T_TEST . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return T_TEST . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return T_TEST . homoscedasticT ( sample1 , sample2 ) ; }
private TestUtils () { super(); }
return y ;
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
double numer = bits & NUMBER_CONSTANT ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
setStateInitialized ( false ) ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final double g = Gaussian . value ( diff , norm , i2s2 ) ;
{ super ( optimizer ) ; ; }
final boolean fatal = true ;
{ this ( specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ Assert . assertEquals ( reference , p . toString () ) ; }
{ Assert . assertEquals ( reference , p . toString () ) ; }
Assert . assertEquals ( reference , p . multiply ( q ) . toString () ) ;
oneOverN = NUMBER_CONSTANT / n ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction () ;
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException () ; }
catch ( IOException ioe ) {}
super ( specific , lo , hi , fLo , fHi , args ) ;
{ this ( LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi ) ; }
{ super ( specific , null ) ; }
super ( specific , wrong , max ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max , boundIsAllowed ) ; }
{ super ( specific , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; }
super ( specific , wrong , expected ) ;
{ this ( LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION , null ) ; }
{ super ( specific , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , NUMBER_CONSTANT ) ; }
super ( specific , wrong , min ) ;
{ this ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min , boundIsAllowed ) ; }
{ super ( specific , wrong , args ) ; }
{ this ( LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
{ super ( specific , max , args ) ; this . max = max ; }
public MaxCountExceededException ( Number max ) { this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
public MathInternalError ( final Throwable cause ) { super ( cause , LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ ++ count ; Assert . assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , STRING_CONSTANT ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
private Erf () {}
private Beta () {}
private Gamma () {}
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
@ Before
{ Assert . assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
@ After public void tearDown () { refValues = null ; matrix = null ; }
@ Before
{ Assert . assertTrue ( isIncludedColumn ( eigenVector , ed . getV () , tolerance ) ) ; }
@ Before
@ Before public void setUp () { f = new Frequency () ; }
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
Assert . assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
{ double variance = regression . estimateRegressandVariance () ; Assert . assertTrue ( variance > NUMBER_CONSTANT ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; Assert . assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; Assert . assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; Assert . assertEquals ( getNumberOfRegressors () , beta.length ) ; }
{ FractionField field = FractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
Assert . assertTrue ( fitnessCalls <= neededCalls ) ;
Assert . assertEquals ( NUMBER_CONSTANT , numDifferent ) ;
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
Assert . assertEquals ( c3 , population . getFittestChromosome () ) ;
{ Assert . assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ Assert . assertEquals ( null , expected , actual , delta ) ; }
{ BigRealField field = BigRealField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
Assert . assertTrue ( uniquePointIsCenter ) ;
Assert . assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
Assert . assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
Assert . assertEquals ( expected . getN () , observed . getN () ) ;
try { new Fraction ( a , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ConvergenceException ce ) {}
{ Assert . assertEquals ( y [ i ] , iResult [ i ] ) ; }
Assert . assertTrue ( FastMath . abs ( h ) < minStep ) ;
catch ( FractionConversionException fce ) { Assert . fail ( fce . getMessage () ) ; }
catch ( FractionConversionException fce ) { Assert . fail ( fce . getMessage () ) ; }
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; Assert . assertNotNull ( drk ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
Assert . assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ After public void tearDown () { pb = null ; integ = null ; }
@ Before
{ BigFractionField field = BigFractionField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
Assert . fail ( STRING_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { Assert . assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( approYDot , yDot [ i ] , threshold ) ;
{ ComplexField field = ComplexField . getInstance () ; Assert . assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { Assert . assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { Assert . assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Before public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
Assert . assertTrue ( maxError < NUMBER_CONSTANT ) ;
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
if ( isLast ) { Assert . assertTrue ( maxError > NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , changes ) ;
{ if ( column > row ) { Assert . assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
{ if ( column < row ) { Assert . assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
Assert . assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
Assert . assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
public NoDataException ( Localizable specific ) { super ( specific ) ; }
double . . . param
double . . . param
final double . . . parameters
double . . . parameters
double . . . param
double . . . param
double . . . param
double . . . param
double . . . param
double . . . param
double . . . doubles
double . . . parameters
double . . . param
double . . . param
UnivariateRealIntegratorImpl integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
public void setMinimalIterationCount ( final int count ) { minimalIterationCount = count ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
final double [] z = concatenateSamples ( x , y ) ;
double getRelativeAccuracy ( ) ;
double getAbsoluteAccuracy ( ) ;
int getMaximalIterationCount ( ) ;
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
{ throw new UnsupportedOperationException ( DEPRECATION_MESSAGE ) ; }
Assert . assertEquals ( PearsonsCorrelation . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ PearsonsCorrelation . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
normps = ps . getFrobeniusNorm () ;
normps = ps . getFrobeniusNorm () ;
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon , maxUlps ) ;
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ context . addMessage ( pattern , args ) ; }
{ getContext () . addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
{ super ( cause ) ; context . addMessage ( pattern , arguments ) ; }
{ context . addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; context . addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
{ context . addMessage ( pattern , args ) ; }
{ super ( cause ) ; context . addMessage ( pattern , args ) ; }
{ context . addMessage ( pattern , args ) ; }
{ getContext () . addMessage ( pattern , args ) ; }
{ context . addMessage ( pattern , args ) ; }
{ super ( max ) ; getContext () . addMessage ( LocalizedFormats.EVALUATIONS ) ; }
this . field = field ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( out , false ) ;
return new ArrayRealVector ( out , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ this ( extractField ( d ) , d ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testData ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
{ return projection ( new ArrayFieldVector < T > ( getField () , v , false ) ) ; }
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
final String source
{ super ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { super ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
final BSPTreeVisitor < S > visitor
void visitLeafNode ( BSPTree < S > node ) ;
BSPTree < S > node
BSPTree < S > node
Hyperplane < S > other
Vector < S > point
final Hyperplane < Euclidean1D > other
final Vector2D p
final Hyperplane < Euclidean2D > other
final Vector2D p
final Vector2D tmp = loop [ min ] ;
final Vector2D [] bLoop
Vector3D point = p . intersection ( l ) ;
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree < Euclidean2D > ( Boolean.FALSE ) ) ; }
final BSPTree < Euclidean1D > tree
Vector3D [] points
final BSPTree < Euclidean2D > tree
public Order visitOrder ( final BSPTree < Euclidean2D > node ) { return Order.MINUS_SUB_PLUS ; }
final Hyperplane < Euclidean3D > other
final Vector < Euclidean3D > point
final Vector3D p
origin = new Vector3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree < Euclidean3D > node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree < Euclidean3D > tree
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyper ) ;
public abstract Side side ( Hyperplane < S > hyper ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.NEGATIVE_ELEMENT_AT_INDEX , i , in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( LocalizedFormats.OUT_OF_RANGE_SIMPLE , val , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( LocalizedFormats.INVALID_BINARY_DIGIT , i ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimateVector ; }
if ( t == NUMBER_CONSTANT && i >= j ) { continue; }
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . maxGenerations = maxGenerations ; }
if ( ! forward ) { h = - h ; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( remA > NUMBER_CONSTANT ) { break; }
if ( x * x == NUMBER_CONSTANT ) { return Double.NaN ; }
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) { return anotherChr ; } } return null ; }
if ( y . equals ( py ) ) { break; }
if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; }
if ( boundaries == null ) { return x ; }
if ( boundaries == null ) { return x ; }
if ( negccov > negcovMax ) { negccov = negcovMax ; }
{ numElements -= i ; if ( front ) { startIndex += i ; } }
{ super ( relativeAccuracy , absoluteAccuracy ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy ) ; }
{ this . allowed = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( var ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( var ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN ) { return NaN ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN || Double . isNaN ( rhs ) ) { return NaN ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
if ( isNaN ) { return NUMBER_CONSTANT ; }
if ( isNaN || rhs.isNaN ) { return NaN ; }
{ if ( isNaN ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathIllegalStateException () ; } }
Assert . assertTrue ( Double . isNaN ( w . getReal () ) ) ;
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( indexOutOfBound ) ; }
{ return outerProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getLInfDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getL1Distance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return getDistance ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return dotProduct ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeDivide ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return ebeMultiply ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return subtract ( ( ( ArrayRealVector ) v ) . data ) ; }
{ return add ( ( ( ArrayRealVector ) v ) . data ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.REGULA_FALSI ) ; }
Assert . assertSame ( Complex.NaN , z ) ;
{ return node . getElement () . intValue () ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new ModelSpecificationException ( LocalizedFormats.NO_REGRESSORS ) ; }
{ addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BracketingNthOrderBrentSolver ( convergence , NUMBER_CONSTANT ) ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolution.LEFT_SIDE ) ;
this . allowed = AllowedSolution.ANY_SIDE ;
this . allowed = AllowedSolution.ANY_SIDE ;
this . allowed = AllowedSolution.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolution.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolution.ANY_SIDE ; this . method = method ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double dot = v1 . dotProduct ( v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == m ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - INDEX_OFFSET , col - INDEX_OFFSET , value ) ; }
{ super . setEntry ( index - INDEX_OFFSET , value ) ; }
fsave = fval . getEntry ( INDEX_OFFSET ) ;
crossP . dotProduct ( otherPlane . getNormal () ) < NUMBER_CONSTANT
crossP . dotProduct ( otherPlane . getNormal () ) < NUMBER_CONSTANT
double scaled = area * facetB . dotProduct ( plane . getNormal () ) ;
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - d . dotProduct ( direction ) , direction ) ;
{ return point . dotProduct ( w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - p . dotProduct ( w ) ; setFrame () ; }
public Line revert () { return new Line ( zero , zero . subtract ( direction ) ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ return t ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return s ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { return t ; }
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
RealVector v = RealVector . unmodifiableRealVector ( u ) ;
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
final ArrayRealVector x = new ArrayRealVector ( dim ) ;
final double [] actual = x . toArray () ;
final double [] actual = z . toArray () ;
double [] d2 = w . toArray () ;
{ return coefficients . dotProduct ( new ArrayRealVector ( point , false ) ) + constantTerm ; }
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , ( RandomGenerator ) null ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * SQRT2 ) ) ) ;
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = ConvergenceException . class )
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumnVector ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertEquals ( z , Complex.INF ) ;
Assert . assertEquals ( z , Complex.NaN ) ;
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext cOut = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
final ExceptionContext c = new ExceptionContext ( new Exception ( STRING_CONSTANT ) ) ;
@ Test ( expected = MaxCountExceededException . class )
@ Test ( expected = MaxCountExceededException . class )
Exception e
Exception e
int i = FACT_LEN - NUMBER_CONSTANT
final double [] x = b . toArray () ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
final double objectiveValue = computeObjectiveValue ( currentBest . toArray () ) ;
f = computeObjectiveValue ( currentBest . toArray () ) ;
final double [] actual = x . toArray () ;
final double [] actual = x . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
final double [] actual = x . combine ( a , b , y ) . toArray () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . toArray () ) ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . toArray () ) { sum -= coefficient ; } return sum ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . toArray () , entryTolerance ) ;
public double [] getStateEstimation () { return stateEstimation . toArray () ; }
double [] y = u . add ( x . operate ( b ) ) . toArray () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . toArray () , NUMBER_CONSTANT ) ;
return e . toArray () ;
{ RealVector b = calculateBeta () ; return b . toArray () ; }
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . toArray () ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( ltI [ i ] , i , absolutePositivityThreshold ) ; }
{ return hasIntercept ? getIntercept ( getSlope () ) : NUMBER_CONSTANT ; }
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
int i = FACT.length - NUMBER_CONSTANT
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecompositionImpl llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecomposition ( s ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecomposition ed
EigenDecomposition ed
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
final int max = val.length ;
final int max = val.length ;
final int max = val.length ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
throw new MathInternalError () ;
final double slope
final double slope
final double alpha
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecomposition < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecomposition ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
catch ( NonMonotonicSequenceException iae ) {}
@ Test ( expected = NonMonotonicSequenceException . class )
@ Test ( expected = NonMonotonicSequenceException . class )
catch ( NonMonotonicSequenceException iae ) {}
final DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( jTj ) , threshold ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecomposition ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecomposition ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix Rinv = new LUDecomposition ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecomposition ( mA ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecomposition ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecomposition ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecomposition ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecomposition ( rm ) ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecomposition ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.Action.CONTINUE ; }
nextAction = EventHandler.Action.CONTINUE ;
ExpandableFirstOrderDifferentialEquations equations
final ExpandableFirstOrderDifferentialEquations equations
final ExpandableFirstOrderDifferentialEquations equations
{ out . writeDouble ( polynomials [ k ] [ l ] ) ; }
final double e = polynomials [ currentDegree ] [ i ] / scale [ i ] ;
Array . newInstance ( field . getRuntimeClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
bp = ( T [] ) Array . newInstance ( field . getRuntimeClass () , m )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getRuntimeClass () , length )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
( T [] [] ) Array . newInstance ( field . getRuntimeClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getRuntimeClass () , length ) ; }
solver . solve ( a , b ) ;
final RealVector x = solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
solver . solve ( a , m , b ) ;
final RealVector x = solver . solve ( a , b ) ;
final RealVector x = solver . solve ( a , b , x0 ) ;
final RealVector x = solver . solveInPlace ( a , b , x0 ) ;
final RealVector x = solver . solve ( a , b ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
solver . solve ( a , b , x ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw new MathIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( MathIllegalArgumentException e ) {}
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( MathParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ZeroException ex ) {}
{ if ( getN () > NUMBER_CONSTANT ) { throw new MathIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw new MathIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new MathIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw new ArrayIndexOutOfBoundsException ( index ) ; }
catch ( ClassCastException ex ) { throw new MathIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathIllegalStateException cause = new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , inMsg ) ;
{ evaluations . incrementCount () ; expandable . computeDerivatives ( t , y , yDot ) ; }
{ this . expandable = equations ; }
allocateInterpolatedArrays ( y.length ) ;
allocateInterpolatedArrays ( - NUMBER_CONSTANT ) ;
catch ( Exception ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + p + STRING_CONSTANT + ex . getMessage () ) ; }
catch ( Exception ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
@ Test ( expected = NonPositiveDefiniteOperatorException . class )
@ Test ( expected = NonSquareOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw new MathIllegalStateException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw new MathIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw new ZeroException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
catch ( IOException e ) { throw new MathIllegalStateException ( e , LocalizedFormats.SIMPLE_MESSAGE , e . getLocalizedMessage () ) ; }
catch ( ZeroException ze ) {}
catch ( MathIllegalStateException mise ) {}
final List < BigFraction > coefficients
final List < BigFraction > coefficients
double y = x * F_1_3 - F_1_2 ;
if ( FastMath . abs ( m ) <= tol || Precision . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
Assert . assertTrue ( Precision . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( mode == StepNormalizerMode.MULTIPLES && Precision . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
{ Assert . assertTrue ( Precision . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( Precision . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || Precision . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
! Precision . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance )
for ( double value : values ) { if ( Precision . equals ( value , x , epsilon ) ) { return; } }
Precision . equalsIncludingNaN ( stat . getN () , getN () )
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ if ( this . parameters == null ) { return null ; } return MathArrays . copyOf ( parameters ) ; }
MathArrays . checkOrder ( knots ) ;
public int [] getOrderOfRegressors () { return MathArrays . copyOf ( vorder ) ; }
{ include ( MathArrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
MathArrays . checkOrder ( x ) ;
{ this ( wrong , previous , index , MathArrays.OrderDirection.INCREASING , true ) ; }
MathArrays . checkOrder ( xval ) ;
final double [] d = MathArrays . copyOf ( direc [ i ] ) ;
MathArrays . checkOrder ( x ) ;
{ return MathArrays . distance ( point , p . getPoint () ) ; }
RealMatrix arzneg = selectColumns ( arz , MathArrays . copyOf ( arReverseIndex , mu ) ) ;
return MathArrays . checkOrder ( x , MathArrays.OrderDirection.INCREASING , true , abort ) ;
MathArrays . sortInPlace ( xNew , yNew ) ;
MathArrays . sortInPlace ( this . x , this . y ) ;
public int [] getSizes () { return MathArrays . copyOf ( size ) ; }
this . size = MathArrays . copyOf ( size ) ;
public int [] getCounts () { return MathArrays . copyOf ( counter ) ; }
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathArrays . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / ArithmeticsUtils . gcd ( a , b ) , b ) ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
int gcd = ArithmeticUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticUtils . gcd ( num , den ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
FastMath . signum ( y0 ) + FastMath . signum ( ym ) == NUMBER_CONSTANT
{ return FastMath . abs ( x ) < SHORTCUT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
if ( n < Precision.EPSILON ) { return zero ; }
if ( n < Precision.SAFE_MIN ) { return distance ( line.zero ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( Precision.SAFE_MIN ) ) ;
if ( d > - Precision.SAFE_MIN && d < Precision.SAFE_MIN ) { return d ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * Precision.EPSILON ;
if ( FastMath . abs ( diag ) < Precision.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
if ( FastMath . abs ( diag ) < Precision.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > Precision.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , Precision.EPSILON ) ; }
FastMath . abs ( sumXX ) > Precision.SAFE_MIN
@ Test ( expected = NumberIsTooLargeException . class )
{ this ( numberOfInterpolationPoints , DEFAULT_INITIAL_RADIUS , DEFAULT_STOPPING_RADIUS ) ; }
this . stopfitness = stopFitness ;
this . stopFitness = stopFitness ;
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public boolean isInfinite () { throw unsupported () ; }
@ Override public boolean isNaN () { throw unsupported () ; }
@ Override public void unitize () { throw unsupported () ; }
@ Override public double getLInfNorm () { throw unsupported () ; }
@ Override public double getL1Norm () { throw unsupported () ; }
@ Override public double getNorm () { throw unsupported () ; }
double [] bounds = empiricalDistribution2 . getGeneratorUpperBounds () ;
FieldDecompositionSolver < Fraction > solver ;
double floatn = v.length ;
final double [] eventY = interpolator . getInterpolatedState () . clone () ;
final double [] yTmp = y0 . clone () ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistribution betaDistribution = new BetaDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
BetaDistribution d = new BetaDistribution ( alpha , beta ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistribution ( df ) ;
setDistribution ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistribution ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistribution ( NUMBER_CONSTANT ) ) ;
FDistribution fd = new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
GammaDistribution distribution = new GammaDistribution ( a , b ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistribution ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
{ gamma = new GammaDistribution ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
HypergeometricDistribution dist = new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NormalDistribution normal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistribution ( mean , sd ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistribution ( p , FastMath . sqrt ( p ) ) ;
TDistribution tDistribution = new TDistribution ( NUMBER_CONSTANT ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
TDistribution td = new TDistribution ( df ) ;
setDistribution ( new TDistribution ( NUMBER_CONSTANT ) ) ;
{ TDistribution td = new TDistribution ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; }
@ Override public TDistribution makeDistribution () { return new TDistribution ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistribution ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistribution ( mean ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
PoissonDistribution dist = new PoissonDistribution ( mean ) ;
{ PoissonDistribution dist = new PoissonDistribution ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistribution ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistribution ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
dist = new ZipfDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return - magnitude ; }
if ( c . isAssignableFrom ( UnivariateFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new XMinus5Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final DifferentiableUnivariateFunction f
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateFunction sif = new SimpleInverseFunction () ;
UnivariateFunction f
UnivariateFunction func
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Gaussian () ;
final UnivariateFunction f = new Gaussian () ;
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
DifferentiableUnivariateFunction f
UnivariateFunction f
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = i . interpolate ( x , y ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction dfdx = f . derivative () ;
final UnivariateFunction f = new Sigmoid () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f
UnivariateFunction f
final UnivariateFunction f
DifferentiableUnivariateFunction f = new QuinticFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction f
UnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final UnivariateFunction f
final UnivariateFunction f
UnivariateFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateFunction dfdx = f . derivative () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f
final UnivariateFunction lsf = new LineSearchFunction ( searchDirection ) ;
DifferentiableUnivariateFunction f
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new QuinticFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction function
UnivariateFunction function
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateFunction function ) { throw unsupported () ; }
public MonitoredFunction ( UnivariateFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateFunction dSpline = spline . derivative () ;
final MultivariateFunction evaluationFunction
MultivariateFunction func
MultivariateFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
final DifferentiableMultivariateFunction f
DifferentiableMultivariateFunction func
DifferentiableMultivariateFunction func
MultivariateFunction func
final MultivariateFunction evaluationFunction
final MultivariateFunction evaluationFunction
MultivariateFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; maxError = NUMBER_CONSTANT ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
evaluations . resetCount () ;
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; }
final DifferentiableMultivariateVectorFunction f
final MultivariateVectorFunction function
final MultivariateVectorFunction function
final MultivariateVectorFunction function
# optimize ( int , MultivariateVectorFunction , double [] , double [] , double [] )
DifferentiableMultivariateVectorFunction problem
result = transformer . inverseTransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inverseTransform2 ( temp ) ; }
double dResult [] = transformer . inverseTransform ( dY ) ;
Object [] o
double [] d
Complex [] f
double [] f
Complex [] f
double [] f
double [] f
double [] f
double [] f
double [] f
int [] x
double [] x
int [] f
double [] f
double [] f
double [] f
double [] f
double [] f
double [] f
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
int bits
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
catch ( Exception e ) { Assert . fail ( STRING_CONSTANT ) ; }
catch ( Exception e ) { Assert . fail ( STRING_CONSTANT ) ; }
int x
p = dist . cumulativeProbability ( ( int ) x ) ;
RealDistribution distribution
RealDistribution distribution
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastFourierTransformer transformer = FastFourierTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
FastCosineTransformer transformer = FastCosineTransformer . create () ;
DifferentiableMultivariateVectorOptimizer optimizer
{ DifferentiableMultivariateVectorOptimizer optimizer = new GaussNewtonOptimizer ( true ) ; checkUnsolvableProblem ( optimizer , false ) ; }
final DifferentiableMultivariateVectorOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
final DifferentiableMultivariateVectorOptimizer optimizer
public GaussianFitter ( DifferentiableMultivariateVectorOptimizer optimizer ) { super ( optimizer ) ; }
final BaseMultivariateOptimizer < FUNC > optimizer
MultivariateOptimizer optim
final DifferentiableMultivariateOptimizer optimizer
final MultivariateOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; clear () ; }
{ if ( rand == null ) { initRan () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
Assert . assertEquals ( NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE , Integer.MAX_VALUE } ) ;
{ return numberOfTrials * probabilityOfSuccess ; }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! ArithmeticUtils . isPowerOfTwo ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! ArithmeticUtils . isPowerOfTwo ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FunctionUtils . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FunctionUtils . sample ( f , min , max , n ) ) ;
{ return fht ( FunctionUtils . sample ( f , min , max , n ) ) ; }
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
final double [] data = FunctionUtils . sample ( f , min , max , n ) ;
return TransformUtils . scaleArray ( fst ( data ) , s ) ;
return TransformUtils . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return TransformUtils . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return TransformUtils . scaleArray ( fst ( f ) , s ) ; }
TransformUtils . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return TransformUtils . scaleArray ( transformed , NUMBER_CONSTANT ) ;
return TransformUtils . scaleArray ( fft ( f ) , s ) ;
return TransformUtils . scaleArray ( fft ( data , true ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return TransformUtils . scaleArray ( fft ( f ) , s ) ; }
return TransformUtils . scaleArray ( fft ( data , false ) , s ) ;
return TransformUtils . scaleArray ( fft ( f , false ) , s ) ;
TransformUtils . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return TransformUtils . scaleArray ( fct ( f ) , s1 ) ;
return TransformUtils . scaleArray ( fct ( f ) , s ) ;
return TransformUtils . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return TransformUtils . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ for ( double diag : rDiag ) { if ( FastMath . abs ( diag ) <= threshold ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag , threshold ) ; }
@ Test ( expected = NumberIsTooLargeException . class )
final UnivariateSolver solver
final UnivariateSolver solver
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolver solver = new MullerSolver () ;
UnivariateSolverUtils . verifyInterval ( lower , upper ) ;
{ return super . solve ( maxEval , f , UnivariateSolverUtils . midpoint ( min , max ) ) ; }
final UnivariateSolver lineSearchSolver
final UnivariateSolver lineSearchSolver
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new RiddersSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new BrentSolver () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
UnivariateSolver solver = new MullerSolver2 () ;
double x = UnivariateSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
UnivariateSolver solver
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
UnivariateSolver solver = getSolver () ;
final UnivariateSolver solver = new RegulaFalsiSolver () ;
final UnivariateSolver solver
final int populationLimit
final Chromosome chromosome
final List < Chromosome > chromosomes
final int arity
final Population population
final Chromosome original
final Chromosome another
final Chromosome another
final int l
final List < Double > chromosomeRepresentation
final Chromosome another
final List < T > sequence
final Double [] representation
final Population current
final RandomGenerator random
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
partialDerivatives = new BivariateFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
BivariateFunction div = new Divide () ;
BivariateFunction bi = new Add () ;
BivariateFunction bi = new Add () ;
final BivariateFunction f
final BivariateFunction f
final BivariateFunction combiner
final BivariateFunction combiner
final BivariateFunction combiner
final IterativeLinearSolverEvent event = new SymmLQEvent ( this , state ) ;
{ return x . ebeDivide ( diag ) ; }
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final RealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( f.length ) ;
roots . computeOmega ( - f.length ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator i = new LinearInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
UnivariateInterpolator interpolator = new NevilleInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateGridInterpolator interpolator = new BicubicSplineInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateInterpolator interpolator = new DividedDifferenceInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateGridInterpolator interpolator = new TricubicSplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
UnivariateInterpolator i = new SplineInterpolator () ;
roots . computeRoots ( f.length ) ;
roots . computeRoots ( - f.length ) ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateIntegrator integrator = new TrapezoidIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , BaseAbstractUnivariateIntegrator.DEFAULT_RELATIVE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_ABSOLUTE_ACCURACY , BaseAbstractUnivariateIntegrator.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new SimpsonIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
UnivariateIntegrator integrator = new RombergIntegrator () ;
final BaseAbstractUnivariateIntegrator baseIntegrator
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new MathIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = n / ( n - NUMBER_CONSTANT ) ;
final double fact2 = n / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double time ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {}
catch ( MathIllegalArgumentException e ) { e . printStackTrace () ; }
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw new MathIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
{ computeDistribution ( EmpiricalDistribution.DEFAULT_BIN_COUNT ) ; }
EmpiricalDistribution dist = new EmpiricalDistribution ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistribution () . load ( ( File ) null ) ; }
{ new EmpiricalDistribution () . load ( ( URL ) null ) ; }
{ new EmpiricalDistribution () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistribution () ;
new EmpiricalDistribution () . load ( x ) ;
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { MathArrays . copyOf ( f , f.length ) , new double [ f.length ] }
final Collection < double [] > categoryData
final Collection < double [] > categoryData
final Collection < double [] > categoryData
final boolean exactPValue
double dResult [] = transformer . transform ( dY , TransformType.INVERSE ) ;
double dResult [] = transformer . transform ( dX , TransformType.FORWARD ) ;
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
UnivariatePointValuePair [] optima = optimizer . getOptima () ;
public SimplexOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
PointValuePair expected
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < PointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < UnivariatePointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < UnivariatePointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
ConvergenceChecker < PointValuePair > checker
PointValuePair [] points
PointValuePair point
final Comparator < PointValuePair > comparator
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
org.apache.commons.math.stat.inference.ChiSquareTest csti = new org.apache.commons.math.stat.inference.ChiSquareTest () ;
ChiSquareTest chiSquareTest = new ChiSquareTest () ;
PointVectorValuePair optimum
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
ConvergenceChecker < PointVectorValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < PointVectorValuePair > checker ) { super ( checker ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleValueChecker () ) ; }
{ this ( new SimpleValueChecker ( rel , abs ) ) ; }
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new MathUnsupportedOperationException () ; }
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
FastSineTransformer transformer = new FastSineTransformer ( DstNormalization.STANDARD_DST_I ) ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , FastMath . abs ( h ) , minStep , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOT_ALLOWED ) ; }
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT ; }
static double [] loadExpFracB () { return EXP_FRAC_B ; }
static double [] loadExpFracA () { return EXP_FRAC_A ; }
static double [] loadExpIntB () { return EXP_INT_B ; }
static double [] loadExpIntA () { return EXP_INT_A ; }
@ Test ( expected = DimensionMismatchException . class )
@ Test ( expected = DimensionMismatchException . class )
StringBuffer imAppendTo ;
{ if ( this . fitness == NO_FITNESS ) { this . fitness = fitness () ; } return this . fitness ; }
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setControlFactors ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment . getResult () - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
double [] hatResiduals = I . subtract ( hat ) . operate ( model . getY () ) . toArray () ;
{ RealVector b = calculateBeta () ; return yVector . subtract ( xMatrix . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( xMatrix . getRowDimension () - xMatrix . getColumnDimension () ) ;
RealVector e = yVector . subtract ( xMatrix . operate ( b ) ) ;
this . yVector = new ArrayRealVector ( y ) ;
return t / ( getX () . getRowDimension () - getX () . getColumnDimension () ) ;
int p = getX () . getColumnDimension () ;
{ return qr . getSolver () . solve ( getY () ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
final RealMatrix x = ols . getX () . copy () ;
final int length = b . getDimension () ;
final double epsa = ( s + MACH_PREC ) * CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state . getRightHandSideVector () ) ; }
this . xL . set ( NUMBER_CONSTANT ) ;
this . xL = x ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new SymmLQ ( maxIterations , NUMBER_CONSTANT , true ) ;
double [] array
final double [] [] householderMatrix
{ this ( k , v , false ) ; }
{ this ( entry . getKey () , entry . getValue () ) ; }
{ key = k ; value = v ; }
throw new MathInternalError () ;
throw new MathInternalError () ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
{ return shape * scale ; }
v . walkInOptimizedOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT ) ; }
{ tree . visit ( new BoundaryBuilder < S > () ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = MathArrays . copyOf ( values ) ; }
catch ( MathArithmeticException e ) {}
T f
T f
final long n1n2prod = ( long ) n1 * n2 ;
{ create ( new double [ NUMBER_CONSTANT ] ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( new double [ NUMBER_CONSTANT ] ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new RealVectorTestImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new RealVectorTestImpl ( data ) ; }
RealVectorTestImpl v7_i = new RealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
Assert . assertEquals ( dataU [ i ] + STRING_CONSTANT + dataV [ j ] , expected , actual , NUMBER_CONSTANT ) ;
private ComplexUtils () {}
Object other
final int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite ) ;
ed = new EigenDecomposition ( distinct ) ;
ed = new EigenDecomposition ( repeated ) ;
ed = new EigenDecomposition ( m ) ;
RealMatrix v = new EigenDecomposition ( matrix ) . getV () ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( symmetric ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
ed = new EigenDecomposition ( matrix ) ;
{ return ( int ) FastMath . min ( nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ final double n = random . nextGaussian () ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C ) ;
BaseRuleFactory < ? extends Number > factory
final GaussIntegrator g = FACTORY . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_PREFIX , DEFAULT_ROW_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m ) . getSolver () ;
{ final double multiplier = tableau . getEntry ( i , pivotCol ) ; tableau . subtractRow ( i , pivotRow , multiplier ) ; }
if ( entry < minValue ) { minValue = entry ; minPos = i ; }
if ( p < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException ( LocalizedFormats.SIMPLE_MESSAGE , e . getMessage () ) ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , EPSILON ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , realMatrixFormat . parse ( source , pos ) ) ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
DifferentiableUnivariateFunction f = new Sin () ;
UnivariateFunction f = new Expm1 () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
final UnivariateFunction f = new Sin () ;
UnivariateFunction f = new Sin () ;
{ delegate . setSecureAlgorithm ( algorithm , provider ) ; }
{ return delegate . nextZipf ( numberOfElements , exponent ) ; }
{ return delegate . nextWeibull ( shape , scale ) ; }
{ return delegate . nextT ( df ) ; }
{ return delegate . nextPascal ( r , p ) ; }
{ return delegate . nextHypergeometric ( populationSize , numberOfSuccesses , sampleSize ) ; }
{ return delegate . nextF ( numeratorDf , denominatorDf ) ; }
{ return delegate . nextChiSquare ( df ) ; }
{ return delegate . nextCauchy ( median , scale ) ; }
{ return delegate . nextBinomial ( numberOfTrials , probabilityOfSuccess ) ; }
{ return delegate . nextBeta ( alpha , beta ) ; }
{ return delegate . nextUniform ( lower , upper ) ; }
{ delegate = new RandomDataGenerator ( rand ) ; }
double dotProduct = new IterativeLegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
FastMath . exp ( logGamma ( shape ) )
@ Override public int hashCode () { throw new MathUnsupportedOperationException () ; }
{ throw new MathUnsupportedOperationException () ; }
final double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( new StreamDataAdapter ( in ) ) ;
final UnivariateDifferentiableFunction sPrime = new Sqrt () ;
final UnivariateDifferentiableFunction f = new QuinticFunction () ;
UnivariateDifferentiableFunction f = new Sin () ;
final UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction f
UnivariateDifferentiableFunction f
final UnivariateDifferentiableFunction q = new QuinticFunction () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.INDEX , i ) ; }
final MultivariateDifferentiableVectorFunction problem ;
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
{ gradient = f . gradient () ; return optimizeInternal ( maxEval , f , goalType , startPoint ) ; }
MultivariateDifferentiableVectorFunction problem
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
final Quaternion product = Quaternion . multiply ( inverseQ , q ) ;
final double normSquareRef = Quaternion . multiply ( q , q . getConjugate () ) . getScalarPart () ;
{ return multiply ( this , q ) ; }
optimum = new PointValuePair ( fitfun . repairAndDecode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
final double tmp = wxi * xi / di ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = iterator () ;
Iterator < Entry > it = v . iterator () ;
Iterator < Entry > it = v . iterator () ;
public double [] getStartPoint () { return start == null ? null : start . clone () ; }
{ return super . optimizeInternal ( maxEval , f , goalType , new InitialGuess ( startPoint ) ) ; }
public double [] getUpperBound () { return super . getUpperBound () ; }
public double [] getLowerBound () { return super . getLowerBound () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + maxIterations ) )
final int dim = getDimension () ;
final int dim = getDimension () ;
final int dim = getDimension () ;
final double [] [] out = new double [ [ sampleSize ] [ dimension ] ;
{ random = rng ; dimension = n ; }
final int dim = d . getDimension () ;
final int dim = d . getDimension () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
double [] insigma = point ( DIM , NUMBER_CONSTANT ) ;
final double . . . f
jF = f ;
{ distribution . get ( i ) . reseedRandomGenerator ( i + NUMBER_CONSTANT + seed ) ; }
FUNC f
FUNC f
final RealMatrix d = MatrixUtils . createRealDiagonalMatrix ( eigenValues ) ;
RealMatrix m = MatrixUtils . createRealDiagonalMatrix ( diagonal ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getInf () ; }
final double [] sigma = optim . computeSigma ( regress , NUMBER_CONSTANT ) ;
final double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . computeCovariances ( paramFound , NUMBER_CONSTANT ) ;
final double [] [] covarMatrix = optimizer . computeCovariances ( solution , NUMBER_CONSTANT ) ;
qrDecomposition ( computeWeightedJacobian ( currentPoint ) ) ;
final RealMatrix j = computeWeightedJacobian ( params ) ;
final RealMatrix weightedJacobian = computeWeightedJacobian ( currentPoint ) ;
try { testStatistic . gTest ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTest ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getCapacity () ) ; }
final ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ final ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode . hashCode () ;
expansionMode == ExpansionMode.MULTIPLICATIVE
expansionMode == ExpansionMode.MULTIPLICATIVE
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , DEFAULT_CONTRACTION_DELTA + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriterion ) . hashCode () ;
result = result && ( other.contractionCriterion == contractionCriterion ) ;
dest.contractionCriterion = source.contractionCriterion ;
{ checkContractExpand ( getContractionCriterion () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriterion = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriterion ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleVectorValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimplePointChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
NaturalRanking ranking = new NaturalRanking ( NaNStrategy.MAXIMAL , TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; maxIterationCount = ITERATION_CHECK_DISABLED ; }
@ Deprecated public SimpleUnivariateValueChecker () { maxIterationCount = ITERATION_CHECK_DISABLED ; }
logBeta ( a , b )
RandomDataGenerator randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
RandomDataGenerator randomData
this . q0 = scalar ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz ) ; }
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
final CodyWaite cw = new CodyWaite ( xa ) ;
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () , STRING_CONSTANT ) ) ;
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( function . getWeight () )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new Weight ( weights )
new Weight ( function . getWeight () )
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( w )
new Weight ( problem . weight () )
{ this ( d , true ) ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS , DEFAULT_CUT_OFF ) ; }
if ( FastMath . abs ( result ) < cutOff ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nRows ) ;
final T [] out = MathArrays . buildArray ( field , nCols ) ;
final T [] [] data = MathArrays . buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , rows ) ;
final T [] out = MathArrays . buildArray ( getField () , columns ) ;
final T [] outData = MathArrays . buildArray ( getField () , rows ) ;
final T [] outData = MathArrays . buildArray ( getField () , columns ) ;
final T [] [] data = MathArrays . buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = MathArrays . buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = MathArrays . buildArray ( field , data.length + NUMBER_CONSTANT ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
T [] out = MathArrays . buildArray ( field , data.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.length ) ;
data = MathArrays . buildArray ( field , v1.data.length + v2.data.length ) ;
data = MathArrays . buildArray ( field , v . getDimension () ) ;
data = MathArrays . buildArray ( field , size ) ;
data = MathArrays . buildArray ( field , size ) ;
final T [] [] out = MathArrays . buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = MathArrays . buildArray ( getField () , nCols ) ;
final T [] out = MathArrays . buildArray ( getField () , nRows ) ;
data = MathArrays . buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = MathArrays . buildArray ( getField () , rowCount , columnCount ) ;
data = MathArrays . buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = MathArrays . buildArray ( field , rowDimension , columnDimension ) ; }
T [] res = MathArrays . buildArray ( field , virtualSize ) ;
int exponent = ( int ) ( y . intLog10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a.value ) ) ; }
{ return new Decimal64 ( FastMath . IEEEremainder ( value , a ) ) ; }
return ePlus . subtract ( eMinus ) . divide ( ePlus . add ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - FastMath . IEEEremainder ( x , y ) ) ;
DerivativeStructure sAccurate = FieldVector3D . dotProduct ( u1 , u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , FieldVector3D . dotProduct ( r . getAxis () , reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataGenerator ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataGenerator () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataGenerator () ; }
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
T extends RealFieldElement < T >
@ Test ( expected = NumberIsTooLargeException . class )
{ getRandomGenerator () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRandomGenerator () . setSeed ( seed ) ; }
final RandomGenerator generator = getRandomGenerator () ;
{ return new FDistribution ( getRandomGenerator () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRandomGenerator () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRandomGenerator () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRandomGenerator () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRandomGenerator () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRandomGenerator () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRandomGenerator () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRandomGenerator () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRandomGenerator () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRandomGenerator () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRandomGenerator () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRandomGenerator () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRandomGenerator () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRandomGenerator () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRandomGenerator () ;
{ return getKernel ( stats ) . sample () ; }
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.INF ) ; }
{ return ( ( Float . floatToRawIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToRawLongBits ( d ) ;
final long bits = Double . doubleToRawLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToRawLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToRawLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long bits = Double . doubleToRawLongBits ( x ) ;
long xl = Double . doubleToRawLongBits ( d ) ;
File file = new File ( url . toURI () ) ;
{ return Double . longBitsToDouble ( MASK_NON_SIGN_LONG & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( MASK_NON_SIGN_INT & Float . floatToRawIntBits ( x ) ) ; }
final double [] [] matrix
{ this ( new Well19937c () , lower , upper ) ; }
{ fit ( initialMixture , DEFAULT_MAX_ITERATIONS , DEFAULT_THRESHOLD ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzziness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzziness ) ;
final long grayCode = i ^ ( i > > NUMBER_CONSTANT ) ;
int count = samples / centers ;
{ this . a [ i ] [ j ] = a [ i * N + j ] ; }
Assert . assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ double tEnd = test ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ double tEnd = test ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ final double midPoint = min + NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
incrementValue ( entry . getKey () , entry . getValue () . longValue () ) ;
Assert . assertFalse ( random . nextBoolean () ) ;
{ result [ i ] = r . call () . doubleValue () ; }
final int uniDimIndex = iter . next () . intValue () ;
{ super ( specific , value , INTEGER_ZERO , true ) ; }
public NotPositiveException ( Number value ) { super ( value , INTEGER_ZERO , true ) ; }
{ super ( specific , INTEGER_ZERO , arguments ) ; }
{ return expected [ index ] . intValue () ; }
{ return wrong [ index ] . intValue () ; }
{ super ( specific , value , INTEGER_ZERO , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , INTEGER_ZERO , false ) ; }
{ super ( specific , Integer . valueOf ( wrong ) , Integer . valueOf ( expected ) ) ; dimension = expected ; }
{ secRand = RandomGeneratorFactory . createRandomGenerator ( SecureRandom . getInstance ( algorithm , provider ) ) ; }
final RandomGenerator secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PAIR > checker ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
RandomDataGenerator randomData = new RandomDataGenerator () ;
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
double inv = NUMBER_CONSTANT / CombinatoricsUtils . factorial ( i ) ;
AbstractOptimizer < PAIR , OPTIM > other
{ return Double . parseDouble ( o . toString () ) ; }
return Double . parseDouble ( str ) ;
{ val = Double . parseDouble ( str ) ; sampleStats . addValue ( val ) ; }
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < Edge > edges = new ArrayList < Edge > ( n ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
List < int [] > row = new ArrayList < int [] > ( dRow.length * NUMBER_CONSTANT ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
final double [] vectorData ;
{ this ( value , DEFAULT_EPSILON , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREE ) ) ;
f . addValue ( THREE ) ;
{ return new Combinations ( n , k ) . iterator () ; }
int [] index = MathArrays . natural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , natural.length ) ; }
AbstractLeastSquaresOptimizer < OPTIM > other
if ( FastMath . abs ( a0 ) > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
mult . multiplyInPlace ( var1 ) ;
{ return MathArrays . verifyValues ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , weights , begin , length , false ) ; }
{ return MathArrays . verifyValues ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . verifyValues ( values , begin , length , false ) ; }
w -= NUMBER_CONSTANT ;
num %= den ;
if ( i > NUMBER_CONSTANT ) { randInt > > = NUMBER_CONSTANT ; }
for ( final T a : data ) { h ^= a . hashCode () ; }
rhs [ m ] /= X ;
coeff1 /= pc2 ;
bits &= NUMBER_CONSTANT ;
den += NUMBER_CONSTANT ;
trial *= NUMBER_CONSTANT ;
den += NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random > > = NUMBER_CONSTANT ; }
if ( result == NUMBER_CONSTANT ) { result *= x ; }
za *= ya ;
e > > = NUMBER_CONSTANT ;
z *= lnb ;
xl &= MASK_30BITS ;
r *= rnd ;
extra -= rh * RADIX ;
{ while ( NUMBER_CONSTANT == n % p ) { n /= p ; factors . add ( p ) ; } }
n |= NUMBER_CONSTANT ;
xx += NUMBER_CONSTANT / NUMBER_CONSTANT ;
iter ++ ;
{ data [ i ] /= d ; }
{ data [ i ] *= d ; }
{ data [ i ] -= d ; }
{ data [ i ] += d ; }
k += m ;
coeff1 /= pc2 ;
{ c [ NUMBER_CONSTANT ] ++ ; return ret ; }
coeff1 /= pc2 ;
{ m > > = NUMBER_CONSTANT ; ++ k ; }
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
e > > = NUMBER_CONSTANT ;
v *= v ;
{ ret = scale * FastMath . pow ( - FastMath . log1p ( - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log1p ( - x ) )
return ( FastMath . expm1 ( ss ) ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
{ correct ( new ArrayRealVector ( z , false ) ) ; }
{ predict ( new ArrayRealVector ( u , false ) ) ; }
minadj /= divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = FastMath.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , FastMath.PI , NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , FastMath.PI , - NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , FastMath.PI , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
double x = FastMath . random () * NUMBER_CONSTANT ;
double x = FastMath . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + FastMath . cos ( a )
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
minDiff = FastMath . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = FastMath . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = FastMath . log ( m . getEntry ( r , c ) ) ; }
double diff = FastMath . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( FastMath . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
double diff = FastMath . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , FastMath . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= FastMath . sqrt ( sp ) ;
{ double f = FastMath . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += FastMath . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * lambda ) )
ret += c [ i ] * ArithmeticUtils . pow ( n , i ) ;
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = FastMath . random () ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , FastMath . min ( seed.length , v.length ) ) ;
expected = FastMath . abs ( period ) - delta ;
final int shift = FastMath . min ( aTwos , bTwos ) ;
double xabs = FastMath . abs ( v [ i ] ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = FastMath . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
final int k = ( int ) FastMath . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * FastMath . pow ( NUMBER_CONSTANT - d , n ) ; }
double err = FastMath . abs ( actual - expected ) / Math . ulp ( expected ) ;
double denom = FastMath . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
{ return FastMath . exp ( x ) - FastMath . pow ( Math.PI , NUMBER_CONSTANT ) ; }
new Fraction ( ( ( FastMath . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = FastMath . abs ( num ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
h += p_i * FastMath . log ( p_i ) ;
h += p_ij * FastMath . log ( p_ij ) ;
if ( FastMath . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * FastMath . abs ( expected ) ;
public double estimateRegressionStandardError () { return FastMath . sqrt ( estimateErrorVariance () ) ; }
Assert . assertTrue ( STRING_CONSTANT , FastMath . abs ( v - randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) > NUMBER_CONSTANT ) ;
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , FastMath . min ( seedLen , rslLen ) ) ;
FastMath . sqrt ( d [ col ] ) < tol [ col ]
FastMath . sqrt ( d [ i ] ) < tol [ i ]
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / FastMath . sqrt ( NUMBER_CONSTANT ) ) ;
final double originalDelta = FastMath . random () ;
final double gn = factor1 * FastMath . log ( qExp1 ) * oneOverN ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * FastMath . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return FastMath . sqrt ( x ) ; } }
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.BLAND && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.DANTZIG ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new LinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , cutOff ) > NUMBER_CONSTANT ) { return true ; }
final Point < S > point
final Point < Euclidean2D > point
final Point < Euclidean2D > point
final Point < Euclidean2D > point
final Point < Euclidean1D > point
final Point < Euclidean2D > point
Point < S > point
final Point < Euclidean3D > point
final Point < Euclidean3D > point
final Point < Euclidean1D > point
final Point < Euclidean3D > point
final Point < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final Point < S > barycenter
final Point < S > point
final Point < S > point
final Point < Euclidean1D > point
public ArcsSet wholeSpace () { return new ArcsSet ( tolerance ) ; }
{ return Vector3D . angle ( pole , direction ) - NUMBER_CONSTANT * FastMath.PI ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet ( tolerance ) ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet ( tolerance ) ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.tolerance ) ; }
{ return new ArcsSet ( tree , tolerance ) ; }
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final Vector1D x = thisLine . toSubSpace ( ( Point < Euclidean2D > ) crossing ) ;
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
Point < Euclidean2D > p
Point < Euclidean1D > p
Point < Euclidean3D > v
final Vector3D point = line . toSpace ( ( Point < Euclidean1D > ) Vector1D.ZERO ) ;
public SubChord copySelf () { return new SubChord ( chord . copySelf () , limits ) ; }
{ this . upper = MathUtils.TWO_PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) , Precision.EPSILON ) ;
{ return buildNew ( hyperplane . copySelf () , remainingRegion ) ; }
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 , NUMBER_CONSTANT ) ) ;
final EdgesBuilder visitor = new EdgesBuilder ( root , getTolerance () ) ;
{ return new SphericalPolygonsSet ( tree , getTolerance () ) ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public SphericalPolygonsSet ( final double tolerance ) { super ( tolerance ) ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct , thisLine . getTolerance () ) ) ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
{ return distance ( p ) < tolerance ; }
final BSPTree < S > cell = node . getCell ( point , tolerance ) ;
{ return new PolyhedronsSet ( tree , getTolerance () ) ; }
public IntervalsSet wholeSpace () { return new IntervalsSet ( tolerance ) ; }
{ add ( new NestedLoops ( bLoop , tolerance ) ) ; }
return new OrientedPoint ( newLoc , op . isDirect () , originalLine.tolerance ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
public PolygonsSet wholeSpace () { return new PolygonsSet ( tolerance ) ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet ( tolerance ) ) ; }
if ( FastMath . abs ( d ) < tolerance ) { return null ; }
{ return new PolygonsSet ( tree , getTolerance () ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () , hyperplaneThickness ) ; }
{ return new ArcsSet ( tree , getTolerance () ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , getTolerance () ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , getTolerance () ) . wholeHyperplane () ; }
{ super ( boundary , tolerance ) ; }
{ super ( tree , tolerance ) ; }
public ArcsSet ( final double tolerance ) { super ( tolerance ) ; }
Segment segment = new Segment ( start , end , new Line ( start , end , NUMBER_CONSTANT ) ) ;
{ return new Line ( start , end , NUMBER_CONSTANT ) . wholeHyperplane () ; }
return new PolygonsSet ( edges , NUMBER_CONSTANT ) ;
final BoundaryProjector projector = new BoundaryProjector ( polyhedronsSet . getTolerance () ) ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet ( tolerance ) ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet ( tolerance ) ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w , tolerance ) ;
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new IntervalsSet ( tree , getTolerance () ) ; }
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI - NUMBER_CONSTANT ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getFirstLeaf ( getTree ( false ) ) . getAttribute ()
Assert . assertTrue ( projection . getOriginal () == v ) ;
Iterable < P > points
final Iterable < P > points
ConvexHull2D hull = generator . generate ( reducePoints ( points ) ) ;
GrahamScan generator = new GrahamScan () ;
RandomGenerator random = new MersenneTwister () ;
@ Before public void setUp () { generator = createConvexHullGenerator ( false ) ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Iterable < Vector2D > points
Assert . assertTrue ( hull . getVertices () . length == NUMBER_CONSTANT ) ;
ConvexHullGenerator2D generator = new MonotoneChain ( true ) ;
public Segment [] getLineSegments () { return retrieveLineSegments () . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.PLUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( inside ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new MonotoneChain ( includeCollinearPoints ) ; }
{ return getOptimizer () . optimize ( getProblem ( points ) ) . getPoint () ; }
final boolean useLU
{ return new LevenbergMarquardtOptimizer () ; }
optimizer = new LevenbergMarquardtOptimizer () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return new LeastSquaresProblemImpl ( model , jacobian , observed , start , checker , maxEvaluations , maxIterations ) ; }
public RealMatrix computeJacobian () { return this . jacobian ; }
public double [] computeValue () { return this . values . toArray () ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.QR ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( Decomposition.LU ) ) ; }
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
final ConvergenceChecker < Evaluation > checker
{ return new LeastSquaresBuilder () . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
builder ( circle ) . checkerPair ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
function . checkTheoreticalMinParams ( optimum . getPoint () . toArray () ) ;
RealVector point
RealVector computeValue ( ) ;
RealVector point
RealVector getStart ( ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
final RealVector point
final RealVector point
final RealVector start
final RealVector target
public RealVector computeValue () { return this . weightSqrt . operate ( unweighted . computeValue () ) ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM , e ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertTrue ( optimum . getRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . getRMS () , TOl ) ;
RealVector getValue ( ) ;
final double cost = lsp . evaluate ( params ) . getCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . getSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . getSigma ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . getRMS () ) ;
final double [] asymptoticStandardErrorFound = optimum . getSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . getCovariances ( NUMBER_CONSTANT ) ;
final double actual = lsp . evaluate ( lsp . getStart () ) . getRMS () ;
final double cost = lsp . evaluate ( lsp . getStart () ) . getCost () ;
Assert . assertArrayEquals ( evaluation . getResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . toArray () ) ;
{ return new LocalLeastSquaresProblem ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getResiduals () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs , NUMBER_CONSTANT ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff ;
public FitnessFunction () { isRepairMode = true ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
public RealVector getResiduals () { return residuals ; }
public RealVector getPoint () { return point ; }
public RealMatrix getJacobian () { return jacobian ; }
super ( randomData . getRandomGenerator () ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantRealDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationType ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationType ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationType ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationType ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator ( true ) ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY , initializeDerivatives ) ;
final FieldMatrix < BigFraction > H = this . createExactH ( d , n ) ;
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
final Percentile p = getUnivariateStatistic () ;
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( final Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final UnivariateStatistic percentile = getUnivariateStatistic () ;
final Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getKthSelector () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getKthSelector () ) ; }
return work.length == NUMBER_CONSTANT ? Double.NaN : estimationType . evaluate ( work , pivotsHeap , p , kthSelector ) ;
kthSelector = original . getKthSelector () ;
final double Umin = ( long ) x.length * y.length - Umax ;
{ return new LazyUnweightedEvaluation ( ( ValueAndJacobianFunction ) model , target , p ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriterion () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ExpansionMode.ADDITIVE ) ;
RandomDataGenerator random = new RandomDataGenerator () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ this . randomData = new RandomDataGenerator ( generator ) ; }
{ this . randomData = randomData . getDelegate () ; }
{ return ( MathUtils.PI_SQUARED / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () , threshold ) ; }
t . insertInTree ( parentTree , isPlusChild , new VanishingToLeaf ( true ) ) ;
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger ( region1 , region2 ) )
{ unlinkReverse () ; originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return Double.NEGATIVE_INFINITY ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = MathArrays . copyOf ( b , b.length ) ; nVals = n ; }
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
org.apache.commons.math4.stat.inference.ChiSquareTest csti = new org.apache.commons.math4.stat.inference.ChiSquareTest () ;
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math4.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math4.linear.SingularMatrixException . class )
( numIterations < maximumIterations ) && ( a > lowerBound || b < upperBound )
public Well19937c ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937c ( int seed ) { super ( K , seed ) ; }
public Well512a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well512a ( int seed ) { super ( K , seed ) ; }
public Well44497b ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497b ( int seed ) { super ( K , seed ) ; }
public Well1024a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well1024a ( int seed ) { super ( K , seed ) ; }
public Well44497a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well44497a ( int seed ) { super ( K , seed ) ; }
public Well19937a ( long seed ) { super ( K , seed ) ; }
{ super ( K , seed ) ; }
public Well19937a ( int seed ) { super ( K , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
x = new UniformRealDistribution ( rng , lo , hi ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI ) ;
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ double actual = getDistribution () . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . probability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . probability ( lower , upper ) ;
try { distribution . probability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
distribution . logDensity ( cumulativeTestPoints [ i ] )
@ Test ( expected = NullArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullArgumentException ex ) {}
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
@ Test ( expected = NullArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { @ Override public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( binCount ) ;
@ Override T reciprocal ( ) ;
delta = ( max - min ) / binCount ;
protected double getSolverAbsoluteAccuracy () { return SOLVER_DEFAULT_ABSOLUTE_ACCURACY ; }
SparseGradient sgY2 = sgX . compose ( poly . value ( x ) , poly . polynomialDerivative () . value ( x ) ) ;
Assert . assertEquals ( f . polynomialDerivative () . polynomialDerivative () . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , tolerance ) ;
UnivariateFunction dSpline = spline . polynomialSplineDerivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < tolerance ; }
if ( direction . getNorm () < tolerance ) { return null ; }
MathArrays . verifyValues ( values , weights , begin , length , true )
MathArrays . verifyValues ( values , begin , length , true )
m . incrementAll ( values ) ;
MathArrays . verifyValues ( values , begin , length , true )
MathArrays . verifyValues ( values , begin , length , true )
MathArrays . verifyValues ( values , begin , length ) && length > NUMBER_CONSTANT
MathArrays . verifyValues ( values , start , length ) ;
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , begin , length ) ;
MathArrays . verifyValues ( values , weights , begin , length , true )
{ MathArrays . verifyValues ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
ptile . incrementAll ( d ) ;
MathArrays . verifyValues ( values , weights , begin , length )
MathArrays . verifyValues ( values , begin , length )
MathArrays . verifyValues ( values , weights , begin , length )
MathArrays . verifyValues ( values , begin , length )
m . incrementAll ( values ) ;
catch ( MathIllegalArgumentException iae ) {}
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
catch ( MathIllegalArgumentException iae ) { return true ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = MathIllegalArgumentException . class )
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException e ) {} }
catch ( MathIllegalArgumentException iae ) {}
final double Hs = nthHarmonic ;
final double Hs = nthHarmonic ;
return generalizedHarmonic ( x , exponent ) / nthHarmonic ;
return - FastMath . log ( x ) * exponent - FastMath . log ( nthHarmonic ) ;
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) || Double . isNaN ( y ) ) { return Double.NaN ; }
if ( Double . isNaN ( x ) || x == NUMBER_CONSTANT ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
if ( Double . isNaN ( x ) ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER , name ) ; this . name = name ; }
final double exponent
MultivariateInterpolator interpolator = new MicrosphereInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double brightnessExponent
{ return ( numerator . signum () == NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () - NUMBER_CONSTANT ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , currentNeighbourhood ) ;
{ return divide ( new Fraction ( i ) ) ; }
{ return multiply ( new Fraction ( i ) ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionInversionSampler . helper2 ( testValue ) * testValue , tol ) ;
this . maxEvaluations = maxEvaluations ;
final int rowOffset ;
long swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . exp ( log1mProbabilityOfSuccess * x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / absX * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new Well1024a ( NUMBER_CONSTANT ) ) ) ;
BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final RealFieldUnivariateFunction < T > f
final RealFieldUnivariateFunction < T > f
RealFieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( rng , combined ) ;
public JDKRandomGenerator ( long seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( ( nSteps + NUMBER_CONSTANT ) / NUMBER_CONSTANT , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ evaluations . increment () ; expandable . computeDerivatives ( t , y , yDot ) ; }
evaluations = evaluations . withStart ( NUMBER_CONSTANT ) ;
catch ( InitializationCompletedMarkerException icme ) { getCounter () . increment ( starter . getEvaluations () ) ; }
FieldVector3D < DerivativeStructure > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
FieldVector3D < Dfp > axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
Vector3D axis = r . getAxis ( RotationConvention.VECTOR_OPERATOR ) ;
{ return r1 . composeInverseInternal ( r2 ) . getAngle () ; }
{ return r1 . composeInverseInternal ( r2 ) . getAngle () ; }
final Rotation composite = r1 . compose ( r2 . compose ( r3 , RotationConvention.FRAME_TRANSFORM ) , RotationConvention.FRAME_TRANSFORM ) ;
{ try { return delegate . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ delegate . setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ delegate . setSeed ( ( long ) seed ) ; }
setSeedInternal ( seed ) ;
{ setSeedInternal ( seed ) ; }
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( mapper , time , theta , oneMinusThetaH ) ;
mapper = null ;
yDotK [ NUMBER_CONSTANT ] = equations . getMapper () . mapDerivative ( stepStart ) ;
mainSetDimension = eqn . getStateDimension () ;
final BracketedRealFieldUnivariateSolver < T > solver
final BracketedRealFieldUnivariateSolver < T > solver
BracketedRealFieldUnivariateSolver < T > solver
public TestProblem5 () { setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
i < getDimension ()
i < getDimension ()
i < getDimension ()
for ( int i = NUMBER_CONSTANT ; i < getDimension () ; ++ i ) { y [ i ] = c ; }
i < getDimension ()
currentState = y ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , - NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialState () . getTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
{ super ( field ) ; setFinalConditions ( getInitialState () . getTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ return new EulerFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T one = getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new LutherFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return doCopy () ; }
final T coeffDot1 = getField () . getOne () . subtract ( coeffDot2 ) ;
final T one = getField () . getOne () ;
{ return new HighamHall54FieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( getField () , forward , mapper ) ; }
final T two = getField () . getZero () . add ( NUMBER_CONSTANT ) ;
{ return getField () . getZero () . add ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator < T > ( field , forward , mapper ) ; }
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE < T > ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
steps . add ( interpolator ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index + NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Override public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Override public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Override public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Override public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Override public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > eqn
final FirstOrderFieldDifferentialEquations < T > eqn
final FirstOrderFieldIntegrator < T > integrator
final FirstOrderFieldDifferentialEquations < T > equations
final FirstOrderFieldDifferentialEquations < T > primary
@ Test ( expected = MaxCountExceededException . class ) public void exceedMaxEvaluations () { doExceedMaxEvaluations ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
{ return taylor ( reference , time , scalingH , scaled , nordsieck ) ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
setSeed ( seed ) ;
{ return timeAndReport ( title , DEFAULT_MAX_NAME_WIDTH , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
@ Deprecated double sample ( ) ;
random = RandomSource . create ( RandomSource.WELL_1024_A , seed ) ;
{ this ( cityList , numNeuronsPerCity , RandomSource . createLong () ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
{ final double u = rng . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
return empiricalDistribution . createSampler ( randomData . getRandomProvider () ) . sample () ;
empiricalDistribution = new EmpiricalDistribution ( binCount ) ;
{ this . value = value ; }
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( n - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
{ rand = new Well19937c () ; }
return complexSolver . solve ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . real2Complex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . real2Complex ( getCoefficients () ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_19937_C , NUMBER_CONSTANT ) ;
RealDistribution.Sampler distribution
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = gauss . sample () ; }
cachedD = MatrixUtils . createRealMatrixWithDiagonal ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
UniformRandomProvider randomGenerator
public NaturalRanking ( UniformRandomProvider randomGenerator ) { this ( DEFAULT_NAN_STRATEGY , TiesStrategy.RANDOM , randomGenerator ) ; }
{ this ( nanStrategy , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , RandomSource . create ( RandomSource.WELL_19937_C ) ) ; }
final UniformRandomProvider random
final UniformRandomProvider random
{ this ( k , maxIterations , measure , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , RandomSource . create ( RandomSource.MT_64 ) ) ; }
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT_64 ) ;
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
UniformRandomProvider randGen = getRandomGenerator () ;
final UniformRandomProvider random
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . sample () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . sample () ; }
final UniformRandomProvider generator
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
final double comp = rand . sample () ;
{ this ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider generator = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = RandomSource . create ( RandomSource.MT , NUMBER_CONSTANT ) ; }
UniformRandomProvider random = RandomSource . create ( RandomSource.XOR_SHIFT_1024_S , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.TWO_CMRES , NUMBER_CONSTANT ) ;
final UniformRandomProvider r
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider r = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider random = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
UniformRandomProvider rng = RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ;
final RandomGenerator rng = new RngAdaptor ( RandomSource.MT ) ;
return InferenceTestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
this . rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
rng = new GaussianRandomGenerator ( RandomSource . create ( RandomSource.WELL_19937_C , seed ) ) ;
final UniformRandomProvider random = RandomSource . create ( RandomSource.MT ) ;
final UniformRandomProvider random = GeneticAlgorithm . getRandomGenerator () ;
final Collection < Neuron > exclude = new ArrayList <> () ;
ArrayFieldVector < T > out = new ArrayFieldVector <> ( field , n ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix <> ( field , m , n ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
return new ArrayFieldVector <> ( field , out , false ) ;
{ return new ArrayFieldVector <> ( this , true ) ; }
{ components = new ArrayList <> () ; firstIndex = primary . getDimension () ; }
this . components = new ArrayList <> () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList <> () , transformers ) ;
List < Object > externalList = new ArrayList <> () ;
List < Double > valuesList = new ArrayList <> () ;
List < Chromosome > popList = new LinkedList <> () ;
return new Array2DRowFieldMatrix <> ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( testData ) ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
Collection < StatisticalSummary > aggregate = new ArrayList <> () ;
Collection < SummaryStatistics > aggregate = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator <> ( problem ) ;
this . circles = new ArrayList <> () ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel <> () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel <> () ;
{ new SparseFieldMatrix <> ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector <> ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector <> ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector <> ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix <> ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList <> () ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
singletons = new ArrayList <> ( pmf . size () ) ;
{ return new GillFieldIntegrator <> ( field , field . getOne () ) ; }
final ArrayList < Object [] > parameters = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HashSet < Object > sampSet = new HashSet <> () ;
final List < double [] > coordinatesList = new ArrayList <> () ;
final List < Neuron > list = new ArrayList <> () ;
final List < City > cityList = new ArrayList <> () ;
public CircleVectorial () { points = new ArrayList <> () ; }
{ return new MidpointFieldIntegrator <> ( field , field . getOne () ) ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
this . convexCellsInsidePoints = new ArrayList <> () ;
root = new BSPTree <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
{ parametersNames = new ArrayList <> () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList <> () ;
return new Array2DRowFieldMatrix <> ( field , d , false ) ;
{ map = new HashMap <> () ; defaultTransformer = new DefaultTransformer () ; }
final Set < T > oneSet = new HashSet <> ( one ) ;
final List < T > neighbors = new ArrayList <> () ;
List < T > seeds = new ArrayList <> ( neighbors ) ;
final List < Segment > segments = new ArrayList <> ( list . size () ) ;
return new Pair <> ( normal , jTr ) ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
List < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
Collection < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
ArrayList < LinearConstraint > constraints = new ArrayList <> () ;
{ points = new ArrayList <> () ; sigma = error ; }
final List < Long > linkEnd = new ArrayList <> () ;
List < Chromosome > chromosomes = new ArrayList <> ( population . getChromosomes () ) ;
List < Comparable < > > modeList = new ArrayList <> () ;
this . features = new AtomicReference <> ( features . clone () ) ;
List < Vector3D > reducedSupport = new ArrayList <> () ;
List < Vector3D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
TreeSet < Double > values = new TreeSet <> () ;
final List < PairDoubleInteger > list = new ArrayList <> ( len ) ;
return new Array2DRowFieldMatrix <> ( pData , false ) ;
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final List < double [] > paramsAndChi2 = new ArrayList <> ( gridSize * gridSize ) ;
{ return new ThreeEighthesFieldIntegrator <> ( field , step ) ; }
p2 = new Pair <> ( STRING_CONSTANT , NUMBER_CONSTANT )
List < Chromosome > popList = new LinkedList <> () ;
final List < Neuron > neuronList = new ArrayList <> () ;
final List < Neuron > neurons = new ArrayList <> () ;
{ copy.linkMap . put ( e . getKey () , new HashSet <> ( e . getValue () ) ) ; }
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final List < WeightedObservedPoint > points = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
final ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
ArrayList < Chromosome > chromosomes = new ArrayList <> () ;
List < Vector2D > reducedSupport = new ArrayList <> () ;
List < Vector2D > list = new ArrayList <> ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList <> () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser <> ( NUMBER_CONSTANT , generator ) ;
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
Map < String , String > referenceRules = new HashMap <> () ;
Map < String , String > referenceRules = new HashMap <> () ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new Array2DRowFieldMatrix <> ( pData , false ) ;
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , step ) ; }
{ return new FieldLUDecomposition <> ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition <> ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition <> ( createFractionMatrix ( testData ) ) . getSolver () ;
List < Chromosome > popList = new ArrayList <> () ;
NPointCrossover < Integer > npc = new NPointCrossover <> ( order ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix <> ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , nCols , nRows ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
return new ArrayFieldVector <> ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix <> ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
loops = new ArrayList <> () ;
final List < Integer > factors = new ArrayList <> ( NUMBER_CONSTANT ) ;
return new SparseFieldVector <> ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector <> ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector <> ( field , vec1 ) ;
{ return new FieldODEState <> ( t0 , y0 ) ; }
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
RegionFactory < Sphere2D > factory = new RegionFactory <> () ;
final ArrayList < Integer > nonZeroPositions = new ArrayList <> () ;
{ this . tolerance = tolerance ; this . segments = new ArrayList <> () ; }
final List < Segment > loop = new ArrayList <> () ;
loops = new ArrayList <> ()
this . lines = new ArrayList <> () ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList <> ( representation ) : representation ) ;
newClusters = new ArrayList <> ( k )
microsphereData = new ArrayList <> ( size ) ;
final Set < Neuron > list = new HashSet <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
this . listeners = new CopyOnWriteArrayList <> () ;
List < Integer > minRatioPositions = new ArrayList <> () ;
{ innerDistribution = new EnumeratedDistribution <> ( createDistribution ( singletons , probabilities ) ) ; }
final List < Interval > list = new ArrayList <> () ;
{ return new LutherFieldIntegrator <> ( field , step ) ; }
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new SparseFieldMatrix <> ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix <> ( this ) ; }
entries = new OpenIntToFieldHashMap <> ( getField () ) ;
entries = new OpenIntToFieldHashMap <> ( other.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
steps = new ArrayList <> () ;
output = new ArrayList <> () ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances <> ( new EuclideanDistance () ) ; }
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > generated = new HashMap <> () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap <> ( field ) ;
Map < Integer , Fraction > map = new HashMap <> () ;
final List < Field > fields = new ArrayList <> () ;
RegionFactory < Euclidean1D > factory = new RegionFactory <> () ;
{ return new ArrayList <> ( observations ) ; }
final HashMap < Neuron , Integer > hit = new HashMap <> () ;
final List < PairNeuronDouble > list = new ArrayList <> () ;
List < CentroidCluster < T > > newClusters = new ArrayList <> () ;
List < Object [] > list = new ArrayList <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new GillFieldIntegrator <> ( field , step ) ; }
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
return new ArrayFieldVector <> ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector <> ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector <> ( vec1 ) ;
return new FieldVectorTestImpl <> ( out ) ;
final List < Object > orig = new ArrayList <> () ;
this . hParam = new HashMap <> () ;
regions = new ArrayList <> ( NUMBER_CONSTANT )
return new BoundaryProjection <> ( original , projected , offset ) ;
binStats = new ArrayList <> () ;
{ return new MidpointFieldIntegrator <> ( field , step ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
{ this . surrounded = new ArrayList <> () ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative <> ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix <> ( nordsieck . getData () , false ) ;
boundary = new ArrayList <> ()
{ return new BSPTree <> ( Boolean.FALSE ) ; }
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix <> ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector <> ( this ) ;
{ return new SparseFieldVector <> ( this ) ; }
FieldVector < T > res = new SparseFieldVector <> ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector <> ( this , n ) ;
entries = new OpenIntToFieldHashMap <> ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
entries = new OpenIntToFieldHashMap <> ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap <> ( v.entries ) ;
entries = new OpenIntToFieldHashMap <> ( field ) ;
{ return new ClassicalRungeKuttaFieldIntegrator <> ( field , field . getOne () ) ; }
public ListUnivariateImpl () { this ( new ArrayList <> () ) ; }
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
this . jacobianProviders = new ArrayList <> () ;
{ return new LutherFieldIntegrator <> ( field , field . getOne () ) ; }
List < Frequency > coll = new ArrayList <> () ;
{ return new ThreeEighthesFieldIntegrator <> ( field , field . getOne () ) ; }
List < Integer > newRepr = new ArrayList <> ( origChrom . getRepresentation () ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker <> ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList <> ( categoryData . size () ) ;
final ArrayList < String > lines = new ArrayList <> () ;
List < Number > components = new ArrayList <> () ;
{ return new EulerFieldIntegrator <> ( field , step ) ; }
final ArrayList < Double > list = new ArrayList <> () ;
List < Vector3D > support = new ArrayList <> () ;
public CircleScalar () { points = new ArrayList <> () ; }
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < Integer > seq = new ArrayList <> () ;
final List < EventHandler > list = new ArrayList <> ( eventsStates . size () ) ;
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
this . chromosomes = new ArrayList <> ( populationLimit ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
return new ArrayFieldVector <> ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix <> ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix <> ( testData ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory <> () ;
return new ArrayList <> ( edgeToNode . keySet () ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList <> () ) ;
List < Object > list = new ArrayList <> () ;
List < Object > externalList = new ArrayList <> () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative <> ( t0 , y0 , y0Dot ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory <> () ;
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
points = new ArrayList <> () ;
{ return new FieldVector3D <> ( NUMBER_CONSTANT , this , factor , v ) ; }
final List < Object > list = new ArrayList <> () ;
final List < Complex > result = new ArrayList <> () ;
return new FieldRotation <> ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation <> ( u1 , u2 , v1 , v2 ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover <> () ;
BSPTree < Sphere1D > tree = new BSPTree <> ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList <> () ;
List < Double > newRepr = new ArrayList <> ( repr ) ;
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
Map < Integer , Double > generated = new HashMap <> () ;
Set < Integer > keysInMap = new HashSet <> ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap <> () ;
final Set < Integer > usedBasicRows = new HashSet <> () ;
final Set < Integer > columnsToDrop = new TreeSet <> () ;
List < LinearConstraint > normalized = new ArrayList <> ( originalConstraints . size () ) ;
final ArrayList < Object [] > parameters = new ArrayList <> () ;
{ return new Pair <> ( k , v ) ; }
public Cluster () { points = new ArrayList <> () ; }
close = new ArrayList <> ()
return new FieldODEStateAndDerivative <> ( time , interpolatedState , interpolatedDerivatives ) ;
final HashSet < Double > values = new HashSet <> () ;
return new Array2DRowFieldMatrix <> ( BigFractionField . getInstance () , Hdata ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 <> ( field ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor <> () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector <> ( point ) ;
{ tree = new BSPTree <> ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree <> ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
List < Integer > baseSequence = new ArrayList <> ( l ) ;
List < S > origDataCopy = new ArrayList <> ( originalData ) ;
List < S > sortedData = new ArrayList <> ( data ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > repr = new ArrayList <> ( l ) ;
List < Double > sortedRepr = new ArrayList <> ( getRepresentation () ) ;
distribution = new ArrayList <> () ;
List < Vector2D > quadrilateral = new ArrayList <> () ;
final List < Vector2D > reducedPoints = new ArrayList <> ( quadrilateral ) ;
List < Integer > rList = new ArrayList <> ( length ) ;
context = new HashMap <> () ;
List < Vector2D > support = new ArrayList <> () ;
final ArrayList < Double > integrationTestPoints = new ArrayList <> () ;
edges = new ArrayList <> ()
final Collection < Vector2D > points = new ArrayList <> () ;
return new FieldODEState <> ( state . getTime () , y ) ;
ArrayList < Integer > out = new ArrayList <> () ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix <> ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix <> ( bfData , false ) ;
{ return new ArrayList <> () ; }
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver <> ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
List < Vector2D > points = new ArrayList <> ( size ) ;
List < Vector2D > points = new ArrayList <> () ;
List < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
final Collection < Vector2D > points = new ArrayList <> () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList <> () ;
RegionFactory < Euclidean2D > factory = new RegionFactory <> () ;
final List < WeightedObservedPoint > observations = new ArrayList <> ( unsorted ) ;
steps = new ArrayList <> () ;
final Set < City > unique = new HashSet <> () ;
final List < Future < > > execOutput = new ArrayList <> () ;
certifiedValues = new HashMap <> () ;
{ return new EulerFieldIntegrator <> ( field , field . getOne () ) ; }
FieldMatrix < T > identity = new Array2DRowFieldMatrix <> ( field , m , m ) ;
return new Array2DRowFieldMatrix <> ( field , bp , false ) ;
return new ArrayFieldVector <> ( bp , false ) ;
return new ArrayFieldVector <> ( field , bp , false ) ;
{ return new Solver <> ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix <> ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix <> ( field , m , m ) ;
List < Chromosome > popChr = new ArrayList <> () ;
Collection < Neuron > exclude = new HashSet <> () ;
Collection < Neuron > exclude = new HashSet <> () ;
final List < BigFraction > list = new ArrayList <> () ;
this . derivatives = new HashMap <> () ;
this . derivatives = new HashMap <> () ;
tasks = new ArrayList <> ()
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative <> ( stepEnd , yTmp , yDotTmp ) ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { @ Override public Population nextGeneration () { return null ; } }
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
@ Override public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { @ Override public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) { num ++ ; } }
if ( count ++ > NUMBER_CONSTANT ) { break; }
if ( count ++ > NUMBER_CONSTANT ) { break; }
if ( counts [ i ] == - NUMBER_CONSTANT ) { continue; }
random . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
delegate . restoreState ( state ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
{ double n = upperMinusLower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
{ return NUMBER_CONSTANT * upperPlusLower ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upperMinusLower + NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT / ( upperMinusLower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) delegate . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomProviderDefaultState ) random . saveState () ) . getState () ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
if ( shuffle ) { ListSampler . shuffle ( rng , points ) ; }
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
Coordinates3D [] points
final List < Coordinates3D > vertices
Arrays . asList ( Coordinates3D.ZERO , Coordinates3D.PLUS_I , Coordinates3D.PLUS_J , Coordinates3D.PLUS_K )
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates2D tmp = loop [ min ] ;
final Coordinates2D [] bLoop
final Coordinates3D axis
Coordinates3D axis
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
Coordinates2D p2 = ( Coordinates2D ) point ;
final Coordinates2D p
final Coordinates2D p
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
final Coordinates3D u
final Coordinates3D u
final Coordinates2D [] vertices
Collection < Coordinates2D > points
this . summedBarycenter = Coordinates3D.ZERO ;
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
final Coordinates3D pole
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double x = ( ( Coordinates1D ) point ) . getX () ;
final Cartesian2D tmp = loop [ min ] ;
final Cartesian2D [] bLoop
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
Cartesian3D [] points
final List < Cartesian3D > vertices
Arrays . asList ( Cartesian3D.ZERO , Cartesian3D.PLUS_I , Cartesian3D.PLUS_J , Cartesian3D.PLUS_K )
try { ps . checkPoint ( Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Cartesian3D p = h . toSpace ( Cartesian2D.ZERO ) ;
final Cartesian2D p = h . toSpace ( Cartesian1D.ZERO ) ;
Cartesian2D expected = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = Cartesian2D.NEGATIVE_INFINITY ;
Cartesian2D c = Cartesian2D.POSITIVE_INFINITY ;
Cartesian2D c = Cartesian2D.NaN ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Cartesian2D c = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double x = ( ( Cartesian1D ) point ) . getX () ;
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
{ return new Line ( new Cartesian2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Cartesian1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Cartesian3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Circle circle = new Circle ( Cartesian3D.PLUS_K , NUMBER_CONSTANT ) ;
{ return new SphericalCoordinates ( new Cartesian3D ( x , y , z ) ) ; }
final Cartesian3D v
this . summedBarycenter = Cartesian3D.ZERO ;
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
{ return Cartesian2D . angle ( p1.vector , p2.vector ) ; }
final Cartesian2D vector
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D c = Cartesian3D.NEGATIVE_INFINITY ;
Cartesian3D c = Cartesian3D.POSITIVE_INFINITY ;
Cartesian3D c = Cartesian3D.NaN ;
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = Cartesian1D.NEGATIVE_INFINITY ;
Cartesian1D c = Cartesian1D.POSITIVE_INFINITY ;
Cartesian1D c = Cartesian1D.NaN ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( - NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D c = new Cartesian1D ( NUMBER_CONSTANT ) ;
final Cartesian3D axis
Cartesian3D axis
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
final double angle = Cartesian3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return ( ( Cartesian3D ) point ) . dotProduct ( w ) + originOffset ; }
final Cartesian3D p
final Cartesian3D translation
final double angle = Cartesian3D . angle ( w , plane.w ) ;
final Cartesian3D tmp = u ;
final Cartesian3D normal
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
{ final Circle otherC = ( Circle ) other ; return Cartesian3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Cartesian3D direction
final Cartesian3D pole
{ return Cartesian3D . angle ( p1.vector , p2.vector ) ; }
final Cartesian3D vector
Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
final double delta = ( ( Cartesian1D ) point ) . getX () - location . getX () ;
final Cartesian1D location
final Cartesian3D u
final Cartesian3D u
final Cartesian3D pole
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
Cartesian2D oneTwo = new Cartesian2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Cartesian2D ( v ) ; }
final Cartesian2D [] vertices
TranslationTransform ( final Cartesian3D translation ) { this . translation = translation ; }
final Cartesian3D translation
final Cartesian3D center
final Cartesian3D center
final Cartesian3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Cartesian3D > vertices
final List < Cartesian3D > vertices
Cartesian1D v
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
Cartesian1D v = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ Space space = new Cartesian1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
final Cartesian2D p
{ centered [ i ] = values [ i ] - means [ i ] ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new GaussianSampler ( new MarsagliaNormalizedGaussianSampler ( rng ) , mean , standardDeviation ) ;
public Plot ( final List < Cartesian2D > points ) { this . points = points ; }
List < Cartesian2D > points = null ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D actual = vector1DFormat . parse ( source ) ;
Vector1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Vector2D p2 = ( Vector2D ) vector ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector2D actual = vector2DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
Vector3D actual = vector3DFormat . parse ( source ) ;
int j = minor
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest () . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = NUMBER_CONSTANT ;
final double tol = NUMBER_CONSTANT ;
Cartesian3D p
rings = new ChineseRings ( new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
try { FieldVector3D . angle ( v1 , Cartesian3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
final Cartesian2D point
final Cartesian2D location
final Cartesian2D . . . vertices
final Cartesian2D . . . vertices
final Cartesian3D p
final double angle = Cartesian3D . angle ( direction , line.direction ) ;
final Cartesian3D point
Cartesian3D v
{ new Cartesian3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Cartesian3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
final Collection < Cartesian2D > points
ConvexHull2D hull = generator . generate ( Collections . < Cartesian2D > emptyList () ) ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Cartesian1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final double x = ( ( Cartesian1D ) point ) . getX () ;
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Cartesian2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v1
final Cartesian3D v2
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D v
final Cartesian3D u
final Cartesian2D [] vertices
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = RegularizedGamma.P . value ( shape , x / scale ) ; }
LogGamma . value ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
final double expected = LogGamma . value ( i + NUMBER_CONSTANT ) ;
{ return RegularizedGamma.P . value ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . value ( mu ) * FastMath . pow ( omega , mu ) )
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . value ( t ) / s , tol ) ;
( sc * sc ) * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( LogGamma . value ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
return LogGamma . value ( n + NUMBER_CONSTANT ) ;
{ ret = RegularizedBeta . value ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
LogBeta . value ( nhalf , mhalf )
{ ret = NUMBER_CONSTANT - RegularizedBeta . value ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return RegularizedBeta . value ( x , alpha , beta ) ; }
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . value ( dev / ( shape * SQRT2 ) ) ;
final double t = InverseErfc . value ( p ) ;
return NUMBER_CONSTANT * ErfDifference . value ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * InverseErf . value ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erfc . value ( - dev / ( standardDeviation * SQRT2 ) ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / FACTORIAL . value ( orders [ k ] ) ; }
double refDer = - Factorial . value ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * Factorial . value ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
BinomialCoefficientDouble . value ( n + m , m )
double binomial = BinomialCoefficient . value ( v + i , i ) ;
final int numCombinations = ( int ) BinomialCoefficient . value ( arraySize , numberOfTrueValues ) ;
long expected = BinomialCoefficient . value ( i + j , i ) ;
{ coeff [ i ] [ j ] = ( int ) BinomialCoefficient . value ( i , j ) ; }
Assert . assertEquals ( BinomialCoefficient . value ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return LinearCombination . value ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return LinearCombination . value ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( LinearCombination . value ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ;
out.value = LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = LinearCombination . value ( a , bDouble ) ;
out.value = LinearCombination . value ( aDouble , bDouble ) ;
{ return FastMath . abs ( LinearCombination . value ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return LinearCombination . value ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( LinearCombination . value ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
final double accurateValue = LinearCombination . value ( a , bDouble ) ;
final double accurateValue = LinearCombination . value ( aDouble , bDouble ) ;
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( LinearCombination . value ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( LinearCombination . value ( a , bDouble ) ) ;
return new Decimal64 ( LinearCombination . value ( aDouble , bDouble ) ) ;
final double r = LinearCombination . value ( coeff [ i ] , pY ) ;
packed [ i + NUMBER_CONSTANT ] = LinearCombination . value ( dv , partials ) ;
final double cos = CosAngle . value ( n , sampleDirection ) ;
final double diffNorm = SafeNorm . value ( diff ) ;
checkRelative ( LinearCombination . value ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( LinearCombination . value ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
{ this ( PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = PlaneAngleRadians . normalize ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , PlaneAngleRadians . normalize ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
final double lB = PlaneAngleRadians . normalize ( limits . get ( j ) , lA ) ;
final double syncedStart = PlaneAngleRadians . normalize ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
{ Assert . assertEquals ( a1 . getReal () , PlaneAngleRadians . normalize ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( angle ) ;
this . angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( alpha ) ;
angle = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( line.angle ) ;
final double normalizedPoint = PlaneAngleRadians . normalize ( point , middle ) ;
this . lower = PlaneAngleRadians . normalizeBetweenZeroAndTwoPi ( lower ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , knots.length , NUMBER_CONSTANT , true ) ; }
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler g = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
UnitSphereSampler rand
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereSampler ( dimension , RandomSource . create ( RandomSource.MT_64 ) ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereSampler sphRandom = new UnitSphereSampler ( NUMBER_CONSTANT , random ) ;
{ sampler = new MarsagliaNormalizedGaussianSampler ( generator ) ; }
private final ContinuousSampler sampler = new LogNormalSampler ( new ZigguratNormalizedGaussianSampler ( rng ) , scale , shape ) ;
final ContinuousDistribution.Sampler random
{ return randomize ( new UniformContinuousDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
DiscreteDistribution.Sampler sampler
final ContinuousDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution normalDistribution = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution distribution
ContinuousDistribution.Sampler sampler
this . random = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . createSampler ( rng ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
final ContinuousDistribution kernel = findKernel ( lower , upper ) ;
x = new UniformContinuousDistribution ( lo , hi ) . createSampler ( rng ) ;
tP = new UniformContinuousDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
@ Override public double getMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( point ) ;
{ Assert . assertEquals ( x , v . getX () , TEST_TOLERANCE ) ; }
Assert . assertFalse ( pt . isDirect () ) ;
Assert . assertTrue ( copy . isDirect () ) ;
Assert . assertTrue ( pt . isDirect () ) ;
assertContains ( result , expected , tolerance ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
y [ i ] = Complex . ofCartesian ( yr , yi ) ;
data [ i ] = Complex . ofCartesian ( re , im ) ;
for ( Complex cc : c ) { TestUtils . assertEquals ( Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , cc , NUMBER_CONSTANT ) ; }
Object expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = Complex . ofCartesian ( Double.NaN , Double.NaN ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = Complex . ofCartesian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( float d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = Complex . ofCartesian ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
for ( float d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofReal ( d ) ; index ++ ; }
{ return Complex . ofReal ( real [ index ] ) ; }
{ return Complex . ofReal ( real [ index ] ) ; }
x [ i ] = Complex . ofReal ( f . value ( t ) ) ;
{ final int value = count ; count += increment ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , SimpsonIntegrator.SIMPSON_MAX_ITERATIONS_COUNT + NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
expr . setLineno ( expr . getLineno () + templateLineno ) ;
if ( definitionNodes . contains ( useSite ) ) { return null ; }
FeatureSet features = ast . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT ) . append ( tags ) ; }
output.compiledCode = writeOutput ( compiler , flags.outputWrapper ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
public final Node getNext () { return next ; }
public final Token getToken () { return token ; }
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
return scope . getCommonTypes () . UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , null ) ; }
this . commonTypes . STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = this . commonTypes . UNKNOWN ; }
if ( isUnknown () ) { return this . commonTypes . UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
if ( this . isUnknown () ) { return this . commonTypes . TRUTHY ; }
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
{ Preconditions . checkState ( function . isFunction () ) ; expandedDefinitions . add ( functionSideEffectMap . get ( function ) ) ; }
n . hasOneChild () && t . inGlobalScope ()
if ( varNode . hasMoreThanOneChild () && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
n . hasOneChild () && parent == googScopeBlock
initializer . isVar () && initializer . hasOneChild ()
if ( n . hasOneChild () && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
if ( ! currentStatement . hasChildren () ) { return; }
typeNode != null && typeNode . isString ()
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
if ( inputId == null ) { setInputId ( NodeUtil . getInputId ( node ) , getSourceName ( node ) ) ; }
String name = getQualifiedName ( node ) ;
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
JSType t = getTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toNonNullString ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toNonNullString ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toNonNullString ( forAnnotations ) ) ; }
b . append ( call.returnType . toNonNullString ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toNonNullString ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . recordPropertyName . apply ( propName ) ; }
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { recordPropertyName ( n . getLastChild () . getString () , n ) ; }
recordPropertyName ( pname , qnameNode ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
compiler . getOptions () . setUseTypesForLocalOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( ! allDefinitionsEquivalent ( singleSiteDefinitions ) ) { return false ; }
NodeTraversal . traverseChangedFunctions ( compiler , new FunctionVisitor ( blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType , new HashSet < JSType > () ) ;
Config config = findMatching ( name , n . getSourceFileName () ) ;
if ( currentScript.defaultExportLocalName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportLocalName ) ;
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
TypeI jsType
TypeI jsType
void setMask ( int mask ) { bitmask |= mask ; }
if ( info . isNoSideEffects () ) {} else { sideEffectInfo . setTaintsGlobalState () ; }
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
( config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) ) || peek ( TokenType.OPEN_ANGLE )
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = NodeUtil . getBestJSDocInfo ( node ) ;
FunctionInformation sideEffectInfo = new FunctionInformation () ;
FunctionInformation representativeNode = new FunctionInformation () ;
if ( modulePath == null ) { t . makeError ( typeNode , COMMON_JS_MODULE_LOAD_ERROR , moduleName ) ; return; }
if ( modulePath == null ) { compiler . report ( t . makeError ( require , COMMON_JS_MODULE_LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( actual () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return this . summary ; }
maybeWarnForInvalidDestructuring ( t , lhs . getParent () , legacyNamespace ) ;
{ options . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameTable ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameTable ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
return IR . exprResult ( assign ) . useSourceInfoIfMissingFromForTree ( var ) ;
{ if ( Matchers . googRequire () . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . googRequire () . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = ( LiteralToken ) eat ( TokenType.STRING ) ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
madeChange = true ;
{ parent . removeChild ( node ) ; madeChange = true ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT , Pattern.DOTALL ) ;
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
new ByteArrayInputStream ( inputString . getBytes ( UTF_8 ) )
inputSourceMaps . put ( jsonFile . getPath () , new SourceMapInput ( sourceMap ) ) ;
{ if ( child != n . getFirstChild () ) { cc . listSeparator () ; } add ( child ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
final Node extendsClause = n . getSecondChild () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.INCOMPATIBLE_STRICT_COMPARISON ) ;
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = newParserConfig ( config ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , WARNING ) ;
@ Override protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
if ( config.languageMode != LanguageMode.TYPESCRIPT ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true , StrictMode.SLOPPY ) ;
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict ) ;
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
{ googRequireNode = IR . constNode ( IR . name ( shortName ) , googRequireNode ) ; }
return getConstJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
! NodeUtil . isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! NodeUtil . isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript . getExportedNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( t , n ) ; }
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE , NewTypeInference.UNDEFINED_SUPER_CLASS ) ; }
IR . call ( IR . getprop ( IR . superNode () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
assertNull ( LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , outputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( t , n , parent ) ; } }
add ( last ) ;
assertValidOrderForChecks ( checks ) ;
assertValidOrderForChecks ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , useTypes ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
declaresFunctionOrClass ( n )
public DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock , newBlock ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { unusedMethodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
new PeepholeReplaceKnownMethods ( late , false )
new PeepholeReplaceKnownMethods ( late , useTypesForOptimization )
public boolean isBuiltinObject () { return this . rawType . isBuiltinObject () ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () && ! isLiteralObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
return nt . isBuiltinObject () || nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( JSTypes.OBJLIT_CLASS_NAME ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
return this . commonTypes . getEmptyObjectLiteral () ;
if ( this == other || other . isBuiltinObject () ) { return true ; }
if ( ! isBuiltinObject () ) { this . subtypes . add ( subtype ) ; }
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; }
return Ascii . toUpperCase ( Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) ) ;
{ CompilerOptions.J2clPassMode j2clPassMode = CompilerOptions.J2clPassMode . valueOf ( Ascii . toUpperCase ( flags.j2clPassMode ) ) ; options . setJ2clPass ( j2clPassMode ) ; }
String lowerParam = Ascii . toLowerCase ( param ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
addParserWarning ( STRING_CONSTANT , Ascii . toLowerCase ( visibility . toString () ) ) ;
{ result = Ascii . toUpperCase ( result . toString () ) ; }
String canonicalizedName = Ascii . toUpperCase ( value . trim () ) . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return NodeUtil . wasCasted ( n ) || isAssertionCall ( parent ) ; }
return getTopObject () ;
! t . isSubtypeOf ( this . commonTypes . getTopObject () ) && ( ! t . hasTypeVariable () || t . hasScalar () )
JSType objLitType = commonTypes . getEmptyObjectLiteral () ;
{ globalThisType = this . commonTypes . getTopObject () . withLoose () ; }
this == other || other.ns != null || ! other.nominalType . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . getBottomObject () ; }
objType != null && ! objType.nominalType . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) { return; }
{ return false ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , def ) ; }
pattern . replaceWith ( IR . name ( tempVarName ) ) ;
patternParam . replaceWith ( newParam ) ;
callNode . replaceWith ( replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
candidateDefinition . replaceWith ( varNode ) ;
parent . replaceWith ( replacement ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( replacement ) ;
first . replaceWith ( name ) ;
n . replaceWith ( placeholder ) ;
{ Node parent = n . getParent () ; parent . replaceWith ( fncBlock ) ; }
n . replaceWith ( call ) ;
msgNode . replaceWith ( newValue ) ;
statement . replaceWith ( newStatement ) ;
assignNode . replaceWith ( rhs ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . replaceWith ( IR . name ( GENERATOR_THIS ) ) ; }
n . replaceWith ( replacement ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( elem ) ;
n . replaceWith ( lengthNode ) ;
n . replaceWith ( newNode ) ;
n . replaceWith ( newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
n . replaceWith ( newStringNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( newNode ) ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . replaceWith ( newNode ) ;
n . replaceWith ( replacement ) ;
callNode . replaceWith ( objNode ) ;
n . replaceWith ( newNode ) ;
subtree . replaceWith ( replacement ) ;
subtree . replaceWith ( replacement ) ;
{ parent . replaceWith ( IR . empty () ) ; }
grandparent . replaceWith ( functionNode ) ;
n . replaceWith ( var ) ;
n . replaceWith ( replacement ) ;
target . replaceWith ( value . cloneTree () ) ;
node . replaceWith ( replacement ) ;
n . replaceWith ( stringNode ) ;
callNode . replaceWith ( objNode ) ;
callNode . replaceWith ( objNode ) ;
{ original . replaceWith ( replacement ) ; return replacement ; }
if ( replaceParent ) { parent . replaceWith ( replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
superCall . replaceWith ( superErrorExpr ) ;
obj . replaceWith ( result ) ;
n . replaceWith ( attachTypeExpr ) ;
loadModuleStatement . replaceWith ( moduleBlockNode ) ;
n . replaceWith ( legacyQname ) ;
exprResultNode . replaceWith ( exportsObjectCreationNode ) ;
call . replaceWith ( exportedNamespaceName ) ;
{ aliasReference . replaceWith ( replacement ) ; }
expressionWithScopeCall . replaceWith ( scopeClosureBlock ) ;
{ newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportCodeChange () ; }
callNode . replaceWith ( replacementNode . detach () ) ;
member . replaceWith ( memberVariable ) ;
{ forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; }
n . replaceWith ( whileNode ) ;
condition . replaceWith ( replacementConditionNode ) ;
n . replaceWith ( replacement ) ;
n . replaceWith ( caseBlock . detach () ) ;
{ if ( result . getParent () != null ) { result . detach () ; } n . replaceWith ( result ) ; }
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
{ oldRoot . replaceWith ( newRoot ) ; }
n . replaceWith ( call ) ;
n . replaceWith ( not ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . replaceWith ( replacement ) ;
enclosingCall . replaceWith ( baseCall ) ;
callNode . replaceWith ( replacement ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
public void testNgInjectSetVisibility ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
Node scopeMethodCall = findScopeMethodCall ( t . getScopeRoot () ) ;
Node n = t . getScopeRoot () ;
return list . isEmpty () ? null : list ;
return list ;
public abstract Node getRoot ( ) ;
String getContent ( ) ;
String getName ( ) ;
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ return STRING_CONSTANT ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! n . hasXChildren ( NUMBER_CONSTANT ) ) { return n ; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind , false ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind , false ) ;
ImmutableCollection < ExportInfo > exports
if ( isUnknownType () ) { return true ; }
return list . isEmpty () ? null : list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . thisNode () ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT , STRING_CONSTANT + superClassQName ) ) ; }
this . ancestorInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . useSourceInfoIfMissingFromForTree ( script ) ) ;
require . useSourceInfoIfMissingFromForTree ( importDecl ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
{ node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ; node . setOriginalName ( originalName ) ; }
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
newChild . useSourceInfoIfMissingFrom ( child ) ;
Node name
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( caseType , switchType ) ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitInterfaceUses () ; }
if ( strictMismatch ) { implicitInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( n , argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options . getTracerMode () . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
options . setTracerMode ( config.tracerMode ) ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
for ( Reference ref : refCollection ) { processReference ( collector , ref , info , v ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , DependencyInfo > parsedFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > depsFiles = new LinkedHashMap <> () ;
Map < String , DependencyInfo > providesMap = new LinkedHashMap <> () ;
( ! allowLoosePropertyAccessOnNode ( n ) || objectType . isStruct () )
{ if ( canCreate ) { return createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d , n ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . isEmpty () ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath , e . getMessage () ) ) ; }
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || n . isForIn () ; }
return newNode ( Token.FOR_IN , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR_IN , target , cond , body ) ;
validateNodeType ( Token.ROOT , n ) ;
validateNodeType ( Token.ROOT , n ) ;
Path path
Path path
TranspileResult transpile ( Path path , String code ) ;
TranspileResult result = transpiler . transpile ( Paths . get ( path ) , s ) ;
Path path
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( SOURCE_JS , STRING_CONSTANT ) ;
Path path
Path path
if ( parent . isForIn () ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
source . isForIn ()
( parent . isForIn () )
if ( n . isForOf () || n . isForIn () ) { return n . getSecondChild () ; }
if ( parent . isForIn () ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( cur . isVanillaFor () ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
forNode . isForIn () || forNode . isForOf ()
c . isForIn ()
parent . isForIn ()
! n . isForIn ()
parent . isFor () && ! parent . isForIn ()
if ( ! parent . isForIn () && child == parent . getFirstChild () ) { return parent ; }
boolean lhsOfForInLoop = gp . isForIn () && gp . getFirstFirstChild () == declNode ;
loopNode . isVanillaFor ()
srcDeclaration . isConst () && ! ( srcParent . isForIn () && srcDeclaration == srcParent . getFirstChild () )
! n . isForIn ()
nextSibling . isForIn ()
! n . isForIn ()
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || n . isForIn () ) { return; }
if ( currentStatement . isForIn () ) { visitForIn () ; return false ; }
if ( parent . isForIn () && parent . getFirstChild () == n ) { return false ; }
n . isForIn ()
Preconditions . checkState ( expr . isForIn () ) ;
Preconditions . checkState ( expr . getParent () . isForIn () ) ;
Preconditions . checkState ( lvalue . getParent () . isForIn () ) ;
n . isForIn ()
Node expr = n . isForIn () ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
if ( parent . isForIn () ) { return; }
if ( n . isForIn () ) { return n ; }
if ( ! node . isForIn () ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
parent . isForIn ()
if ( ! parent . isForIn () ) { return ( parent . getSecondChild () == expr ) ; }
( parent . isForIn () && parent . getFirstChild () == n )
return n . isForIn () ? null : n . getSecondChild () ;
( parent . isForIn () && parent . getFirstChild () == n )
! n . isForIn ()
control . isForIn ()
n . isForIn ()
parent . isFor () && ! parent . isForIn () && NodeUtil . getConditionExpression ( parent ) != n
if ( ! n . isForIn () ) { tryRemoveAssignment ( t , NodeUtil . getConditionExpression ( n ) , state ) ; }
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
Preconditions . checkState ( ! NodeUtil . isLoopStructure ( parent ) ) ;
currentStatement . isVanillaFor ()
n . isAssign () && ! ( parent . isVanillaFor () || parent . isForIn () )
n . isAssign () && ( parent . isExprResult () || parent . isVanillaFor () || parent . isReturn () )
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
nextSibling . isVanillaFor () && nextSibling . getFirstChild () . isEmpty ()
Node initializer = NodeUtil . isAnyFor ( n ) ? n . getFirstChild () : IR . empty () ;
if ( ! parent . isVanillaFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
grandparent . isForIn ()
{ appendFieldStart ( out , name , false ) ; }
Preconditions . checkNotNull ( scope , STRING_CONSTANT , t . getScopeRoot () ) ;
boolean preserveBlock = n . isNormalBlock () && ! n . isSyntheticBlock () ;
parent . isNormalBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isRoot () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.ROOT ) ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
testMissingRequireStrict ( js , STRING_CONSTANT ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , mode ) ; }
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = getSentinelObjectLiteral () ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeMinimizeConditions ( late , false , false )
getInvalidationsErrors () . get ( t )
throw new RuntimeException ( cause ) ;
if ( exception [ NUMBER_CONSTANT ] != null ) { throw new RuntimeException ( exception [ NUMBER_CONSTANT ] ) ; }
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableUnusedLocalAssignmentCheck = false ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.UNUSED_LOCAL_VARIABLE , CheckLevel.WARNING ) ; } return options ; }
invalidationMap . get ( t )
private String getNewName () { return paramPrefix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPrefix = Preconditions . checkNotNull ( paramPrefix ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
( new NodeTraversal ( compiler , this , scopeCreator ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testDoesNotInject ( STRING_CONSTANT ) ; }
validateBlock ( n . getLastChild () ) ;
{ validateNodeType ( Token.DEFAULT_CASE , n ) ; validateChildCount ( n ) ; validateBlock ( n . getLastChild () ) ; }
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . setIsAddedBlock ( true ) ;
block . setIsAddedBlock ( true ) ;
block . setIsAddedBlock ( true ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
testSame ( src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; foldSame ( STRING_CONSTANT ) ; }
public void testDivision () { foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
testSame ( js ) ;
foldSame ( STRING_CONSTANT ) ;
foldSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; }
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testSameLocal ( STRING_CONSTANT ) ; }
testSameLocal ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSameWithInversion ( STRING_CONSTANT ) ;
testSame ( fullJsCode ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( ! isClinitMethod ( node ) ) { return; } trySubstituteEmptyFunction ( node ) ; }
{ tryRemovingClinit ( node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
PropertyType pt = getPropTypeHelper ( jsdoc , getProp , rawType ) ;
{ lint ( Paths . get ( filename ) , new Compiler ( System.out ) ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
options . setProtectHiddenSideEffects ( true ) ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this , scopeCreator ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertThat ( compiler . getErrors () ) . isEmpty () ; return root ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { markConstructorToProcess ( n ) ; return false ; }
new RemoveCode ( compiler ) . process ( externs , root ) ;
handleStubDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
lastIndex = replacement . getEndPosition () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () == TracerMode.ALL ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
@ Nullable Object object
{ checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( @ Nullable TypeI type ) { this . typei = type ; }
@ Nullable public TypeI getTypeI () { return typei ; }
public void setJSType ( @ Nullable JSType jsType ) { this . typei = jsType ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( parent ) ; parent . removeChild ( this ) ; return this ; }
public AncestorIterable getAncestors () { return new AncestorIterable ( checkNotNull ( this . getParent () ) ) ; }
@ Nullable public Node getParent () { return parent ; }
void setPropListHead ( @ Nullable PropListItem propListHead ) { this . propListHead = propListHead ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( @ Nullable StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable Object value
{ checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
checkNotNull ( target , STRING_CONSTANT ) ;
{ checkNotNull ( prevChild.next , STRING_CONSTANT ) ; replaceChild ( prevChild.next , newChild ) ; }
{ checkArgument ( child.parent == null ) ; child.parent = this ; }
@ Nullable public Node getSecondChild () { return first.next ; }
@ Nullable public Node getFirstChild () { return first ; }
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Nullable PropListItem next
@ Override public abstract PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem next
PropListItem chain ( @ Nullable PropListItem next ) ;
@ Nullable PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
condition . isCall () && condition . hasTwoChildren ()
Preconditions . checkState ( node . hasTwoChildren () ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . hasTwoChildren ()
boolean isDeprecatedCall = callNode . hasTwoChildren () && callName . isGetProp () ;
checkState ( n . hasTwoChildren () , n ) ;
Preconditions . checkState ( left . hasTwoChildren () ) ;
Preconditions . checkState ( n . hasTwoChildren () , n ) ;
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
if ( createSourceMap ) { mcp . generateSourceMap ( code , sourceMap ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
assertThat ( templateTypes ) . isEmpty () ;
String shortName = getShortNameForRequire ( namespace ) ;
String shortName = getShortNameForRequire ( namespace ) ;
String shortName = getShortNameForRequire ( namespaceToRequire ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
Ascii . toUpperCase ( rightmostName )
{ checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent ) ;
checkNotNull ( reportPath ) ;
@ Nullable NameInformation referring
@ Nullable NameInformation referring
checkNotNull ( ns , STRING_CONSTANT , n ) ;
{ checkNotNull ( name ) ; scopes . put ( node , name ) ; }
checkState ( node . isCall () ) ;
{ super ( name , node ) ; checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT_2015 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
assertNoPureCalls ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoPureCalls ( source ) ;
assertNoPureCalls ( source ) ;
JSType recvType = simpleInferExprTypeRecur ( recv ) ;
JSType t = simpleInferExprTypeRecur ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . add ( name ) ; }
qname != null && noSideEffectExterns . contains ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new EnumMap <> ( ParamGroup . class ) ;
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
statement . isNormalBlock ()
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
currentFile . markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isRoot () ) ;
if ( ! originalBody . isNormalBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
! body . isNormalBlock ()
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
checkState ( body . isNormalBlock () , body ) ;
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
Preconditions . checkArgument ( block . isNormalBlock () , STRING_CONSTANT ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
parent . isScript () || ( parent . isNormalBlock () && parent . getParent () . isFunction () )
c . isNormalBlock ()
c . isNormalBlock ()
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
! labeledStatement . isNormalBlock ()
last . isNormalBlock ()
currentStatement . isNormalBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
Preconditions . checkArgument ( node . isNormalBlock () ) ;
parent != null && ( parent . isNormalBlock () || parent . isScript () )
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
umdPattern.activeBranch . isNormalBlock () && umdPattern.activeBranch . getChildCount () == NUMBER_CONSTANT
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
node . isNormalBlock ()
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) ) { return; }
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
return expectedBlock . isNormalBlock () ? expectedBlock : null ;
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
Preconditions . checkState ( n . isNormalBlock () , n ) ;
if ( maybeAssign . isNormalBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
Preconditions . checkState ( tryBody . isNormalBlock () ) ;
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
Preconditions . checkState ( then . isNormalBlock () ) ;
Preconditions . checkState ( body . isNormalBlock () ) ;
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
n . hasChildren () && n . getFirstChild () . isNormalBlock ()
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
Preconditions . checkState ( externs . isRoot () ) ;
{ assertTrue ( mainRoot . isRoot () && ! mainRoot . hasChildren () ) ; }
assertNode ( functionA . getBodyNode () ) . hasType ( Token.BLOCK ) ;
assertNode ( mainFunction . getAstNode () ) . hasType ( Token.ROOT ) ;
assertNode ( mainFunction . getBodyNode () ) . hasType ( Token.ROOT ) ;
return ImmutableList . of ( qmark , bang ) ;
return scopeRoot . isNormalBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
n . isNormalBlock ()
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isNormalBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isNormalBlock () ) { return false ; }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isNormalBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
endPass ( STRING_CONSTANT ) ;
! currentScope . hasThis () && NodeUtil . containsType ( fn . getLastChild () , Token.SUPER , NodeUtil.MATCH_NOT_FUNCTION )
Renamer createForChildScope ( boolean hoisted ) ;
{ renamer = nameStack . peek () . createForChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
if ( ! isInferrableConst ( jsdoc , nameNode , false ) ) { return; }
testWarning ( STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_SUPER_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Node argList = NodeUtil . getFunctionParameters ( function ) ;
Node argList = NodeUtil . getFunctionParameters ( function ) ;
throw new MalformedException ( STRING_CONSTANT + node , fnChild ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
if ( isCallInLoop ) { fixUninitializedVarDeclarations ( newBlock , newBlock ) ; }
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
void clear () { providedNamespaces . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , providedNamespaces ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
if ( instrumentationData . get ( fileName ) != null ) { node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; }
{ node . addChildrenToFront ( newHeaderNode ( traversal , node ) . removeChildren () ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternatesWithoutStructuralTyping () : null ; }
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toMaybeObjectType () ;
TypeI type
TypeI type
{ objectType = objectType . getTopDefiningInterface ( propName ) ; }
if ( isInterface () ) { return getInstanceType () . getTopDefiningInterface ( propertyName ) ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedTypeOfEnumElement () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedTypeOfEnumElement () ;
{ NominalType tmp = NominalType . join ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
NominalType nominal = NominalType . join ( nt1 , nt2 ) ;
@ Override public CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled ) ; }
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
parent . removeFirstChild () ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ( currentScript.exportsToInline . keySet () )
Preconditions . checkArgument ( o instanceof JSType , STRING_CONSTANT , o ) ;
this . registry = compiler . getTypeIRegistry () ;
test ( DEFAULT_EXTERNS + externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = STRING_CONSTANT ;
testSets ( js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; this . mode = TypeInferenceMode.OTI_ONLY ; }
public DisambiguatePropertiesTest () { super ( DEFAULT_EXTERNS ) ; parseTypeInfo = true ; }
if ( ! ( t . inGlobalHoistScope () || t . inModuleScope () ) ) { return false ; }
{ assertError ( e ) . hasType ( type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertError ( result.errors [ NUMBER_CONSTANT ] ) . hasType ( errorType ) ;
assertThat ( result.success ) . isTrue () ;
assertThat ( compiler . getResult () . success ) . isTrue () ;
currentModule.importsByLongRequiredName . put ( extractFirstArgumentName ( callNode ) , parent ) ;
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
polymerVersion = null ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( options.polymerVersion == null ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
if ( options.polymerVersion != null ) { checks . add ( polymerPass ) ; }
options . setPolymerVersion ( NUMBER_CONSTANT ) ;
if ( other . isGeneric () ) { other = other . instantiateGenericsWithUnknown () ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown () . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown () . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; }
public boolean isConstDeclaration () { return getParent () . isConst () ; }
public boolean isVarDeclaration () { return getParent () . isVar () ; }
{ traverseClass ( n ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
String zipEntryPath = JAR_URL_PREFIX + absoluteZipPath + BANG_SLASH + entryPath ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
{ options . setPolymerVersion ( value ? NUMBER_CONSTANT : null ) ; }
fix . getReplacements () . keySet ()
nameDefinitionMultimap . keySet ()
nameDefinitionMultimap . keys ()
nameDefinitionMultimap . keySet ()
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
{ checkState ( scope . isGlobal () , scope ) ; scanVars ( n , true , true ) ; }
{ CompilerOptions options = createCompilerOptions () ; options . setCheckTypes ( true ) ; test ( options , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
markConstAndCopyJsDoc ( assignNode , jsdocNode ) ;
markConstAndCopyJsDoc ( target , target ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode ) ;
{ return Iterables . getLast ( list ) ; }
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
super . setCode ( cachedCode , Objects . equals ( this . getCharset () , StandardCharsets.UTF_8 ) ) ;
if ( this . ns != null ) { builder . append ( this . ns ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
this . functionContextStack . addLast ( initialGeneratorContext ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
Node namespaceArg = crDefineCallNode . getSecondChild () ;
Node pathArg = crExportPathNode . getSecondChild () ;
String target = call . getSecondChild () . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return result ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.ASYNCHRONOUS ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.GENERATOR ) ;
parseFunctionTail ( builder , FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , FunctionFlavor.ASYNCHRONOUS ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
parseFunctionTail ( builder , isGenerator ? FunctionFlavor.GENERATOR : FunctionFlavor.NORMAL ) ;
recvType = recvType . removeType ( commonTypes.NULL_OR_UNDEFINED ) ;
if ( isCallTo ( destructuringLhsNode . getLastChild () , GOOG_REQUIRE ) ) { return; }
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , GOOG_FORWARDDECLARE ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && isCallTo ( call , GOOG_LOADMODULE ) && call . getLastChild () . isFunction () ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , null , nameGenerator ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedFirstCharacters , reservedNonFirstCharacters ) ;
reset ( reservedNames , prefix , reservedCharacters , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options . getPropertyReservedNamingFirstChars () , options . getPropertyReservedNamingNonFirstChars () ) ; }
if ( isBottom () || isUnknown () || isTheTruthyType () ) { return this . commonTypes . UNKNOWN ; }
private boolean isTheFalsyType () { return FALSY_MASK == getMask () ; }
private boolean isTheTruthyType () { return TRUTHY_MASK == getMask () ; }
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
scope . getVarIterable ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
parse ( STRING_CONSTANT ) ;
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
scope . getAllSymbols ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getAllSymbols () ) ; }
{ return NodeUtil . isLoopStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , sourceType , targetType ) ; }
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , argType , paramType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , rightType , leftType ) ;
TypeMismatch . recordImplicitInterfaceUses ( this . implicitInterfaceUses , n , caseType , switchType ) ;
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getPrototypeObject () ; }
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getThisType () ) . append ( STRING_CONSTANT ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( isBuiltinObjectPrototype () , STRING_CONSTANT , this ) ; return null ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( n ) && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + BANG_SLASH + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
isNameDeclaration ( parent ) || parent . isExprResult ()
println ( STRING_CONSTANT , funType ) ;
reportCodeChange () ;
reportCodeChange () ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp () { style = RELAX ; }
@ Override public void setUp () { enableNormalize () ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkState ( ! areSubtypes , STRING_CONSTANT , obj1 , obj2 ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return ch == NUMBER_CONSTANT || Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkArgument ( callNode . isCall () , STRING_CONSTANT , callNode ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getJsRoot () ;
{ assertThat ( aggregateWarnings ) . named ( STRING_CONSTANT ) . isEmpty () ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( js , js , null , null ) ; }
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT_NEXT ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_NEXT ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT5 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
{ languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
languageMode = LanguageMode.ECMASCRIPT_2015 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT_2015 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT_2016 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT_2016 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; compiler = createCompiler () ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT_2015 ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT_2015 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ testWarning ( js , expected , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT_2015 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT_2015 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ; return options ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT_2015 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT_2015 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT_2016 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_NEXT , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
return CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT_2015 ;
options . setLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
setLanguage ( LanguageMode.ECMASCRIPT_2015 , LanguageMode.ECMASCRIPT5_STRICT ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
{ testError ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( createShorthandFunctionInObjLit ( body ) ) ; }
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testFailure ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
replaceSymbol ( t , n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType == null ? null : functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
testSame ( STRING_CONSTANT ) ;
replaceSymbol ( n , name , t . getInput () ) ;
findDeclaredNames ( t , functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( t , declarationRoot , renamer , false ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . isFrozen , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( this . isFrozen ) ;
if ( ! this . isFrozen ) { return null ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
{ if ( isFrozen && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFrozen ) ;
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
Preconditions . checkArgument ( nominalType . isFrozen () ) ;
if ( ! thisNode . isEquivalentWithSideEffectsToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = compiler . getChangeStamp () ; }
maybeSanityCheck ( name , externs , root ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { nameGenerator = null ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
public InlineVariablesConstantsTest () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
globalScope = TypedScope . createGlobalScope ( rootNode ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () , getTemplateTypes () ) ) ;
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportChangeToEnclosingScope ( grandparent ) ; }
@ Override public final boolean isUnresolved () { return false ; }
final JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportChangeToEnclosingScope ( block ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( newBody ) ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportChangeToEnclosingScope ( newBlockNode ) ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportChangeToEnclosingScope ( origValueNode ) ; }
if ( newValue != msgNode ) { newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportChangeToEnclosingScope ( newValue ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
compiler . reportChangeToEnclosingScope ( parent ) ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportChangeToEnclosingScope ( retValue ) ; }
compiler . reportChangeToEnclosingScope ( getProp ) ;
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
compiler . reportChangeToEnclosingScope ( newQualifiedNameNode ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( binaryNamespaceExportNode ) ;
compiler . reportChangeToEnclosingScope ( jsdocNode ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( var ) ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ parent . removeChild ( n ) ; compiler . reportChangeToEnclosingScope ( parent ) ; functions . put ( t . getModule () , n ) ; }
if ( codeChanged ) { compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
compiler . reportChangeToEnclosingScope ( objNode ) ;
t . getCompiler () . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( and ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( rhs ) ;
@ Override protected void setUp () { allowExternsChanges ( true ) ; }
compiler . reportChangeToEnclosingScope ( var ) ;
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportChangeToEnclosingScope ( newChild ) ; }
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
compiler . reportChangeToEnclosingScope ( classDeclaration ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( outerBlock ) ;
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
{ n . setString ( prop + fileid ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportChangeToEnclosingScope ( attachTypeExpr ) ; }
compiler . reportChangeToEnclosingScope ( node ) ;
compiler . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( propstmt ) ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
compiler . reportChangeToEnclosingScope ( callSite.parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.ADDING_PROPERTY_TO_NON_OBJECT ) ;
@ Override protected void setUp () { super . enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( ref ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
for ( Node closureRequire : requiresToBeRemoved ) { compiler . reportChangeToEnclosingScope ( closureRequire ) ; closureRequire . detach () ; }
notifyOfRemoval ( node , parent ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node , parent ) ; }
@ Override public void setUp () { enableNormalize () ; }
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
scope . isFunctionScope ()
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( global.root ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( varNode ) ;
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( genBlock ) ;
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
compiler . reportChangeToEnclosingScope ( var ) ;
compiler . reportChangeToEnclosingScope ( result ) ;
compiler . reportChangeToEnclosingScope ( newBlock ) ;
compiler . reportChangeToEnclosingScope ( newFor ) ;
compiler . reportChangeToEnclosingScope ( name ) ;
compiler . reportChangeToEnclosingScope ( stringKey ) ;
compiler . reportChangeToEnclosingScope ( init ) ;
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( mathDotPowCall ) ;
compiler . reportChangeToEnclosingScope ( initSymbol ) ;
{ return new DevirtualizePrototypeMethods ( compiler ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
n . isName () && NodeUtil . isNameDeclaration ( n . getParent () )
Iterable < JSModule > getAllModules () { return modules ; }
compiler . setChangeScope ( null ) ;
initTraversal ( root ) ;
initTraversal ( scopeRoot ) ;
initTraversal ( root ) ;
compiler . reportChangeToEnclosingScope ( exportCall ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
compiler . reportChangeToEnclosingScope ( objLit ) ;
compiler . reportChangeToEnclosingScope ( expression ) ;
{ c . setQuotedString () ; compiler . reportChangeToEnclosingScope ( c ) ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportChangeToEnclosingScope ( dollarChildProp ) ; }
compiler . reportChangeToEnclosingScope ( stmt ) ;
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { enableNormalize () ; }
compiler . reportChangeToEnclosingScope ( assign ) ;
compiler . reportChangeToEnclosingScope ( stmts ) ;
compiler . reportChangeToEnclosingScope ( stmts ) ;
compiler . reportChangeToEnclosingScope ( fnNameNode ) ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; t . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( t , n ) ; } }
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( t , n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; t . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( t , n , parent ) ; } }
reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( lastAncestor ) ;
reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; reportCodeChange () ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
{ visitArrowFunction ( t , n , checkNotNull ( thisContext ) ) ; }
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
this . reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . reportCodeChange () ; }
reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( injectionPointParent ) ;
compiler . reportChangeToEnclosingScope ( expressionRoot ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( newValue ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( parent ) ;
visitClass ( t , n , parent ) ;
visitRestParam ( t , n , parent ) ;
reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
t . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . copy () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . copy () : expr ; } return null ; }
if ( foundObj . isGenericObjectType () ) { foundType = foundObj . getRawType () ; }
ImmutableMap < String , TypeI > typeVars
if ( obj != null && obj . isGenericObjectType () ) { return obj . instantiateGenericsWithUnknown () ; }
if ( foundType != null && foundType . isGenericObjectType () ) { foundType = foundType . getRawType () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc () ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; }
compiler . reportChangeToEnclosingScope ( objectLit ) ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( t , parent , callNode ) ; }
compiler . reportChangeToEnclosingScope ( addingRoot ) ;
compiler . reportChangeToEnclosingScope ( body ) ;
compiler . reportChangeToEnclosingScope ( inheritsExpressionResult ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove ( compiler ) ; }
if ( codeChanged ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
if ( options . getInstrumentForCoverageOnly () ) { instrumentForCoverage ( options.instrumentBranchCoverage ) ; return; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override protected int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT , name ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null ) ;
if ( typeWithBannedProp . isSubtypeWithoutStructuralTyping ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
t . reportCodeChange () ;
t . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; t . reportCodeChange () ; }
t . reportCodeChange () ;
compiler . reportChangeToEnclosingScope ( root ) ;
t . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; t . reportCodeChange () ; }
AbstractCompiler compiler
reportChangeToEnclosingScope ( parent ) ;
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
t . reportCodeChange () ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( t , n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( t , parent , parent . getParent () ) ; }
{ n . setString ( newName ) ; t . reportCodeChange () ; return; }
maybeRewriteClassDefinition ( t , n ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
Iterable < JSModule > getAllModules () { return modules ; }
tightenNameTypeAndDontWarn ( varName , expr , declType , inferredType , requiredType )
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
List < TypeMismatch > actual = ImmutableList . copyOf ( getLastCompiler () . getTypeMismatches () ) ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
JSTypeRegistry registry = getLastCompiler () . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
NodeUtil . isCompoundAssignmentOp ( n ) || n . isInc () || n . isDec ()
if ( NodeUtil . isCompoundAssignmentOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
bundler . appendTo ( out , input , input . getSourceFile () . getCode () ) ;
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . loadSource ( path ) ) ;
ExternalSourceLoader originalSourcesLoader
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
readInputs () ;
{ ensureRequirementIsMutable () ; com.google.protobuf.AbstractMessageLite.Builder . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e . unwrapIOException () ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessageV3.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessageV3.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessageV3.BuilderParent parent
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseDelimitedWithIOException ( PARSER , input , extensionRegistry ) ; }
{ return com.google.protobuf.GeneratedMessageV3 . parseWithIOException ( PARSER , input , extensionRegistry ) ; }
public void testInlineInFunction1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( n . isAsyncFunction () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
NodeUtil . isNameDeclaration ( declaration ) && declaredVarOrProp . isName ()
assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; assertGetNameResult ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { changeVerifier = new ChangeVerifier ( compiler ) . snapshot ( jsRoot ) ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; changeVerifier . checkRecordedChanges ( passName , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6RewriteClass.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , NodeUtil . newUndefinedNode ( node ) ) ;
compiler . performOptimizations () ;
n . isName () && NodeUtil . isNameDeclaration ( searchIt . currentParent () ) && n . getString () . equals ( STRING_CONSTANT )
( NodeUtil . isNameDeclaration ( declaration . getParent () ) && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet <> ( clinitsCalledAtBranch ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
NTIScope innerScope = this . currentScope . getScope ( fnName ) ;
lhs . isName () && this . currentScope . isConstVar ( lhs . getString () )
if ( ! this . currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && this . currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
JSType declType = this . currentScope . getDeclaredTypeOf ( name ) ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
guardA . addGuard ( visibilityOff ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( ! t . getScope () . isHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getChangeScopeForNode ( n ) ) ; notifyChangeHandlers () ; }
{ return precedence ( n ) < minPrecedence ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
{ invalidatingPropRef = ! isValidCandidateDefinition ( t , n , parent ) ; }
TypeI type
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
checkState ( ! maybeDecl . isInitializingDeclaration () ) ;
checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getSmallestCoveringDependency ( ImmutableList . of ( m , deepestModule ) ) ; }
{ return precedence ( n ) < minPrecedence ; }
checkNotNull ( js ) ;
checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
checkState ( currentTracer != null , STRING_CONSTANT ) ;
checkState ( currentTracer == null ) ;
{ checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . stage1AndStage2Passes () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . getRoot () == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( passNameMsg , n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isPropertyDeclarationOnThis ( parent . getFirstChild () , currentScope ) )
Reference aliasRef = aliasRefs.references . get ( i ) ;
Reference ref
maybeTemporarilyLiveNodes . add ( expr ) ;
node . matchesQualifiedName ( name )
@ Nullable String newName
public InlineObjectLiteralsTest () { enableNormalize () ; setAcceptedLanguage ( ECMASCRIPT_NEXT ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
{ return fromFile ( file , UTF_8 ) ; }
{ parent . detach () ; }
qNameRoot != null && qNameRoot . matchesQualifiedName ( EXPORTS ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . detach () ;
onlyExport . detach () ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return call . getFirstChild () . matchesQualifiedName ( STRING_CONSTANT ) ; }
boolean isInClass = n . getParent () . isClassMembers () ;
{ parent . detach () ; }
{ n . detach () ; }
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . detach () ; }
assignmentParent . detach () ;
return parent != null && parent . isAssign () && parent . getFirstChild () == n ;
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . detach () ; } }
return enclosingNode != null && ! enclosingNode . isFunction () ;
if ( ! anc . getFirstChild () . matchesQualifiedName ( name ) ) { return Ref.Type.ALIASING_GET ; }
Node block = t . getScopeRoot () ;
isASTNormalized () && constructorNameNode . isName ()
parent . detach () ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
checkState ( ! name . equals ( ARGUMENTS ) ) ;
checkArgument ( ! idPrefix . isEmpty () ) ;
{ checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( currentScript.isModule ) { rewriteShortObjectKey ( t , n ) ; }
{ testWarning ( js , warning , LanguageMode.ECMASCRIPT_2015 ) ; }
shouldRemove ( t , nameNode )
if ( isConstToBeInferred ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
CrossModuleReferenceCollector collector
public void testNgInjectAddsInjectToClassConstructor ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str . intern () ; }
this . quoteKeywordProperties = options . shouldQuoteKeywordProperties () ;
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , new Es6SyntacticScopeCreator ( compiler ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = Optional . of ( emitUseStrict ) ; return this ; }
builder . setTagAsStrict ( firstOutput && options . shouldEmitUseStrict () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT , error.description ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal t = new NodeTraversal ( compiler , finder , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
NodeTraversal t = new NodeTraversal ( compiler , null , new Es6SyntacticScopeCreator ( compiler ) ) ;
checkState ( reference . isName () ) ;
if ( checkUnusedLocals && unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
ObjectsBuilder newObjs = new ObjectsBuilder () ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; }
while ( s.parent != null ) { if ( s . isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( STRING_CONSTANT + MAX_STEP + STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageOut () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = Optional . of ( isStrictModeInput ) ; return this ; }
Config.StrictMode strictMode = options . expectStrictModeInput () ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY ;
if ( options . expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . expectStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
Pattern . compile ( STRING_CONSTANT )
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageIn () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageIn () , key . getString () )
String finalMessage = STRING_CONSTANT + message ;
STRING_CONSTANT + number + ( ! supported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . supported == supported
this . number >= other.number && ( ! this . supported || other.supported )
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
{ parent . replaceChild ( assignNode , IR . number ( NUMBER_CONSTANT ) . srcref ( assignNode ) ) ; }
builder . append ( STRING_CONSTANT ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedTypedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
{ foundNodes . add ( name ) ; }
{ this . names = names ; foundNodes = new HashSet <> () ; }
checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = maybeCreateSources ( STRING_CONSTANT , externs ) ;
test ( compiler , null , createSources ( STRING_CONSTANT , expected ) , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
validateFeature ( Feature.NAMESPACE_DECLARATION , n ) ;
{ validateFeature ( Feature.AMBIENT_DECLARATION , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateFeature ( Feature.TYPE_ALIAS , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateFeature ( Feature.ARROW_FUNCTIONS , n ) ;
validateFeature ( Feature.CLASSES , n ) ;
validateFeature ( Feature.INTERFACE , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.TEMPLATE_LITERALS , n ) ;
validateFeature ( Feature.MODULES , n ) ;
{ validateFeature ( Feature.ASYNC_FUNCTIONS , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateFeature ( Feature.GENERATORS , n ) ;
setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
this . setFeatureSet ( options . getLanguageIn () . toFeatureSet () ) ;
{ Compiler compiler = new Compiler () ; compiler . setFeatureSet ( acceptedLanguage . toFeatureSet () ) ; return compiler ; }
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
compiler . getOptions () . needsTranspilationFrom ( FeatureSet.ES6 )
Node root2 = compiler . parseSyntheticCode ( STRING_CONSTANT , source ) ;
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) ;
return replaceNode ( n , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
int precedence
expectFeatures ( Feature.DESTRUCTURING , Feature.ARRAY_PATTERN_REST ) ;
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6OrHigher ( script ) ) { return true ; } }
isScriptEs6OrHigher ( scriptRoot )
isScriptEs6OrHigher ( singleRoot )
{ if ( isScriptEs6OrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6OrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6OrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6OrHigher ( singleRoot ) ) { return true ; } } }
return isConst && ! JsdocUtil . hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , JsdocUtil . getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new Es6RewriteModules ( this ) . processFile ( root , forceRewrite ) ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . performPostCompilationTasks () ; }
performPostCompilationTasks () ;
performPostCompilationTasks () ;
{ if ( ! compiler . getFeatureSet () . has ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
features = features . union ( factory . getFeatures () ) ;
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . has ( feature ) ) { return mode ; } }
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.ARRAY_PATTERN_REST ) ;
features = features . with ( Feature.DESTRUCTURING ) ;
features = features . with ( Feature.NEW_TARGET ) ;
features = features . with ( Feature.EXPONENT_OP ) ;
features = features . with ( Feature.ARROW_FUNCTIONS , Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . with ( Feature.EXPONENT_OP ) ; }
{ features = features . with ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . with ( Feature.REST_PARAMETERS ) ;
features = features . with ( Feature.DEFAULT_PARAMETERS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
features = features . with ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertFS ( result.features ) . contains ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.CLASSES , Feature.MEMBER_DECLARATIONS , Feature.CONST_DECLARATIONS , Feature.LET_DECLARATIONS ) ;
m.featureSet . has ( Feature.ASYNC_FUNCTIONS )
expectFeatures ( Feature.DESTRUCTURING , Feature.DEFAULT_PARAMETERS ) ;
expectFeatures ( Feature.MEMBER_DECLARATIONS ) ;
STRING_CONSTANT + featureSet . version ()
features = features . with ( Feature.STRING_CONTINUATION ) ;
features = features . with ( feature ) ;
features = features . with ( feature ) ;
features = features . with ( Feature.SETTER ) ;
features = features . with ( Feature.GETTER ) ;
features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ;
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . has ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
features . has ( Feature.MODULES )
setFeatureSet ( featureSet . without ( Feature.MODULES ) ) ;
BitSet modules
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info . disallowMovement () ; } }
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
Preconditions . checkArgument ( root . isRoot () , STRING_CONSTANT , root . getToken () ) ;
assertPrettyPrintSame ( STRING_CONSTANT + String . format ( STRING_CONSTANT , NUMBER_CONSTANT ) + STRING_CONSTANT ) ;
String [] parts = path . split ( MODULE_SLASH ) ;
public void testConstTarget () { disableTypeCheck () ; testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ test ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGoogScopeClassOutput () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testExtractableExport4 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testEs6Class_testMethod () { test ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
private void assertNoWarningEs6 ( String js ) { testSame ( js ) ; }
private void assertAmbiguousEs6 ( String js ) { testSame ( js ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( STRING_CONSTANT ) ;
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDuplicate_destructuring () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
testWarning ( STRING_CONSTANT , UNUSED_LABEL ) ;
testSame ( STRING_CONSTANT ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testPassModule () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testPathologicalCaseThatsOkAnyway () { testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
public void testNullUndefined () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testWarning ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
{ testWarning ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testWarning ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
testWarning ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testWarning ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
{ return ! found && ! n . isFunction () ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( typedefExterns , code ) ;
testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT ) ;
testNoWarning ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
testWarning ( input , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testNoWarning ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
testNoWarning ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal unusedT
Node export = n . getFirstFirstChild () ;
public void testObjLit () { assertUnreachable ( STRING_CONSTANT ) ; }
if ( options . needsTranspilationFrom ( ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
catch ( IOException e ) { report ( JSError . make ( AbstractCompiler.READ_ERROR , input . getName () , e . getMessage () ) ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler , scopeCreator ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler , scopeCreator ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler , SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler , t . getScopeCreator () ) ;
public void testObjectDestructuringDefaultVals () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignNewVarNames () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignWithoutDeclaration () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringBasicAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringVarAssign () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringSwap () { testSame ( STRING_CONSTANT ) ; }
{ new GraphReachability <> ( controlFlowGraph , REACHABLE ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( metadata.superClassNameNode ) ;
Node lp = scope . getParentScope () . getRootNode () . getSecondChild () ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
assertThat ( cssNames ) . isEqualTo ( expected ) ;
catch ( IOException | ClassNotFoundException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
public void testVarArguments () { testConsts ( STRING_CONSTANT , STRING_CONSTANT ) ; }
peepholePass . setRetraverseOnChange ( retraverseOnChange ) ;
public void testIssue () { allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; }
allowExternsChanges () ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
enableRunTypeCheckAfterProcessing () ;
allowExternsChanges () ;
{ allowExternsChanges () ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
allowExternsChanges () ;
allowExternsChanges () ;
allowExternsChanges () ;
if ( transpileEnabled && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public final String getFilename () { return filename ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; }
enableCheckAccessControls () ;
enableCheckAccessControls () ;
public GatherRawExportsTest () { super ( EXTERNS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; enableRunTypeCheckAfterProcessing () ; }
disableCompareJsDoc () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; useGoogleCodingConvention = true ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; }
public void testEs6ONoEs6 () { allowExternsChanges () ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; }
{ enableTypeCheck () ; allowExternsChanges () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
allowExternsChanges () ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; }
this . runSmartNameRemoval = true ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges () ;
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges () ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ disableCompareAsTree () ; super . testExternChanges ( input , expectedExtern ) ; }
disableValidateAstChangeMarking () ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; }
{ value = key . removeFirstChild () ; }
Node assign = IR . assign ( windowPropAccess , nameNode . removeFirstChild () ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( currentScript.legacyNamespace ) ;
exportedNamespaceName . setOriginalName ( legacyNamespace ) ;
binaryNamespaceName . setOriginalName ( legacyNamespace ) ;
Node initializer = n . removeFirstChild () ;
Node extern = externs . removeFirstChild () ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ ModulesTestUtils . testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( caught . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ;
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_STRING_LITERAL_ERROR ) ; }
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
shadowedVar != null && shadowedVar . isLocal ()
this . redeclarationHandler = DEFAULT_REDECLARATION_HANDLER ;
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR . size () * ( RandomNameGenerator.NONFIRST_CHAR . size () + NUMBER_CONSTANT ) ;
{ this . random = random ; reset ( ImmutableSet . < String > of () , STRING_CONSTANT , null ) ; }
NodeUtil . isNameDeclaration ( var . getParentNode () ) && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = scopeCreator . createScope ( root , null ) ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations ( compiler ) ) ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove ( compiler ) ; }
this . changeProxy = new AstChangeProxy ( compiler ) ;
clonesByCurrent . clear () ;
if ( hasExternsRoot () && n == externsRoot ) { externsScope = t . getScope () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setChromePass ( flags.chromePass ) ;
if ( options . isChromePassEnabled () ) { checks . add ( chromePass ) ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ if ( n . isFunction () ) { NormalizeStatements . visitFunction ( n , compiler ) ; } }
if ( visitFunction ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ) ;
test ( modules , expected ( expected ) , warning ( warning ) ) ;
{ test ( srcs ( js ) , expected ( js ) ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ test ( srcs ( js ) , expected ( expected ) ) ; }
testWarning ( externs , js , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
testSame ( externs , js ) ;
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
{ testNoWarning ( js ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js ) ; }
testSame ( externs , js ) ;
{ test ( code , addLibraries ( code , libraries ) , warning ( warning ) ) ; }
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test . testError ( inputs , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code ) ; }
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testSame ( externs , STRING_CONSTANT ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ) ;
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
{ setAcceptedLanguage ( lang ) ; test ( code , expected , warning ( warning ) ) ; }
testError ( googModule , MISSING_MODULE_OR_PROVIDE , warning ) ;
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
test ( externs , input , expected ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( ProcessDefines.UNKNOWN_DEFINE_WARNING ) ) ; }
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , warning ( NAMESPACE_REDEFINED_WARNING ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( externs , code ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) , exportsNameNode ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
public void testES6VarAliasClassDeclarationWithoutNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testES6VarAliasClassDeclarationWithNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
if ( NodeUtil . isEnhancedFor ( parent ) ) { return; }
public void testSimpleConstAliasInCode () { testSame ( STRING_CONSTANT ) ; }
{ checkState ( error.node . getParent () . isStringKey () , error.node . getParent () ) ; fix . delete ( error.node . getParent () ) ; }
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
checkState ( fullNameMatcher . matches () , error.description ) ;
checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr ) ;
mayWarnAboutGlobalThis ( expr ) ;
T o
public HierarchicalSet ( @ Nullable HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( isObjectLitOrCastOfObjectLit ( n ) && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertThat ( var.name ) . isNotEqualTo ( name ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState functionState ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
Map < String , Node > map = new HashMap <> ( stringLiteralMatches ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( new Es6SyntacticScopeCreator ( compiler ) ) ;
{ test ( createModuleStar ( moduleInputs ) , expected ) ; }
{ Preconditions . checkState ( expected == null ) ; expected = fromSources ( ( Sources ) part ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new FlatSources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new FlatSources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new FlatSources ( maybeCreateSources ( filename , srcText ) ) ; }
{ test ( srcs ( modules ) , expected ( modules ) ) ; }
{ test ( srcs ( modules ) , expected ( expected ) ) ; }
builder . setTypeRegistry ( getTypeIRegistry () ) ;
validateChildCount ( n ) ;
public Es6RewriteModules ( AbstractCompiler compiler ) { this . compiler = compiler ; }
ModulesTestUtils . testModulesError ( this , STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.ERROR ) ;
@ Override protected FeatureSet featureSet () { return ES7_MODULES ; }
@ Override protected FeatureSet featureSet () { return ES6_MODULES ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
{ return STRING_CONSTANT + type . toMaybeObjectType () . getEnumeratedTypeOfEnumObject () . toNonNullAnnotationString () + STRING_CONSTANT ; }
TypeI getEnumeratedTypeOfEnumObject ( ) ;
@ Override public TypeI getEnumeratedTypeOfEnumObject () { return null ; }
checkState ( sum > NUMBER_CONSTANT ) ;
checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
checkState ( curNode != null ) ;
checkNotNull ( parent ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.OTHER ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; this . mode = InputLanguageMode.TRANSPILATION ; }
if ( ! functionScope . isDeclaredSloppy ( name , false ) ) { return; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( this , getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , factory , factory ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope , null ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope , null ) . populate () ;
undeclareInteral ( var ) ;
NodeUtil . isAnyFor ( n )
{ logger . fine ( STRING_CONSTANT + scopeRoot ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
checkArgument ( nameNode . isQualifiedName () ) ;
checkArgument ( functionNode . isFunction () ) ;
checkArgument ( nameNode . isQualifiedName () ) ;
checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
checkState ( functionBody . isNormalBlock () ) ;
checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { checkArgument ( ctorNode . isFunction () , ctorNode ) ; constructorsToProcess . add ( ctorNode ) ; }
int getMaxArity ( ) ;
int getMinArity ( ) ;
index < funType . getMaxArity ()
{ if ( currentType . getMaxArity () <= expectedType . getMaxArity () ) { return expectedType ; } }
{ this ( res , new NumberValue ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new NumberValue ( op2 ) ) ; }
checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
checkArgument ( nt . isGeneric () , nt ) ;
checkArgument ( nameNode . getParent () . isVar () ) ;
checkArgument ( funNode . isFunction () ) ;
checkState ( n . isOr () || n . isAnd () ) ;
checkState ( n . isGetElem () ) ;
return checkNotNull ( funType ) . toFunctionType () ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkState ( declNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkNotNull ( lendsName ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
checkState ( qnameNode . isQualifiedName () ) ;
checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { checkState ( maybeAssign . isExprResult () ) ; } }
checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ JSType t = castTypes . get ( n ) ; checkNotNull ( t ) ; return t ; }
{ checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
checkNotNull ( name , STRING_CONSTANT ) ;
checkState ( n . isScript () ) ;
checkState ( passName . equals ( logStats.pass ) ) ;
checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
checkNotNull ( qualifiedName ) ;
checkArgument ( lastLink.nextLink == null ) ;
checkState ( token == JsDocToken.PIPE ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
checkState ( annotation == Annotation.IMPLEMENTS ) ;
checkState ( other instanceof NominalType ) ;
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
checkState ( this . rawType . equals ( other.rawType ) ) ;
checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
checkArgument ( other . isStructuralInterface () ) ;
checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
checkState ( this . rawType . isFrozen () ) ;
{ checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
checkState ( this . rawType . isFrozen () ) ;
checkState ( isUninstantiatedGenericType () ) ;
checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
checkState ( node . isSuper () ) ;
{ checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ checkState ( m == null ) ; }
checkState ( line < nextLine || col <= nextCol ) ;
checkArgument ( n . isFunction () ) ;
checkState ( variableNode != null ) ;
checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
checkNotNull ( name ) ;
checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
checkArgument ( ret . isReturn () ) ;
checkArgument ( node . isNormalBlock () ) ;
{ checkArgument ( classByAlias . containsKey ( original ) ) ; classByAlias . put ( alias , classByAlias . get ( original ) ) ; }
checkState ( subclassMember . isAssign () , subclassMember ) ;
checkState ( staticGetProp . isGetProp () ) ;
{ checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
{ checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
checkArgument ( n . isCast () ) ;
checkState ( first . getParent () == last . getParent () ) ;
{ checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
checkArgument ( mode != TypeInferenceMode.BOTH ) ;
checkState ( subns.namespaceType != null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( this . namespaceType == null ) ;
checkState ( ! prop . isOptional () ) ;
this . defSite = checkNotNull ( defSite ) ;
checkNotNull ( clinitName ) ;
checkNotNull ( name ) ;
checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
{ super ( symbolName , value ) ; this . exportPath = checkNotNull ( exportPath ) ; }
checkArgument ( fn . isFunction () ) ;
{ checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
{ checkState ( valueToExport . isObjectLit () ) ; initializer = createExternObjectLit ( valueToExport ) ; }
checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
checkState ( isNamespacePlaceholder ( decl ) ) ;
{ checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
checkArgument ( explicitNode != node ) ;
checkState ( n . isCall () ) ;
checkNotNull ( providedModule , n ) ;
checkState ( parent . isExprResult () ) ;
checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( moduleNode . isModuleBody () ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
checkArgument ( parent . isModuleBody () , parent ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkArgument ( scriptNode . isScript () ) ;
checkArgument ( n . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
checkArgument ( subtree . isCall () ) ;
{ checkState ( script . isScript () ) ; visit ( script ) ; }
checkState ( ! member . isStaticMember () ) ;
checkNotNull ( constructor ) ;
checkArgument ( object != null , STRING_CONSTANT ) ;
checkState ( ! frozen ) ;
checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
checkNotNull ( registry ) ;
checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
checkArgument ( ! envs . isEmpty () ) ;
{ checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
checkState ( meaning != null ) ;
checkArgument ( n . isCall () || n . isNew () ) ;
checkState ( n . isNew () ) ;
checkState ( n . isCall () ) ;
checkState ( n . isCall () , n ) ;
checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
checkArgument ( node . isGetProp () ) ;
checkNotNull ( compiler ) ;
{ checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
checkState ( n . isGetProp () , n ) ;
checkNotNull ( typei ) ;
checkArgument ( callSite . isCall () || callSite . isNew () ) ;
checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
checkNotNull ( functionInfo ) ;
checkNotNull ( cacheCall ) ;
this . compiler = checkNotNull ( compiler ) ;
checkState ( initialization . getGrandparent () . isExprResult () ) ;
checkState ( value != null ) ;
checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
checkState ( scriptRoot . isScript () ) ;
Time ( String name ) { checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { checkNotNull ( value ) ; this . value = value ; }
checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
checkState ( n . isScript () , n ) ;
checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
checkArgument ( n . isStringKey () , n ) ;
checkState ( scriptRoot . isScript () , scriptRoot ) ;
checkState ( c . isScript () , c ) ;
checkState ( returnNode . isReturn () , returnNode ) ;
{ checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
{ checkState ( isInterface () ) ; isStructuralInterface = flag ; }
checkArgument ( isConstructor () || isInterface () ) ;
checkNotNull ( that ) ;
checkArgument ( interfaceType . isInterface () ) ;
checkState ( msgBuilder != null ) ;
checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
{ checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
checkNotNull ( name ) ;
checkArgument ( n . isFunction () ) ;
checkState ( rootNode . isFunction () ) ;
checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { checkState ( restFormals != null ) ; return restFormals ; }
checkArgument ( propertyName . isString () ) ;
checkArgument ( superSet . isAssign () ) ;
checkArgument ( objectLit . isObjectLit () ) ;
checkState ( parent . isCall () ) ;
checkState ( parent . isObjectLit () ) ;
checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( state != State.RESOLVED ) ;
public JSType getType () { checkState ( state == State.RESOLVED ) ; return type ; }
checkNotNull ( typeExpr ) ;
{ checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
{ checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
checkState ( functionBody . getParent () . isFunction () ) ;
checkArgument ( n . isLabel () ) ;
checkState ( n . isFunction () , n ) ;
checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { checkNotNull ( renamingMap ) ; return renamingMap ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( refNode ) ;
checkNotNull ( value ) ;
if ( invalidatingPropRef ) { checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
checkState ( n . isName () , n ) ;
checkNotNull ( inputId ) ;
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
checkState ( function . isFunction () ) ;
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
checkState ( mayBeExpression ( value ) ) ;
{ checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
{ checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
checkArgument ( node . isGetProp () ) ;
checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
checkNotNull ( lValue ) ;
{ checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
checkArgument ( parent . isExprResult () ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
checkState ( expressionRoot != null ) ;
checkState ( notAlreadyOutstanding ) ;
checkState ( Thread . currentThread () == startThread ) ;
checkState ( noCycles ) ;
{ checkState ( parentClass . isInterface () ) ; warnings . add ( JSError . make ( funNode , CONFLICTING_EXTENDED_TYPE , STRING_CONSTANT , functionName ) ) ; }
checkState ( thisRoot . getToken () == Token.BANG ) ;
checkArgument ( params != null || jsdoc != null ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
checkNotNull ( n ) ;
checkNotNull ( commonTypes ) ;
checkState ( options.sourceMapDetailLevel != null ) ;
checkState ( n . isNormalBlock () , n ) ;
checkState ( line >= NUMBER_CONSTANT ) ;
checkState ( sourceMapDetailLevel != null ) ;
checkArgument ( getCfg () . hasNode ( useNode ) ) ;
{ checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
checkNotNull ( templateType , STRING_CONSTANT ) ;
checkState ( index >= NUMBER_CONSTANT ) ;
checkNotNull ( type ) ;
checkArgument ( ! values . isEmpty () ) ;
checkState ( scope . isFunctionScope () , scope ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
checkArgument ( o instanceof ObjectType ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
checkArgument ( qname . isIdentifier () ) ;
{ checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
checkNotNull ( this . ns ) ;
checkState ( isLoose || other.isLoose ) ;
checkNotNull ( pname ) ;
checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
checkNotNull ( resultNominalType ) ;
checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
checkNotNull ( reference ) ;
checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
checkNotNull ( other ) ;
{ checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
checkState ( first . isString () ) ;
checkArgument ( ctorType . isConstructor () ) ;
{ checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
checkState ( n . isGetElem () , n ) ;
checkNotNull ( data ) ;
checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! isDefined ( qnameNode ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkState ( s != null ) ;
{ checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
checkArgument ( qnameNode . isQualifiedName () ) ;
{ checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
checkNotNull ( declaredType ) ;
Node getBody () { checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
checkNotNull ( commonTypes ) ;
checkArgument ( NodeUtil . isGet ( n ) ) ;
checkState ( left . isString () ) ;
checkArgument ( n . isGetElem () ) ;
checkArgument ( n . isNew () ) ;
checkArgument ( n . isCall () ) ;
{ checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
checkArgument ( node . isAdd () ) ;
checkArgument ( n . isAssign () ) ;
checkArgument ( n . isInstanceOf () ) ;
checkState ( n . hasOneChild () , n ) ;
checkArgument ( originalTypeofNode . isTypeOf () ) ;
checkNotNull ( n ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = checkNotNull ( compiler ) ; }
checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { checkState ( pass . isOneTimePass () ) ; } }
checkState ( this . namespaceType == null ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
checkState ( ! compiler . hasErrors () ) ;
checkState ( parametersList . isParamList () ) ;
checkNotNull ( traversal ) ;
checkNotNull ( traversal ) ;
{ checkArgument ( usingNameNode . isName () ) ; return referencesByNameNode . get ( usingNameNode ) ; }
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
checkArgument ( isStorageNode ( node ) ) ;
checkArgument ( variableReference . isName () ) ;
checkState ( n . isGetProp () , n ) ;
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
checkArgument ( token.type == TokenType.STRING ) ;
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
checkArgument ( scriptNode . isScript () ) ;
checkState ( ret . isString () ) ;
checkState ( work . isEmpty () ) ;
checkArgument ( isZipEntry ( zipURL ) ) ;
checkArgument ( arrowFunction . isArrowFunction () ) ;
{ checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
checkState ( templateJs == null , STRING_CONSTANT ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
{ JSModule module = input . getModule () ; checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
checkState ( n . isCall () , n ) ;
{ checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
checkNotNull ( thisType ) ;
checkState ( moduleSpecifier . isString () ) ;
checkNotNull ( ref . getTwin () ) ;
checkState ( isObjKey || isQName ) ;
checkState ( ref.node . getParent () . isExprResult () ) ;
checkState ( child . hasOneChild () ) ;
checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
public int getArgIndex () { checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
public JSType getExpectedType () { return checkNotNull ( this . expected ) ; }
public JSType getFoundType () { return checkNotNull ( this . found ) ; }
public String getPropName () { return checkNotNull ( this . propName ) ; }
checkState ( firstScript . isScript () ) ;
checkState ( namespace . hasExternsRoot () ) ;
{ checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ checkState ( this . newName == null ) ; this . newName = newName ; }
checkState ( nameNode . isName () ) ;
checkArgument ( n . isAnd () || n . isOr () ) ;
checkNotNull ( replacementFnType ) ;
checkNotNull ( type ) ;
checkNotNull ( resultType ) ;
checkNotNull ( var ) ;
checkArgument ( objectType . isUnknownType () ) ;
checkNotNull ( errorRoot ) ;
{ checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
checkState ( this != callSiteType ) ;
checkState ( this != callSiteType ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkState ( fnRecursionName != null ) ;
checkArgument ( n . isDo () ) ;
checkArgument ( n . isVanillaFor () ) ;
checkArgument ( n . isWhile () ) ;
{ checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
checkState ( isSimpleAssignment ( n ) ) ;
checkState ( n . isSwitch () , n ) ;
checkState ( subtree . isAssign () ) ;
checkState ( n . isTry () , n ) ;
checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
checkState ( ! this . isFrozen ) ;
{ checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ! this . isFrozen ) ;
if ( isClass () ) { checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
checkState ( isInterface () ) ;
checkState ( isClass () ) ;
checkState ( ancestor . isInterface () ) ;
checkState ( ! this . isFrozen ) ;
checkState ( ancestor . isClass () ) ;
{ checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { checkState ( this . isFrozen ) ; return this . protoObject ; }
checkNotNull ( objectKind ) ;
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
checkState ( this . isSingletonObj () ) ;
checkState ( this . isSingletonObj () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
checkState ( this . isFunctionType () ) ;
{ checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
checkState ( this . isFunctionType () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
checkArgument ( type != null ) ;
checkNotNull ( arrayType ) ;
checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { checkState ( ! getEnums () . isEmpty () ) ; return this ; }
checkState ( ! areSubtypes ) ;
checkNotNull ( type ) ;
checkState ( this . isSingletonObj () ) ;
checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
checkState ( newExpr . isNew () ) ;
checkState ( newExpr . isNew () ) ;
checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
checkState ( value . getParent () == null ) ;
checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
checkArgument ( ! isIdentifier () ) ;
{ checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
checkArgument ( fnNode . isFunction () ) ;
checkArgument ( unsafe != null ) ;
{ checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
checkArgument ( n . isScript () ) ;
checkNotNull ( lValue ) ;
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { checkNotNull ( in ) ; this . in = in ; }
{ checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
checkState ( inputs . contains ( other ) ) ;
checkState ( n . isSwitch () ) ;
checkState ( allCatchNodes . hasOneChild () ) ;
checkArgument ( type instanceof TypeDeclarationNode ) ;
checkNotNull ( reader ) ;
{ checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
public JSTypeExpression getTypeExprForErrorReporting () { checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
checkNotNull ( typeExpr ) ;
{ checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
checkArgument ( n . isNot () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( objLit . isObjectLit () ) ;
checkState ( script . isScript () ) ;
checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
checkState ( block . isNormalBlock () ) ;
checkState ( tryNode . isTry () ) ;
checkState ( n . isName () , n ) ;
checkState ( objlit . isObjectLit () ) ;
checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
checkState ( node . hasTwoChildren () , node ) ;
{ checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
checkState ( n . isFunction () || n . isClass () ) ;
checkState ( n . isFunction () || n . isClass () ) ;
checkState ( descriptor . isObjectLit () ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
checkNotNull ( var ) ;
checkState ( function . isFunction () ) ;
checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ checkState ( this . fn == null ) ; this . fn = fn ; }
checkArgument ( changed != null ) ;
checkState ( functionState . hasExistingFunctionDefinition () ) ;
checkState ( n . isName () , n ) ;
checkState ( name . isName () ) ;
checkState ( NodeUtil . isGet ( child ) ) ;
checkArgument ( fn . isFunction () ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
checkNotNull ( data ) ;
{ checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
checkNotNull ( site ) ;
checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
int exitCodeValue = checkNotNull ( exitCode ) ;
{ checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
checkState ( specs != null ) ;
checkState ( zipEntryName . contains ( filename ) ) ;
checkNotNull ( input ) ;
{ this . exitCodeReceiver = checkNotNull ( newExitCodeReceiver ) ; }
checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
checkState ( currentInfo != null ) ;
{ this . compilerOptions = checkNotNull ( compilerOptions ) ; return this ; }
{ checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
checkNotNull ( sourceString ) ;
checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
checkState ( block . isNormalBlock () ) ;
{ checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
checkArgument ( newSourceInd < sources . size () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( result != null ) ;
checkState ( n . isNew () || n . isCall () ) ;
checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
checkState ( null == m . put ( type , top ) ) ;
{ Integer priority = priorities . get ( n ) ; checkNotNull ( priority ) ; return priority ; }
checkState ( handler . isTry () ) ;
checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
checkState ( currentStatement . isDo () ) ;
checkNotNull ( compiler ) ;
{ checkState ( parent == scope . getParent () ) ; }
checkArgument ( nameNode . isName () ) ;
checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
private int getMaskForBitIndex ( int bitIndex ) { checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
{ checkState ( parent . isCall () ) ; compiler . report ( JSError . make ( parent , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; }
checkArgument ( call . isCall () ) ;
{ checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
checkState ( isGeneric () ) ;
{ checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
checkState ( this . isLoose () || f2 . isLoose () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
checkArgument ( ! isTopFunction () ) ;
{ checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { checkNotNull ( restFormals ) ; return restFormals ; }
checkState ( isUniqueConstructor () ) ;
checkNotNull ( commonTypes ) ;
checkArgument ( o instanceof DeferredCheck ) ;
checkArgument ( pname . isIdentifier () ) ;
checkState ( insideQualifiedName ) ;
checkNotNull ( type ) ;
checkArgument ( pname == null || pname . isIdentifier () ) ;
checkNotNull ( type ) ;
{ checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
checkArgument ( expr . isNew () || expr . isCall () ) ;
checkArgument ( callNode . isCall () || callNode . isNew () ) ;
checkNotNull ( type ) ;
checkArgument ( thisExpr . isThis () ) ;
checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkArgument ( getProp . isGetProp () ) ;
checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
checkNotNull ( funType ) ;
checkState ( receiver == null || isFwd ) ;
checkState ( ! formalType . isBottom () ) ;
checkArgument ( call . isCall () ) ;
checkState ( logicalOp == Token.AND ) ;
checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
checkState ( qnameRoot . isName () ) ;
{ checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
checkNotNull ( n . getParent () ) ;
checkState ( n . getParent () != null ) ;
checkNotNull ( dNode ) ;
checkNotNull ( dNode ) ;
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { checkState ( globalScope == null , STRING_CONSTANT ) ; }
checkNotNull ( declNode ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkState ( fn . isConstructor () || fn . isInterface () ) ;
checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
checkState ( callNode . isCall () ) ;
checkState ( currentModule == null ) ;
{ checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
checkNotNull ( entryPoints ) ;
{ checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
checkState ( value instanceof String ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
checkState ( script . isScript () ) ;
{ checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
{ checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
if ( n . isScript () ) { checkState ( this . script == null ) ; this . script = n ; }
checkState ( root . isScript () ) ;
checkState ( root . isScript () ) ;
checkState ( newReachable . getAnnotation () != REACHABLE ) ;
checkNotNull ( compiler ) ;
{ super ( source ) ; checkNotNull ( source ) ; this . excerpt = excerpt ; }
checkNotNull ( paramType , STRING_CONSTANT ) ;
checkState ( n . isAssign () ) ;
protected boolean isASTNormalized () { checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
checkNotNull ( typeParameters ) ;
{ checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ checkState ( returnType == null ) ; returnType = t ; return this ; }
{ checkState ( restFormals == null ) ; restFormals = t ; return this ; }
checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = checkNotNull ( commonTypes ) ; }
checkArgument ( qName != null && ownerName != null ) ;
checkArgument ( ! variableName . isEmpty () ) ;
{ checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
checkArgument ( o instanceof Property ) ;
checkArgument ( inferredType != null ) ;
checkNotNull ( inputId ) ;
checkNotNull ( inputId ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( checkNotNull ( referencedType ) ) ; }
checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
checkState ( behaviorObjLit . isObjectLit () ) ;
checkState ( behaviorObjLit . isObjectLit () ) ;
checkNotNull ( keys ) ;
checkNotNull ( namedType ) ;
{ checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
checkArgument ( source == null || source . isFunction () ) ;
checkState ( source . isFunction () , source ) ;
{ checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
checkNotNull ( inputId ) ;
checkState ( n . hasOneChild () , n ) ;
{ checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
checkNotNull ( declaration ) ;
checkState ( parent . isClassMembers () ) ;
checkState ( parent . isObjectLit () ) ;
checkState ( obj instanceof AstChange ) ;
checkArgument ( functionName != null ) ;
checkArgument ( parameterName != null ) ;
checkState ( labeledVariable . isVar () ) ;
Property nameProp = checkNotNull ( getOrCreateProperty ( n ) ) ;
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
checkArgument ( assignedAt . isQualifiedName () ) ;
{ checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
checkArgument ( obj . isObjectLit () ) ;
{ checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
checkState ( defParent . isExprResult () ) ;
checkArgument ( use . isName () ) ;
checkState ( t . getScopeRoot () . isFunction () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
checkState ( nameNode != null ) ;
checkState ( ! name . isEmpty () ) ;
checkState ( ! current.renameMap . containsKey ( name ) ) ;
checkState ( fnNode . isFunction () ) ;
checkState ( callNode . isCall () ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
{ checkState ( n . isFunction () , n ) ; return true ; }
checkState ( this . namespaceType == null ) ;
checkNotNull ( interfaceType ) ;
checkNotNull ( node ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
builder . put ( typeParam , firstNonBottom ( t , UNKNOWN ) ) ;
pair = analyzeExprFwd ( index , pair.env , firstNonBottom ( indexType , UNKNOWN ) ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.BROWSER ;
public void testEs6ThisWithImportModule () { testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT ;
String result = STRING_CONSTANT + STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ this ( config , errorReporter , source , offset , false ) ; }
return new ParseResult ( root , comments , features , p . getSourceMapURL () ) ;
Node objectLit = n . getFirstChild () . getFirstFirstChild () ;
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . substituteGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . substituteGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . substituteGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . substituteGenerics ( typeMap ) ;
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
! invalidatingTypes . isInvalidating ( dest )
! props . containsKey ( propName ) && ! invalidatingTypes . isInvalidating ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , firstNonNull ( declType , UNKNOWN ) ) ; }
preciseType = firstNonNull ( declType , requiredType ) ;
{ JSType result = ft . getSuperPrototype () ; pair.type = firstNonNull ( result , UNDEFINED ) ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return firstNonNull ( tmp , UNKNOWN ) ; }
declRetType = firstNonNull ( declRetType , UNKNOWN ) ;
throw new IllegalStateException ( STRING_CONSTANT + name . getToken () ) ;
{ return new InstrumentFunctions ( compiler , compiler . getFunctionNames () , options.instrumentationTemplate , options.appNameStr ) ; }
{ compiler . setVariableMap ( runVariableRenaming ( compiler , prevVariableMap , externs , root ) ) ; }
compiler . setPropertyMap ( rprop . getPropertyMap () ) ;
compiler . setAnonymousFunctionNameMap ( naf . getFunctionMap () ) ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
compiler . setStringMap ( pass . getStringMap () ) ;
compiler . setIdGeneratorMap ( pass . getSerializedIdMappings () ) ;
compiler . setFunctionNames ( pass . getFunctionNames () ) ;
compiler . setCssNames ( newCssNames ) ;
{ return new CrossModuleMethodMotion ( compiler , new IdGenerator () , canMoveExterns , noStubs ) ; }
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence ( true ) ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence ( false ) ; } nextChar () ; return true ; }
return isUnknown () || ( isAmbiguousObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
objType == null || types . contains ( objType ) || objType . isAmbiguousObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isAmbiguousObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
TypeI type
TypeI type
TypeI type
boolean mustReplaceThisAndArguments () { return isAsyncContext () || thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
parent . getParent () . isCall () && NodeUtil . isInvocationTarget ( parent )
checkArgument ( expr . isCall () || expr . isTaggedTemplateLit () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isInvocationTarget ( n ) ) ) ;
return analyzeInvocationArgsFwdWhenError ( call , inEnv ) ;
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) , pname ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getDirectSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getDirectSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
options . setWarningLevel ( DiagnosticGroups.UNNECESSARY_ESCAPE , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISSING ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfoCollector.REDECLARED_PROPERTY ) ;
typeCheck ( js , GlobalTypeInfoCollector.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfoCollector.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getGlobalTypeInfo () ;
passes . add ( makePassFactory ( STRING_CONSTANT , new GlobalTypeInfoCollector ( compiler ) ) ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfoCollector.UNRECOGNIZED_TYPE_NAME ) ;
@ Override protected CompilerPass create ( final AbstractCompiler compiler ) { return new GlobalTypeInfoCollector ( compiler ) ; }
globalTypeInfo = compilerState.globalTypeInfo ;
this . globalTypeInfo = compiler.globalTypeInfo ;
return getGlobalTypeInfo () . getImplicitInterfaceUses () ;
return getGlobalTypeInfo () . getMismatches () ;
globalTypeInfo = null ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfoCollector.INVALID_PROP_OVERRIDE ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.SINGLE_FILE ) ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , CheckMissingAndExtraRequires.Mode.FULL_COMPILE ) ; }
public void testFailGoogArray () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckMissingAndExtraRequires.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckMissingAndExtraRequires ( compiler , mode ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckMissingAndExtraRequires.Mode.FULL_COMPILE ; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
assertTrue ( fBlockScope . isDeclaredInFunctionBlockOrParameter ( STRING_CONSTANT ) ) ;
if ( ! functionBlockScope . isDeclaredInFunctionBlockOrParameter ( name ) ) { return; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
public static Matcher googModuleOrProvide () { return anyOf ( googModule () , functionCall ( STRING_CONSTANT ) ) ; }
maybeProcessAccessibilityModifier ( tree , member , tree.access ) ;
maybeProcessAccessibilityModifier ( tree , n , tree.access ) ;
maybeProcessAccessibilityModifier ( functionTree , member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; enableTranspile () ; }
{ env = analyzeExprBwd ( prop , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) , STRING_CONSTANT , superType , pname ) ;
return state . getIn () . reachingDef . get ( allVarsInFn . get ( name ) ) ;
Var dep = allVarsInFn . get ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( allVarsInFn . values () ) ; }
Collection < Var > vars
return state . getOut () . mayUseMap . get ( allVarsInFn . get ( name ) ) ;
{ Pattern pattern = new Pattern () ; pattern.regExp = new RegExp ( string ) ; return pattern ; }
node = new Node < E > ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
@ Nullable E e
@ Override public void add ( @ Nullable E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( other . find ( elem ) , elem ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnused ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnused ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclared ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclared ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarning ( STRING_CONSTANT ) ; }
assertNoWarning ( STRING_CONSTANT ) ;
NodeUtil . isNameDeclaration ( parent )
@ Nullable Pattern includeFilePattern
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
{ overrideDefines ( collectDefines ( externs , root ) ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
recordPropertyName ( getProp . getLastChild () ) ;
recordPropertyName ( prop ) ;
Function < Node , Void > recordPropertyName
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
new ProcessDefines ( compiler , overrides , doReplacements ) . injectNamespace ( namespace ) . process ( externs , js ) ;
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , ! options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , true ) . collectDefines ( externs , root ) . keySet () ;
n . isName () && isDeclaration ( n )
public boolean isAsyncFunction () { return isFunction () && getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return isFunction () && getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () || key . isComputedProp () ) { continue; }
invalidatingTypes . isInvalidating ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( invalidatingTypes . isInvalidating ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( invalidatingTypes . isInvalidating ( top ) ) { invalidate () ; return; }
PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler )
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , PolymerClassDefinition.DefinitionType.ObjectLiteral , compiler ) ;
new PolymerPass ( compiler , NUMBER_CONSTANT , true ) . process ( externs , root ) ;
new PolymerPass ( compiler , NUMBER_CONSTANT , false ) . process ( externsRoot , mainRoot ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Property p = getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = getPropFromClass ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfoCollector . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfoCollector . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
return this . nominalType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
if ( nom != null ) { return nom . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
Property p = this . rawType . getOwnProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
( ns . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
isCtorDefinedByCall ( getProp )
classType . hasStaticProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
isCtorDefinedByCall ( nameNode )
final CompilerPass simplifier = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSimplifyRegExp () ) ;
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ReorderConstantExpression () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler , getName () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () ) ; }
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVariablesForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node ) ) ;
super ( isExtern , NameBasedDefinitionProvider . getSimplifiedName ( getLValue ( name ) ) ) ;
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( node . getFirstChild () ) ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns , NameBasedDefinitionProvider . getSimplifiedName ( lValue ) ) ;
Property p = this . rawType . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ;
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveNonStrayProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnNonStrayProp ( pname )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.EXCLUDE_STRAY_PROPS ) ; }
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || NodeUtil . isNameDeclaration ( n ) ; }
NodeUtil . isNameDeclaration ( parent )
NodeUtil . isNameDeclaration ( n . getParent () )
! NodeUtil . isNameDeclOrSimpleAssignLhs ( callNode , parent )
! NodeUtil . isNameDeclOrSimpleAssignLhs ( name , name . getParent () )
{ if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
if ( NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent ) ) { return; }
{ if ( nextParent == null || ! NodeUtil . isNameDeclOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
NodeUtil . isNameDeclOrSimpleAssignLhs ( n , n . getParent () )
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isNameDeclOrSimpleAssignLhs ( n , parent )
public void testEs6EnhancedObjLiteralsPropertyShorthand () { testSame ( STRING_CONSTANT ) ; }
public void testES6ClassComputedProperty () { testSame ( STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; }
final byte prop
byte propType
byte propType
byte propType
public void putBooleanProp ( byte propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
byte propType
byte propType
byte propType
public boolean getBooleanProp ( byte propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
byte propType
byte propType
byte propType
byte propType
byte propType
byte propType
@ Override public byte getType () { return propType ; }
byte propType
byte propType
Set < ? extends Var > escaped
Set < N > entrySet = new LinkedHashSet <> () ;
Set < N > nodes = new LinkedHashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( lValue ) ;
isStatementBlock ( parent ) || isSwitchCase ( node ) || node . isMemberFunctionDef ()
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . hasSize ( NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
{ validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n , NUMBER_CONSTANT ) ; validateExpression ( n . getFirstChild () ) ; }
new PeepholeReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getAllScopesInFunction () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isFalse () ;
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getPropertyNames () : this . props . keySet ()
{ otherPropNames = otherNt . getPropertyNames () ; if ( otherPropNames == null ) { return false ; } }
QualifiedName setterPname = new QualifiedName ( commonTypes . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( commonTypes . createGetterPropName ( pname ) ) ;
scopeRoots . add ( node ) ;
{ validateChildCount ( n ) ; validateLHS ( n . getToken () , n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateLHS ( n . getParent () . getToken () , n ) ; }
public void testInvalidAnnotation5 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testError ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . isHoistScope () ) { return; }
{ if ( t . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScopeRoot () ;
{ if ( n . isVar () && t . getScopeRoot () != t . getClosestHoistScopeRoot () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScopeRoot () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScopeRoot () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
yield . setYieldAll ( tree.isYieldAll ) ;
if ( n . isYieldAll () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
if ( isGlobal () || isModuleScope () ) { return null ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled , canUseEs6Syntax ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
Diagnostic warning
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithInvalidPropertyNameIdentifier ( fnNode ) ) { functionState . setInline ( false ) ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
NodeUtil . tryMergeBlock ( scopeClosureBlock , false ) ;
NodeUtil . tryMergeBlock ( callbackBlock , false ) ;
if ( NodeUtil . tryMergeBlock ( n , false ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody , true ) ;
Throwable cause
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Error | Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Throwable unexpectedException
abstract void throwInternalError ( String msg , Throwable cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! NodeUtil . isNameDeclaration ( init ) ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( NodeUtil . isNameDeclaration ( n ) && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
return this . globalScope . getInstanceType ( typeName ) ;
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredTypeForOwnBody () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredTypeForOwnBody () ;
return this . registry . evaluateTypeExpression ( expr , this . typeEnv ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
Node mapFunctionBody = NodeUtil . getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeIRegistry () ;
List < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : this ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? this : t . getReferencedType () ; }
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredTypeForOwnBody () . getThisType () ; }
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = CompilerTestCaseUtils . multistageSerializeAndDeserialize ( this , compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT , functionBody ) ; }
reportCodeChange ( STRING_CONSTANT , n ) ;
reportCodeChange ( STRING_CONSTANT , n ) ;
boolean isFull () { return numUnfilledTemplateKeys () == NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( true ) ;
public abstract Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT , defineName ) ;
compiler . addToDebugLog ( STRING_CONSTANT , var.name ) ;
compiler . addToDebugLog ( STRING_CONSTANT , name , STRING_CONSTANT , newName ) ;
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
t . getCompiler () . addToDebugLog ( STRING_CONSTANT , fn . getName () ) ;
{ return new IntPropListItem ( propType , intValue , next ) ; }
{ return new ObjectPropListItem ( propType , objectValue , next ) ; }
public void testRestParamWithoutContext () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
var . setStaticSourceFileFrom ( name ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
assertPassOrder ( checks , chromePass , checkJsDocAndEs6Modules , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
TypeParameters typeParameters
public List < String > getTypeParameters () { return this . typeParameters . asList () ; }
builder . addTypeParameters ( TypeParameters . make ( nt . getTypeParameters () ) ) ;
this . typeParameters = TypeParameters.EMPTY ;
TypeParameters typeParameters
TypeParameters typeParameters
public final boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable final PropListItem getPropListHeadForTesting () { return propListHead ; }
public final int getSourcePosition () { return sourcePosition ; }
public final int getCharno () { return extractCharno ( sourcePosition ) ; }
public final int getLineno () { return extractLineno ( sourcePosition ) ; }
public final int getLength () { return this . length ; }
public final boolean hasProps () { return propListHead != null ; }
public final boolean hasChildren () { return first != null ; }
{ validateLHS ( n . getLastChild () . getToken () , n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; enableNormalize () ; }
NodeUtil . isNameDeclaration ( parent )
public void toStringIsEqualTo ( String typeString ) { assertEquals ( typeString , actual () . toString () ) ; }
if ( n . isParamList () ) { return; }
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
n . isName () && parent . isVar ()
checkState ( e != null , STRING_CONSTANT ) ;
Typedef td = Typedef . make ( qnameNode , jsdoc . getTypedefType () ) ;
TypeI type = typeEnv . getNamespaceOrTypedefType ( name ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
packageJsonEntryNames = ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , false ) ; }
if ( this . instanceProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( instanceProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
Property p = getNonInheritedProp ( pname , propAccess ) ;
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasNonInheritedProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getNonInheritedPropertyDefSite ( propertyName ) ; }
classType . mayHaveNonInheritedProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
this . externs = makeExternInputs ( externs ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
{ for ( Var var : scriptToVarMap . removeAll ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( t , n , parent ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( compiler , serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
newEmptyClinitMethod = true ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
visitForOf ( n , parent ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
return this . globalScope . getType ( typeName ) ;
JSType t = getType ( typeName ) ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.UNKNOWN_TYPE ) ; }
{ tmpEnv = collectTypesForEscapedVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForEscapedVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getExitTypeEnv () ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET , true ) ;
handleGet ( module , scope , n , parent , name , type , true ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { reportCodeChange ( STRING_CONSTANT , n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers () ) ;
preloadEs6RuntimeFunction ( compiler , function ) ;
visitForOf ( t , n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , UNKNOWN ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString ( Nullability.IMPLICIT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString ( Nullability.EXPLICIT ) ) ;
if ( ! runOptimizeCalls ) { passes . add ( getRemoveUnusedVars ( PassNames.REMOVE_UNUSED_VARS , false ) ) ; }
checks . add ( createEmptyPass ( PassNames.BEFORE_TYPE_CHECKING ) ) ;
NodeUtil . markFunctionsDeleted ( nameNode , compiler ) ;
if ( ! n . hasOneChild () ) { return false ; }
Node statementNode = rhsNode . getGrandparent () ;
if ( ! call . hasTwoChildren () || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( ! call . hasTwoChildren () || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getGrandparent () )
NodeTraversal . traverseEs6 ( compiler , fnName . getGrandparent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName . equals ( STRING_CONSTANT ) , entryName ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
{ checkState ( this . setUpRan , STRING_CONSTANT ) ; Collections . addAll ( ignoredWarnings , warnings ) ; }
{ @ Override public boolean apply ( Node n ) { return n . matchesQualifiedName ( name ) ; } }
catch ( IllegalArgumentException expected ) { assertThat ( expected ) . hasMessageThat () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ; }
Node classNode = root . getFirstChild () . getFirstFirstChild () ;
Node fNode = root . getFirstChild () . getFirstFirstChild () ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = RENAME_FUNCTION_DEFINITION + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG ) ; }
{ testSame ( EXTERNS + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node fNode = root . getFirstFirstChild () ;
assertNull ( noInline ) ;
if ( parent . isVar () ) { parent . detach () ; reportCodeChange () ; return null ; }
{ node . detach () ; reportCodeChange () ; return null ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( CHAR_CONS ) ; }
public void testImportedNameCollision () { testSame ( STRING_CONSTANT ) ; }
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
@ Override public FeatureSet featureSet () { return ES5 ; }
{ checkArgument ( n . isTry () ) ; return n . hasXChildren ( NUMBER_CONSTANT ) ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ iterableType = iterable . getTypeI () . autobox () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
emptiedClinitMethods . add ( fnQualifiedName ) ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = renamerStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { renamerStack . pop () ; } }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( STRING_CONSTANT ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ super . setUp () ; enableNormalize () ; this . mode = TypeInferenceMode.BOTH ; }
{ super . setUp () ; allowExternsChanges () ; this . mode = TypeInferenceMode.BOTH ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.NEITHER ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; cc . endLine () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
v != null || ! isShadowingAllowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clClinitPass ) ; }
boolean shouldPrintExterns () { return this . printExterns || incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ; }
return check () . about ( types () ) . that ( actualPropType ) ;
t . inGlobalScope () && NodeUtil . isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertTrue ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
warningOtiNti ( TYPE_MISMATCH_WARNING , MISTYPED_ASSIGN_RHS )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
checkNotNull ( curNode ) ;
boolean isFunctionExpression = parent != null && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () , s ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , child.parent , this ) ;
passes . add ( createEmptyPass ( PassNames.BEFORE_MAIN_OPTIMIZATIONS ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testObjectDescructuringError2 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , ImmutableList . of ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT ) ;
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; testSame ( STRING_CONSTANT ) ; }
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( t , n ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneTree () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetter ( PROPERTY_DECLARER , functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( PROPERTY_DECLARER , superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( firstArg ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; }
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; compiler . reportChangeToEnclosingScope ( replacement ) ; return replacement ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( whileNode ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( replacementConditionNode ) ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportChangeToEnclosingScope ( parent ) ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportChangeToEnclosingScope ( switchNode ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( caseBlock ) ;
{ compiler . reportChangeToEnclosingScope ( maybeBreak ) ; maybeBreak . detach () ; }
compiler . reportChangeToEnclosingScope ( parent ) ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportChangeToEnclosingScope ( right ) ; return right ; }
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( elem ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( newStringNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( newNode ) ;
compiler . reportChangeToEnclosingScope ( replacement ) ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( subtree ) ;
if ( codeChanged ) { compiler . reportChangeToEnclosingScope ( subtree ) ; }
compiler . reportChangeToEnclosingScope ( stringNode ) ;
compiler . reportChangeToEnclosingScope ( call ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportChangeToEnclosingScope ( newLiteralNode ) ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
compiler . reportChangeToEnclosingScope ( replacement ) ;
compiler . reportChangeToEnclosingScope ( parent ) ;
compiler . reportChangeToEnclosingScope ( n ) ;
compiler . reportChangeToEnclosingScope ( parentNode ) ;
compileFiles ( STRING_CONSTANT , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.AUTO ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
checkState ( child.parent == this , STRING_CONSTANT , this , child ) ;
assertThat ( result.transformed ) . isFalse () ;
assertThat ( result.transformed ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = Transpiler . compilerSupplier () ; }
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , UTF_8 ) . write ( code ) ;
{ this . def = checkNotNull ( def ) ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars , false ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false , noStubFunctions ) ;
compilationLevelParsed = CompilationLevel . fromString ( Ascii . toUpperCase ( compilationLevel ) ) ;
if ( cacheEntry.input == null ) { cacheEntry.input = CompilerInput . makePersistentInput ( source ) ; }
boolean transformed = transformed ( result ) ;
@ Override public FeatureSet featureSet () { return FeatureSet . latest () ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
jsDoc != null && jsDoc . hasConstAnnotation () && jsDoc . getType () == null
newNode . useSourceInfoIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () , n ) ;
public boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
public boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
public boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
decl . simplify ( compiler ) ;
public void testForIn () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
NodeUtil . isEnhancedFor ( n )
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_DEFS , STRING_CONSTANT ) ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT ) ) ;
Iterable < Node > replacements
@ Override public String toString () { return appendTo ( new StringBuilder () , ToStringContext.TO_STRING ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( forAnnotations ? getNormalizedReferenceName () : getReferenceName () ) ; }
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( forAnnotations ? STRING_CONSTANT : STRING_CONSTANT ) ; }
{ checkArgument ( qnameNode . isQualifiedName () , qnameNode ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = isImportRhs ( rhs ) ;
ignoreWarnings ( NewTypeInference.INEXISTENT_PROPERTY ) ;
public void testInherits4 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInherits3 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits2 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLoggerOnObject3b () { ignoreWarnings ( NewTypeInference.GLOBAL_THIS ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
if ( checkAnnotated && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
if ( devMode ) { runValidityCheck () ; if ( hasErrors () ) { return null ; } }
maybeRunValidityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new ValidityCheck ( compiler ) ; }
if ( options.devMode == DevMode.EVERY_PASS ) { phaseOptimizer . setValidityCheck ( validityCheck ) ; }
if ( options.devMode == DevMode.START_AND_END ) { runValidityCheck () ; }
! validityCheck
{ declarationCheck = ! validityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
validityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { validityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { validityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { validityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
validityCheck = false ;
@ Override public ObjectType prototypeOrInstance () { return prototype ; }
@ Override public ObjectType instance () { return instance ; }
@ Override public FunctionType constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( rawType . getAsNominalType () ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . qmarkFunction () )
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadBaseMethodUse ( t , n , clazz . getFirstChild () . getString () , STRING_CONSTANT ) ; }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
return bindComponents.thisValue == null ? null : simpleInferExpr ( bindComponents.thisValue , this . currentScope ) ;
this . currentScope . isConstructor ()
JSType rhsType = simpleInferExpr ( rhs , this . currentScope ) ;
JSType newPropType = rhs == null ? null : simpleInferExpr ( rhs , this . currentScope ) ;
JSType recvType = simpleInferExpr ( recv , this . currentScope ) ;
JSType t = initializer == null ? null : simpleInferExpr ( initializer , this . currentScope ) ;
if ( initializer != null ) { inferredType = simpleInferExpr ( initializer , this . currentScope ) ; }
JSType t = simpleInferExpr ( prop . getFirstChild () , this . currentScope ) ;
checkState ( n . isName () || n . isImportStar () , n ) ;
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
if ( type . isEquivalentTo ( domHelperType ) ) { return true ; }
case SIMPLIFY_RHS :
void markProvided ( String providedName ) { checkNotNull ( providedName ) ; providedNamespaces . add ( providedName ) ; }
void markNameProcessed ( String fullyQualifiedName ) { checkNotNull ( fullyQualifiedName ) ; seenNames . add ( fullyQualifiedName ) ; }
{ return new ObjectLiteralPropertyDefinition ( n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
public void testDontPreserveUnknownTypeDeclarations () { testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( CLOSURE_BASE , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( isUnknown () || isUnresolved () ) { return this ; }
checkArgument ( nameNode . isQualifiedName () || nameNode . isStringKey () , nameNode ) ;
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late ) ) ;
TernaryValue result = evaluateComparison ( n . getToken () , left , right ) ;
Double rightValObj = NodeUtil . getNumberValue ( right ) ;
Double result = NodeUtil . getNumberValue ( n ) ;
new PeepholeMinimizeConditions ( late )
new PeepholeMinimizeConditions ( late )
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel ) ;
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late )
optimizations . add ( new PeepholeMinimizeConditions ( late ) ) ;
Node n = parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.STRING_CONTINUATION ) , STRING_CONSTANT + STRING_CONSTANT ) ;
replacement . setTypeI ( call . getTypeI () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , false , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , false , subSuperMap , null ) ; }
{ return isSubtypeOfHelper ( other , true , SubtypeCache . create () , null ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( false ) ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new ArrayList <> () ;
{ passes = new ArrayList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new ArrayList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypeObject () ;
return superClass == null ? null : superClass . getPrototypeObject () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypeObject () ;
checkState ( n . isCall () || n . isTaggedTemplateLit () , n ) ;
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e ) . hasMessageThat () . contains ( STRING_CONSTANT ) ; }
ref.scope . getClosestHoistScope () . isGlobal ()
ref.scope . isGlobal ()
try { compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTVAR_EXTERNS , inputs , options ) ;
Result result = compiler . compile ( testExterns , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( CHAR_CONS ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new LinkedHashMap <> () ;
Map < String , Integer > map = new HashMap <> () ;
NodeUtil . findLhsNodesInNode ( n )
NodeUtil . findLhsNodesInNode ( n )
NodeUtil . findLhsNodesInNode ( decl )
Iterable < Node > allVars = NodeUtil . findLhsNodesInNode ( n ) ;
names = NodeUtil . findLhsNodesInNode ( c ) ;
NodeUtil . findLhsNodesInNode ( paramList )
checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
NodeUtil . findLhsNodesInNode ( varNode )
{ for ( Node lhs : NodeUtil . findLhsNodesInNode ( n ) ) { declareVar ( s , lhs ) ; } }
NodeUtil . findLhsNodesInNode ( declaration )
if ( NodeUtil . findLhsNodesInNode ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
ref.scope . getClosestHoistScope () . isGlobal ()
public void testLocalAliasWithLet3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalAliasWithLet2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
List < Var > orderedVars = new ArrayList <> () ;
List < Node > arrayFoldedChildren = new ArrayList <> () ;
Deque < ScriptDescription > scriptDescriptions = new ArrayDeque <> () ;
List < Node > newVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
List < Var > orderedVars = new ArrayList <> () ;
this . orderedVars = new ArrayList <> () ;
languageIn = LanguageMode.ECMASCRIPT3 ;
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
public void testConst1 () { inFunction ( STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
rewriteDeclsToVars () ;
rewriteDeclsToVars () ;
@ Nullable Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of ( STRING_CONSTANT ) ) ;
assertTrue ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
languageIn = LanguageMode.ECMASCRIPT3 ;
return STRING_CONSTANT + fnName + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getPropType () ; }
{ type = locals . get ( name ) . getDeclaredType () ; }
{ locals . put ( name , TaggedType . makeDeclared ( newDeclType ) ) ; }
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () || n . isGetProp () , n ) ;
finder . visitTree ( root ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( CHAR_CONS , CHAR_CONS ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
NodeUtil . isNameDeclaration ( statementNode )
checkState ( declNode . isGetProp () , declNode ) ;
{ getGlobalScope () . addNamespaceLit ( new QualifiedName ( WINDOW_INSTANCE ) , qnameNode ) ; return true ; }
compilerOptions . setPreserveClosurePrimitives ( true ) ;
compilerOptions . setPreserveClosurePrimitives ( true ) ;
keyNode . isStringKey () || keyNode . isGetProp ()
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
JSType jsdocType = ( JSType ) prop . getTypeI () ;
pair.type = ( JSType ) expr . getTypeI () ;
JSType jsdocType = ( JSType ) prop . getTypeI () ;
JSType toType = ( JSType ) expr . getTypeI () ;
visitNamespacePropertyDeclaration ( getProp , QualifiedName . fromNode ( recv ) , pname ) ;
JSType propDeclType = ( JSType ) prop . getTypeI () ;
return ( JSType ) n . getTypeI () ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.TOO_MANY_TYPE_PARAMS , CheckLevel.WARNING ) ; return options ; }
js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
Node script = compiler . parseSyntheticCode ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = lines ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) }
typeCheck ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
String localVar = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testReference ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
t . inGlobalHoistScope () && NodeUtil . isFunctionDeclaration ( n )
Preconditions . checkState ( ! isFunctionDeclaration ( n ) ) ;
return checkForNewObjects || isFunctionDeclaration ( n ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { return true ; }
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleType = ModuleType.ES6 ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new ProcessCommonJSModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { return; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers ) ; }
processInherits ( findStaticMembers ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String src = CompilerTestCase . lines ( lines ) ;
String src = CompilerTestCase . lines ( lines ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! fn . isFromExterns () ) { GlobalTypeInfoCollector . this . scopes . add ( fnScope ) ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
useSourceInfoForNewQName ( node , basisNode ) ;
{ return assertAbout ( JSErrorSubject : : new ) . that ( error ) ; }
{ return assertAbout ( NodeSubject : : new ) . that ( node ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , transpiledFeatures , findStaticMembers ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
TranspilationPasses . processTranspile ( compiler , externs , transpiledFeatures , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , features , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , features , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , checkedFeatures , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , checkedFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; }
{ if ( allowMethodCallDecomposing ) { return DecompositionType.DECOMPOSABLE ; } else { return DecompositionType.UNDECOMPOSABLE ; } }
checkState ( allowMethodCallDecomposing , STRING_CONSTANT ) ;
Node name = NodeUtil . newQName ( compiler , PROTOTYPE_ALIAS + STRING_CONSTANT + declar.memberName , declar.node , declar.memberName ) ;
Node var = NodeUtil . newVarNode ( PROTOTYPE_ALIAS , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
isAssignmentOp ( declNode )
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () || nt . isIObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || ( unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ) ; }
resultPair = analyzeCastFwd ( expr , inEnv ) ;
Name superclassNameObj = getOrCreateName ( superclassName , true ) ;
void verify ( Compiler compiler ) ;
currentArgumentsAccess = new ArrayList <> () ;
List < MemberDefinition > allProperties = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < SourceFile > files = new ArrayList <> () ;
List < String > entryPoints = new ArrayList <> () ;
cur = instance.declarations . get ( instance.declarations . size () - NUMBER_CONSTANT ) . node ;
PrototypeMemberDeclaration first = instance.declarations . get ( NUMBER_CONSTANT ) ;
if ( lValue . isRest () ) { lValue = lValue . getOnlyChild () ; }
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( var ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = traverseVar ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = traverseVar ( classVar ) ;
checkState ( isCallOrNew ( invocation ) , invocation ) ;
@ Nullable Scope scope
checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
checkState ( current . isLabel () , current ) ;
checkState ( isControlStructure ( parent ) , parent ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkState ( n . isClassMembers () || n . isObjectLit () , n ) ;
checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + ref ) ; }
throw new IllegalStateException ( STRING_CONSTANT + expr ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) , n ) ;
boolean isMarkedConst = n . getParent () . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new ArrayDeque <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . addFirst ( n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
assertNoPureCalls ( source ) ;
@ Nullable Var v
@ Nullable Node definitionRValue
isStaticCtorProp ( getProp )
@ Nullable JSModule module
@ Nullable JSModule module
NameBasedDefinitionProvider definitionProvider
if ( defs . isEmpty () ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return ImmutableMultimap . copyOf ( useSitesByName ) ; }
{ if ( inExterns ) { visitExterns ( traversal , node ) ; } else { visitCode ( traversal , node ) ; } }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames , false ) . process ( externs , root ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
{ visitScript ( t , n ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , ModuleLoader.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () , fnNode ) ;
LinkedHashMap < String , Node > actualMap = getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT , name ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new ArrayDeque <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < blockScope . getVarCount () + functionScope . getVarCount () ) { return; }
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
exceptionVarInfo . setIsExplicitlyNotRemovable () ;
canonicalTotallyUnremovableVarInfo . setIsExplicitlyNotRemovable () ;
ImmutableSet < String > namesToAlias
ImmutableSet < String > needAliases
ImmutableMap < String , Node > argMap
return LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! NodeUtil . isNameDeclaration ( n ) ) { return; }
NodeUtil . isNameDeclaration ( parent ) && nameNode . hasOneChild ()
NodeUtil . isNameDeclaration ( parent )
removeUnusedProperties && r . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isPrototypeObjectNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . doesFunctionReferenceOwnArgumentsObject ( rValue ) ) { return false ; }
if ( NodeUtil . doesFunctionReferenceOwnArgumentsObject ( fnc ) ) { return false ; }
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
funType . isSomeConstructorOrInterface ()
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.ROOT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; knownConstants . clear () ; }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
public void testES6Modules () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testNoWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
options . setErrorHandler ( new BlackHoleErrorManager () ) ;
String classAndItsMethodAliasedAsExtern = lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String getPropertyName () { return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT + toRemove . toStringTree () ) ; }
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
assertTrue ( options . shouldCollapseProperties () ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldCollapseProperties () ; }
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
return ! NodeUtil . isNameDeclaration ( n . getFirstChild () ) ;
public void testNoGlobalScopeChanges () { testSame ( STRING_CONSTANT ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , options.removeUnusedPrototypeProperties ) ;
( getTypeDeprecationInfo ( getTypeOfThis ( scopeRoot ) ) != null )
Var var
Var var
@ Override boolean isClassOrPrototypeNamedProperty () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
boolean isClassOrPrototypeNamedProperty () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedPrototypeProperties
removeUnusedPrototypeProperties && removable . isNamedProperty ()
if ( removeUnusedPrototypeProperties ) { removeUnreferencedProperties () ; }
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCodeOnce () ) ; } }
new RemoveUnusedCode.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalClassFunctionDeclarationsToVarAssignmentsCallback () ) ;
SimpleDependencyInfo . builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER || mode == Mode.ES_NEXT ;
ImmutableList < String > getWeakRequires ( ) ;
ImmutableList < String > getRequires ( ) ;
ImmutableList < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testDefaultParam_argIsUndefined () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( n , parent ) ;
Annotation annotation = annotations . get ( annotationName ) ;
config . languageMode () != LanguageMode.TYPESCRIPT
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config . languageMode () == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config . runMode () == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler , options . getPropertyCollapseLevel () ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
if ( p != null && ! canCollapse ( p ) ) { continue; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
if ( ! canCollapseChildNames || ! canCollapse ( n ) ) { return; }
isObjLit && canEliminate ( n )
isObjLit && canEliminate ( n )
if ( canCollapse ( n ) ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
new CollapseProperties ( compiler , PropertyCollapseLevel.ALL ) . process ( externs , js ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler , propertyCollapseLevel ) ; }
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ;
collapsePropertiesLevel = PropertyCollapseLevel.NONE ;
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) { return true ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ options . setCollapsePropertiesLevel ( value ? PropertyCollapseLevel.ALL : PropertyCollapseLevel.NONE ) ; }
for ( String filename : files ) { if ( fix ) { fixRepeatedly ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( removeUnusedCodeOnce ) ;
String qualifiedName = getAliasedNamespace ( aliasVar . getInitialValue () ) ;
String aliasExpanded = checkNotNull ( getAliasedNamespace ( aliasDefinition ) ) ;
this . inliningReach = Reach.LOCAL_ONLY ;
public void testLocalFunctionInliningOnly4 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . inliningReach = Reach.LOCAL_ONLY ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
inliningReach = Reach.ALL ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
public boolean includesGlobals () { return this == ALL ; }
logger . finest ( STRING_CONSTANT + file . getName () ) ;
checkArgument ( NodeUtil . isAssignmentOp ( assignNode ) , assignNode ) ;
Node superClassNameNode = metadata.superClassNameNode . cloneTree () ;
VarInfo varInfo = traverseNameNode ( classNameNode , classScope ) ;
VarInfo varInfo = traverseNameNode ( classNameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo varInfo = traverseNameNode ( nameNode , scope ) ;
VarInfo exceptionVarInfo = traverseNameNode ( exceptionNameNode , scope ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT ) ; }
rhs == null || PotentialDeclaration . isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
getAllSymbols ()
public Iterable < Symbol > getAllSymbols () { return ImmutableList . copyOf ( symbols . values () ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
getAllSymbols ()
getAllSymbols ()
if ( key . isShorthandProperty () ) { maybeWarn = true ; }
if ( node . isStringKey () && node . isShorthandProperty () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( parent . isObjectPattern () ) { return ! n . isStringKey () ; }
{ validateEnumStringKey ( c ) ; }
passes . add ( extraSmartNamePass ) ;
options . setInlineFunctions ( Reach.NONE ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
options . setInlineFunctions ( Reach.ALL ) ;
{ this . setInlineFunctions ( inlineFunctions ? Reach.ALL : Reach.NONE ) ; }
allSymbols . addAll ( table . getAllSymbols () ) ;
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; }
if ( isClassMethod ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
isClassMethod ( functionNode )
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordNameDeclaration ( name , t . getScope () ) ; } }
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
if ( ClassUtil . isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && ClassUtil . isThisProp ( nameNode )
if ( ClassUtil . isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! ClassUtil . isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method . type () ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( ClassUtil . isClassMethod ( functionNode ) ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isDotPrototype ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodeCount () ;
checkState ( n . isName () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
if ( NodeUtil . isLValue ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeDotPropertyReference () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisDotPropertyReference ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisDotPropertyReference ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . disallowInlining () ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar . isGlobal () ; }
Node name = importSpec . getSecondChild () ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedStaticProperties = value ; return this ; }
this . removeUnusedStaticProperties = builder.removeUnusedStaticProperties ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Scope s = getAbstractScope () ;
refinedScope != null && getAbstractScope () != refinedScope
checkArgument ( ! name . isEmpty () ) ;
String name = ClassUtil . getFullyQualifiedNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getRemovableNode () , compiler ) ;
Node oldStatement = getRemovableNode () ;
Node getRemovableNode () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { checkNotNull ( referencedObjType ) ; return referencedObjType . hasReferenceName () ; }
passes . add ( removeUnusedCodeOnce ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceNodeWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( ARGUMENTS , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
{ ( ( Scope ) scope ) . declare ( name , n , input ) ; }
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
AbstractScope < , > s
private void pushScope ( AbstractScope < , > s ) { pushScope ( s , false ) ; }
AbstractScope < , > refinedScope
AbstractScope < , > scope
AbstractScope < , > s
Scope hoistedScope = t . getClosestHoistScope () . untyped () ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Es6SyntacticScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , getVarCount () , input ) ;
AbstractScope < , > parent
Es6SyntacticScopeCreator scopeCreator = createScopeCreator () ;
AbstractScope < , > parent
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ return new FeatureSet ( union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( EnumSet < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( Var.ARGUMENTS ) )
if ( Var.ARGUMENTS . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
public final S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return getParent () . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
optimizations . add ( new MinimizeExitPoints () ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , ( String ) null ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
assertChanges ( externs , originalCode , template , expectedCode ) ;
assertChanges ( STRING_CONSTANT , originalCode , template , expectedCode ) ;
public void clearTemplates () { templates = null ; matchedTemplates = null ; }
checkNotNull ( funType , STRING_CONSTANT , recvType , setterPname ) ;
if ( isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , inputPathByWebpackId ) ;
options . setModuleResolutionMode ( resolutionMode ) ;
public JsonFileSpec ( String src , String path ) { this ( src , path , null , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.hasNonLocalOrNonLiteralValue = true ; }
catch ( RuntimeException e ) { throw new AssertionError ( STRING_CONSTANT , e ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalValueOrPrototype () { return true ; }
foldSame ( STRING_CONSTANT ) ;
public void testNewOperator3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperator1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return JSType . getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () , n ) ;
Node newDeclaration = NodeUtil . newDeclaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
Map < String , TypeI > props = new LinkedHashMap <> () ;
checkState ( mayBeStatement ( stmt ) , STRING_CONSTANT , stmt . getToken () ) ;
NameDeclarationStatement removable = builder . buildNameDeclarationStatement ( declarationStatement ) ;
( NodeUtil . isEnhancedFor ( parent ) )
if ( grandparent != null && NodeUtil . isNameDeclaration ( grandparent ) ) { return false ; }
public void testLoggerMethodCallByVariableType_var () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
ParseTree right = parseExponentiationExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRICT_INEXISTENT_PROPERTY ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () , e . getMessage () ) ) ; return SimpleDependencyInfo.EMPTY ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () , e . getMessage () ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( compiler , referenceNode , v . getNameNode () ) ;
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
return fnThisType == null ? null : fnThisType . toObjectType () ;
IR . string ( t . getInput () . getName () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckSuper ( compiler ) ; }
checks . add ( checkSuper ) ;
passes . add ( checkSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , rvalue ) ; }
visitGetProp ( t , n ) ;
checkArgument ( scriptNode . isScript () , scriptNode ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , isLoopOrFunction ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , true ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_CHECK_TYPES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
@ Deprecated boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = checkNotNull ( functionContext.function ) ;
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( name , decl ) ; } }
if ( getRhs () == null || shouldPreserve () ) { return; }
if ( ! PotentialDeclaration . isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = PotentialDeclaration . isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! PotentialDeclaration . isImportRhs ( lhsToSplit . getLastChild () )
PotentialDeclaration . isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
jsdoc == null || ! jsdoc . containsDeclaration () || isConstToBeInferred ( jsdoc , jsdocNode )
checkState ( caseBody . isNormalBlock () , caseBody ) ;
checkState ( first . getString () . isEmpty () , first ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ; }
testSame ( externs ( CompilerTypeTestCase.DEFAULT_EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( SHARED_EXTERNS ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( METHOD_DEFS ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
{ testSame ( externs ( externs ) , srcs ( source ) ) ; assertEquals ( expected , found ) ; found . clear () ; }
tester . testSame ( externs ( STRING_CONSTANT ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( ALL_NATIVE_EXTERN_TYPES ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( STRING_CONSTANT ) ) ;
testSame ( externs ( externs ) , srcs ( js ) ) ;
testSame ( externs ( externs ) , srcs ( code ) ) ;
testSame ( externs ( EXTERNS ) , srcs ( STRING_CONSTANT ) ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( js ) ; }
testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new HashMap <> () ;
NodeUtil . isNameDeclaration ( parent )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
addExpr ( first . getNext () , NUMBER_CONSTANT , Context.OTHER ) ;
public void testFindExpressionRoot5 () { assertNode ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . hasType ( Token.FOR ) ; }
{ return parent . getParent () ; }
{ return ! isReasonableObjectPropertyKey ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_STRING ) , null , null ) ; }
this . allBitwisableValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
public abstract Builder setRequires ( Collection < Require > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
rootInput . getRequiredSymbols ()
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; }
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS ) . withMessage ( STRING_CONSTANT )
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING ) . withMessage ( warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING ) . withMessage ( warningText ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR ) . withMessage ( message ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning ) . withMessage ( description ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e ) . withMessage ( STRING_CONSTANT + STRING_CONSTANT ) ) ;
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error ) . withMessage ( description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error ) . withMessage ( description ) ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING ) . withMessage ( warning ) ) ;
public abstract Builder setRequires ( Collection < String > requires ) ;
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
rootInput . getRequires ()
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
userOrderedInput . getRequires ()
input . getRequires ()
{ input . addOrderedRequire ( require ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks , preprocessorSymbolTableFactory ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes , preprocessorSymbolTableFactory ) ; }
n . putBooleanProp ( Node.MODULE_ALIAS , true ) ;
TranspilationPasses . addEs6ModulePass ( factories , new PreprocessorSymbolTable.CachedInstanceFactory () ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
noInline ( STRING_CONSTANT ) ;
noInline ( STRING_CONSTANT ) ;
for ( TemplateType unused : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.LANGUAGE_FEATURE ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT ) ) ;
if ( node . hasTwoChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
TypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
scopeCreator = new TypedScopeCreator ( compiler ) ;
TypedScopeCreator scopeCreator
TypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
TypedScopeCreator scopeCreator
public abstract Builder setRequires ( Collection < Require > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
rootInput . getRequiredSymbols ()
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives ; }
noInline ( STRING_CONSTANT ) ;
public void testNoInlineGetElem () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp1 () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { throw new UnsupportedOperationException () ; }
final Scope usageScope
List < String > provides = new ArrayList <> ( depInfo . getProvides () ) ;
this . nullOrUndefined = typeRegistry . getNativeType ( JSTypeNative.NULL_VOID ) ;
{ return testForEquality ( that ) . equals ( TernaryValue.UNKNOWN ) ; }
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableStrictMissingPropertyChecks () ;
disableStrictMissingPropertyChecks () ;
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
disableStrictMissingPropertyChecks () ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , false , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , true , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs2018Message ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES2018 ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return isValidAliasRhs ( rhs ) ;
if ( this . isNoOp () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet <> () : new HashSet <> ( info . getParameterNames () )
JSType type = typeRegistry . getGlobalType ( dottedName ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
{ return metadata . getCompiler () . getTypeRegistry () . getGlobalType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ return registry . getGlobalType ( typeName ) ; }
domHelperType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getGlobalType ( r.type ) ;
TypeI typeWithBannedProp = registry . getGlobalType ( prop.type ) ;
{ TypeI type = registry . getGlobalType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
TypeI methodClassType = registry . getGlobalType ( className ) ;
final Scope scope = t . getScope () ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
Predicates . alwaysTrue ()
ImmutableList.Builder < Callback > callbacks = ImmutableList . builder () ;
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
Streams . stream ( fixChoices ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
Streams . stream ( fixChoices ) . map ( f - > f . getAlternatives () . size () )
newVar = declare ( scopeToDeclareIn , variableName , n , type , input , inferred ) ;
if ( isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( config.parseTypeSyntax , errorReporter , commentRecorder , source , offset ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6TypedFullError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkState ( nameNode . isName () , nameNode ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase . createCaseNode () ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock ) ; it . remove () ; continue; }
this . context = new TranspilationContext () ;
ImmutableSortedSet . copyOf ( comparingByKey () , map . entrySet () )
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , DependencyInfo : : getName ) , pathResolver ) , moduleRootPaths ) ;
{ this . cache = builder . build ( CacheLoader . from ( delegate : : transform ) ) ; }
{ return this : : transform ; }
{ return function : : apply ; }
Predicates . alwaysTrue ()
return NodeUtil . has ( node , pred , Predicates . alwaysTrue () ) ;
{ this ( compiler , behavior , creator , Predicates . alwaysTrue () ) ; }
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . alwaysTrue () ) ;
return result == null ? ImmutableList . of () : ImmutableList . of ( result ) ;
if ( customPasses == null ) { customPasses = LinkedHashMultimap . create () ; }
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . alwaysTrue () ) ; }
{ maybeAddUsage ( t , n , typeNode , false , Predicates . alwaysTrue () ) ; }
Predicates . alwaysTrue ()
{ return eval ( ttlAst , typeVars , ImmutableMap . of () ) ; }
List < Ref > getRefs () { return refs == null ? ImmutableList . of () : refs ; }
{ return chars == null ? ImmutableSet . of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . emptySet ()
return invocation . hasOneChild () ? ImmutableList . of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . alwaysTrue () ) ; }
Predicates . alwaysTrue ()
Arrays . sort ( arr , Ordering . natural () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs ) ; }
ImmutableSet . of ()
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . create () ;
return new JSTypeExpression ( typeNode , VIRTUAL_FILE ) ;
JSType type = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ;
TypeI type = registry . getGlobalType ( target . getFirstFirstChild () . getQualifiedName () ) ;
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverriddenNativeProperty ( STRING_CONSTANT ) ; }
TypeI type = compiler . getTypeIRegistry () . getGlobalType ( typeName ) ;
public void testMissingProperty33 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { disableStrictMissingPropertyChecks () ; testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , VIRTUAL_FILE ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
return ( nameNode . hasChildren () || isLhsOfEnhancedForExpression ( nameNode ) ) ;
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos ) ; } }
if ( node . isQuotedString () || ! node . hasChildren () ) { return; }
declList . sort ( DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; redeclareSimpleVar ( informed , item , newType ) ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
abstract JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) ;
ErrorReporter reporter
@ Override JSType resolveInternal ( ErrorReporter reporter , StaticTypedScope < JSType > scope ) { return this ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler , STRING_CONSTANT ) ; }
private String transpileEs6Module ( String s ) { return transpile ( s , es6ModuleTranspiler ) ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtypeOf ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtypeOf ( alternate ) ) { return this ; }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtypeOf ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
{ return type . isSubtypeOf ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
{ JSType arrayType = getNativeType ( ARRAY_TYPE ) ; return arrayType . isSubtypeOf ( type ) ? arrayType : null ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtypeOf ( ctorType ) ? null : type ; }
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtypeOf ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtypeOf ( getNativeType ( STRING_TYPE ) ) ) ;
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtypeOf ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
assertTrue ( unknown . isSubtypeOf ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtypeOf ( nullOrUnknown ) ) ;
! argType . isSubtypeOf ( paramType )
! rightType . isSubtypeOf ( leftType )
! leftType . isNoType () && ! rightType . isSubtypeOf ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtypeOf ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtypeOf ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtypeOf ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtypeOf ( allBitwisableValueTypes )
! type . isSubtypeOf ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtypeOf ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtypeOf ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtypeOf ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtypeOf ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtypeOf ( that ) || that . isSubtypeOf ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtypeOf ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtypeOf ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtypeOf ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
if ( that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
! type . isSubtypeOf ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtypeOf ( type ) ) ;
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtypeOf ( type )
argObjectType . isSubtypeOf ( referencedParamType )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtypeOf ( providedJsType )
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtypeOf ( returnType ) ; }
if ( that . isUnknownType () || that . isSubtypeOf ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtypeOf ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
@ Override public boolean isSubtype ( JSType that ) { return this . isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
return thisType . isSubtypeOf ( thatType ) || thatType . isSubtypeOf ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtypeOf ( functionType ) || functionType . isSubtype ( thisType ) ; } }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , decl ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { new AstValidator ( compiler ) . setTypeValidationEnabled ( typeInfoValidationEnabled ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , export ) ) ;
exportedNameToLocalQName . put ( name , new LocalQName ( name , lhs ) ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , new LocalQName ( name , export ) ) ;
Map.Entry < String , LocalQName > entry
functionNames = compilerState.functionNames ;
this . functionNames = compiler.functionNames ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( moduleScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( blockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( forOfScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionScope ) . declares ( STRING_CONSTANT ) . directly () ;
assertScope ( functionBlockScope ) . declares ( STRING_CONSTANT ) . directly () ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessageThat () . isEqualTo ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingNode ( n . getParent () , NodeUtil : : isValidCfgRoot ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , scopeCreator , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , currentScope ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
TypedVar var = currentScope . getVar ( qName ) ;
TypedVar var = currentScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( currentScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer () ) ; }
registry . createNullableType ( registry . getGlobalType ( STRING_CONSTANT ) )
{ super ( null , registry , reference , sourceName , lineno , charno ) ; }
unresolvedNamedTypes . removeAll ( scope ) ;
public void clearNamedTypes () { unresolvedNamedTypes . clear () ; }
{ checkTypeName ( name ) ; namesToTypes . put ( name , type ) ; }
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( null , STRING_CONSTANT ) ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( EMPTY_SCOPE , STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
! newType . isEquivalentTo ( varType , true )
{ assertTypeEquals ( expected , resolve ( actual ) ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW , EqCache . create () ) ; }
{ if ( constructorI . isEquivalentTo ( constructorJ ) ) { shouldCheck = false ; } }
{ this ( Functions . identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( SYNTHETIC_CODE_PREFIX + resourceName + STRING_CONSTANT , originalCode ) ;
if ( ! scope . hasSlot ( NodeUtil.JSC_PROPERTY_NAME_FN ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
if ( scope . hasOwnSlot ( qName ) ) { continue; }
! scope . hasOwnSlot ( qName ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . hasSlot ( name ) ) { return true ; }
if ( t . getScope () . hasSlot ( alias ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
n . isName () && ! t . getScope () . hasSlot ( n . getString () )
if ( current . hasOwnSlot ( oldName ) ) { return; } else { current = current . getParent () ; }
assertScope ( fooScope ) . declares ( STRING_CONSTANT ) . directly () ;
if ( ! getRootNode () . isFunction () ) { return getClosestContainerScope () . getTypeOfThis () ; }
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestContainerScope () == containerScope ;
this . containerScope = syntacticScope ;
while ( t . getScope () . hasSlot ( pseudoName ) ) { pseudoName += STRING_CONSTANT ; }
varsInFunctionBody . contains ( refName ) && ! scope . hasSlot ( refName )
curScope . hasSlot ( assignment.oldName )
AbstractVar < , > var = getVar ( name ) ;
AbstractVar < , > var = getVar ( name ) ;
if ( isUnflowable ( getDeclaredVar ( scope , varName ) ) ) { return; }
isLocallyInferred = ( var != getDeclaredVar ( scope , qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct , scope ) ;
backwardsInferenceFromCallSite ( n , fnType , scope ) ;
TypedVar var = getDeclaredVar ( scope , qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( getDeclaredVar ( scope , varName ) ) ;
{ type = info . getType () . evaluate ( scope . getDeclarationScope () , registry ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = currentScope . getVar ( fnName ) ;
Node rootNode = currentHoistScope . getClosestContainerScope () . getRootNode () ;
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( currentScope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = currentScope . getVar ( slotName ) ;
TypedVar slot = currentScope . getVar ( name ) ;
{ return rValueInfo . getType () . evaluate ( currentScope , typeRegistry ) ; }
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info , isLValueRootedInGlobalScope ( lValue ) ) ; }
return isLValueRootedInGlobalScope ( lValue ) || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == currentScope . getRootNode ()
if ( this . cache . functionScope != that.cache.functionScope ) { return false ; }
return slot != null ? slot : syntacticScope . getSlot ( var . getName () ) ;
{ return getSlot ( getVarFromSyntacticScope ( name ) ) ; }
ScopedName var = getVarFromSyntacticScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) , scope ) ; }
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . writeInvalidationsInto ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingScopeRoot ( n ) ;
AbstractScope ( Node rootNode ) { this . rootNode = checkNotNull ( rootNode ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
SymbolTable table = createSymbolTable ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value , false ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_IN_NON_MODULE ) ) ; } }
NodeUtil . isNameDeclaration ( n )
if ( NodeUtil . isNameDeclaration ( n ) ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! NodeUtil . isNameDeclaration ( child ) && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && NodeUtil . isNameDeclaration ( parent )
Node node = withType ( IR . number ( id ) , numberType ) . useSourceInfoFrom ( sourceNode ) ;
sourceNode . replaceWith ( createBreakNodeFor ( sourceNode ) ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , createBreakNodeFor ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( createBreakNodeFor ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == actual ()
{ checkState ( scope != actual () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = checkNotNull ( var ) ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( actual () . getAllAccessibleVariables () ) ;
if ( NodeUtil . isNameDeclaration ( replace ) ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
NodeUtil . isNameDeclaration ( ref . getParent () )
NodeUtil . isNameDeclaration ( parent )
if ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isNew () ) { return; }
{ return ( NodeUtil . isNameDeclaration ( n ) || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
checkArgument ( returnNode . isReturn () , returnNode ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return contents . charAt ( index ++ ) ; }
String value = this . contents . substring ( startOffset , index ) ;
{ NodeTraversal . traverse ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , collector ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , extractionInfo ) ;
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverse ( compiler , root , new Callback () ) ; }
{ NodeTraversal . traverse ( compiler , externs , this ) ; addWindowProperties () ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , body , updater ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverse ( compiler , root , new Traversal () ) ; }
NodeTraversal . traverse ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverseRoots ( compiler , renamer , externs , root ) ;
{ NodeTraversal . traverse ( compiler , checkNotNull ( root ) , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverse ( compiler , singleRoot , callback ) ; }
do { codeChanged = false ; NodeTraversal . traverse ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverse ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
NodeTraversal . traverse ( compiler , root , finder ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , scriptRoot , finder ) ;
NodeTraversal . traverse ( compiler , block , new UnmarkedNodeTranspiler () ) ;
{ YieldFinder yieldFinder = new YieldFinder () ; NodeTraversal . traverse ( compiler , n , yieldFinder ) ; return yieldFinder . getYieldNode () ; }
NodeTraversal . traverse ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverse ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverse ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
NodeTraversal . traverseRoots ( compiler , pass , externs , root ) ;
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , this ) ;
{ NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ; }
{ NodeTraversal . traverse ( compiler , js , this ) ; }
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverse ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverse ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , superSet . getLastChild () , this ) ;
{ NodeTraversal . traverse ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverse ( compiler , scriptRoot , callback ) ; }
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , n , gatherCb ) ;
NodeTraversal . traverse ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverse ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
NodeTraversal . traverse ( compiler , scriptRoot , this ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverse ( compiler , root , constFinder ) ; }
NodeTraversal . traverse ( this , n , sia ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverse ( compiler , tree , test ) ;
NodeTraversal . traverse ( compiler , tree , test ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , root , new Callback () ) ;
NodeTraversal . traverse ( compiler , root , traversal ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , externs , externsCallback ) ;
NodeTraversal . traverse ( compiler , originalRoot , cb ) ;
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new GatherCollapses () ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverseScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
NodeTraversal . traverse ( compiler , script , test ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverse ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverse ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
NodeTraversal . traverse ( compiler , root , new Strip () ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverse ( compiler , root , this ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverse ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverse ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , script , this ) ;
NodeTraversal . traverse ( compiler , googRoot , this ) ;
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverse ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; } }
NodeTraversal . traverse ( compiler , tree , cb ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverseRoots ( compiler , this , externs , root ) ;
NodeTraversal . traverse ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , new ProcessVars () ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverse ( compiler , source , new UseSiteGatheringCallback () ) ; }
NodeTraversal . traverse ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ requiresLineNumbers = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverse ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverse ( compiler , enclosingFunction , checkAssigns ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , findExportableNodes ) ;
NodeTraversal . traverse ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverse ( compiler , root , pass ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , pass ) ;
NodeTraversal . traverse ( compiler , body , traversal ) ;
NodeTraversal . traverse ( compiler , root , getterSetterCollector ) ;
NodeTraversal . traverse ( compiler , body , this ) ;
NodeTraversal . traverseScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
{ requiresTypes = false ; NodeTraversal . traverse ( compiler , root , this ) ; }
NodeTraversal . traverse ( compiler , root , this ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRoots ( compiler , this , externs , root ) ; }
NodeTraversal . traverse ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverseScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverse ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverse ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
{ NodeTraversal . traverse ( compiler , root , this ) ; }
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverse ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverse ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverse ( compiler , root , suppressBehaviorsCallback ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value ) ;
NodeTraversal . traverse ( compiler , script , cb ) ;
NodeTraversal . traverse ( compiler , rootNode , callback ) ;
NodeTraversal . traverse ( metadata . getCompiler () , script , callback ) ;
assertType ( x . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( bar . getType () ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
assertType ( f . getPropertyType ( STRING_CONSTANT ) ) . toStringIsEqualTo ( STRING_CONSTANT ) ;
if ( NodeUtil . isNameDeclaration ( item ) ) { item = item . getFirstChild () ; }
{ checkArgument ( parent . isFunction () || NodeUtil . isNameDeclaration ( parent ) || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
NodeTraversal . traverse ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( STRING_CONSTANT , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( STRING_CONSTANT , js ) ; }
{ testTypesWithExterns ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypesWithExterns ( externs , js , ( String ) null , false ) ; }
{ testTypesWithExterns ( STRING_CONSTANT , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( DEFAULT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypesWithCommonExterns ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypesWithCommonExterns ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( getNativeNumberType () ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( getNativeNullType () ) ; return n ; }
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
public void testTransformationWithUnionInMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( getNativeUnknownType () , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( getNativeUnknownType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( getNativeStringType () , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
assertTypeEquals ( type , getNativeObjectType () ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeErrorType () , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( getNativeNumberType () , type ) ;
assertTypeEquals ( STRING_CONSTANT , getNativeNumberType () , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( getNativeRegexpConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( getNativeDateConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( getNativeArrayConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( getNativeObjectConstructorType () , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( getNativeVoidType () , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( getNativeArrayType () , a . getType () ) ;
assertTypeEquals ( getNativeVoidType () , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( getNativeBooleanType () , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( getNativeBooleanType () , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( getNativeStringType () , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( getNativeNumberType () , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( getNativeNumberType () , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
JSDocInfo jsDoc = NodeUtil . isNameDeclaration ( node . getParent () ) ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
shouldAddTypes ? contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + ESCAPER . escape ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
options . setPreserveClosurePrimitives ( true ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( scope . getDeclarationScope () , qualifiedName ) ) ;
JSType windowType = getTypeInternal ( null , STRING_CONSTANT ) ;
private void registerGlobalType ( JSType type ) { register ( null , type , type . toString () ) ; }
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; scopedNameTable . clear () ; initializeRegistry () ; }
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getGlobalType ( STRING_CONSTANT ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType type = registry . getType ( resolutionScope , reference ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
NodeUtil . isLoopStructure ( scopeRoot )
actualYieldType = actualYieldType . autobox () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.OTI_ONLY ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
warning ( TYPE_MISMATCH_WARNING )
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.DISABLED ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.CHECKED ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warning ( TypeValidator.TYPE_MISMATCH_WARNING ) )
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warning ( TOO_MANY_TEMPLATE_PARAMS ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter ) ; }
activeXObject . resolve ( null ) ;
namedA . resolve ( null ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter ) ; } }
a . resolve ( null ) ;
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve () ; }
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
public void testAbstractClass () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
disableTypeCheck () ;
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ disableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node parse ( String js ) { return parse ( js , false ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { disableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; disableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; enableTranspile () ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
public void testClassWithEmptyMembers () { disableTypeCheck () ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { disableTypeCheck () ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
public void testArguments6 () { disableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { disableTypeCheck () ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; disableTypeCheck () ; }
public void disable_testClassMethodUnused2 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { disableTypeCheck () ; unused ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
disableTypeCheck () ;
disableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ disableTypeCheck () ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
new CodePrinter.Builder ( parse ( js , true ) )
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
public void testCoercionSubstitution_expression () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
public void testCoercionSubstitution_booleanResult0 () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; enableTypeCheck () ; }
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
public boolean isTypecheckingEnabled () { return this . checkTypes ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
return getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
ignoreWarnings ( TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , TypeValidator.TYPE_MISMATCH_WARNING ) ;
validator . expectCanAssignTo ( t , loopVarNode , actualType , declaredType , STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
hoistNode ( varStatement ) ;
hoistNode ( n ) ;
if ( NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isSomeCompileTimeConstStringValue ( ast ) ; }
{ if ( ! isSafeValue ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
if ( prop != null ) { if ( NodeUtil . isSomeCompileTimeConstStringValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isSomeCompileTimeConstStringValue ( propAccess . getNext () ) )
String lastPart = typeString . substring ( typeString . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( CHAR_CONS ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
URI path
URI path
URI path
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
List < ? extends LocationMapping > sourceMapLocationMappings
URI path
URI path
{ switch ( n . getToken () ) { case FOR_OF : visitForOf ( n , parent ) ; break; default: break; } }
this . registry = compiler . getTypeRegistry () ;
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeRegistry () ) . build () . trim ()
JSType type = fnNode . getJSType () ;
JSType type = n . getJSType () ;
public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
JSType type = srcObj . getJSType () ;
JSType attrsType = attrs . getJSType () ;
JSType type = srcObj . getJSType () ;
ObjectType targetType = target . getJSType () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getJSType () . toString () ;
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
{ return n . getJSType () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
JSType thrown = n . getFirstChild () . getJSType () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionType restrictedCallType
FunctionType restrictedCallType
FunctionType functionType
JSType type = n . getJSType () ;
{ return isAssertionCall ( n . getParent () ) || n . getJSTypeBeforeCast () != null ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ JSType type = n . getJSType () ; return ( type == null || type . isUnknownType () ) ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
n . setJSType ( type ) ;
FunctionType getterType
JSTypeRegistry typeRegistry
public TypeSubject ( FailureMetadata failureMetadata , JSType type ) { super ( failureMetadata , type ) ; }
JSType type
FunctionType getterType
builder . setTypeRegistry ( getTypeRegistry () ) ;
StaticTypedScope < ? extends JSType > scope
private String formatTypeVar ( JSType var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
JSTypeRegistry registry
JSType typeI = getPropLhs . getJSType () ;
if ( n . getJSType () == null ) { throw new IllegalStateException ( STRING_CONSTANT + n + STRING_CONSTANT + STRING_CONSTANT ) ; }
Builder ( JSTypeRegistry registry ) { this . registry = registry ; }
ObjectType objectType
@ Nullable ObjectType referenceType
JSType type = name . getJSType () ;
JSTypeRegistry typeRegistry
JSType type
public JSType getReturnType () { return call.returnType ; }
JSType type
JSType type
JSType type
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
JSTypeRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionType getterType ) ;
Node assign = withType ( IR . assign ( copiedVarName , varName . removeFirstChild () ) , varName . getJSType () ) . useSourceInfoFrom ( varName ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getJSType () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getJSType () ) , program ) , originalGenReturnType ) )
JSTypeRegistry typeRegistry
JSType type = n . getJSType () ;
JSTypeRegistry registry
JSTypeRegistry registry
FunctionType getterType
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getJSType () ) ;
this . registry = compiler . getTypeRegistry () ;
ImmutableMap < String , JSType > typeVars
JSTypeRegistry registry
{ JSType type = n . getJSType () ; return ( type != null && type . isFunctionType () ) ; }
JSType jsType
JSType jsType
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeRegistry () ) ;
lit . setJSType ( exportedObjectLit . getJSType () ) ;
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
replacement . setJSType ( call . getJSType () ) ;
JSType type = expr . getJSType () ;
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getJSType () ) . useSourceInfoIfMissingFromForTree ( n )
JSType type = n . getJSType () ;
lastCompiler . getTypeRegistry ()
lastCompiler . getTypeRegistry ()
JSType type
new InvalidatingTypes.Builder ( compiler . getTypeRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
JSType type
JSType receiverType = determineReceiverType ( n ) ;
this . registry = compiler . getTypeRegistry () ;
JSType type = n . getJSType () ;
replacement . setJSType ( getNativeStringType () ) ;
newName . setJSType ( child . getJSType () ) ;
@ Override public JSType getType () { return null ; }
public Builder setTypeRegistry ( JSTypeRegistry registry ) { this . registry = registry ; return this ; }
ObjectType prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , JSType type , Node defSite ) ;
void declareInstanceProperty ( String name , JSType type , Node defSite ) ;
void declareConstructorProperty ( String name , JSType type , Node defSite ) ;
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( obj ) ;
JSType objlitType = getType ( n ) ;
JSType type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getJSType () . isStructuralInterface () ;
JSType recvType = getType ( recv ) ;
JSType type
JSType type
ObjectType objectType
ObjectType objectType
JSType type = n . getJSType () ;
this . typeRegistry = compiler . getTypeRegistry () ;
for ( Node n : nodeList ) { n.jstype = ( JSType ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.jstype ) ; }
dst . setJSType ( this . jstype ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getProp ( TYPE_BEFORE_CAST ) ; }
public FunctionType getOwnerFunction () { return null ; }
JSType type = firstArg . getJSType () ;
@ Nullable JSType typeI
n . getJSType () == null
Path path
Path path
Path path
Path path
Path path
List < LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
abstract boolean hasTypeCheckingRun ( ) ;
this . compiler . setTypeCheckingHasRun ( true ) ;
this . addTypes = compiler . hasTypeCheckingRun () ;
compiler . setTypeCheckingHasRun ( true ) ;
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
typeCheckingHasRun = compilerState.typeCheckingHasRun ;
this . typeCheckingHasRun = compiler.typeCheckingHasRun ;
compiler . setTypeCheckingHasRun ( true ) ;
{ this . compiler = compiler ; this . addTypes = compiler . hasTypeCheckingRun () ; }
this . addTypes = compiler . hasTypeCheckingRun () ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_CHECK_TYPES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap ( varsByFrequency ) ; }
if ( ! validator . expectAutoboxesToIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
public ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
JSType objectType
JSType objectType
if ( iterableType != null ) { typeParam = iterableType . getInstantiatedTypeArgument ( registry . getNativeType ( JSTypeNative.ITERABLE_TYPE ) ) ; }
JSType newType = objType . getInstantiatedTypeArgument ( getNativeType ( ITERABLE_TYPE ) ) ;
defineSlot ( astParameter , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesSymbolContext ()
FunctionType makeIteratorType = registry . createFunctionType ( iteratorType , paramBuilder . build () ) ;
{ return isSubtype ( that , ImplCache . createWithoutStructuralTyping () , SubtypingMode.NORMAL ) ; }
URI path
URI path
List < ? extends LocationMapping > sourceMapLocationMappings
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
URI path
URI path
URI path
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
visitImport ( t . getInput () . getPath () , n ) ;
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
return dereferencePointer ( n . getFirstChild () , scope ) ;
{ testTypes ( externs , js , description , false ) ; }
{ testTypes ( STRING_CONSTANT , js , diagnosticType , isError ) ; }
{ testTypes ( STRING_CONSTANT , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypesWithCommonExterns ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypesWithCommonExterns ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType getTypeOfThis ( ) ;
StaticTypedScope scope
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot ) sym ) . getType () ; } return null ; }
StaticTypedScope scope
StaticTypedScope typeEnv
StaticTypedScope getDeclarationScope ( ) ;
FlowScope createChildFlowScope ( StaticTypedScope scope ) ;
@ Override public JSType getTypeOfThis () { return null ; }
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedScope scope
StaticTypedSlot slot
StaticTypedScope scope
@ Override StaticTypedScope getScope ( ) ;
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
visitArgumentList ( t , n , functionType ) ;
visitArgumentList ( t , n , fnType ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
while ( current.parent != null && current.scopes == current.parent.scopes ) { current = current.parent ; }
NodeUtil . isInvocation ( n ) || n . isYield ()
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
updateTypeOfArguments ( n , fnType ) ;
updateTypeOfParameters ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6InjectRuntimeLibraries ( compiler ) ; }
updateTypeOfArguments ( n , fnType ) ;
if ( ! options.checksOnly ) {}
if ( decl . isAliasDefinition () ) { return; }
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( n . isAssignAdd () ) { scope = updateScopeForAssignment ( scope , left , leftType , type ) ; }
flowScope = flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
FlowScope [] blind = newScope () ;
child = child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
if ( this == that ) { return true ; }
FlowScope output = input . withSyntacticScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope ;
assign . useSourceInfoIfMissingFromForTree ( method ) ;
{ scope = traverseChildren ( name , scope ) ; }
parentChunkCanSeeSymbolsDeclaredInChildren = false ;
List < String > moduleNameRegexList = options.chunksToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossChunkCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentChunkCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossChunkNames ) ; }
assertFalse ( REGEXP_TYPE . canBeCalled () ) ;
obj != null && obj . isFunctionPrototypeType ()
return subtype . isEmptyType () ;
@ Override public final boolean isVoidable () { return true ; }
@ Override public final boolean isNullable () { return true ; }
@ Override public final boolean isNoObjectType () { return false ; }
type . isEnumElementType ()
type . isFunctionPrototypeType ()
! callClassType . isEmptyType () && ! callClassType . isSomeUnknownType ()
type == null || type . isUnknownType () || type . isUnresolved () || type . isAllType ()
return ! type . isAllType () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isAllType () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isEmptyType () ; }
{ JSType type = n . getJSType () ; return type != null && type . isAllType () ; }
if ( ft != null ) { functionNode . setJSType ( convertMethodToFunction ( ft ) ) ; }
if ( body . isEmptyType () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isEmptyType () ? getUnknownType () : result ;
if ( type . isEnumElementType () ) { return type . getEnumeratedTypeOfEnumElement () ; }
return type != null && containsArray ( type ) ;
if ( objType . isFunctionPrototypeType () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
type . isEnumElementType ()
{ return type . isEnumType () || type . isBoxableScalar () ; }
if ( type . isEnumElementType () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isAllType () ) { return; }
type . isAllType () || type . isUnknownType ()
type . isAllType () || type . isUnknownType ()
public final boolean isAbstract () { return isAbstract ; }
return shouldTreatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public final ObjectType getPrototypeProperty () { return getPrototype () ; }
public final boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public final JSType getReturnType () { return call.returnType ; }
@ Override public final boolean canBeCalled () { return true ; }
public final void setDict () { propAccess = PropAccess.DICT ; }
public final void setStruct () { propAccess = PropAccess.STRUCT ; }
return restricted . isEmptyType () ? type : restricted ;
retType != null && ! retType . isEmptyType () && ! funType . isInterface ()
final ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
final JSType getReferencedTypeInternal () { return referencedType ; }
if ( ! receiverType . meetWith ( type ) . isEmptyType () ) { return true ; }
@ Override public final boolean matchesStringContext () { return true ; }
@ Override public final boolean matchesSymbolContext () { return true ; }
@ Override public final boolean matchesObjectContext () { return true ; }
@ Override public final boolean matchesNumberContext () { return true ; }
@ Override public final boolean isConstructor () { return false ; }
if ( type == null || type . isUnknownType () || type . isAllType () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
{ return type == null ? null : type . dereference () ; }
propdef . setJSType ( stringType ) ;
visitImport ( n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkMethodMotion () ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options . shouldRunCrossChunkCodeMotion () ; }
ensureTyped ( n ) ;
{ ensureTyped ( name , valueType ) ; }
ensureTyped ( n ) ;
ensureTyped ( n ) ;
ensureTyped ( n , type ) ;
ensureTyped ( iterableNode ) ;
if ( ! options.checksOnly ) {}
if ( recordUnresolvedTypes ) { unresolvedNamedTypes . add ( namedType ) ; }
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypes () ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( options . getLanguageIn () . toFeatureSet () ) ) { transpileAndDontCheck () ; } }
FeatureSet features = NodeUtil . getFeatureSetOfScript ( script ) ;
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isBlock () ) ;
if ( ! block . isBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isBlock () && ! stmt . hasChildren () )
{ checkState ( expr . isName () ) ; checkState ( body . isBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isBlock () ) ;
checkState ( tryBody . isBlock () ) ;
{ checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
checkState ( body . isBlock () ) ;
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isBlock () ) ;
if ( n . isExprResult () || n . isBlock () ) { return; }
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
! n . isBlock ()
{ checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
n . isBlock ()
! target . getParent () . isScript () && ! target . getParent () . isBlock () && ! target . getParent () . isModuleBody ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
n . isBlock ()
checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isBlock () ) ;
node . isBlock ()
{ return n . isRoot () || n . isScript () || n . isBlock () || n . isModuleBody () ; }
if ( ! block . isBlock () ) { return false ; }
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
checkState ( body . getNext () == null && body . isBlock () , body ) ;
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
checkState ( n . isBlock () , n ) ;
statement . isBlock ()
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isBlock () ) { return false ; }
{ return getRootNode () . isBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
checkState ( block . isBlock () ) ;
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
scopeRoot . isBlock () && scopeRoot . getParent () . isFunction ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
n . isFunction () && parent != null && parent . isBlock () && ! parent . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
if ( body . isBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
checkArgument ( node . isBlock () ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
! originalBody . isBlock ()
block . isBlock ()
checkState ( body . isBlock () , body ) ;
checkState ( block . isBlock () ) ;
checkState ( jumpBlock . isBlock () ) ;
checkState ( block . isBlock () ) ;
checkState ( catchBody . isBlock () ) ;
context . transpileUnmarkedBlock ( n . isBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isBlock () , newGeneratorHoistBlock ) ;
{ return node . getParent () . isExprResult () && node . getGrandparent () . isBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isBlock () ) )
! body . isBlock () || body . hasChildren ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
n . isFunction () && n . getParent () . isBlock () && ! n . getGrandparent () . isFunction ()
checkState ( ifBlock . isBlock () , ifBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( innerBlock . isBlock () , innerBlock ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
checkState ( block . isBlock () , block ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isBlock () ) { return; } }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
parent != null && ( parent . isBlock () || parent . isScript () )
if ( ! n . isScript () && ! n . isBlock () ) { return; }
! body . isBlock ()
! body . isBlock ()
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isBlock ()
c . isBlock ()
c . isBlock ()
checkState ( caseBody . isBlock () , caseBody ) ;
! labeledStatement . isBlock ()
last . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
JSType calleeTypeI = checkNotNull ( callee . getJSType () , STRING_CONSTANT , callNode . toStringTree () ) ;
assertFalse ( numbers . isSubtype ( sub1 ) ) ;
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getOutputFeatureSet () . version () ) ; }
if ( options . getOutputFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getOutputFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getOutputFeatureSet () ;
if ( ! options . getOutputFeatureSet () . contains ( FeatureSet.ES5 ) ) { throw new InvalidOptionsException ( STRING_CONSTANT ) ; }
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || FeatureSet.ES3 . contains ( getOutputFeatureSet () ) ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getOutputFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getOutputFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . setLanguageOut ( language ) ; }
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getOutputFeatureSet () . contains ( FeatureSet.TYPESCRIPT ) ) { return Format.PRETTY ; } return Format.COMPACT ; }
public void testNestingArrow () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testAssigningArrowToObjectLiteralField_ExpressionBody () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . contextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
assertThat ( compiler . getErrors () ) . isEmpty () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.OFF ; } return null ; }
{ this . outputFeatureSet = Optional . of ( featureSet ) ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList ( this ) ; }
{ asPropertyMap () . set ( key , value ) ; return this ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7RewriteExponentialOperator ( compiler ) ; }
FunctionScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
NormalScopeBuilder scopeBuilder = new NormalScopeBuilder ( globalScope ) ;
{ return new ModulePath ( normalize ( pathEscaper . escape ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( t . getInput () . getPath () , n ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
String path = pathEscaper . escape ( moduleAddress ) ;
private void skipOctalDigits () { while ( peekOctalDigit () ) { nextChar () ; } }
if ( ! currentInfo . hasConstAnnotation () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
assertThat ( jsdoc . isConstant () ) . isTrue () ;
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . isConstant () )
Token type
String name
String name
return shouldDescend ( n , parent ) ;
@ Nullable JSType ownerType
{ currentModule . moduleType ( ModuleType.COMMON_JS , t , n ) ; return; }
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . isEmpty () ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . googNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
JSType ownerType
return parent == null || ! NodeUtil . createsScope ( n ) ;
final Token type
final String name
final String name
assertTypeEquals ( STRING_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ if ( expandObjectLitAssignment ( t , root , export.scope ) ) { return; } }
@ JsMethod ( namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , rightType , STRING_CONSTANT ) ; }
return shouldDescend ( n , parent ) ;
Token type
String name
String name
@ Nullable JSType ownerType
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
@ JsMethod ( namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . restDeletionVarName ) ;
{ int baseHash = super . hashCode () ; if ( isSpecializedOnlyWithUnknown ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( instrumentationData , reach ) ) ; }
abstract ImmutableMultiset.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredGoogNamespacesBuilder ( ) ;
abstract ImmutableMultiset.Builder < String > requiredTypesBuilder ( ) ;
public void testSettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { mode = LanguageMode.ECMASCRIPT3 ; parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ES_NEXT ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
testSame ( STRING_CONSTANT ) ;
validateDefaultValue ( n ) ;
options . setEs6ModuleTranspilation ( Es6ModuleTranspilation.TO_COMMON_JS_LIKE_MODULES ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isRest () || parameter . isVarArgs () ; }
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return checkNotNull ( root ) ; }
this . root = checkNotNull ( root ) ;
Node originalRoot = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( input . getAstRoot ( this ) ) ;
findDeps . process ( checkNotNull ( input . getAstRoot ( this ) ) ) ;
Node root = checkNotNull ( input . getAstRoot ( this ) ) ;
return checkNotNull ( root ) ;
if ( ! options.checksOnly ) {}
{ matchedNodeInfo = MatchedNodeInfo . create ( node , RefactoringUtils . isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateObjectPatternRest ( type , c ) ;
validateArrayPatternRest ( type , c ) ;
{ validateRestParameters ( Token.PARAM_LIST , c ) ; }
public void testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( parent . isVar () || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . maybeMarkFeaturesAsTranspiledAway ( compiler , features ) ; }
checkState ( source . isFunction () || source . isClass () , source ) ;
JSType returnType = getExplicitReturnTypeIfExpected ( n ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RelativizeImportPaths ( compiler ) ; }
case RELATIVIZE_IMPORT_PATHS :
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler ) ; }
public void testSpreadLibInjection () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
{ JSType referencedType = getReferencedType () ; if ( areIdentical ( referencedType , this ) ) { handleTypeCycle ( reporter ) ; } }
if ( areIdentical ( this , that ) ) { return true ; }
public final boolean isGlobalThisType () { return areIdentical ( this , registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || ( isNamedType () && isUnknownType () ) ; }
assertSame ( objectType . getImplicitPrototype () , OBJECT_TYPE ) ;
defineVars ( n ) ;
defineVar ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( t , context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
NumberOfInvocationsVerifierTest . class
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
state . verifyingStarted ( OngoingVerifyingMode . atLeastOnce () ) ;
OngoingVerifyingMode mode
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
OngoingVerifyingModeTest . class
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
MockingProgressImpl state = new MockingProgressImpl () ;
MockingProgressImplTest . class
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockingProgress . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
state = new MockingProgressImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
mockingProgress . validateState () ;
mockingProgress . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockingProgress . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
verifyingRecorder . recordInvocation ( invocationMatcher . getInvocation () ) ;
verifyingRecorder = new VerifyingRecorder < T > () ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
@ Test ( expected = TooLittleActualInvocationsError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk ( null ) ;
verifyingRecorder = createRecorder () ;
InvocationsCalculator calculator = new InvocationsCalculator ( invocations ) ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . differentMethod () . toInvocation () ;
simpleMethod = new InvocationBuilder () . simpleMethod () . toInvocation () ;
VerificationModeTest . class
< T > T verify ( T mock , VerificationMode verificationMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
VerificationMode mode
public void reset () { stubbingInProgress = false ; verificationMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
VerificationMode mode
{ return verify ( mock , VerificationMode . times ( wantedNumberOfInvocations ) ) ; }
VerificationMode mode
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( i . isVerifiedStrictly () ) { continue; }
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedStrictly ( mock ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) ) ;
if ( unverified != null ) { reporter . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { reporter . strictlyRequiresFamiliarMock () ; }
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { reporter . missingMethodInvocation () ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( times ( NUMBER_CONSTANT ) ) ) ;
IAnswer result
assertThat ( chunk , collectionHasExactlyInOrder ( invocationOneChunkOne , invocationTwoChunkOne ) ) ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod ( textOne ) ;
Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
verify ( list , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . add ( STRING_CONSTANT ) ;
verify ( map , times ( NUMBER_CONSTANT ) ) . put ( anyObject () , anyObject () ) ;
verify ( mock , times ( NUMBER_CONSTANT ) ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly , Verification.EXPLICIT ) ; }
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
assertNotNull ( STRING_CONSTANT , verifierStub.invocations ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
verifier . verify ( asList ( wanted . getInvocation () ) , wanted , mode ) ;
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () , new NoMoreInvocationsVerifier () )
{ this . invocations = invocations ; return invocationToReturn ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( ! mode . exactNumberOfInvocationsMode () ) { return; }
if ( mode . strictMode () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
{ if ( mode . strictMode () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . explicitMode () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
if ( mode . explicitMode () ) { return; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && explicitMode () ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean explicitMode () { return verification == Verification.EXPLICIT ; }
public boolean strictMode () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null && verification == Verification.EXPLICIT ; }
assertNull ( Mockito.MOCKING_PROGRESS . pullStubable () ) ;
if ( mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; MOCKING_PROGRESS . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; MOCKING_PROGRESS . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( MOCKING_PROGRESS , new MatchersBinder () ) ;
void say ( String message ) ;
void say ( Object message ) ;
boolean withBooleanVarargs ( int value , boolean . . . b ) ;
String throwsError ( int count ) ;
String throwsIOException ( int count ) throws IOException ;
String throwsNothing ( boolean value ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
MockHandlerTest . class
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getMockHandler ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getMockHandler ( STRING_CONSTANT ) ; }
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List < Invocation > invocationsOfSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
for ( Object mock : mocks ) { MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
NoInteractionsWantedError e
NoInteractionsWantedError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
Invocation actual = analyzer . findActualInvocation ( invocations , wanted ) ;
int actualCount = analyzer . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , analyzerStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
return actualbyName != null ? actualbyName : findFirstUnverified ( invocations ) ;
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubbable ( this ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
VerificationModeImplTest . class
VerificationModeImpl mode
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
VerificationModeImpl mode
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , null , VerificationModeImpl . noMoreInteractions () ) ;
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ;
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
VerificationModeImpl mode
{ VerificationModeImpl mode = VerificationModeImpl . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationModeImpl mode = new VerificationModeBuilder () . strict () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertTrue ( methodsOnTraceAfterRemoving . isEmpty () ) ; }
three . simpleMethod ( NUMBER_CONSTANT ) ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( times , Arrays . asList ( new Object () ) ) ; }
assertSame ( verifierStub.mode , mode ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
catch ( VerificationError e ) {}
StackTraceFilteringTest . class
{ verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = mock ( LinkedList . class ) ; }
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
InvocationDiffersFromActual e
TooManyActualInvocations e
TooLittleActualInvocations e
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
WantedButNotInvoked e
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( WantedButNotInvoked e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual error
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocations e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
throw new NoInteractionsWanted ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new InvocationDiffersFromActual ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
wantedInvocation . differsWithArgumentTypes ( actualInvocation )
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
catch ( InvocationDiffersFromActual e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWanted e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( WantedButNotInvoked e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = WantedButNotInvoked . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
TooLittleActualInvocations e
TooManyActualInvocations e
TooManyActualInvocations e
WantedButNotInvoked e
InvocationDiffersFromActual e
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWanted e
NoInteractionsWanted e
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
InvocationDiffersFromActual e
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( StrictVerificationFailure e ) {}
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualityBasedDistributor () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualityBasedDistributor () )
catch ( StrictVerificationFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = StrictVerificationFailure . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
catch ( StrictVerificationFailure e ) {}
@ Test ( expected = StrictVerificationFailure . class )
@ Test ( expected = StrictVerificationFailure . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( StrictVerificationFailure e ) {}
strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () && explicitMode () ; }
Invocation unverified = finder . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
{ Invocation similar = finder . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstUnverifiedChunk ( invocations , wanted ) ;
{ finder.firstUnverifiedToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
finderStub.similarToReturn = actualInvocation ;
finderStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , finderStub.invocations ) ; }
finderStub = new InvocationsFinderStub () ;
InvocationsFinder finder
public MissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
InvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new InvocationsFinder () , new Reporter () ) ; }
InvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsFinder () ) ; }
finderStub = new InvocationsFinderStub () ;
finder = new InvocationsFinderStub () ;
List < ? extends Object > mocksToBeVerifiedStrictly
List < ? extends Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = finder . getLastStackTrace ( chunk ) ;
HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . toReturn ( true ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
return handler . voidMethodStubbable () ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ strictly () ; fail () ; }
Strictly strictly = strictly ( mock ) ;
{ Strictly strictly = strictly ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { strictly () ; }
strictly = strictly ( mock , mockTwo ) ;
Strictly strictly = strictly ( mockDatabase ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
strictly = strictly ( mock , mockTwo ) ;
strictly = strictly ( one , two , three ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne ) ;
strictly = strictly ( mockOne , mockThree ) ;
strictly = strictly ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockTwo ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne ) ;
Strictly strictly = strictly ( mockOne , mockThree ) ;
Strictly strictly = strictly ( mockTwo , mockThree ) ;
Strictly strictly = strictly ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = strictly ( mock ) ;
T argument
T actual
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
public Not ( ArgumentMatcher first ) { this . first = first ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
return null ;
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { return isA ( String . class ) ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . returnZero () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . returnFalse () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . returnNull () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . returnChar () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . returnZero () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . returnFalse () ; }
public boolean returnFalse () { return false ; }
public < T > T returnNull () { return null ; }
public char returnChar () { return NUMBER_CONSTANT ; }
public byte returnZero () { return NUMBER_CONSTANT ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
{ return reportMatcher ( new Same ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . < T > returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . < T > returnNull () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
detects ( new OnVerifyInOrder () , UnfinishedVerificationException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
detects ( new OnVerifyInOrder () , UnfinishedStubbingException . class ) ;
assertFalse ( inOrder ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
inOrder = inOrder ( mock , mockTwo ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedInOrder () ) ;
inOrder = inOrder ( mock , mockTwo ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , times ( NUMBER_CONSTANT ) ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockOne , times ( NUMBER_CONSTANT ) ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
finderStub.allMatchingUnverifiedChunksToReturn . add ( invocation ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . addAll ( asList ( first , second ) ) ;
finderStub.allMatchingUnverifiedChunksToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.allMatchingUnverifiedChunksToReturn . isEmpty () ) ;
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
@ Test ( expected = WantedButNotInvoked . class )
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
assertEquals ( wanted , reporterStub.wanted ) ;
{ reporter . wantedButNotInvoked ( wanted ) ; }
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable wanted
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
Printable previous
Printable undesired
assertEquals ( firstUnverified , reporterStub.undesired ) ;
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
Printable wanted
Printable wanted
assertEquals ( wanted , reporterStub.wanted ) ;
assertEquals ( wanted , reporterStub.wanted ) ;
Printable previous
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations ) ;
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
public String toString () { return actual ; }
public String toString () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( anyString () ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
Matcher < T > matcher
List < Matcher > matchers
public Not ( Matcher first ) { this . first = first ; }
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
Object actual
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( Matcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
public ReturnValues reportMatcher ( Matcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
catch ( NeverWantedButInvoked e ) {}
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . neverWanted () && noMatchFound ) { return; }
ArgumentsAreDifferentException e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
OverloadingPuzzleTest . class
PrintableInvocation undesired
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation undesired
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
if ( matchers == null ) { this . matchers = invocation . argumentsToMatchers () ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , ( Integer ) null ) ;
argumentsMatch ( actual )
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
@ Test ( expected = ArgumentsAreDifferent . class )
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) {}
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferent e
assertTrue ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( invocation . hasSimilarMethod ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . hasSimilarMethod ( verified ) ) ;
assertTrue ( STRING_CONSTANT + cause . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + text + STRING_CONSTANT + value . getMessage () , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
DefaultReturnValuesTest . class
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
ExampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . instance () . setReturnValues ( new MyDefaultReturnValues () ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . instance () . setReturnValues ( myDefaultReturnValues ) ; }
Invocation . isToString ( invocation )
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
InvocationOnMock invocation
return returnValueFor ( returnType ) ;
assertEquals ( ( char ) NUMBER_CONSTANT , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . addMocks ( mocks ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
String mockDescription = STRING_CONSTANT + ClassNameFinder . classNameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
assertThat ( m . getMatchers () , hasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , hasExactlyInOrder ( simpleMethod ) ) ;
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
{ f . set ( testClass , Mockito . mock ( f . getType () , f . getName () ) ) ; }
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
stub ( mock . oneArg ( not ( Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( Matchers . contains ( STRING_CONSTANT ) , Matchers . contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return ! Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return ConfigurationSupport . defaultValueFor ( invocation ) ; } }
{ super . run ( notifier ) ; ConfigurationSupport . getConfiguration () . resetReturnValues () ; }
{ Object test = super . createTest () ; ConfigurationSupport . getConfiguration () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return Configuration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = ConfigurationSupport . getConfiguration () ;
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . answers . add ( result ) ; }
private Result ( Answer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addAnswer ( Result . createReturnResult ( value ) ) ; }
AnswerFactoryTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowingAnswer ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowingAnswer ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowingAnswer ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
assertEquals ( null , mock . oneArg ( ( Object ) null ) ) ;
public String toString () { return toString ( argumentsToMatchers () , false ) ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ return ( String ) anyObject () ; }
Answer answer = answerFactory . createReturningAnswer ( value ) ;
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer ( invocation ) ; } }
{ result . answer ( null ) ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer ( null ) ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer ( null ) ) ; }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( isNotNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
Answer < > answer
Answer < > answer
Answer < > answer
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
Answer < > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { stubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ;
{ state . stubbingStarted () ; stubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ stubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
public void setInstance ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () , null ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () , null ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () , null ) ;
{ return mock ( classToMock , null ) ; }
return delegate . intercept ( proxy , method , args , methodProxy ) ;
try { stubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
this . stubber = new Stubber ( mockingProgress ) ;
void setInstance ( T mock ) ;
@ Before public void setUp () { StateMaster . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateMaster . reset () ; mock = mock ( IMethods . class ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new ThrowsException ( toBeThrown ) ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( new Returns ( toBeReturned ) ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( ( Object ) null ) . toString () ; fail () ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
return handler . voidMethodStubbable ( mock ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
try { mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . setMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new DoesNothing () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
DoesNothing answer
doNothing () . doNothing () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
Stubber doNothing ( ) ;
if ( answer instanceof DoesNothing ) { validateDoNothing ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoAnswer () , UnfinishedVerificationException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
detects ( new OnDoAnswer () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( SearchingClassLoader . combineLoadersOf ( toMock ) ) ;
AtLeastXVerificationTest . class
try { mockitoStubber . answerTo ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
InvocationOnMock invocation
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mode . atLeastMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , null , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
when ( mock . size () ) . thenThrow ( new RuntimeException () ) ;
{ when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( null ) ; }
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( error ) ;
when ( reader . read () ) . thenThrow ( ioException ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenThrow ( expected ) ;
when ( mockTwo . toString () ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . booleanReturningMethod () ) . thenReturn ( true ) ;
when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( Boolean.FALSE ) ;
{ when ( mock . simpleMethod () ) . thenThrow ( null ) ; }
{ when ( mock . simpleMethod () ) . thenThrow ( new Exception () ) ; }
Mockito . when ( mock . add ( STRING_CONSTANT ) ) . thenReturn ( true ) ;
when ( mock . simpleMethod () ) . thenThrow ( new RuntimeException () ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
when ( mock . oneArg ( anyString () ) ) . thenReturn ( STRING_CONSTANT ) ;
AssertionError e
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( AssertionError expected ) {}
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . wantedCount () , actualCount , wanted , lastInvocation ) ; }
if ( mode . explicitMode () || mode . atLeastMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= wantedInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && ( explicitMode () || atLeastMode () ) ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( NUMBER_CONSTANT , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
ClassImposterizerTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . atLeastOnce () ) ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { assertFalse ( verifier . appliesTo ( VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ) ; }
new VerificationModeDecoder ( mode ) . atLeastMode ()
new VerificationModeDecoder ( mode ) . inOrderMode ()
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationMode mode
VerificationMode inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationMode mode = VerificationModeImpl . atLeastOnce () ;
VerificationMode mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationMode mode
public boolean appliesTo ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationMode mode
VerificationMode mode
VerificationMode mode
VerificationMode mode
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new InOrderVerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = new VerifyingRecorder () ;
state . verificationStarted ( VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , VerificationModeFactory . atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode
MockitoVerificationMode mode
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
VerificationMode mode = VerificationModeFactory . atLeastOnce () ;
VerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
MockitoVerificationMode mode
MockitoVerificationModeTest . class
{ return VerificationModeFactory . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeFactory . atLeastOnce () ; }
{ return VerificationModeFactory . times ( wantedNumberOfInvocations ) ; }
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ mode . verify ( new VerificationDataImpl ( getRegisteredInvocations () , wanted ) ) ; }
public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnMap () ; }
{ return reportMatcher ( Any.ANY ) . returnList () ; }
{ return reportMatcher ( Any.ANY ) . returnString () ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () ; }
AtMostXVerificationTest . class
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
this . registeredInvocations = new RegisteredInvocations () ;
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getAll () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
RegisteredInvocationsTest . class
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( mode . getClass () . getSimpleName () + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoAssertionError e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public boolean neverWanted () { return mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations ) ; }
Times mode
Times mode
public VerificationModeDecoder ( Times mode ) { this . mode = mode ; }
TimesTest . class
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
Times mode
private VerificationModeDecoder decode ( Times mode ) { return new VerificationModeDecoder ( mode ) ; }
Times atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Times mode
return Mockito . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
int wantedCount
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode . wantedCount () ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
wantedCount > NUMBER_CONSTANT
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . check ( data . getAllInvocations () , data . getWanted () ) ; }
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
checker = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; checker . check ( invocations , wanted ) ; }
checker . check ( invocations , wanted ) ;
checker = new MissingInvocationChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
checker = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
numberOfCalls . check ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . check ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { MOCKING_PROGRESS . reset () ; REPORTER . missingMethodInvocation () ; }
Object value
public DeprecatedOngoingStubbing < T > toReturn ( T value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( T value ) { return thenAnswer ( new Returns ( value ) ) ; }
T value
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () , null ) ;
{ return returnValues . valueFor ( invocation ) ; }
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MockitoNamingPolicy.INSTANCE ) ; }
MockingProgress state = new MockingProgressImpl () ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
ArgumentMatcherStorage argumentMatcherStorage
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
getArgumentMatcherStorage () . validateState () ;
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
private boolean shouldPrint () { return ! unusedStubs . isEmpty () || ! unstubbedInvocations . isEmpty () ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return null ; }
public void addUnstubbedInvocation ( InvocationMatcher invocation ) { unstubbedInvocations . add ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingInfo () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
void println ( Object what ) ;
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void println () { System.out . println () ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
void log ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( unusedStubs , unstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } unstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class , loggerStub ) ; }
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
String loggedInfo = loggerStub . getLoggedInfo () ;
public void log ( Object what ) { super . log ( what ) ; loggedInfo . append ( what ) ; }
{ return DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ someUnusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
EmptyReturnValuesTest . class
HandyReturnValues reportMatcher ( Matcher matcher ) ;
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
Foo mock = mock ( Foo . class , RETURNS_SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; }
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
MockName mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
unfinishedVerificationHere () ;
{ validateState () ; resetOngoingStubbing () ; verificationMode = new Localized ( verify ) ; }
verify ( mock ) ;
{ mock ( IMethods . class ) ; fail () ; }
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter < MockHandler < T > > ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ClickableStackTracesTest . class
STRING_CONSTANT + pluralize ( actualCount ) + STRING_CONSTANT
{ matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
reporter . tooLittleActualInvocations ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocations ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrder ( new Discrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrder ( new AtLeastDiscrepancy ( wantedCount , actualCount ) , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure f ) {}
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
catch ( VerificationInOrderFailure e ) {}
@ Test ( expected = VerificationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
VerificationInOrderFailure e
catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationInOrderFailure e ) {}
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerificationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
assertContains ( expectedMessage , actualMessage ) ;
private void misplacedArgumentMatcherHere () { anyString () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ return new VoidMethodStubbableImpl ( mock ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
public void reset () { stubbingInProgress = null ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( filtered ) ; throw filtered ; }
assertEquals ( invocation . getLocation () , reporterStub.location ) ;
assertSame ( third . getLocation () , reporterStub.location ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.location ) ; }
assertSame ( second . getLocation () , reporterStub.location ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
Location firstUndesired
Location firstUndesired
Throwable hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getLocation () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
assertSame ( previous . getLocation () , reporterStub.previousLocation ) ;
assertSame ( actualInvocation . getLocation () , reporterStub.actualLocation ) ;
assertNull ( reporterStub.actualLocation ) ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
int expectedMatchersSize = invocation . getArgumentsCount () ;
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( actualInvocations ) ;
Location lastInvocation = finder . getLastLocation ( chunk ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder ) ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified ) ; }
@ Override public String toString () { return STRING_CONSTANT + this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return Collections . emptyList () ; }
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
assertTrue ( ret . getClass () . isArray () ) ;
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return mockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
{ return MOCKITO_CORE . inOrder ( mocks ) ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MOCKITO_CORE . stubVoid ( mock ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ MOCKITO_CORE . verifyNoMoreInteractions ( mocks ) ; }
{ return MOCKITO_CORE . verify ( mock , mode ) ; }
{ MOCKITO_CORE . reset ( mock ) ; }
{ return MOCKITO_CORE . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MOCKITO_CORE . when ( methodCall ) ; }
{ return MOCKITO_CORE . stub ( methodCall ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS ) ; }
mockingProgress . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ mockingProgress . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ mockingProgress . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
super . makeStackTracesClean () ;
super . makeStackTracesClean () ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; super . makeStackTracesClean () ; }
{ super . makeStackTracesClean () ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { new StateMaster () . validate () ; MockitoAnnotations . initMocks ( this ) ; }
new StateMaster () . validate () ;
{ return anyObject () ; }
filter . filterConditionally ( t ) ;
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterConditionally ( this ) ; }
filter . filterConditionally ( this ) ;
filter . filterConditionally ( this ) ;
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filter ( t ) ;
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
final boolean overloadedButSameArgs = ! methodEquals && safelyArgumentsMatch ( candidate . getArguments () ) ;
{ return ( T ) anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber , null ) ;
TestedObject mock = mock ( TestedObject . class ) ;
public Person ( Integer age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . noArgumentValueWasCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { Mockito . validateMockitoUsage () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return this . capturingMatcher . getAllValues () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; legacyRunner . run ( notifier ) ; }
{ if ( classProvider . isJUnit45OrHigherAvailable () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( RunnerProvider classProvider ) { this . classProvider = classProvider ; }
{ this . runner = new JUnit44RunnerImpl ( klass ) ; }
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
runner . run ( notifier ) ;
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invokeSuper ( proxy , args ) ; }
{ try { new ShallowCopyTool () . copyToMock ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = spy . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
Name guessName () { return defaultName ; }
public String getName () { return guessName () . name ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
new MockUtil () . isMock ( instance )
new MockUtil () . getMockHandler ( withFinal ) ;
MockName name = new MockUtil () . getMockName ( mock ) ;
try { mockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( mockUtil . getMockHandler ( mock ) ) ; }
List < Invocation > fromSingleMock = new MockUtil () . getMockHandler ( mock ) . getRegisteredInvocations () ;
MockHandler < T > handler = mockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } mockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , withSettings () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , withSettings () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , withSettings () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , withSettings () . extraInterfaces ( List . class , null ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getDefaultAnswer () ) ; }
IMethods mock = mock ( IMethods . class , withSettings () . defaultAnswer ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
{ return mockSettings . getDefaultAnswer () . answer ( invocation ) ; }
{ assertEquals ( STRING_CONSTANT , values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . answer ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultAnswer ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
ReturnsEmptyValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideDefaultAnswer ( null ) ; }
runner = new ConsoleSpammingMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . callRealMethod () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( CALLS_REAL_METHODS ) )
catch ( Throwable t ) { throw t ; }
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
this . firstTraceElement = filter . filter ( stackTrace , false ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , true ) ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
StackTraceElement [] filtered = filter . filter ( t , false ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseMatchers () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseMatchers () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public void setMatchersToBePrintedVerbosely ( Integer [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Integer . . . verboselyPrinted
Integer . . . toBePrintedVerbosely
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getSelfDescribingVerbosely () ) ; }
SelfDescribing getSelfDescribingVerbosely ( ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getSelfDescribingVerbosely () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , describe ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( OngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = reflectOnCreateInfo ( methodProxy ) ;
{ return getInterceptor ( mock ) . getMockHandler () ; }
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
ArgumentCaptor < String > captor = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > person = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
ArgumentCaptor < String > argument = ArgumentCaptor . forClass ( String . class ) ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings ( false ) + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return STRING_CONSTANT + i . getLocation () + STRING_CONSTANT ; }
{ this ( unusedStubs , unstubbedInvocations , false ) ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
private int hashCodeForMock ( Object mock ) { return System . identityHashCode ( mock ) ; }
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
objectMethodsGuru . isEqualsMethod ( method )
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
if ( objectMethodsGuru . isHashCodeMethod ( method ) ) { return hashCodeForMock ( proxy ) ; }
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
proxy . setCallbacks ( new Callback [] { interceptor , SerializableNoOp.SERIALIZABLE_INSTANCE } ) ;
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MockitoMethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
Any mock = mock ( Any . class , withSettings () . serializable () ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod method
MockitoMethod getMethod ( ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null , null ) ) ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler , settings ) ;
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
public Class < > getReturnType () { return returnType ; }
MockitoMethod mockitoMethod = new MockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new SerializableMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMethod ( toStringMethod ) ;
public SerializableMethod getMethod () { return invocation . getMethod () ; }
SerializableMethod getMethod ( ) ;
SerializableMethod method
Invocation i = new Invocation ( mock , new SerializableMethod ( method ) , args , sequenceNumber , null ) ;
Method getMethod ( ) ;
public Method getMethod () { return invocation . getMethod () ; }
{ if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
{ if ( invocation . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
MockitoMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueOrNullFor ( clazz ) ; }
public MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () ;
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ mockitoStubber . getRegisteredInvocations () . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber ) ;
public void addAnswer ( Answer answer ) { registeredInvocations . removeLast () ; addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return handler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( handler , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockSettings () . getMockName () ; }
MockHandler () { this ( new MockSettingsImpl () ) ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { invocationContainerImpl . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ invocationContainerImpl . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { invocationContainerImpl . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; invocationContainerImpl . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ invocationContainerImpl . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
{ invocationContainerImpl . addConsecutiveAnswer ( answer ) ; return this ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , invocationContainerImpl ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
String printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings ) ; }
int varargs ( String . . . string ) ;
int varargs ( Object . . . object ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . find ( mocksToBeVerifiedInOrder ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
public void log ( Object what ) { System.out . print ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { stubbingInProgress = null ; }
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUnstubbed ( i ) ; }
verify ( listener , only () ) . foundUnstubbed ( unstubbedInvocation ) ;
void foundUnstubbed ( InvocationMatcher unstubbed ) ;
{ this ( new ConsoleMockitoLogger () , new RunnerFactory () . create ( klass ) ) ; }
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( MockCreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || STRING_CONSTANT . equals ( warnings ) ; }
SimpleTestCase test = new SimpleTestCase () ;
SimpleTestCase test = new SimpleTestCase () ;
@ Test ( expected = ArgumentsAreDifferent . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = NewMockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks Object iAmNull = null ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMocks @ Spy List mock ; } ) ; }
null != field . getAnnotation ( InjectMocks . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMocks . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMocks . class )
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ; }
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , this ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue ( invocation . getMethod () . getName () ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
try { t . verify ( data ) ; fail () ; } catch ( MockitoAssertionError e ) {}
public InvocationMatcher getWanted () { return wanted ; }
public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
Object instance = new FieldInitializer ( testClass , field ) . initialize () ;
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getType () . getSimpleName () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String f ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify ( mock . getClass () ) ; }
validateMostStuff () ;
new ObjectMethodsGuru () . isToString ( invocation . getMethod () )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( invocation . toString () , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . toString () ; }
null != field . getAnnotation ( org.mockito.MockitoAnnotations.Mock . class )
final Object testClass
int index = filter . accept ( actualMethod , actualMethods ) ;
notifyAllInvocationListener ( invocation ) ;
MockHandler < > handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithInvocationMatcher ( handler , null ) ; }
doThrow ( SOME_EXCEPTION ) . when ( throwingListener )
public OngoingMockInjection tryPropertyOrFieldInjection () { injectionStrategies . thenTry ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { injectionStrategies . thenTry ( new ConstructorInjection () ) ; return this ; }
{ return nextStrategy != null && nextStrategy . process ( field , fieldOwner , mockCandidates ) ; }
{ assert wasAccessible != null : STRING_CONSTANT ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
VerifiableInvocationsFinder finder = new VerifiableInvocationsFinder () ;
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListeners () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
given ( handler . getMockSettings () . getInvocationListeners () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener1 ) . invocationListeners ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . invocationListeners ( listener ) ) ;
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , VerboseMockInvocationLogger . class ) ; }
MethodInvocationReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( STRING_CONSTANT ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( STRING_CONSTANT ) ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ notifier . handle ( invocation ) ; fail () ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; fail () ; }
{ mockSettingsImpl . invocationListeners () ; fail () ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; fail () ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath () , obtainClassPath ( STRING_CONSTANT ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitializedUsingContructorArgs () ;
mocks . addAll ( scanAndPrepareMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.oldAntenna ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( clazz ) . addTo ( mockDependentFields ) ;
{ return ( MockHandlerInterface ) mockMaker . getHandler ( mock ) ; }
String canThrowException ( ) throws CharacterCodingException ;
MockSettingsInfo mockSettings
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo settings
public void setTheField ( final File theField ) { theFieldSetterWasUsed = true ; this . theField = theField ; }
Class configClass ;
private void misplaced_anyBoolean_argument_matcher () { anyBoolean () ; }
private void misplaced_anyInt_argument_matcher () { anyInt () ; }
private void misplaced_anyObject_argument_matcher () { anyObject () ; }
List < LocalizedMatcher > pullLocalizedMatchers ( ) ;
Set < Object > mocks = newMockSafeHashSet () ;
Set < Object > mocks = newMockSafeHashSet () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ForwardsInvocations ( this . delegatedInstance ) ) ; }
public int getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArguments () . length ;
if ( this . getMethod () . getDeclaringClass () . isInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
public String toString () { return new PrintSettings () . print ( matchers , invocation ) ; }
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
{ this . matchers = ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( ArgumentsProcessor . argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
List matchers = ArgumentsProcessor . argumentsToMatchers ( i . getArguments () ) ;
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new LocationImpl () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl firstUndesired
LocationImpl firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new LocationImpl () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new LocationImpl ()
LocationImpl location
LocationImpl location
public Localized ( T object ) { this . object = object ; location = new LocationImpl () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
LocationImpl actualLocation
public LocationImpl getLocation () { return invocation . getLocation () ; }
LocationImpl last = finder . getLastLocation ( invocations ) ;
this . location = new LocationImpl () ;
String loc = new LocationImpl ( filterReturningEmptyArray ) . toString () ;
LocationImpl lastLocation = null ;
{ this . actualMatcher = actualMatcher ; this . location = new LocationImpl () ; }
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
LocationImpl actualLocation
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
invocation . markStubbed ( new StubInfoImpl ( stubbedInvocation ) ) ;
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () . toString () ) ; }
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfoImpl ( s ) ) ; return s ; }
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > MAX_LINE_LENGTH )
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl undesired
InvocationImpl undesired
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( InvocationImpl . class ) ) ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > unusedStubs
InvocationImpl actual
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
InvocationImpl invocationOnClass = getLastInvocation () ;
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
public ExposedInvocation ( InvocationImpl toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation
List < InvocationImpl > getAllInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
List < InvocationImpl > getInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > allInvocations
InvocationImpl invocation
given ( handler.invocationContainerImpl . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl nullDereference
InvocationImpl compareTo = this . getLastInvocation () ;
public MethodInfo ( Invocation theInvocation ) { this . method = theInvocation . getMethod () ; }
Invocation theInvocation
Invocation compareTo = this . getLastInvocation () ;
List < Invocation > allInvocations
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
List < Invocation > getAllInvocations ( ) ;
List < Invocation > getAllInvocations ( ) ;
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
List < Invocation > invocations
Invocation i = new InvocationBuilder () . toInvocation () ;
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
List < Invocation > getInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation invocation = new InvocationBuilder () . toInvocation () ;
List < Invocation > unusedStubs
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , Invocation invocation ) { throw new InvalidUseOfMatchersException () ; } }
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
Invocation undesired
Invocation undesired
List < Invocation > chunk
Invocation invocation
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation invocationOnClass = getLastInvocation () ;
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation actual
Invocation actual
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
public Location getLocation () { return invocation . getLocation () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location lastLocation = null ;
Location actualLocation
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
Location firstUndesired
Location firstUndesired
Location lastActualLocation
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location location
Location lastActualLocation
Location lastActualLocation
Location lastActualInvocation
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location firstUndesired
Location actualLocation
Location location
Location location
Location last = finder . getLastLocation ( invocations ) ;
Location actualLocation
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Invocation invocation
for ( Invocation i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
Invocation invocation
Invocation invocation
Invocation invocation
Invocation previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation nullDereference
Invocation invocation
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation invocation
{ markVerified ( chunk , wanted ) ; for ( Invocation i : chunk ) { context . markVerified ( i ) ; } }
Invocation invocation
return new LinkedList < Invocation > ( invocationsInOrder ) ;
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
synchronized ( invocations ) { copiedList = new LinkedList < Invocation > ( invocations ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
{ new Reporter () . tooLittleActualInvocations ( new org.mockito.internal.reporting.Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
org.mockito.internal.reporting.Discrepancy discrepancy
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
@ Override public void wantedButNotInvoked ( DescribedInvocation wanted ) { this . wanted = wanted ; }
DescribedInvocation invocation
public StubInfoImpl ( DescribedInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
public void markStubUsed ( DescribedInvocation usedAt ) { this . usedAt = usedAt ; }
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
DescribedInvocation wanted
public void wantedButNotInvoked ( DescribedInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
{ return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = new MockitoCore () . getLastInvocation () ;
InvocationImplTest . class
Mock annotation
{ return ( Answer < T > ) new ReturnsArgumentAt ( position ) ; }
new ReturnsArgumentAt ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsArgumentAt ( ReturnsArgumentAt.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsArgumentAt ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( cast ( newHandler ) , settings ) ) ; }
MockHandlerInterface handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) getMockHandler ( mock ) ;
Set < Class > extraInterfaces
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
Set < Class > extraInterfaces
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockSettingsInfo settings = oldHandler . getMockSettings () ;
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
mockUtil . maybeRedefineMockName ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Collection < Class > interfaces ) { extraInterfacesValidated = true ; }
MockSettingsInfo mockSettings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler ( new MockSettingsImpl () ) ;
T mock = mockUtil . createMock ( classToMock , mockSettings ) ;
Collection < Class > extraInterfaces
name . isDefault ()
{ this . mockName = toInstanceName ( classToMock ) ; this . defaultName = true ; }
{ if ( getMockName ( mock ) . isDefault () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
IMethods methods = mock ( IMethods . class , delegatesTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , delegatesTo ( delegatedList ) ) ;
MockCreationSettings settings = oldHandler . getMockSettings () ;
MockCreationSettings mockSettings
public MockCreationSettings getMockSettings () { return mockHandler . getMockSettings () ; }
MockCreationSettings settings
MockCreationSettings settings
MockCreationSettings settings
MockCreationSettings mockSettings
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
mockingProgress . mockingStarted ( mock , typeToMock ) ;
MockHandlerImpl < T > mockHandler
MockHandlerImplTest . class
newHandler = new InvocationNotifierHandler < T > ( new MockHandlerImpl < T > ( settings ) , settings )
InternalMockHandler mockitoHandler = cast ( handler ) ;
InternalMockHandler handler
MockHandler newHandler
MockHandler handler
MockHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
InternalMockHandler < T > mockHandler
{ return Primitives . primitiveValueOrNullFor ( type ) ; }
result = NUMBER_CONSTANT * result + ( clazz != null ? clazz . hashCode () : NUMBER_CONSTANT ) ;
registerTypeParametersOn ( clazz . getTypeParameters () ) ;
return typeVariable . equals ( ( ( TypeVarBoundedType ) o ) . typeVariable ) ;
< O extends K > O typeVar_with_type_params ( ) ;
< S , T extends S > T two_type_params ( ) ;
List < ? super Integer > returning_wildcard_with_class_lower_bound ( ) ;
public void setMockitoGenericMetadata ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
public MockSettings parameterizedInfo ( GenericMetadataSupport mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
GenericMetadataSupport returnTypeGenericMetadata
{ VerificationDataImpl data = createVerificationData ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress , mockSettings ) ;
RegisteredInvocationsAllTest . class
DefaultRegisteredInvocationsTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
{ return mockSettings . isStubOnly () ? new SingleRegisteredInvocation () : new DefaultRegisteredInvocations () ; }
catch ( CannotVerifyStubOnlyMock e ) {}
@ After public void yes_I_know_some_matchers_are_misplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingOnPurposeBecauseIncorrectAnnotationUsage . class ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . inferFrom ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = inferFrom ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
GenericsNest < > mock = mock ( GenericsNest . class , RETURNS_DEEP_STUBS ) ;
return recordDeepStubMock ( createNewDeepStubMock ( returnTypeGenericMetadata ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , DEFAULT_MOCK_MAKER_CLASS ) ; }
if ( ! mockitoCore . isTypeMockable ( clazz ) ) { return null ; }
{ if ( ! mockUtil . isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! mockitoCore . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
SerializableAndNoDefaultConstructor ( Observable o ) { super(); }
MockCreationSettings mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
{ if ( mockUtil . isMock ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! MOCKITO_PROXY_MARKER . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . toString () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; fail ( STRING_CONSTANT ) ; }
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable ( SerializableMode.ACROSS_CLASSLOADERS ) ) ;
this . serializableMode = copy.serializableMode ;
{ if ( AcrossJVMMockitoMockSerializable . class . isAssignableFrom ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . clear () ;
public VerificationMode never () { new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostAndNeverShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_TIMEOUT_MILLIS * NUMBER_CONSTANT ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getPollingPeriod () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , millis , delegate , true ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriod , delayMillis , verificationMode , false ) ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getDuration () ) ;
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriodMillis ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; fail () ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( new SerializableTypeVariable ( typeParameter ) , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ return mockitoCore () . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new ReturnsDeepStubsSerializationFallback ( returnTypeGenericMetadata ) ; }
return deepStub ( invocation , returnTypeGenericMetadata ) ;
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( ! isEquals ) { return this ; }
{ return ( T ) PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . get ( primitiveOrWrapperType ) ; }
{ return PRIMITIVE_OR_WRAPPER_DEFAULT_VALUES . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) PRIMITIVE_TYPES . get ( clazz ) ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
if ( ! CLEANER . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
T
long delayMillis
long millis
long millis
public long getDuration () { return durationMillis ; }
public long getPollingPeriod () { return pollingPeriodMillis ; }
long sleep
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
{ verifyNoMoreInteractions ( ( Object [] ) null ) ; }
{ inOrder ( ( Object [] ) null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + mock + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method . hashCode () ; }
timer . isUp ( startTime )
this . timer = new Timer ( durationMillis ) ;
when ( timer . isCounting () ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; mockingProgress . resetOngoingStubbing () ; }
when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( CannotStubVoidMethodWithReturnValue e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
{ return type == null ? STRING_CONSTANT : STRING_CONSTANT + type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
return new ClassImposterizer ( new CachingObjenesisInstantiator () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
Factory proxy = instantiator . newInstance ( proxyClass ) ;
STRING_CONSTANT + instantiator . getClass () . getSimpleName ()
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
DefaultClassImposterizerTest . class
CglibClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizerTest . class
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
new CGLIBHacker () . setMockitoNamingPolicy ( methodProxy ) ;
{ return getMethodProxy () . invokeSuper ( target , arguments ) ; }
CleanTraceRealMethod realMethod = new CleanTraceRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . setPair ( left , right ) ; }
boolean jars = binaryComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
mock = mock ( List . class , delegatesTo ( new FakeList < String > () ) )
{ return new ArrayList < T > () ; }
{ return new ArrayList < T > () ; }
ZipComparator.Result result = zipComparator . compareFiles () ;
{ zipComparator . setPair ( left , right ) ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( new CreationSettings () ) ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator ( settings ) )
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator ( settings . getOuterClassInstance () ) ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator ( null ) ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
public String toString () { return commits . size () + STRING_CONSTANT + author ; }
{ authorId = commit . getAuthorId () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getAuthorId () { return email ; }
Commit commit
Commit commit
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) , new IgnoreCiSkip () ) ; }
DefaultContributionSet contributions = new DefaultContributionSet ( ignoredCommit ) ;
if ( ignoreCommit . isTrue ( commit ) ) { return; }
Map.Entry < String , Contribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent , null ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT , null ) ; }
long id
public GitHubImprovementsProvider ( String authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
String content = IOUtil . readFully ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT ) ; }
{ return new ThenImpl < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable , e ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader , e ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output , e ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileInputStream ( file ) ) ) ;
if ( ! pluginSwitch . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitch ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > ( attempted ) ;
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule () ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return RETURNS_DEFAULTS . answer ( invocation ) ; }
mockSettings . defaultAnswer ( annotation . answer () ) ;
ReleaseStep getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail , runner ) ;
{ return anyObject () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public static VersionTool getVersionTool () { return new DefaultVersionTool ( new VersionBumper () ) ; }
long millis
public ClassLoader build () { return new InMemoryClassLoader ( parent , inMemoryClassObjects ) ; }
catch ( AssertionError e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return invokeConstructor ( constructor , params ) ; }
catch ( InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockedType . hashCode () ;
if ( ! mockedType . equals ( mockKey.mockedType ) ) return false ;
Class < T > mockedType
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
@ Origin ( cacheMethod = true ) Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
{ return ( Class < ? extends T > ) PREVIOUSLY_GENERATED_MOCK_CLASSES . get ( mockKey ) ; }
PREVIOUSLY_GENERATED_MOCK_CLASSES . put ( mockKey , mockType ) ;
T mock = classInstantiator . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingMockBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assertThat ( cache ) . hasSize ( NUMBER_CONSTANT ) ;
assertThat ( cachingMockBytecodeGenerator.avoidingClassLeakageCache ) . hasSize ( NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.IMITATE_SUPER_TYPE ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getSerializationSupport () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; serializationSupport = new ByteBuddyCrossClassLoaderSerializationSupport () ; }
CachingMockBytecodeGeneratorTest . class
Collections . sort ( unsortedFields , cmp ) ;
Collections . sort ( unsortedFields , cmp ) ;
PropertyAndSetterInjection . sortSuperTypesLast ( unsortedFields ) ;
sortSuperTypesLast ( declaredFields ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + safelyGetMockName ( mock )
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + safelyGetMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
@ Before public void setup () { mock = Mockito . mock ( IMethods . class , STRING_CONSTANT ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException expected ) {}
catch ( MockitoException expected ) {}
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new RuntimeException ( STRING_CONSTANT , ie ) ; } }
{ this ( pollingPeriodMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
{ return new After ( wrappedVerification . copyWithVerificationMode ( verificationMode ) ) ; }
{ return new Timeout ( wrappedVerification . copyWithVerificationMode ( newVerificationMode ) ) ; }
{ this ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
@ Origin ( cache = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList < Improvement > () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) { Assert . assertTrue ( true ) ; }
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumentsFromInvocation . class ) ) ;
{ injectionOccurred |= injectMockCandidates ( fieldClass , fieldInstanceNeedingInjection , newMockSafeHashSet ( mockCandidates ) ) ; fieldClass = fieldClass . getSuperclass () ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockAccess mockAccess = ( MockAccess ) mockInstance ;
if ( interceptor == null ) { return superCall . call () ; }
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return HamcrestPrinter . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
Class < > classToMock
Class < > classToMock
Class < > classToMock
Class < > classToMock
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class < > > emptySet () , false ) )
Set < Class < > > extraInterfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > interfaces
Set < Class < > > extraInterfaces
{ byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
MockitoMatcher m
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return actualMatcher . describe () ; }
MockitoMatcher actualMatcher
List < MockitoMatcher > matchers
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < MockitoMatcher > ) ( List ) lastMatchers ) ;
MockitoMatcher matcher
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
public Not ( MockitoMatcher first ) { this . first = first ; }
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . toString () , m . toStringWithType () ) ; }
ContainsExtraTypeInfo equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInfo equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInfo equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toString () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . toStringWithType () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String toString () { return STRING_CONSTANT ; } } ;
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
public String toString () { return describe ( wanted ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . toString () ) ;
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . toString () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . toString () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . toString () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . toString () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . toString () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . toString () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . toString () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . toString () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . toString () ) ; }
{ return m . toString () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
out . append ( new Equals ( array [ i ] ) . toString () ) ;
public String toString () { return STRING_CONSTANT ; }
public String toString () { return STRING_CONSTANT ; }
{ out . add ( new FormattedText ( MatcherToString . toString ( matcher ) ) ) ; }
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
List < ArgumentMatcher > matchers
ArgumentMatcher m
ArgumentMatcher m
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
ArgumentMatcher < Double > matcher
ArgumentMatcher < Float > matcher
ArgumentMatcher < Long > matcher
ArgumentMatcher < Integer > matcher
ArgumentMatcher < Short > matcher
ArgumentMatcher < Byte > matcher
ArgumentMatcher < Boolean > matcher
ArgumentMatcher < Character > matcher
ArgumentMatcher matcher
ArgumentMatcher m
ArgumentMatcher m = matchers . get ( position ) ;
List < ArgumentMatcher > matchers
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
ArgumentMatcher matcher
ArgumentMatcher matcher
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < ArgumentMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
@ After public void reset_state () { super . resetState () ; }
{ return MOCKITO_CORE . stubber () . doReturn ( toBeReturned ) ; }
{ return MOCKITO_CORE . stubber () . doNothing () ; }
{ return MOCKITO_CORE . stubber () . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . stubber () . doCallRealMethod () ; }
if ( throwables == null ) { return thenThrow ( ( Throwable ) null ) ; }
Assertions . assertThat ( returnedMock ) . isEqualTo ( expectedMock ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
Assertions . assertThat ( dog . bark () ) . isEqualTo ( STRING_CONSTANT ) ;
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = checkNonNullThrowable ( throwableClass ) ; }
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( ( Object ) any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = Plugins . getInstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForInstrumentedType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed |= t . isFailed () ; }
{ pomComparator = new PomComparator ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () . with ( TypeValidation.DISABLED ) ; random = new Random () ; }
runner . addListener ( new TextListener ( DevNull.out ) ) ;
{ return invocation . getMock () == invocation . getArgument ( NUMBER_CONSTANT ) ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
String arg = invocation . getArgument ( NUMBER_CONSTANT ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArgument ( actualArgumentPosition ( invocation ) ) ; }
ImportLogBean bean = invocation . getArgument ( NUMBER_CONSTANT ) ;
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
{ return invocation . getArgument ( NUMBER_CONSTANT ) ; }
runner = new MockitoJUnitRunner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = ArgumentCaptor . forClass ( Person . class ) ;
{ try { AdditionalAnswers . returnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule ( new ConsoleMockitoLogger () ) ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . contains ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgument ( position ) ) ; }
assertTrue ( mock instanceof List ) ;
{ return CoreMatchers . isA ( ( Class ) type ) ; }
assertTrue ( runner instanceof JUnit45AndHigherRunnerImpl ) ;
assertTrue ( runner instanceof JUnit44RunnerImpl ) ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
doAnswer ( recordCall ) . when ( mock ) . voidMethod () ;
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( new RuntimeException () ) . when ( mock ) . clone () ;
doThrow ( expected ) . when ( mock ) . clear () ;
{ return CoreMatchers . is ( ( Class ) type ) ; }
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , null , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , null , injectTestCase ) . evaluate () ;
{ return new JUnitRule ( new ConsoleMockitoLogger () ) ; }
VerificationCollectorImpl () { this . resetBuilder () ; }
verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; verify ( methods ) . simpleMethod () ; }
MockHandler newHandler = createMockHandler ( settings ) ;
MockHandler mockHandler = createMockHandler ( settings ) ;
{ setField ( testClass , field , mock ) ; }
setField ( descInstance , classNameField , proxyClass . getCanonicalName () ) ;
{ setField ( instance , field , value ) ; }
{ setField ( testInstance , field , mock ) ; }
setField ( testClass , field , newFieldInstance ) ;
setField ( testClass , field , newFieldInstance ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { setField ( injectee , candidateFieldToBeInjected , matchingMock ) ; }
InternalMockHandler handler = createMockHandler ( settings ) ;
InternalMockHandler handler = createMockHandler ( settings ) ;
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { throw invocationListenerThrewException ( listener , listenerThrowable ) ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { throw invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
{ if ( ! superMethod . isInvokable () ) { throw cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { throw invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { throw noMoreInteractionsWantedInOrder ( unverified ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { throw mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; throw missingMethodInvocation () ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { throw defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( o . isToString ( wanted . getMethod () ) ) { throw cannotVerifyToString () ; }
catch ( RuntimeException e ) { throw cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
{ if ( alreadyAssigned ) { throw moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { throw usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { throw mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { throw mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
{ if ( mockSettings . isStubOnly () ) { throw stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { throw incorrectUseOfApi () ; }
{ if ( ! methodInfo . isVoid () ) { throw onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } }
if ( foundSize > maxNumberOfInvocations ) { throw wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( method . isAbstract () ) { throw cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
public MissingInvocationChecker () { this ( new InvocationsFinder () ) ; }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { throw notAnException () ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . isOut ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . isOut ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
markVerified ( actualInvocations , wanted ) ;
markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () ) ; }
markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
markVerifiedInOrder ( chunk , wanted , context ) ;
markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
markVerified ( actualInvocations , wanted ) ;
markVerified ( found , wanted ) ;
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
void reportMatcher ( ArgumentMatcher matcher ) ;
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return false ; }
{ reportMatcher ( matcher ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( matcher ) ; return null ; }
{ reportMatcher ( new StartsWith ( prefix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new EndsWith ( suffix ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Matches ( regex ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new Contains ( substring ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( NotNull.NOT_NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( Null.NULL ) ; return null ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new Equals ( value ) ) ; return false ; }
{ reportMatcher ( AnyVararg.ANY_VARARG ) ; return null ; }
{ reportMatcher ( Any.ANY ) ; return null ; }
{ Mockito . argThat ( capturingMatcher ) ; return defaultValue ( clazz ) ; }
{ return Primitives . defaultValue ( type ) ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new ArrayEquals ( value ) ) ; return null ; }
{ reportMatcher ( new Find ( regex ) ) ; return null ; }
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return true ; } return defaultCleaner . isOut ( candidate ) ; }
T argument
String argument
new ArgumentMatcher < String > () { public boolean matches ( String argument ) { return true ; } }
public void setAnswersForStubbing ( List < Answer < > > answers ) { answersForStubbing . addAll ( answers ) ; }
Class < > clazz
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Map < , > map () { return null ; }
LinkedList < > linkedList () { return null ; }
List < > list () { return null ; }
List < Answer < > > answers
public void setAnswersForStubbing ( List < Answer < > > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings < > settings
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
Long longPretendingAnInt = NUMBER_CONSTANT ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
assertFalse ( mockUtil . isSpy ( null ) ) ;
void setAnswersForStubbing ( List < Answer < > > answers ) ;
int compareTo ( HasCompare redHerring ) ;
int foo ( HasCompare other ) ;
int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
assertNotNull ( readObject ) ;
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
verify ( mock ) . simpleMethod ( anyObject () ) ;
catch ( Exception e ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
Class < > classToMock
int secondArgument = ( Integer ) invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
void reportMatcher ( ArgumentMatcher < > matcher ) ;
void mockingStarted ( Object mock , Class < > classToMock ) ;
void mockingStarted ( Object mock , Class < > classToMock ) ;
OngoingStubbing < > pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing < > ongoingStubbing ) ;
Class < > classToMock
public void reportOngoingStubbing ( OngoingStubbing < > iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
public ArgumentMatcher < > getMatcher () { return matcher ; }
ArgumentMatcher < > matcher
createdMocks = new LinkedList < Object > () ;
public void mockingStarted ( Object mock , Class < > classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List < Object > toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class < > expected
{ copy ( from , to , from . getClass () ) ; }
Class < > actualType
Class < > lhsClass = lhs . getClass () ;
Class < > reflectUpToClass
Class < > typeToMock
Iterable < > lines
new SerializableMethod ( type . getMethod ( methodName , new Class < > [ NUMBER_CONSTANT ] ) )
Class < > classToMock
Class < > mockedType
Class < > type
Class < > [] argTypes
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class < > [] ) null ) ) ; }
for ( Class < > anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
for ( Class < > i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
Class < > currentExploredClass = clazz
Class < > type
{ mock . oneArg ( ( char ) ( CHAR_CONS + i ) ) ; }
Answer < > answer
Answer < > answer
public BDDStubber will ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer < > answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer < > answer
Answer < > answer
return matchers ;
HoldingAReference ( WeakReference < Class < > > a ) { this . a = a ; }
Class < > . . . extraInterfaces
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = InvocationsFinder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = InvocationsFinder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = findFirstUnverified ( data . getAllInvocations () ) ;
Invocation next = findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
public int size ( Collection < > collection ) { return collection . size () ; }
public int size ( Map < , > map ) { return map . size () ; }
verify ( ( Iterable < String > ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable < String > ) iterable ) . iterator () ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer < > > () ) ;
FailingConstructor ( Set < > set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public Set < > getHistogram2 () { return histogram2 ; }
public Set < > getHistogram1 () { return histogram1 ; }
public TreeSet < > getSearchTree () { return searchTree ; }
public List < > getAList () { return aList ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet < Float > () , new ByteArrayOutputStream () ) ) ;
public some_class_with_parametered_constructor ( List < > collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator ( false ) ; }
public LessThan ( T value ) { super ( value ) ; }
public LessOrEqual ( T value ) { super ( value ) ; }
public GreaterOrEqual ( T value ) { super ( value ) ; }
T value
T value
T value
T value
T value
public CompareTo ( T value ) { this . wanted = value ; }
public GreaterThan ( T value ) { super ( value ) ; }
public CompareEqual ( T value ) { super ( value ) ; }
UnmockableHashCodeAndEquals mock = mock1 ;
Transformer.ForMethod . withModifiers ( SynchronizationState.PLAIN )
VerificationMode only ( ) ;
VerificationMode atLeastOnce ( ) ;
VerificationMode never ( ) ;
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection () ; }
Method getJavaMethod ( ) ;
Class < > [] getExceptionTypes ( ) ;
Class < > [] getParameterTypes ( ) ;
Class < > getReturnType ( ) ;
String getName ( ) ;
{ return false ; }
Object writeReplace ( ) ;
{ mockingProgress () . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress () . validateState () ;
mockingProgress () . validateState () ;
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
MockingProgress p = mockingProgress () ;
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ mockingProgress () . getArgumentMatcherStorage () . reportAnd () ; return false ; }
assertThat ( mockingProgress () . pullOngoingStubbing () ) . isNull () ;
mockingProgress () . stubbingCompleted ( invocation ) ;
InvocationContainerImpl invocations = new InvocationContainerImpl ( new MockSettingsImpl () ) ;
mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress () . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , ANY ) ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
assertThat ( result ) . isSuccessful () ;
{ return new RunnerProvider () . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , Reporter . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( MockitoJUnitListener . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
FailureDetecter listener = new FailureDetecter () ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ;
! hasTestMethods ( klass )
MockCreationSettings < T > settings
MockCreationSettings < T > mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( invocation . toString () ) . endsWith ( STRING_CONSTANT ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ;
Assertions . assertThat ( chunk ) . containsSequence ( simpleMethodInvocation , simpleMethodInvocationTwo ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . has ( onlyThoseClasses ( STRING_CONSTANT ) ) ;
JUnitResultAssert . assertThat ( result ) . isSuccessful () ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; JUnitResultAssert . assertThat ( result ) . isSuccessful () ; }
catch ( RuntimeException e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { Assertions . assertThat ( expected ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { Assertions . assertThat ( e ) . has ( firstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
Assertions . assertThat ( t ) . has ( onlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Assertions . assertThat ( filtered ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
Assertions . assertThat ( timer . isCounting () ) . isFalse () ;
Assertions . assertThat ( timer . isCounting () ) . isTrue () ;
{ reportMatcher ( new InstanceOf ( Iterable . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class , STRING_CONSTANT ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class , STRING_CONSTANT ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class , STRING_CONSTANT ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class , STRING_CONSTANT ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class , STRING_CONSTANT ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class , STRING_CONSTANT ) ) ; return false ; }
void save ( Person capture ) ;
String targetMethod ( String arg ) ;
Integer getValue ( Integer param ) ;
Object otherMethod ( Object param ) ;
Object someMethod ( Object param ) ;
MyIterator < T > iterator ( ) ;
public void setSpy ( List < > spy ) { this . spy = spy ; }
public List < > getList () { return list ; }
assertThat ( log ) . containsIgnoringCase ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e . getMessage () ) . doesNotContain ( STRING_CONSTANT ) ; }
catch ( AssertionError e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertThat ( e ) . hasMessageContaining ( expected ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
{ assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertThat ( out ) . contains ( STRING_CONSTANT ) ;
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
assertThat ( name ) . contains ( STRING_CONSTANT ) ;
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( InvalidUseOfMatchersException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( Exception e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( SmartNullPointerException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( UnfinishedVerificationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertThat ( failure . getException () ) . hasMessageContaining ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
assertThat ( mockTwo . toString () ) . contains ( STRING_CONSTANT ) ;
catch ( MockitoException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT ) ; }
assertNotNull ( MockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( MockUtil . getMockHandler ( mock ) ) ;
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( MockUtil . isMock ( initializedSpy ) ) ; }
Class < > mockType = MockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
MockUtil . isMock ( instance )
MockUtil . isMock ( instance )
if ( isMockOrSpy ( instance ) ) { MockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockCreationSettings < > mockSettings = MockUtil . getMockSettings ( mockitoMock ) ;
MockCreationSettings parentMockSettings = MockUtil . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( invocation . getMock () ) ;
assertTrue ( MockUtil . isMock ( subClass.list ) ) ;
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect ) ; }
InvocationContainer invocationContainer = getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { resetMock ( m ) ; }
if ( ! isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = createMock ( creationSettings ) ;
InternalMockHandler < Object > handler = MockUtil . getMockHandler ( mock ) ;
TypeMockability typeMockability = MockUtil . typeMockabilityOf ( classToMock ) ;
{ if ( MockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
String mockName = getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
String qualifiedName = MockUtil . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > all = AllInvocationsFinder . find ( createdMocks ) ;
List < Invocation > invocations = VerifiableInvocationsFinder . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > invocations = AllInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
verify ( mockHandler ) . setAnswersForStubbing ( ArgumentMatchers . < Answer < > > anyList () ) ;
when ( sorter . sort ( ArgumentMatchers . < String > anyList () ) ) . thenReturn ( null ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
MissingInvocationChecker . checkMissingInvocation ( invocations , wanted ) ;
{ results . add ( sortSuperTypesLast ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = sortSuperTypesLast ( unsortedFields ) ;
List < Field > l = sortSuperTypesLast ( Arrays . asList ( o1 , o2 ) ) ;
return sortSuperTypesLast ( declaredFields ) ;
isNullOrEmpty ( args )
@ Override public InvocationMatcher getWanted () { return wanted ; }
public boolean isOut ( Invocation invocation ) { return isToStringMethod ( invocation . getMethod () ) ; }
if ( isToStringMethod ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
if ( ! filterRequested && listener . isSussessful () ) { reporter . validateUnusedStubs ( testClass , notifier ) ; }
mockingProgress () . mockingStarted ( mock , creationSettings ) ;
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . addListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
Iterable < > mocks
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e . getMessage () ) ;
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
{ if ( value == null ) { throw new IllegalArgumentException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
public TypeVariable < > typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable < > typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable < > [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable < > ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable < > ) wildCardBoundedType . firstBound () ) ; }
TypeVariable < > typeVariable
assertThat ( to.privateTransientField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
assertThat ( to.finalField ) . isNotEqualTo ( NUMBER_CONSTANT ) ;
Class < > classToMock
public int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthorName ( ) ;
String getAuthorEmail ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + authorName ; }
public String getAuthorName () { return author ; }
public String getAuthorEmail () { return email ; }
UnusedStubbings ( Collection < ? extends Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( this , type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT , MILLISECONDS ) ;
generatedMockClass = generator . generateMockClass ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertEquals ( STRING_CONSTANT , Collections . emptySet () , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > mockedProxyType = createMockType ( settings ) ;
Class < ? extends T > type = createMockType ( settings ) ;
dispatcher == null || ! dispatcher . isMocked ( mock , origin )
public AbstractByteBuddyMockMakerTest ( MM mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = bytecodeGenerator . mockClass ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class . class ) ) )
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
{ addStep ( task , config ) ; return this ; }
MatchableInvocation wanted
MatchableInvocation wantedMatcher = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
public String print ( MatchableInvocation invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted = data . getWanted () ;
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation getWanted ( ) ;
private RemoveNotMatching ( MatchableInvocation wanted ) { this . wanted = wanted ; }
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
MatchableInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getTarget () ) ;
MatchableInvocation wanted = data . getTarget () ;
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ Checks . checkNotNull ( listener , STRING_CONSTANT ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { delayedExecution = new DelayedExecution () ; stopWatch = createNotStarted () ; }
@ Advice.Return ( readOnly = false , typing = Assigner.Typing.DYNAMIC ) Object returned
@ Advice.AllArguments Object [] arguments
private ExcludeHandler ( Object root ) { this . root = root ; }
@ Override public Invocation getInvocation () { return invocation ; }
{ return isMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMock ( mock )
mockingProgress () . stubbingCompleted () ;
AnnotationEngine customizedEngine = new IndependentAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . tryGetPluginAnnotationEngine () ;
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_DEPENDING_ON_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ throw new IllegalArgumentException ( format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { excludedPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
MockitoStatement statement
mock . otherMethod () ;
public void doAssert ( Throwable throwable ) { assertThrowable ( throwable , expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) {}
public JUnitRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
void doAssert ( Throwable t ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectFailure ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectFailure ( PotentialStubbingProblem . class ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( UnnecessaryStubbingException . class ) ;
rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectFailure ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectFailure ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectFailure ( AssertionError . class , STRING_CONSTANT ) ;
notifyStubbedAnswerLookup ( invocation , stubbedInvocation ) ;
List < StubbingLookupListener > getStubbingLookupListeners ( ) ;
{ return new JUnitRule ( new ConsoleMockitoLogger () , Strictness.WARN ) ; }
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.LENIENT ) ; }
case LENIENT :
( ( CreationSettings ) settings ) . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode , mockingProgress . verificationListeners () ) ) ;
private int wantedArgumentPosition () { return wantedArgumentPosition ; }
DefaultAnswerValidator . validateReturnValueFor ( invocation , ret ) ;
private boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher < > matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . createStrict ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () , null ) ;
MockitoJUnitRunner ( InternalRunner runner ) throws InvocationTargetException { this . runner = runner ; }
InternalRunner runner
loader . getStrategy ( features.mockedType )
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
@ Override public boolean mockable () { return INSTRUMENTATION . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT + result . getRunCount () + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatch . class ) ;
Result result = runner . run ( UnnecessaryStubbing . class ) ;
{ return mock ( classToMock , withSettings () ) ; }
return new AndroidClassLoadingStrategy.Injecting ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( CALLS_REAL_METHODS ) . name ( field . getName () ) )
InnerStaticClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw noMatchingConstructor ( cls ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
NumberOfInvocationsChecker . checkNumberOfInvocations ( invocations , wanted , NUMBER_CONSTANT , context ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblem ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
Failure f = firstOf ( result . getFailures () ) ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
mockito . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mockito . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mockito . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . setCurrentStrictness ( strictness ) ; }
event . getFailure () == null && ! stubbingLookupListener . isMismatchesReported ()
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMockingSession () ; }
assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return ExceptionFactory . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN )
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { evaluateConstructor ( matchingConstructors , constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( null ) ) ;
catch ( Throwable throwable ) { lastException = throwable ; return null ; }
if ( unused . isEmpty () ) { return; }
return STRING_CONSTANT . equals ( method . getName () ) ;
STRING_CONSTANT . equals ( method . getName () )
STRING_CONSTANT . equals ( m . getName () )
Type genericInterface = findGenericInterface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return parameterTypes ; }
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , args ) ;
this . arguments = ArgumentsProcessor . expandArgs ( mockitoMethod , arguments ) ;
parameterTypes = SuspendMethod . trimSuspendParameterTypes ( method . getParameterTypes () ) ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( ( Invocation ) invocation , argumentPosition ) ;
public InOrderImpl ( List < > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , any () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
@ Override public String indirect () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
List < Stubbing > getStubbedInvocations ( ) ;
MockHandler handler
public NullResultGuardian ( MockHandler < T > delegate ) { this . delegate = delegate ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( newHandler , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( handler , settings ) ) ;
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler < > handler = createMockHandler ( settings ) ;
MockHandler < T > mockHandler
MatchableInvocation invocation
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainer . setAnswersForStubbing ( answers ) ; }
this . invocationContainer = new InvocationContainerImpl ( mockSettings ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainer . invokedMock () ; }
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = getInvocationContainer () . getStubbedInvocations () ;
InvocationContainerImpl invocations
InvocationContainerImpl invocations = getInvocationContainer ( mock ) ;
for ( T m : mocks ) { getInvocationContainer ( m ) . clearInvocations () ; }
MockUtil . getInvocationContainer ( mock ) . setAnswersForStubbing ( answers ) ;
InvocationContainerImpl invocationContainer
MockCreationSettings < T > creationSettings = impl . build ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return MockUtil . getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
verify ( mock ) ;
{ RealMethod.FromCallable superMethod = new RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new RealMethod.FromCallable ( superCall ) ) ;
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod
RealMethod realMethod ;
return ! node . getSort () . isResolved () || ! node . getRepresentative () . asDefined () . represents ( origin ) ;
if ( ! isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Collections . < Stubbing > emptyList () ) ;
{ addListeners ( listeners , this . verificationStartedListeners , STRING_CONSTANT ) ; return this ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw Reporter . methodDoesNotAcceptParameter ( STRING_CONSTANT , STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new Event () ;
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mockitoMock ) ;
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mock , mockMaker . getHandler ( mock ) ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
catch ( Exception e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockingDetails ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockingDetails ) ; }
assertEquals ( Double . valueOf ( NUMBER_CONSTANT ) , captor . getValue () ) ;
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
@ Override public MockName getMockName () { return mockName ; }
@ Override public Object getOuterClassInstance () { return outerClassInstance ; }
@ Override public SerializableMode getSerializableMode () { return serializableMode ; }
@ Override public MockName getMockName () { return mockName ; }
@ Override public Object getSpiedInstance () { return spiedInstance ; }
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyHandler () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyHandler () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyHandler () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyHandler () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyHandler () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyHandler () ) ;
new MockitoMockKey ( params.mockedType , params.interfaces , params.serializableMode , params.stripAnnotations )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < MockitoMockKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { fail () ; }
assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
sb . append ( STRING_CONSTANT ) . append ( mock ) . append ( STRING_CONSTANT ) ;
singletonLock || classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return instance != interceptors.target && interceptors . containsKey ( instance ) ; }
@ Override public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + TEST_NAME + STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestName ( ) ;
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( org.mockito.creation.instance.InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = org.mockito.creation.instance.InstantiationException . class )
catch ( org.mockito.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
if ( explosive . get () != null ) { throw new RuntimeException ( MyMockMaker . class . getName () ) ; }
return pluginType . cast ( new InstantiatorProvider2Adapter ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderAdapter ( ( InstantiatorProvider ) impl ) ; }
{ return createInvocation ( target , method , args , superMethod , settings ) ; }
this . mockRef . get () . equals ( other.mockRef . get () )
public String getStuff () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
T ref = this . ref . get () ;
this . instanceRef = new MockWeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( createMethodInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( createMethodInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( createMethodInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( createMethodInvocation () ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
Set < Object > testInstances
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , u . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( Primitives . primitiveTypeOf ( referenceType ) ) ; }
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . annotationType () ) ) { return ( T ) firstParamAnnotation ; } }
assertThat ( subList . isEmpty () ) . isTrue () ;
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } )
assumeTrue ( ClassFileVersion . ofThisVm () . isAtLeast ( ClassFileVersion.JAVA_V7 ) ) ;
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = CODEGEN_PACKAGE + type . getSimpleName () ; }
{ super ( Opcodes.ASM6 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) public MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVarargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
fireChangeEvent () ;
{ fireChangeEvent () ; }
{ this . radiusGridlinePaint = paint ; fireChangeEvent () ; }
{ this . radiusGridlineStroke = stroke ; fireChangeEvent () ; }
if ( this . radiusGridlinesVisible != visible ) { this . radiusGridlinesVisible = visible ; fireChangeEvent () ; }
{ this . angleGridlinePaint = paint ; fireChangeEvent () ; }
{ this . angleGridlineStroke = stroke ; fireChangeEvent () ; }
if ( this . angleGridlinesVisible != visible ) { this . angleGridlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . angleLabelsVisible != visible ) { this . angleLabelsVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . cornerTextItems . clear () ; fireChangeEvent () ; }
if ( removed ) { fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionDepth = sectionDepth ; fireChangeEvent () ; }
{ this . outerSeparatorExtension = percent ; fireChangeEvent () ; }
{ this . innerSeparatorExtension = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . separatorsVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . drawBorder = status ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
if ( this . labelType != type ) { this . labelType = type ; fireChangeEvent () ; }
{ super . setFixedRangeAxisSpace ( space ) ; setFixedRangeAxisSpaceForSubplots ( space ) ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
{ this . intervals . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . dialOutlinePaint = paint ; fireChangeEvent () ; }
{ this . drawBorder = draw ; fireChangeEvent () ; }
{ this . dialBackgroundPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . tickLabelPaint = paint ; fireChangeEvent () ; }
{ this . tickLabelFont = font ; fireChangeEvent () ; }
if ( this . tickLabelsVisible != visible ) { this . tickLabelsVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . units = units ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . legendLabelURLGenerator = generator ; fireChangeEvent () ; }
{ this . legendLabelToolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . urlGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . simpleLabels = simple ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . labelShadowPaint = paint ; fireChangeEvent () ; }
{ this . labelOutlineStroke = stroke ; fireChangeEvent () ; }
{ this . labelOutlinePaint = paint ; fireChangeEvent () ; }
{ this . labelBackgroundPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . labelLinkMargin = margin ; fireChangeEvent () ; }
{ this . labelLinksVisible = visible ; fireChangeEvent () ; }
{ this . maximumLabelWidth = width ; fireChangeEvent () ; }
{ this . labelGap = gap ; fireChangeEvent () ; }
{ this . labelGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . shadowYOffset = offset ; fireChangeEvent () ; }
{ this . shadowXOffset = offset ; fireChangeEvent () ; }
{ this . shadowPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionOutlineStrokeMap . put ( key , stroke ) ; fireChangeEvent () ; }
{ this . sectionOutlineStroke = stroke ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionOutlinePaintMap . put ( key , paint ) ; fireChangeEvent () ; }
{ this . sectionOutlinePaint = paint ; fireChangeEvent () ; }
{ this . sectionOutlinesVisible = visible ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . sectionPaintMap . put ( key , paint ) ; fireChangeEvent () ; }
{ this . sectionPaint = paint ; fireChangeEvent () ; }
{ this . ignoreZeroValues = flag ; fireChangeEvent () ; }
{ this . ignoreNullValues = flag ; fireChangeEvent () ; }
{ this . circular = circular ; if ( notify ) { fireChangeEvent () ; } }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . startAngle = angle ; fireChangeEvent () ; }
{ this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; fireChangeEvent () ; }
{ this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { fireChangeEvent () ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; fireChangeEvent () ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; fireChangeEvent () ; }
{ fireChangeEvent () ; }
if ( this . annotations != null ) { this . annotations . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
if ( this . rangeMarkers != null ) { this . rangeMarkers . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
if ( this . domainMarkers != null ) { this . domainMarkers . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . colorBar = axis ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . colorBarLocation = edge ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . gap = gap ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . urlGenerator = generator ; fireChangeEvent () ; }
{ this . toolTipGenerator = generator ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . seriesOutlineStrokeList . setStroke ( series , stroke ) ; fireChangeEvent () ; }
{ this . seriesOutlineStroke = stroke ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . seriesOutlinePaintList . setPaint ( series , paint ) ; fireChangeEvent () ; }
{ this . seriesOutlinePaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . seriesPaintList . setPaint ( series , paint ) ; fireChangeEvent () ; }
{ this . seriesPaint = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . axisLabelGap = gap ; fireChangeEvent () ; }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . maxValue = value ; fireChangeEvent () ; }
{ this . startAngle = angle ; fireChangeEvent () ; }
{ this . headPercent = percent ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . webFilled = flag ; fireChangeEvent () ; }
{ this . darkerSides = darker ; fireChangeEvent () ; }
{ this . depthFactor = factor ; fireChangeEvent () ; }
{ this . gap = gap ; fireChangeEvent () ; }
{ this . columnRadius = r ; fireChangeEvent () ; }
{ this . bulbRadius = r ; fireChangeEvent () ; }
{ this . useSubrangePaint = flag ; fireChangeEvent () ; }
{ this . followDataInSubranges = flag ; fireChangeEvent () ; }
{ this . subrangePaint [ range ] = paint ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . showValueLines = b ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . valuePaint = paint ; fireChangeEvent () ; }
{ this . valueFont = f ; fireChangeEvent () ; }
{ this . axisLocation = location ; fireChangeEvent () ; }
{ this . valueLocation = location ; fireChangeEvent () ; }
if ( this . units != u ) { this . units = u ; fireChangeEvent () ; }
{ if ( paint != null ) { this . thermometerPaint = paint ; fireChangeEvent () ; } }
{ if ( s != null ) { this . thermometerStroke = s ; fireChangeEvent () ; } }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ this . limit = limit ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . renderingHints . put ( RenderingHints.KEY_TEXT_ANTIALIASING , val ) ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ fireChangeEvent () ; }
{ this . datasetToScaleMap . set ( index , new Integer ( scaleIndex ) ) ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
{ result = iterateRangeBounds ( dataset , includeInterval ) ; }
{ result = iterateRangeBounds ( dataset , includeInterval ) ; }
public void datasetChanged ( DatasetChangeEvent event ) { notifyListeners ( event ) ; }
double gap = height - sumOfLabelHeights ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Range r = DatasetUtilities . findRangeBounds ( d , true ) ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
double delta = getTickLength () ;
XYSeries series = new XYSeries ( STRING_CONSTANT , true , false ) ;
{ if ( stroke instanceof BasicStroke ) { setData ( stroke ) ; } else { throw new RuntimeException ( STRING_CONSTANT ) ; } }
double maxWidth = space * getMaximumItemWidth () ;
{ super(); setBaseToolTipGenerator ( toolTipGenerator ) ; setURLGenerator ( urlGenerator ) ; setBaseShapesVisible ( false ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
public Date getUpperDate () { return new Date ( this . upperDate ) ; }
public Date getLowerDate () { return new Date ( this . lowerDate ) ; }
public long getSerialIndex () { return this . time ; }
{ return this . time ; }
public long getMiddleMillisecond () { return this . time ; }
{ return this . time ; }
public long getLastMillisecond () { return this . time ; }
{ return this . time ; }
public long getFirstMillisecond () { return this . time ; }
difference = this . time - t1.time ;
public int hashCode () { return ( int ) this . time ; }
{ FixedMillisecond m = ( FixedMillisecond ) object ; return this . time == m . getFirstMillisecond () ; }
long t = this . time ;
long t = this . time ;
public Date getTime () { return new Date ( this . time ) ; }
{ this . time = time . getTime () ; }
entities != null && isPointInRect ( dataArea , xx , yy )
public Date getEnd () { return new Date ( this . end ) ; }
public Date getStart () { return new Date ( this . start ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
RelativeDateFormat rdf = new RelativeDateFormat ( c0 . getTime () . getTime () ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
long skip
if ( pointCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( periodCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
setChart ( chart ) ;
setLayout ( layout ) ;
setLayout ( layout ) ;
setLayout ( layout ) ;
{ this ( parent , style ) ; setColor ( color ) ; }
if ( dataset != null ) { setDataset ( dataset ) ; }
Paint paint = lookupSectionPaint ( key ) ;
Paint paint = lookupSectionPaint ( key ) ;
Paint paint = lookupSectionPaint ( key ) ;
EventListener listener
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( this . gridBandAlternatePaint ) ; }
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( this . gridBandAlternatePaint ) ; }
this . autoPopulateSeriesStroke = true ;
g2 . setPaint ( renderer . getShadowPaint () ) ;
Paint paint = renderer . getItemOutlinePaint ( row , column ) ;
g2 . setPaint ( renderer . getShadowPaint () ) ;
new Object [] { new Integer ( - s - NUMBER_CONSTANT ) , new Double ( negBase ) }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
TimeZone zone
{ if ( this . year < Year.MAXIMUM_YEAR ) { return new Year ( this . year + NUMBER_CONSTANT ) ; } else { return null ; } }
if ( ( year < Year.MINIMUM_YEAR ) || ( year > Year.MAXIMUM_YEAR ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + year + STRING_CONSTANT ) ; }
{ return createStandardDateTickUnits ( TimeZone . getDefault () , Locale . getDefault () ) ; }
Calendar calendar = Calendar . getInstance ( this . timeZone , this . locale ) ;
Calendar calendar = Calendar . getInstance ( this . timeZone , this . locale ) ;
assertEquals ( true , r . getAutoPopulateSeriesStroke () ) ;
if ( item == s . getLastItemIndex () ) { drawFirstPassShape ( g2 , pass , series , item , s.seriesPath ) ; }
setMinorTickCount ( NUMBER_CONSTANT ) ;
{ this . minorTickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . minorTickMarkInsideLength = length ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . tickMarkStroke = stroke ; fireChangeEvent () ; }
{ this . tickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . tickMarkInsideLength = length ; fireChangeEvent () ; }
if ( flag != this . tickMarksVisible ) { this . tickMarksVisible = flag ; fireChangeEvent () ; }
{ this . tickLabelInsets = insets ; fireChangeEvent () ; }
fireChangeEvent () ;
{ this . tickLabelFont = font ; fireChangeEvent () ; }
if ( flag != this . minorTickMarksVisible ) { this . minorTickMarksVisible = flag ; fireChangeEvent () ; }
if ( flag != this . tickLabelsVisible ) { this . tickLabelsVisible = flag ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
{ this . axisLineVisible = visible ; fireChangeEvent () ; }
{ this . labelAngle = angle ; fireChangeEvent () ; }
{ this . labelInsets = insets ; if ( notify ) { fireChangeEvent () ; } }
fireChangeEvent () ;
{ this . labelFont = font ; fireChangeEvent () ; }
if ( flag != this . visible ) { this . visible = flag ; fireChangeEvent () ; }
catch ( Exception e ) { e . printStackTrace () ; }
public static Test suite () { return new TestSuite ( SubCategoryAxisTests . class ) ; }
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
renderer1 . setBaseToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
ResourceBundle resources = ResourceBundleWrapper . getBundle ( baseResourceClass ) ;
this . shell . setText ( ResourceBundleWrapper . getBundle ( STRING_CONSTANT ) . getString ( STRING_CONSTANT ) ) ;
ResourceBundle resources = ResourceBundleWrapper . getBundle ( baseName ) ;
result = NUMBER_CONSTANT * result + this . unitType . hashCode () ;
TimeSeries overwritten = new TimeSeries ( STRING_CONSTANT + getKey () ) ;
{ throw new SeriesException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ this ( name , DEFAULT_DOMAIN_DESCRIPTION , DEFAULT_RANGE_DESCRIPTION ) ; }
drawZoomRectangle ( g2 , ! this . useBuffer ) ;
if ( ! this . useBuffer ) { drawZoomRectangle ( g2 , true ) ; }
{ return this . zoomFillPaint ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
return new Color ( g , g , g , this . alpha ) ;
this . shadowsVisible = getDefaultShadowsVisible () ;
this . shadowsVisible = getDefaultShadowsVisible () ;
if ( dataset == null ) { return null ; }
Calendar calendar = Calendar . getInstance ( zone , locale ) ;
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Paint paint = renderer . getItemOutlinePaint ( row , column ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( this . gridStrokeSample , this . availableStrokeSamples ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( this . outlineStrokeSample , this . availableStrokeSamples ) ;
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( label , first , last , TimeZone . getDefault () , Locale . getDefault () ) ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
TimeSeries result = new TimeSeries ( name ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT ) ;
calendar . add ( unit . getCalendarField () , unit . getMultiple () ) ;
public boolean isOutlineVisible () { return this . outlineVisible ; }
{ return this . maxY ; }
{ return this . minY ; }
{ return this . maxX ; }
{ return this . minX ; }
clone.zValues = DataUtilities . clone ( this . zValues ) ;
public Stroke getLabelOutlineStroke () { return this . labelOutlineStroke ; }
s1 . updateByIndex ( NUMBER_CONSTANT , new Double ( NUMBER_CONSTANT ) ) ;
s1 . updateByIndex ( NUMBER_CONSTANT , new Double ( - NUMBER_CONSTANT ) ) ;
rangeAxis . resizeRange2 ( factor , anchorY ) ;
rangeAxis . resizeRange2 ( factor , anchorY ) ;
domainAxis . resizeRange2 ( factor , anchorX ) ;
{ return STRING_CONSTANT + ImageMapUtilities . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ if ( ! Double . isNaN ( hiY ) ) { result = Math . max ( result , hiY ) ; } }
this . domainAxis . resizeRange2 ( factor , anchorX ) ;
{ this ( renderer , false ) ; }
this . rangePannable = false ;
( mods & this . panMask ) == this . panMask
if ( entities != null ) { addEntity ( entities , hotspot , dataset , row , column , x1 , y1 ) ; }
public NumberAxis3D ( String label ) { super ( label ) ; }
this . stripOutlineVisible = true ;
TimeSeries series = new TimeSeries ( name ) ;
catch ( Exception e ) { e . printStackTrace () ; success = false ; }
Line2D line = new Line2D.Double ( startX , startY , arrowBaseX , arrowBaseY ) ;
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( this . powerLabel ) ; }
{ this . legendShapeList . setShape ( series , shape ) ; fireChangeEvent () ; }
{ return this . legendShapeList . getShape ( series ) ; }
return result ;
double ol ;
double transY0 ;
Paint seriesPaint ;
double value ;
Rectangle2D titleArea ;
double x0 ;
TimeSeriesDataItem item = series . getRawDataItem ( i ) ;
{ return getRawDataItem ( index ) . getValue () ; }
{ return getRawDataItem ( index ) . getPeriod () ; }
XYDataItem item = getRawDataItem ( index ) ;
{ return getRawDataItem ( index ) . getY () ; }
{ return getRawDataItem ( index ) . getX () ; }
catch ( Exception e ) { e . printStackTrace () ; }
{ return ( double [] ) this . coefficients . clone () ; }
catch ( Exception e ) { e . printStackTrace () ; }
double maxRadius = plot . getAxis () . getUpperBound () ;
{ return getDataset ( NUMBER_CONSTANT ) ; }
fireDatasetChanged () ;
catch ( Exception e ) { e . printStackTrace () ; }
Line2D line = new Line2D.Double ( startX , startY , arrowBaseX , arrowBaseY ) ;
{ super ( info ) ; this . area = new GeneralPath () ; this . line = new Line2D.Double () ; }
{ this . shapesVisible = shapesVisible ; fireChangeEvent () ; }
JPopupMenu result = new JPopupMenu ( localizationResources . getString ( STRING_CONSTANT ) + STRING_CONSTANT ) ;
String text = localizationResources . getString ( STRING_CONSTANT ) ;
public boolean isCounterClockwise () { return this . counterClockwise ; }
public double getAngleOffset () { return this . angleOffset ; }
getSectionOutlinesVisible () && outlinePaint != null && outlineStroke != null
{ Object c1 = new XYSeriesCollection () ; assertTrue ( c1 instanceof PublicCloneable ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; assertTrue ( false ) ; return; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () ) ; }
this . shadowGenerator = null ;
this . shadowGenerator = null ;
this . maxY = maxIgnoreNaN ( this . maxY , yy ) ;
if ( ! file . exists () ) { throw new ServletException ( STRING_CONSTANT + filename + STRING_CONSTANT ) ; }
public boolean isRadiusMinorGridlinesVisible () { return this . radiusMinorGridlinesVisible ; }
assertTrue ( true ) ;
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( Exception e ) { fail ( e . toString () ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
catch ( CloneNotSupportedException e ) { fail ( STRING_CONSTANT ) ; return; }
result = Range . combineIgnoringNaN ( result , r ) ;
boolean include ;
{ setItemLabelsVisible ( Boolean . valueOf ( visible ) ) ; }
{ setBaseItemLabelsVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesItemLabelsVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setSeriesShapesFilled ( series , Boolean . valueOf ( flag ) ) ; }
{ setShapesFilled ( Boolean . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setShapesVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setLinesVisible ( Boolean . valueOf ( visible ) ) ; }
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return c . getTimeInMillis () ;
return c . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
return calendar . getTimeInMillis () ;
if ( dimension > NUMBER_CONSTANT ) { space . add ( dimension , edge ) ; return space ; }
return c . getTimeInMillis () - NUMBER_CONSTANT ;
if ( counterClockwise ) { angleDegrees = - angleDegrees ; }
if ( sectionKeys . isEmpty () ) { return; }
{ this . stepped = stepped ; }
{ this . paletteName = paletteName ; }
catch ( Exception e ) { fail ( e . getMessage () ) ; }
catch ( CloneNotSupportedException e ) { fail ( e . getMessage () ) ; }
LegendItem result ;
if ( this . data . isEmpty () ) { return; }
ValueAxis valueAxis ;
double dim ;
Line2D line ;
Line2D line ;
boolean paintLine ;
ValueAxis valueAxis ;
ValueAxis valueAxis ;
Range adjusted ;
AxisState state ;
Rectangle2D bounds ;
CategoryToolTipGenerator result ;
try { clone = super . clone () ; } catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; }
Range adjusted ;
EntityBlockParams ebp ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator ;
int result ;
catch ( CloneNotSupportedException e ) { throw new RuntimeException ( e ) ; }
public void valueBound ( HttpSessionBindingEvent event ) {}
public void init ( ) throws ServletException {}
float l ;
double result ;
catch ( Exception e ) { throw new RuntimeException ( e ) ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () ) ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
double result ;
{ this . labelInfo = info ; fireChangeEvent () ; }
{ this . minorTickMarkOutsideLength = length ; fireChangeEvent () ; }
{ this . minorTickMarkInsideLength = length ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ this . minorTickMarksVisible = visible ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
this . dateFormat = ( DateFormat ) dateFormat . clone () ;
{ this . categoryLabelToolTips . clear () ; fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
{ this . maximumCategoryLabelWidthRatio = ratio ; fireChangeEvent () ; }
{ this . maximumCategoryLabelLines = lines ; fireChangeEvent () ; }
{ this . categoryMargin = margin ; fireChangeEvent () ; }
{ this . upperMargin = margin ; fireChangeEvent () ; }
{ this . lowerMargin = margin ; fireChangeEvent () ; }
Range adjusted ;
{ this . minorTickCount = count ; fireChangeEvent () ; }
{ this . standardTickUnits = source ; fireChangeEvent () ; }
{ this . autoTickUnitSelection = flag ; if ( notify ) { fireChangeEvent () ; } }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
fireChangeEvent () ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
if ( this . inverted != flag ) { this . inverted = flag ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
{ this . negativeArrowVisible = visible ; fireChangeEvent () ; }
{ this . positiveArrowVisible = visible ; fireChangeEvent () ; }
if ( this . verticalTickLabels != flag ) { this . verticalTickLabels = flag ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
if ( this . gridBandsVisible != flag ) { this . gridBandsVisible = flag ; fireChangeEvent () ; }
{ this . numberFormatOverride = formatter ; fireChangeEvent () ; }
if ( notify ) { fireChangeEvent () ; }
fireChangeEvent () ;
fireChangeEvent () ;
Date result ;
public int hashCode () { return super . hashCode () ; }
assertSame ( url2 , url1 ) ;
assertSame ( tt2 , tt ) ;
assertSame ( url2 , url1 ) ;
assertSame ( tt2 , tt ) ;
{ return ChartFactory . createPieChart3D ( STRING_CONSTANT , dataset ) ; }
return ChartFactory . createPieChart ( STRING_CONSTANT , data ) ;
{ return createXYAreaChart ( title , xAxisLabel , yAxisLabel , dataset , PlotOrientation.VERTICAL , true , true , false ) ; }
try { series2 . setKey ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {}
this . maxY = maxIgnoreNaN ( this . maxY , yy ) ;
double gap = NUMBER_CONSTANT ;
Date result ;
Line2D line ;
Line2D line ;
boolean paintLine ;
CategoryAxis axis ;
RectangleEdge result ;
ItemLabelPosition position ;
ItemLabelPosition position ;
( float ) regions [ NUMBER_CONSTANT ] . getMaxY ()
double result ;
StringBuilder tag = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator ;
ItemLabelPosition position ;
Shape box ;
Shape box ;
ItemLabelPosition position ;
double space ;
int historyIdx ;
Range result ;
String result ;
double startX ;
BlockContainer result ;
DrawingSupplier result ;
String label ;
Arc2D notch ;
int izV ;
int izV ;
boolean paintLine ;
boolean include ;
double space ;
double yyAverage ;
double aRadius ;
int series ;
int series ;
double rectWidth ;
double rectHeight ;
Line2D line ;
Line2D line ;
Paint p ;
boolean visible ;
@ Ignore
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { @ Override public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
boolean success ;
new Rectangle2D.Double ( Math . min ( x1 , x2 ) , dataArea . getMinY () , Math . abs ( x2 - x1 ) , dataArea . getHeight () )
return directions [ index ] ;
{ if ( y <= this . minY || y >= this . maxY ) { updateMinMaxYByIteration () ; } }
updateMinMaxYByIteration () ;
if ( removed ) { updateMinMaxYByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
if ( removed ) { updateMinMaxYByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
{ updateMinMaxYByIteration () ; }
{ updateMinMaxYByIteration () ; }
Line2D extendedSeparator = LineUtilities . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
setRange ( calculateValueNoINF ( log1 ) , calculateValueNoINF ( log2 ) ) ;
{ this . attributedLabels . put ( section , label ) ; }
{ super ( labelFormat , numberFormat , percentFormat ) ; this . attributedLabels = new HashMap () ; }
CategoryPlot p2 ;
CategoryPlot p2 ;
CategoryPlot p2 ;
this . datasets . put ( index , dataset ) ;
this . rangeAxisLocations . put ( index , location ) ;
int result = findRangeAxisIndex ( axis ) ;
this . rangeAxes . put ( index , axis ) ;
this . domainAxisLocations . put ( index , location ) ;
this . domainAxes . put ( index , axis ) ;
{ this . toolTipGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . toolTipGeneratorMap . get ( series ) ; }
{ this . itemLabelGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . itemLabelGeneratorMap . get ( series ) ; }
{ this . legendTextFontMap . put ( series , font ) ; fireChangeEvent () ; }
{ return this . legendTextFontMap . get ( series ) ; }
{ this . negativeItemLabelPositionMap . put ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . positiveItemLabelPositionMap . put ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . itemLabelFontMap . put ( series , font ) ; if ( notify ) { fireChangeEvent () ; } }
{ return this . itemLabelFontMap . get ( series ) ; }
{ this . itemURLGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ this . toolTipGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
{ return this . toolTipGeneratorMap . get ( series ) ; }
{ this . itemLabelGeneratorMap . put ( series , generator ) ; fireChangeEvent () ; }
int result = findRangeAxisIndex ( axis ) ;
int result = findDomainAxisIndex ( axis ) ;
this . renderers . put ( index , renderer ) ;
this . datasets . put ( index , dataset ) ;
this . rangeAxisLocations . put ( index , location ) ;
this . rangeAxes . put ( index , axis ) ;
this . rangeAxes . put ( NUMBER_CONSTANT , axis ) ;
this . domainAxisLocations . put ( index , location ) ;
this . domainAxes . put ( index , axis ) ;
try { copy . add ( clone ) ; } catch ( SeriesException e ) { throw new RuntimeException ( e ) ; }
if ( nDataPoints > this . valueHistory . length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
try { copy . add ( clone ) ; } catch ( SeriesException e ) { throw new RuntimeException ( STRING_CONSTANT , e ) ; }
{ super ( null , null , rangeAxis , null ) ; this . subplots = new java.util.ArrayList < XYPlot > () ; }
{ super ( null , domainAxis , null , null ) ; this . subplots = new java.util.ArrayList < XYPlot > () ; }
double adj = percent * length ;
{ return this . fontRenderContext ; }
ChartPanel chartPanel = new ChartPanel ( chart , false ) ;
public FixedMillisecond ( long millisecond ) { this . time = millisecond ; }
int response = JOptionPane . showConfirmDialog ( this , fileExists , localizationResources . getString ( STRING_CONSTANT ) , JOptionPane.OK_CANCEL_OPTION ) ;
int response = JOptionPane . showConfirmDialog ( this , fileExists , localizationResources . getString ( STRING_CONSTANT ) , JOptionPane.OK_CANCEL_OPTION ) ;
XYDataset dataset
ChartPanel panel = new ChartPanel ( chart , false ) ;
ChartPanel panel = new ChartPanel ( chart , false ) ;
this . panel = new ChartPanel ( this . chart , false ) ;
r1 . setBaseLegendTextPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.GREEN ) ) ;
g2 . draw ( new Line2D.Double ( xxMin , yymid - halfW , xxMin , yymid + halfW ) ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . canvas . removeChartMouseListener ( listener ) ; }
if ( ! hasUniqueID ( handler ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + handler . getID () + STRING_CONSTANT ) ; }
this . viewer . hideZoomRectangle () ;
this . viewer . showZoomRectangle ( x , y , w , h ) ;
ValueAxis xAxis = getDomainAxisForDataset ( datasetIndex ) ;
updateCrosshairValues ( crosshairState , x , y , datasetIndex , block . getCenterX () , block . getCenterY () , orientation ) ;
if ( entities != null ) { addEntity ( entities , block , dataset , series , item , transX , transY ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtils . clone ( this . legendLine ) ; }
if ( ! ObjectUtils . equal ( this . additionalItemLabelGenerator , that.additionalItemLabelGenerator ) ) { return false ; }
UIUtils . centerFrameOnScreen ( demo ) ;
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . defaultGroup , that.defaultGroup ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . bounds = ( Rectangle2D ) SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . bounds , stream ) ; }
clone.bounds = ( Rectangle2D ) ShapeUtils . clone ( this . bounds ) ;
if ( ! ObjectUtils . equal ( this . id , that.id ) ) { return false ; }
{ ValueDataset vd = ( ValueDataset ) obj ; return ObjectUtils . equal ( this . value , vd . getValue () ) ; }
UIUtils . centerFrameOnScreen ( demo ) ;
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
clone.items = ( List ) ObjectUtils . deepClone ( this . items ) ;
{ StandardEntityCollection that = ( StandardEntityCollection ) obj ; return ObjectUtils . equal ( this . entities , that.entities ) ; }
Object toAdd = ObjectUtils . deepClone ( entry ) ;
{ anchor = ShapeUtils . getPointInRectangle ( anchor . getX () , anchor . getY () , dataArea ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
clone.legendLine = ShapeUtils . clone ( this . legendLine ) ;
{ setShapesFilled ( Boolean . valueOf ( filled ) ) ; }
UIUtils . centerFrameOnScreen ( demo ) ;
if ( ! ObjectUtils . equal ( this . seriesKey , that.seriesKey ) ) { return false ; }
clone.legendItemShape = ShapeUtils . clone ( this . legendItemShape ) ;
if ( ! ObjectUtils . equal ( this . seriesShapesFilled , that.seriesShapesFilled ) ) { return false ; }
{ this . seriesShapesFilled . setBoolean ( series , Boolean . valueOf ( filled ) ) ; fireChangeEvent () ; }
if ( ! ObjectUtils . equal ( this . drawable , that.drawable ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
Paint paint = SerialUtils . readPaint ( stream ) ;
SerialUtils . writePaint ( paint , stream ) ;
if ( ! PaintUtils . equal ( p1 , p2 ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendArea , that.legendArea ) ) { return false ; }
clone.legendArea = ShapeUtils . clone ( this . legendArea ) ;
{ this . drawShapes = Boolean . valueOf ( this . drawShapesCheckBox . isSelected () ) ; }
{ this . drawLines = Boolean . valueOf ( this . drawLinesCheckBox . isSelected () ) ; }
clone.bins = ( List ) ObjectUtils . deepClone ( this . bins ) ;
if ( this . data != null ) { clone.data = ArrayUtils . clone ( this . data ) ; }
{ if ( ! ShapeUtils . equal ( s1 [ i ] , s2 [ i ] ) ) { return false ; } }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
{ DefaultBoxAndWhiskerCategoryDataset dataset = ( DefaultBoxAndWhiskerCategoryDataset ) obj ; return ObjectUtils . equal ( this . data , dataset.data ) ; }
Shape shadowArc = ShapeUtils . createTranslatedShape ( path , ( float ) shadowXOffset , ( float ) shadowYOffset ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
if ( ! PaintUtils . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . image , that.image ) ) { return false ; }
{ stream . defaultReadObject () ; this . shadowPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . shadowPaint , stream ) ; }
hash = NUMBER_CONSTANT * hash + ObjectUtils . hashCode ( this . seriesKey ) ;
{ stream . defaultReadObject () ; this . subLabelPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . subLabelPaint , stream ) ; }
clone.rows = ( List ) ObjectUtils . deepClone ( this . rows ) ;
if ( ! ObjectUtils . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
{ stream . defaultReadObject () ; this . backgroundPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . backgroundPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
return ObjectUtils . equal ( this . data , that.data ) ;
final Shape shape = ShapeUtils . createTranslatedShape ( getItemShape ( seriesIndex , i ++ ) , x , y ) ;
{ this . seriesFilled . setBoolean ( series , Boolean . valueOf ( filled ) ) ; }
if ( ! ObjectUtils . equal ( this . y , that.y ) ) { return false ; }
{ setSeriesShapesFilled ( series , Boolean . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setShapesVisible ( Boolean . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , Boolean . valueOf ( visible ) ) ; }
{ setLinesVisible ( Boolean . valueOf ( visible ) ) ; }
clone.seriesList = ( List ) ObjectUtils . deepClone ( this . seriesList ) ;
{ MatrixSeriesCollection c = ( MatrixSeriesCollection ) obj ; return ObjectUtils . equal ( this . seriesList , c.seriesList ) ; }
if ( ! PaintUtils . equal ( p1 , p2 ) ) { return false ; }
Paint paint = SerialUtils . readPaint ( in ) ;
Shape rotatedBox = ShapeUtils . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Shape rotatedBox = ShapeUtils . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( ! ObjectUtils . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . formatter , that.formatter ) ) { return false ; }
clone.rangeAxis = ( ValueAxis ) ObjectUtils . clone ( this . rangeAxis ) ;
if ( ! PaintUtils . equal ( this . groupPaint , that.groupPaint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . indexParamName , that.indexParamName ) ) { return false ; }
clone.tasks = ( List ) ObjectUtils . deepClone ( this . tasks ) ;
if ( ! ObjectUtils . equal ( this . formatter , that.formatter ) ) { return false ; }
{ addEntity ( info , ShapeUtils . createLineRegion ( line , NUMBER_CONSTANT ) , rendererIndex , toolTip , url ) ; }
clone.legendLine = ShapeUtils . clone ( this . legendLine ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
clone.legendItemShape = ShapeUtils . clone ( this . legendItemShape ) ;
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
if ( ! ObjectUtils . equal ( getDescription () , that . getDescription () ) ) { return false ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultReadObject () ; this . sublabelPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . sublabelPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . sublabelPaint , that.sublabelPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . chartArea = ( Rectangle2D ) SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . chartArea , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtils . readShape ( stream ) ; }
clone.legendArea = ShapeUtils . clone ( this . legendArea ) ;
if ( ! ShapeUtils . equal ( this . legendArea , that.legendArea ) ) { return false ; }
{ stream . defaultReadObject () ; this . defaultPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . defaultPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . defaultPaint , that.defaultPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . title , that.title ) ) { return false ; }
{ result . put ( key , ObjectUtils . clone ( value ) ) ; }
{ result . add ( ObjectUtils . clone ( obj ) ) ; }
if ( ! ObjectUtils . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . wallPaint , stream ) ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtils . readPaint ( stream ) ; }
if ( ! PaintUtils . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendBar , stream ) ; }
{ stream . defaultReadObject () ; this . legendBar = SerialUtils . readShape ( stream ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendShape , stream ) ; }
{ stream . defaultReadObject () ; this . legendShape = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendShape , that.legendShape ) ) { return false ; }
if ( ! ObjectUtils . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , Boolean . valueOf ( v0 < getBase () ) }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , Boolean . valueOf ( v0 < getBase () ) }
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
if ( ! ObjectUtils . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtils . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( getArea () , stream ) ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
Stroke stroke = SerialUtils . readStroke ( stream ) ;
SerialUtils . writeStroke ( stroke , stream ) ;
if ( ! ObjectUtils . equal ( s1 , s2 ) ) { return false ; }
{ stream . defaultReadObject () ; this . area = SerialUtils . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . area , stream ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
if ( ! ObjectUtils . equal ( this . obj , that.obj ) ) { return false ; }
result = NUMBER_CONSTANT * result + ObjectUtils . hashCode ( this . fillPaint ) ;
if ( ! ObjectUtils . equal ( this . date , that.date ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
result.subplots = ( List ) ObjectUtils . deepClone ( this . subplots ) ;
if ( ! ObjectUtils . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultReadObject () ; this . artifactPaint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . artifactPaint , stream ) ; }
if ( ! PaintUtils . equal ( this . artifactPaint , that.artifactPaint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtils . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtils . readShape ( stream ) ; }
if ( ! ShapeUtils . equal ( this . legendLine , that.legendLine ) ) { return false ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtils . clone ( this . legendLine ) ; }
clone.data = ( List ) ObjectUtils . deepClone ( this . data ) ;
return ObjectUtils . equal ( this . data , that.data ) ;
if ( ! ObjectUtils . equal ( this . key , that.key ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtils . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtils . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtils . equal ( this . paint , that.paint ) ) { return false ; }
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT ) ;
TimeSeries series = new TimeSeries ( STRING_CONSTANT ) ;
TimeSeries s1 = new TimeSeries ( STRING_CONSTANT ) ;
Week w = new Week ( gc . getTime () , zone , Locale.UK ) ;
boolean interval = includeInterval ;
{ this ( label , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateTickUnit a1 = new DateTickUnit ( DateTickUnitType.DAY , NUMBER_CONSTANT ) ;
axis . setTickUnit ( new DateTickUnit ( DateTickUnitType.MONTH , NUMBER_CONSTANT , sdf ) ) ;
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () , Locale . getDefault () ) ; }
{ this . maxItemWidth = percent ; fireChangeEvent () ; }
public double getMaximumItemWidth () { return this . maxItemWidth ; }
setDefaultToolTipGenerator ( toolTipGenerator ) ;
r1 . setDefaultItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
setDefaultToolTipGenerator ( labelGenerator ) ;
r1 . setDefaultPaint ( Color.red ) ;
r1 . setDefaultItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
if ( result == null ) { result = this . defaultLegendTextPaint ; }
if ( result == null ) { result = this . defaultLegendTextFont ; }
if ( result == null ) { result = this . defaultLegendShape ; }
if ( position == null ) { position = this . defaultNegativeItemLabelPosition ; }
if ( position == null ) { position = this . defaultPositiveItemLabelPosition ; }
if ( result == null ) { result = this . defaultItemLabelPaint ; }
if ( result == null ) { result = this . defaultShape ; }
if ( result == null ) { result = this . defaultOutlineStroke ; }
if ( result == null ) { result = this . defaultStroke ; }
if ( seriesOutlinePaint == null ) { seriesOutlinePaint = this . defaultOutlinePaint ; }
if ( seriesFillPaint == null ) { seriesFillPaint = this . defaultFillPaint ; }
if ( generator == null ) { generator = this . defaultToolTipGenerator ; }
if ( generator == null ) { generator = this . defaultItemLabelGenerator ; }
setDefaultToolTipGenerator ( toolTipGenerator ) ;
setDefaultToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( new BoxAndWhiskerToolTipGenerator () ) ;
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYZToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setDefaultToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setDefaultToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setDefaultToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setDefaultToolTipGenerator ( tt ) ;
renderer . setDefaultToolTipGenerator ( toolTipGenerator ) ;
setDefaultToolTipGenerator ( new BoxAndWhiskerXYToolTipGenerator () ) ;
setDefaultLegendShape ( this . legendLine ) ;
renderer1 . setDefaultToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
setDefaultToolTipGenerator ( toolTipGenerator ) ;
if ( generator == null ) { generator = this . defaultItemURLGenerator ; }
if ( result == null ) { result = this . defaultToolTipGenerator ; }
if ( generator == null ) { generator = this . defaultItemLabelGenerator ; }
assertEquals ( Color.GRAY , r . getDefaultOutlinePaint () ) ;
assertEquals ( Color.WHITE , r . getDefaultFillPaint () ) ;
assertEquals ( Color.BLUE , r . getDefaultPaint () ) ;
if ( ! dataAreaHotspot . isEmpty () ) { addEntity ( entities , dataAreaHotspot , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( entities != null ) { addEntity ( entities , hotspot , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
{ this ( new RectangleInsets ( top , left , bottom , right ) , Color.BLACK ) ; }
chart . setBackgroundPaint ( Color.WHITE ) ;
this . noDataMessagePaint = Color.BLACK ;
public DialBackground () { this ( Color.WHITE ) ; }
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) , new BasicStroke ( NUMBER_CONSTANT ) )
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) , new BasicStroke ( NUMBER_CONSTANT ) )
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.BLACK ) ;
public StandardDialRange () { this ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ; }
g2 . setPaint ( Color.GRAY ) ;
p1 . setSubrangePaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
baseline . setPaint ( Color.BLACK ) ;
{ this ( label , Color.BLACK ) ; }
this . arrowPaint = Color.BLACK ;
{ this ( x0 , y0 , x1 , y1 , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
{ this ( x1 , y1 , x2 , y2 , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
this . arrowPaint = Color.BLACK ;
a1 . setAxisLinePaint ( Color.RED ) ;
this . outlinePaint = Color.BLACK ;
{ this ( shape , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
{ this ( polygon , new BasicStroke ( NUMBER_CONSTANT ) , Color.BLACK ) ; }
g2 . setPaint ( Color.BLACK ) ;
this . sublabelPaint = Color.BLACK ;
this . labelPaint = Color.BLACK ;
public Crosshair ( double value ) { this ( value , Color.BLACK , new BasicStroke ( NUMBER_CONSTANT ) ) ; }
LegendGraphic g1 = new LegendGraphic ( r , Color.BLACK ) ;
LegendGraphic g1 = new LegendGraphic ( r , Color.BLACK ) ;
g2 . setColor ( Color.BLACK ) ;
this . defaultSectionPaint = Color.GRAY ;
this . paint = Color.BLACK ;
g2 . setPaint ( Color.BLUE ) ;
{ super ( datasetIndex ) ; this . paint = Color.RED ; this . stroke = new BasicStroke ( NUMBER_CONSTANT , BasicStroke.CAP_ROUND , BasicStroke.JOIN_BEVEL ) ; }
this . axisLinePaint = Color.BLACK ;
this . shadowPaint = Color.GRAY ;
this . artifactPaint = Color.BLACK ;
ObjectInputStream stream
ObjectOutputStream stream
Graphics2D g2
TextBlock block
double offset
double offset
Paint paint
Paint paint
RectangleInsets gap
Stroke stroke
Paint paint
ObjectInputStream stream
ObjectOutputStream stream
this . boxPaint = Color.GREEN ;
Graphics2D g2
TextUtils . drawAlignedString ( valueStr , g2 , x , y , TextAnchor.TOP_CENTER ) ;
Rectangle2D tickLabelBounds = TextUtils . getTextBounds ( tickLabel , g2 , fm ) ;
{ FontMetrics fm = g2 . getFontMetrics ( getLabelFont () ) ; bounds = TextUtils . getTextBounds ( axisLabel , g2 , fm ) ; }
Rectangle2D bounds = TextUtils . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D r = TextUtils . getTextBounds ( text , g2 , fm ) ;
if ( tick . getText () != null ) { labelBounds = TextUtils . getTextBounds ( tick . getText () , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtils . getTextBounds ( tick . getText () , g2 , fm ) ; }
this . label = TextUtils . createTextBlock ( this . text , font , this . paint ) ;
this . label = TextUtils . createTextBlock ( text , font , this . paint ) ;
Rectangle2D r = TextUtils . getTextBounds ( this . internalMarkerCycleBoundTick . getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( this . text , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
TextUtils . drawRotatedString ( label , g2 , xx , yy , TextAnchor.CENTER , NUMBER_CONSTANT , TextAnchor.CENTER ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( label , g2 , fm ) ;
Rectangle2D bounds = getTextBounds ( text , g2 , fm ) ;
public DefaultShadowGenerator () { this ( NUMBER_CONSTANT , Color.BLACK , NUMBER_CONSTANT , NUMBER_CONSTANT , - Math.PI / NUMBER_CONSTANT ) ; }
Paint paint
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.BLACK ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
f1 . setBackgroundPaint ( Color.BLUE ) ;
r1 . setDefaultPaint ( Color.RED ) ;
a1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
p1 . setAggregatedItemsPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ) ;
new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW )
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
this . gridPaintSample = new PaintSample ( Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.RED , Color.BLUE , false ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.RED , Color.BLUE , false ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED ) ;
a1 . setSubLabelPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
Color defaultColor = ( p instanceof Color ? ( Color ) p : Color.BLUE ) ;
a1 . setTickLabelPaint ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
r1 . setShapePaint ( Color.RED ) ;
this . downPaint = Color.RED ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
this . paint = Color.RED ;
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
a1 . setOutlinePaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.BLUE ) ;
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
new BlockBorder ( new RectangleInsets ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) )
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) ;
r1 . setSeriesPaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.YELLOW ) ) ;
{ this ( label , range , Color.YELLOW , new BasicStroke ( NUMBER_CONSTANT ) , null ) ; }
g2 . setPaint ( Color.BLUE ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.BLUE ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.RED , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.WHITE ) ) ;
this . incompletePaint = Color.RED ;
this . zoomOutlinePaint = Color.BLUE ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
@ Override public int hashCode () { return HashUtils . hashCodeForDoubleArray ( this . coefficients ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . radius ) ; return result ; }
{ return HashUtils . hashCode ( super . hashCode () , this . stepPoint ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . visible ) ; return result ; }
result = result * NUMBER_CONSTANT + HashUtils . hashCodeForPaint ( this . arrowPaint ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . formatPattern ) ; return result ; }
{ int result = NUMBER_CONSTANT ; result = HashUtils . hashCode ( result , this . formatPattern ) ; return result ; }
{ int result = super . hashCode () ; result = HashUtils . hashCode ( result , this . isArrowAtTop ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
{ int result = super . hashCode () ; result = HashUtils . hashCode ( result , this . key ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . arrowPaint ) ;
{ int hash = super . hashCode () ; hash = HashUtils . hashCode ( hash , this . errorIndicatorPaint ) ; return hash ; }
result = NUMBER_CONSTANT * result + HashUtils . hashCodeForPaint ( this . paint ) ;
ChartUtils . saveChartAsJPEG ( tempFile , chart , width , height , info ) ;
ChartUtils . saveChartAsPNG ( tempFile , chart , width , height , info ) ;
{ return STRING_CONSTANT + ImageMapUtils . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return ImageMapUtils . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ; }
{ writer . println ( ImageMapUtils . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ) ; }
ImageMapUtils . writeImageMap ( writer , name , info , toolTipTagFragmentGenerator , new StandardURLTagFragmentGenerator () ) ;
{ return STRING_CONSTANT + ImageMapUtils . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
Line2D extendedSeparator = LineUtils . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
visible = LineUtils . clipLine ( state.workingLine , dataArea ) ;
boolean visible = LineUtils . clipLine ( line , dataArea ) ;
boolean visible = LineUtils . clipLine ( line , dataArea ) ;
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( dataset , getBase () ) ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( dataset ) ; }
! DatasetUtils . isEmptyOrNull ( dataset )
Range range = DatasetUtils . findDomainBounds ( this . dataset , false ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DatasetUtils . calculateStackTotal ( ( TableXYDataset ) dataset , item ) ; value = value / total ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtils . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; }
{ if ( dataset != null ) { return DatasetUtils . findRangeBounds ( dataset , true ) ; } else { return null ; } }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtils . iterateDomainBounds ( this , includeInterval ) ; } }
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
boolean hasData = ! DatasetUtils . isEmptyOrNull ( currentDataset ) ;
Range r = DatasetUtils . findRangeBounds ( d , true ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ final XYDataset dataset = plot . getDataset ( i ) ; if ( ! DatasetUtils . isEmptyOrNull ( dataset ) ) { return false ; } }
! DatasetUtils . isEmptyOrNull ( this . dataset )
double total = DatasetUtils . calculatePieDatasetTotal ( dataset ) ;
double totalValue = DatasetUtils . calculatePieDatasetTotal ( this . dataset ) ;
! DatasetUtils . isEmptyOrNull ( this . dataset )
if ( this . dataset != null ) { state . setTotal ( DatasetUtils . calculatePieDatasetTotal ( plot . getDataset () ) ) ; }
{ if ( dataset != null ) { return DatasetUtils . findZBounds ( dataset ) ; } else { return null ; } }
Range r = DatasetUtils . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtils . findDomainBounds ( dataset , false ) ;
{ if ( dataset != null ) { return DatasetUtils . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; } else { return null ; } }
Range r = DatasetUtils . findStackedRangeBounds ( dataset , this . seriesToGroupMap ) ;
if ( d != null ) { result = Range . combine ( result , DatasetUtils . findRangeBounds ( d ) ) ; }
! DatasetUtils . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
Range r = DatasetUtils . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtils . findDomainBounds ( dataset , false ) ;
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtils . iterateDomainBounds ( this , includeInterval ) ; } }
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtils . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DataUtils . calculateColumnTotal ( dataset , column , state . getVisibleSeriesArray () ) ; value = value / total ; }
{ this ( DataUtils . createNumberArray2D ( starts ) , DataUtils . createNumberArray2D ( ends ) ) ; }
clone.zValues = DataUtils . clone ( this . zValues ) ;
if ( ! DataUtils . equal ( this . zValues , that.zValues ) ) { return false ; }
double total = DataUtils . calculateColumnTotal ( dataset , column ) ;
if ( this . renderAsPercentages ) { total = DataUtils . calculateColumnTotal ( dataset , index , validRows ) ; }
OHLCItem item2 = ( OHLCItem ) TestUtils . serialised ( item1 ) ;
XYLineAnnotation a2 = ( XYLineAnnotation ) TestUtils . serialised ( a1 ) ;
Hour h2 = ( Hour ) TestUtils . serialised ( h1 ) ;
CustomXYToolTipGenerator g2 = ( CustomXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
BoxAndWhiskerToolTipGenerator g2 = ( BoxAndWhiskerToolTipGenerator ) TestUtils . serialised ( g1 ) ;
StandardCategoryToolTipGenerator g2 = ( StandardCategoryToolTipGenerator ) TestUtils . serialised ( g1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtils . serialised ( r1 ) ;
XYTaskDataset d2 = ( XYTaskDataset ) TestUtils . serialised ( d1 ) ;
ClusteredXYBarRenderer r2 = ( ClusteredXYBarRenderer ) TestUtils . serialised ( r1 ) ;
YInterval i2 = ( YInterval ) TestUtils . serialised ( i1 ) ;
XYBubbleRenderer r2 = ( XYBubbleRenderer ) TestUtils . serialised ( r1 ) ;
WindItemRenderer r2 = ( WindItemRenderer ) TestUtils . serialised ( r1 ) ;
LineNeedle n2 = ( LineNeedle ) TestUtils . serialised ( n1 ) ;
SpiderWebPlot p2 = ( SpiderWebPlot ) TestUtils . serialised ( p1 ) ;
assertFalse ( TestUtils . containsInstanceOf ( ec . getEntities () , XYItemEntity . class ) ) ;
StandardXYItemRenderer r2 = ( StandardXYItemRenderer ) TestUtils . serialised ( r1 ) ;
DateTickMarkPosition p2 = ( DateTickMarkPosition ) TestUtils . serialised ( p1 ) ;
DialValueIndicator i2 = ( DialValueIndicator ) TestUtils . serialised ( i1 ) ;
XIntervalSeriesCollection c2 = ( XIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
CategoryAxis a2 = ( CategoryAxis ) TestUtils . serialised ( a1 ) ;
PiePlot p2 = ( PiePlot ) TestUtils . serialised ( p1 ) ;
NumberTickUnit t2 = ( NumberTickUnit ) TestUtils . serialised ( t1 ) ;
XYDrawableAnnotation a2 = ( XYDrawableAnnotation ) TestUtils . serialised ( a1 ) ;
IntervalCategoryItemLabelGenerator g2 = ( IntervalCategoryItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
ItemLabelAnchor a2 = ( ItemLabelAnchor ) TestUtils . serialised ( a1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtils . serialised ( p1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtils . serialised ( p1 ) ;
TimePeriodValues s2 = ( TimePeriodValues ) TestUtils . serialised ( s1 ) ;
CategoryToPieDataset d2 = ( CategoryToPieDataset ) TestUtils . serialised ( d1 ) ;
Vector v2 = ( Vector ) TestUtils . serialised ( v1 ) ;
WaterfallBarRenderer r2 = ( WaterfallBarRenderer ) TestUtils . serialised ( r1 ) ;
XYIntervalSeries s2 = ( XYIntervalSeries ) TestUtils . serialised ( s1 ) ;
XYInterval i2 = ( XYInterval ) TestUtils . serialised ( i1 ) ;
HighLowRenderer r2 = ( HighLowRenderer ) TestUtils . serialised ( r1 ) ;
CombinedDomainCategoryPlot plot2 = ( CombinedDomainCategoryPlot ) TestUtils . serialised ( plot1 ) ;
LabelBlock b2 = ( LabelBlock ) TestUtils . serialised ( b1 ) ;
DeviationRenderer r2 = ( DeviationRenderer ) TestUtils . serialised ( r1 ) ;
PowerFunction2D f2 = ( PowerFunction2D ) TestUtils . serialised ( f1 ) ;
StandardTickUnitSource t2 = ( StandardTickUnitSource ) TestUtils . serialised ( t1 ) ;
Minute m2 = ( Minute ) TestUtils . serialised ( m1 ) ;
PieSectionEntity e2 = ( PieSectionEntity ) TestUtils . serialised ( e1 ) ;
CombinedRangeCategoryPlot plot2 = ( CombinedRangeCategoryPlot ) TestUtils . serialised ( plot1 ) ;
StandardXYZToolTipGenerator g2 = ( StandardXYZToolTipGenerator ) TestUtils . serialised ( g1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtils . serialised ( m1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtils . serialised ( m1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtils . serialised ( p1 ) ;
DefaultKeyedValues v2 = ( DefaultKeyedValues ) TestUtils . serialised ( v1 ) ;
LayeredBarRenderer r2 = ( LayeredBarRenderer ) TestUtils . serialised ( r1 ) ;
BoxAndWhiskerXYToolTipGenerator g2 = ( BoxAndWhiskerXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
TimeTableXYDataset d2 = ( TimeTableXYDataset ) TestUtils . serialised ( d1 ) ;
Quarter q2 = ( Quarter ) TestUtils . serialised ( q1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtils . serialised ( c1 ) ;
PlumNeedle n2 = ( PlumNeedle ) TestUtils . serialised ( n1 ) ;
SlidingCategoryDataset d2 = ( SlidingCategoryDataset ) TestUtils . serialised ( d1 ) ;
GanttRenderer r2 = ( GanttRenderer ) TestUtils . serialised ( r1 ) ;
LongNeedle n2 = ( LongNeedle ) TestUtils . serialised ( n1 ) ;
StackedXYAreaRenderer r2 = ( StackedXYAreaRenderer ) TestUtils . serialised ( r1 ) ;
BorderArrangement b2 = ( BorderArrangement ) TestUtils . serialised ( b1 ) ;
StandardDialFrame f2 = ( StandardDialFrame ) TestUtils . serialised ( f1 ) ;
ItemLabelPosition p2 = ( ItemLabelPosition ) TestUtils . serialised ( p1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtils . serialised ( b1 ) ;
CategoryAnchor a2 = ( CategoryAnchor ) TestUtils . serialised ( a1 ) ;
XYShapeRenderer r2 = ( XYShapeRenderer ) TestUtils . serialised ( r1 ) ;
XYBarDataset bd2 = ( XYBarDataset ) TestUtils . serialised ( bd1 ) ;
VectorRenderer r2 = ( VectorRenderer ) TestUtils . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtils . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtils . serialised ( r1 ) ;
CategoryLabelEntity e2 = ( CategoryLabelEntity ) TestUtils . serialised ( e1 ) ;
PlotOrientation orientation2 = ( PlotOrientation ) TestUtils . serialised ( orientation1 ) ;
CategoryLabelWidthType w2 = ( CategoryLabelWidthType ) TestUtils . serialised ( w1 ) ;
XYIntervalSeriesCollection c2 = ( XYIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
StandardXYURLGenerator g2 = ( StandardXYURLGenerator ) TestUtils . serialised ( g1 ) ;
XYIntervalDataItem item2 = ( XYIntervalDataItem ) TestUtils . serialised ( item1 ) ;
CategoryItemEntity e2 = ( CategoryItemEntity ) TestUtils . serialised ( e1 ) ;
PolynomialFunction2D f2 = ( PolynomialFunction2D ) TestUtils . serialised ( f1 ) ;
StatisticalLineAndShapeRenderer r2 = ( StatisticalLineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
DefaultPieDataset d2 = ( DefaultPieDataset ) TestUtils . serialised ( d1 ) ;
DateTick t2 = ( DateTick ) TestUtils . serialised ( t1 ) ;
ShipNeedle n2 = ( ShipNeedle ) TestUtils . serialised ( n1 ) ;
XYDataItem i2 = ( XYDataItem ) TestUtils . serialised ( i1 ) ;
GradientBarPainter p2 = ( GradientBarPainter ) TestUtils . serialised ( p1 ) ;
StandardDialRange r2 = ( StandardDialRange ) TestUtils . serialised ( r1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtils . serialised ( m1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtils . serialised ( m1 ) ;
LogFormat f2 = ( LogFormat ) TestUtils . serialised ( f1 ) ;
StackedBarRenderer r2 = ( StackedBarRenderer ) TestUtils . serialised ( r1 ) ;
OHLCSeries s2 = ( OHLCSeries ) TestUtils . serialised ( s1 ) ;
DefaultIntervalCategoryDataset d2 = ( DefaultIntervalCategoryDataset ) TestUtils . serialised ( d1 ) ;
MyComparableObjectSeries s2 = ( MyComparableObjectSeries ) TestUtils . serialised ( s1 ) ;
VectorSeriesCollection c2 = ( VectorSeriesCollection ) TestUtils . serialised ( c1 ) ;
IntervalBarRenderer r2 = ( IntervalBarRenderer ) TestUtils . serialised ( r1 ) ;
KeyedValuesDataset d2 = ( KeyedValuesDataset ) TestUtils . serialised ( d1 ) ;
DialCap c2 = ( DialCap ) TestUtils . serialised ( c1 ) ;
PointerNeedle n2 = ( PointerNeedle ) TestUtils . serialised ( n1 ) ;
DateAxis a2 = ( DateAxis ) TestUtils . serialised ( a1 ) ;
IntervalCategoryToolTipGenerator g2 = ( IntervalCategoryToolTipGenerator ) TestUtils . serialised ( g1 ) ;
XYItemEntity e2 = ( XYItemEntity ) TestUtils . serialised ( e1 ) ;
FixedMillisecond m2 = ( FixedMillisecond ) TestUtils . serialised ( m1 ) ;
DefaultOHLCDataset d2 = ( DefaultOHLCDataset ) TestUtils . serialised ( d1 ) ;
SymbolicXYItemLabelGenerator g2 = ( SymbolicXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
LevelRenderer r2 = ( LevelRenderer ) TestUtils . serialised ( r1 ) ;
PeriodAxis a2 = ( PeriodAxis ) TestUtils . serialised ( a1 ) ;
DatasetGroup g2 = ( DatasetGroup ) TestUtils . serialised ( g1 ) ;
Axis a2 = ( Axis ) TestUtils . serialised ( a1 ) ;
VectorDataItem v2 = ( VectorDataItem ) TestUtils . serialised ( v1 ) ;
StandardCategoryItemLabelGenerator g2 = ( StandardCategoryItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
KeyToGroupMap m2 = ( KeyToGroupMap ) TestUtils . serialised ( m1 ) ;
MatrixSeriesCollection c2 = ( MatrixSeriesCollection ) TestUtils . serialised ( c1 ) ;
Year y2 = ( Year ) TestUtils . serialised ( y1 ) ;
XYStepRenderer r2 = ( XYStepRenderer ) TestUtils . serialised ( r1 ) ;
SimpleTimePeriod p2 = ( SimpleTimePeriod ) TestUtils . serialised ( p1 ) ;
DefaultMultiValueCategoryDataset d2 = ( DefaultMultiValueCategoryDataset ) TestUtils . serialised ( d1 ) ;
XYSeries s2 = ( XYSeries ) TestUtils . serialised ( s1 ) ;
CombinedRangeXYPlot plot2 = ( CombinedRangeXYPlot ) TestUtils . serialised ( plot1 ) ;
CategoryTableXYDataset d2 = ( CategoryTableXYDataset ) TestUtils . serialised ( d1 ) ;
YIntervalRenderer r2 = ( YIntervalRenderer ) TestUtils . serialised ( r1 ) ;
TaskSeriesCollection c2 = ( TaskSeriesCollection ) TestUtils . serialised ( c1 ) ;
SimpleHistogramBin b2 = ( SimpleHistogramBin ) TestUtils . serialised ( b1 ) ;
DefaultCategoryDataset d2 = ( DefaultCategoryDataset ) TestUtils . serialised ( d1 ) ;
BubbleXYItemLabelGenerator g2 = ( BubbleXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
PaintScaleLegend l2 = ( PaintScaleLegend ) TestUtils . serialised ( l1 ) ;
OHLCDataItem i2 = ( OHLCDataItem ) TestUtils . serialised ( i1 ) ;
AreaRendererEndType t2 = ( AreaRendererEndType ) TestUtils . serialised ( t1 ) ;
BoxAndWhiskerRenderer r2 = ( BoxAndWhiskerRenderer ) TestUtils . serialised ( r1 ) ;
HistogramDataset d2 = ( HistogramDataset ) TestUtils . serialised ( d1 ) ;
MiddlePinNeedle n2 = ( MiddlePinNeedle ) TestUtils . serialised ( n1 ) ;
CombinedDomainXYPlot plot2 = ( CombinedDomainXYPlot ) TestUtils . serialised ( plot1 ) ;
IntervalXYDelegate d2 = ( IntervalXYDelegate ) TestUtils . serialised ( d1 ) ;
XYDifferenceRenderer r2 = ( XYDifferenceRenderer ) TestUtils . serialised ( r1 ) ;
StandardCategoryURLGenerator g2 = ( StandardCategoryURLGenerator ) TestUtils . serialised ( g1 ) ;
StandardPieURLGenerator g2 = ( StandardPieURLGenerator ) TestUtils . serialised ( g1 ) ;
Millisecond m2 = ( Millisecond ) TestUtils . serialised ( m1 ) ;
TimeSeriesDataItem item2 = ( TimeSeriesDataItem ) TestUtils . serialised ( item1 ) ;
YIntervalDataItem item2 = ( YIntervalDataItem ) TestUtils . serialised ( item1 ) ;
XYTextAnnotation a2 = ( XYTextAnnotation ) TestUtils . serialised ( a1 ) ;
SubCategoryAxis a2 = ( SubCategoryAxis ) TestUtils . serialised ( a1 ) ;
GrayPaintScale g2 = ( GrayPaintScale ) TestUtils . serialised ( g1 ) ;
YIntervalSeriesCollection c2 = ( YIntervalSeriesCollection ) TestUtils . serialised ( c1 ) ;
StandardXYBarPainter p2 = ( StandardXYBarPainter ) TestUtils . serialised ( p1 ) ;
LineBorder b2 = ( LineBorder ) TestUtils . serialised ( b1 ) ;
XYAreaRenderer r2 = ( XYAreaRenderer ) TestUtils . serialised ( r1 ) ;
XYDotRenderer r2 = ( XYDotRenderer ) TestUtils . serialised ( r1 ) ;
GradientXYBarPainter p2 = ( GradientXYBarPainter ) TestUtils . serialised ( p1 ) ;
MatrixSeries m2 = ( MatrixSeries ) TestUtils . serialised ( m1 ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtils . serialised ( chart ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
XYPlot p2 = ( XYPlot ) TestUtils . serialised ( p1 ) ;
CustomCategoryURLGenerator g2 = ( CustomCategoryURLGenerator ) TestUtils . serialised ( g1 ) ;
StandardXYToolTipGenerator g2 = ( StandardXYToolTipGenerator ) TestUtils . serialised ( g1 ) ;
XIntervalDataItem item2 = ( XIntervalDataItem ) TestUtils . serialised ( item1 ) ;
MarkerAxisBand a2 = ( MarkerAxisBand ) TestUtils . serialised ( a1 ) ;
HistogramBin b2 = ( HistogramBin ) TestUtils . serialised ( b1 ) ;
TimeSeriesCollection c2 = ( TimeSeriesCollection ) TestUtils . serialised ( c1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtils . serialised ( p1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtils . serialised ( p1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtils . serialised ( f1 ) ;
CategoryTick t2 = ( CategoryTick ) TestUtils . serialised ( t1 ) ;
ArrowNeedle n2 = ( ArrowNeedle ) TestUtils . serialised ( n1 ) ;
ArcDialFrame f2 = ( ArcDialFrame ) TestUtils . serialised ( f1 ) ;
XYBlockRenderer r2 = ( XYBlockRenderer ) TestUtils . serialised ( r1 ) ;
AxisLocation location2 = ( AxisLocation ) TestUtils . serialised ( location1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtils . serialised ( f1 ) ;
XYBoxAnnotation a2 = ( XYBoxAnnotation ) TestUtils . serialised ( a1 ) ;
GroupedStackedBarRenderer r2 = ( GroupedStackedBarRenderer ) TestUtils . serialised ( r1 ) ;
NormalDistributionFunction2D f2 = ( NormalDistributionFunction2D ) TestUtils . serialised ( f1 ) ;
SimpleHistogramDataset d2 = ( SimpleHistogramDataset ) TestUtils . serialised ( d1 ) ;
KeyedObjects2D ko2D2 = ( KeyedObjects2D ) TestUtils . serialised ( ko2D1 ) ;
PolarPlot p2 = ( PolarPlot ) TestUtils . serialised ( p1 ) ;
DomainOrder d2 = ( DomainOrder ) TestUtils . serialised ( d1 ) ;
VectorSeries s2 = ( VectorSeries ) TestUtils . serialised ( s1 ) ;
ColorBlock b2 = ( ColorBlock ) TestUtils . serialised ( b1 ) ;
PieLabelRecord p2 = ( PieLabelRecord ) TestUtils . serialised ( p1 ) ;
DefaultPolarItemRenderer r2 = ( DefaultPolarItemRenderer ) TestUtils . serialised ( r1 ) ;
XYPointerAnnotation a2 = ( XYPointerAnnotation ) TestUtils . serialised ( a1 ) ;
LegendItemEntity e2 = ( LegendItemEntity ) TestUtils . serialised ( e1 ) ;
TaskSeries s2 = ( TaskSeries ) TestUtils . serialised ( s1 ) ;
DefaultCategoryItemRenderer r2 = ( DefaultCategoryItemRenderer ) TestUtils . serialised ( r1 ) ;
Range r2 = ( Range ) TestUtils . serialised ( r1 ) ;
ExtendedCategoryAxis a2 = ( ExtendedCategoryAxis ) TestUtils . serialised ( a1 ) ;
DefaultDrawingSupplier r2 = ( DefaultDrawingSupplier ) TestUtils . serialised ( r1 ) ;
Month m2 = ( Month ) TestUtils . serialised ( m1 ) ;
PinNeedle n2 = ( PinNeedle ) TestUtils . serialised ( n1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtils . serialised ( r1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtils . serialised ( r1 ) ;
CustomXYURLGenerator g2 = ( CustomXYURLGenerator ) TestUtils . serialised ( g1 ) ;
LineFunction2D f2 = ( LineFunction2D ) TestUtils . serialised ( f1 ) ;
XYSeriesCollection c2 = ( XYSeriesCollection ) TestUtils . serialised ( c1 ) ;
StandardPieSectionLabelGenerator g2 = ( StandardPieSectionLabelGenerator ) TestUtils . serialised ( g1 ) ;
Second s2 = ( Second ) TestUtils . serialised ( s1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtils . serialised ( r1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtils . serialised ( d1 ) ;
CompassPlot p2 = ( CompassPlot ) TestUtils . serialised ( p1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtils . serialised ( d1 ) ;
MultipleXYSeriesLabelGenerator g2 = ( MultipleXYSeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
CategoryTextAnnotation a2 = ( CategoryTextAnnotation ) TestUtils . serialised ( a1 ) ;
StandardCategorySeriesLabelGenerator g2 = ( StandardCategorySeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
CategoryMarker m2 = ( CategoryMarker ) TestUtils . serialised ( m1 ) ;
Day d2 = ( Day ) TestUtils . serialised ( d1 ) ;
DateTitle t2 = ( DateTitle ) TestUtils . serialised ( t1 ) ;
Week w2 = ( Week ) TestUtils . serialised ( w1 ) ;
AreaRenderer r2 = ( AreaRenderer ) TestUtils . serialised ( r1 ) ;
TickUnits t2 = ( TickUnits ) TestUtils . serialised ( t1 ) ;
BoxAndWhiskerItem i2 = ( BoxAndWhiskerItem ) TestUtils . serialised ( i1 ) ;
TimePeriodAnchor a2 = ( TimePeriodAnchor ) TestUtils . serialised ( a1 ) ;
PaintMap m2 = ( PaintMap ) TestUtils . serialised ( m1 ) ;
PaintMap m2 = ( PaintMap ) TestUtils . serialised ( m1 ) ;
RingPlot p2 = ( RingPlot ) TestUtils . serialised ( p1 ) ;
StandardBarPainter p2 = ( StandardBarPainter ) TestUtils . serialised ( p1 ) ;
LegendItemCollection c2 = ( LegendItemCollection ) TestUtils . serialised ( c1 ) ;
RangeType r2 = ( RangeType ) TestUtils . serialised ( r1 ) ;
StatisticalBarRenderer r2 = ( StatisticalBarRenderer ) TestUtils . serialised ( r1 ) ;
DefaultKeyedValue v2 = ( DefaultKeyedValue ) TestUtils . serialised ( v1 ) ;
OHLC i2 = ( OHLC ) TestUtils . serialised ( i1 ) ;
StandardXYItemLabelGenerator g2 = ( StandardXYItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
BlockContainer c2 = ( BlockContainer ) TestUtils . serialised ( c1 ) ;
NumberAxis a2 = ( NumberAxis ) TestUtils . serialised ( a1 ) ;
LogAxis a2 = ( LogAxis ) TestUtils . serialised ( a1 ) ;
CategoryStepRenderer r2 = ( CategoryStepRenderer ) TestUtils . serialised ( r1 ) ;
CustomPieURLGenerator g2 = ( CustomPieURLGenerator ) TestUtils . serialised ( g1 ) ;
PeriodAxisLabelInfo info2 = ( PeriodAxisLabelInfo ) TestUtils . serialised ( info1 ) ;
DefaultHighLowDataset d2 = ( DefaultHighLowDataset ) TestUtils . serialised ( d1 ) ;
DialPointer i2 = ( DialPointer ) TestUtils . serialised ( i1 ) ;
DialPointer i2 = ( DialPointer ) TestUtils . serialised ( i1 ) ;
KeyedObject ko2 = ( KeyedObject ) TestUtils . serialised ( ko1 ) ;
BlockBorder b2 = ( BlockBorder ) TestUtils . serialised ( b1 ) ;
MultiplePiePlot p2 = ( MultiplePiePlot ) TestUtils . serialised ( p1 ) ;
XYSplineRenderer r2 = ( XYSplineRenderer ) TestUtils . serialised ( r1 ) ;
XYShapeAnnotation a2 = ( XYShapeAnnotation ) TestUtils . serialised ( a1 ) ;
YWithXInterval i2 = ( YWithXInterval ) TestUtils . serialised ( i1 ) ;
DefaultBoxAndWhiskerCategoryDataset d2 = ( DefaultBoxAndWhiskerCategoryDataset ) TestUtils . serialised ( d1 ) ;
CompositeTitle t2 = ( CompositeTitle ) TestUtils . serialised ( t1 ) ;
CategoryPointerAnnotation a2 = ( CategoryPointerAnnotation ) TestUtils . serialised ( a1 ) ;
XYPolygonAnnotation a2 = ( XYPolygonAnnotation ) TestUtils . serialised ( a1 ) ;
Task t2 = ( Task ) TestUtils . serialised ( t1 ) ;
DialPlot p2 = ( DialPlot ) TestUtils . serialised ( p1 ) ;
XYTitleAnnotation a2 = ( XYTitleAnnotation ) TestUtils . serialised ( a1 ) ;
DefaultKeyedValues2D kv2D2 = ( DefaultKeyedValues2D ) TestUtils . serialised ( kv2D1 ) ;
StackedAreaRenderer r2 = ( StackedAreaRenderer ) TestUtils . serialised ( r1 ) ;
TimePeriodValue tpv2 = ( TimePeriodValue ) TestUtils . serialised ( tpv1 ) ;
DefaultHeatMapDataset d2 = ( DefaultHeatMapDataset ) TestUtils . serialised ( d1 ) ;
XYLineAndShapeRenderer r2 = ( XYLineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
XYStepAreaRenderer r2 = ( XYStepAreaRenderer ) TestUtils . serialised ( r1 ) ;
YIntervalSeries s2 = ( YIntervalSeries ) TestUtils . serialised ( s1 ) ;
GridArrangement f2 = ( GridArrangement ) TestUtils . serialised ( f1 ) ;
XYAreaRenderer2 r2 = ( XYAreaRenderer2 ) TestUtils . serialised ( r1 ) ;
WindNeedle n2 = ( WindNeedle ) TestUtils . serialised ( n1 ) ;
HighLowItemLabelGenerator g2 = ( HighLowItemLabelGenerator ) TestUtils . serialised ( g1 ) ;
DefaultBoxAndWhiskerXYDataset d2 = ( DefaultBoxAndWhiskerXYDataset ) TestUtils . serialised ( d1 ) ;
TimeSeriesURLGenerator g2 = ( TimeSeriesURLGenerator ) TestUtils . serialised ( g1 ) ;
LogarithmicAxis a2 = ( LogarithmicAxis ) TestUtils . serialised ( a1 ) ;
StandardPieToolTipGenerator g2 = ( StandardPieToolTipGenerator ) TestUtils . serialised ( g1 ) ;
CyclicNumberAxis a2 = ( CyclicNumberAxis ) TestUtils . serialised ( a1 ) ;
KeyedObjects ko2 = ( KeyedObjects ) TestUtils . serialised ( ko1 ) ;
CandlestickRenderer r2 = ( CandlestickRenderer ) TestUtils . serialised ( r1 ) ;
MonthDateFormat mf2 = ( MonthDateFormat ) TestUtils . serialised ( mf1 ) ;
XYBoxAndWhiskerRenderer r2 = ( XYBoxAndWhiskerRenderer ) TestUtils . serialised ( r1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtils . serialised ( i1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtils . serialised ( i1 ) ;
XYCoordinate v2 = ( XYCoordinate ) TestUtils . serialised ( v1 ) ;
StandardEntityCollection c2 = ( StandardEntityCollection ) TestUtils . serialised ( c1 ) ;
CrosshairOverlay o2 = ( CrosshairOverlay ) TestUtils . serialised ( o1 ) ;
PiePlot3D p2 = ( PiePlot3D ) TestUtils . serialised ( p1 ) ;
FastScatterPlot p2 = ( FastScatterPlot ) TestUtils . serialised ( p1 ) ;
DefaultKeyedValueDataset d2 = ( DefaultKeyedValueDataset ) TestUtils . serialised ( d1 ) ;
TextTitle t2 = ( TextTitle ) TestUtils . serialised ( t1 ) ;
ComparableObjectItem item2 = ( ComparableObjectItem ) TestUtils . serialised ( item1 ) ;
TimeSeries s2 = ( TimeSeries ) TestUtils . serialised ( s1 ) ;
TimePeriodValuesCollection c2 = ( TimePeriodValuesCollection ) TestUtils . serialised ( c1 ) ;
LegendItem item2 = ( LegendItem ) TestUtils . serialised ( item1 ) ;
item2 = ( LegendItem ) TestUtils . serialised ( item1 ) ;
LineAndShapeRenderer r2 = ( LineAndShapeRenderer ) TestUtils . serialised ( r1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtils . serialised ( b1 ) ;
StackedXYBarRenderer r2 = ( StackedXYBarRenderer ) TestUtils . serialised ( r1 ) ;
MinMaxCategoryRenderer r2 = ( MinMaxCategoryRenderer ) TestUtils . serialised ( r1 ) ;
StandardChartTheme t2 = ( StandardChartTheme ) TestUtils . serialised ( t1 ) ;
SlidingGanttCategoryDataset d2 = ( SlidingGanttCategoryDataset ) TestUtils . serialised ( d1 ) ;
QuarterDateFormat qf2 = ( QuarterDateFormat ) TestUtils . serialised ( qf1 ) ;
StackedXYAreaRenderer2 r2 = ( StackedXYAreaRenderer2 ) TestUtils . serialised ( r1 ) ;
IntervalMarker m2 = ( IntervalMarker ) TestUtils . serialised ( m1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtils . serialised ( d1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtils . serialised ( d1 ) ;
MeterInterval m2 = ( MeterInterval ) TestUtils . serialised ( m1 ) ;
LegendTitle t2 = ( LegendTitle ) TestUtils . serialised ( t1 ) ;
ScatterRenderer r2 = ( ScatterRenderer ) TestUtils . serialised ( r1 ) ;
OHLCSeriesCollection c2 = ( OHLCSeriesCollection ) TestUtils . serialised ( c1 ) ;
PlotRenderingInfo p2 = ( PlotRenderingInfo ) TestUtils . serialised ( p1 ) ;
ModuloAxis a2 = ( ModuloAxis ) TestUtils . serialised ( a1 ) ;
MeanAndStandardDeviation m2 = ( MeanAndStandardDeviation ) TestUtils . serialised ( m1 ) ;
DateTickUnit a2 = ( DateTickUnit ) TestUtils . serialised ( a1 ) ;
CategoryLabelPositions p2 = ( CategoryLabelPositions ) TestUtils . serialised ( p1 ) ;
CategoryLabelPosition p2 = ( CategoryLabelPosition ) TestUtils . serialised ( p1 ) ;
ShortTextTitle t2 = ( ShortTextTitle ) TestUtils . serialised ( t1 ) ;
DateRange r2 = ( DateRange ) TestUtils . serialised ( r1 ) ;
XIntervalSeries s2 = ( XIntervalSeries ) TestUtils . serialised ( s1 ) ;
CategoryLineAnnotation a2 = ( CategoryLineAnnotation ) TestUtils . serialised ( a1 ) ;
StandardXYSeriesLabelGenerator g2 = ( StandardXYSeriesLabelGenerator ) TestUtils . serialised ( g1 ) ;
Crosshair c2 = ( Crosshair ) TestUtils . serialised ( c1 ) ;
LegendGraphic g2 = ( LegendGraphic ) TestUtils . serialised ( g1 ) ;
SymbolAxis a2 = ( SymbolAxis ) TestUtils . serialised ( a1 ) ;
DefaultKeyedValues2DDataset d2 = ( DefaultKeyedValues2DDataset ) TestUtils . serialised ( d1 ) ;
TickLabelEntity e2 = ( TickLabelEntity ) TestUtils . serialised ( e1 ) ;
entities != null && ShapeUtils . isPointInRect ( dataArea , xx , yy )
entities != null && ShapeUtils . isPointInRect ( dataArea , xx , yy )
Rectangle2D area
float s
float s
float s
Shape shape
entities != null && ShapeUtils . isPointInRect ( dataArea , x , y )
ObjectInputStream stream
ObjectOutputStream stream
Graphics2D g2
TextFragment fragment
TextFragment fragment
public TextLine ( String text ) { this ( text , TextFragment.DEFAULT_FONT ) ; }
int month
int code
boolean shortened
int weekday
String title
Object o
String name
Font font
Font font
Font font
Font font
Font font
double height
double height
double width
double width
double width
double width
double width
double width
double height
double height
double height
double height
int d
int serial
String name
String name
Dialog dialog
Window frame
Window frame
String name
double height
double width
int maxrows
TextLine line
String name
int index
ObjectOutputStream stream
int index
public ObjectList ( int initialCapacity ) { super ( initialCapacity ) ; }
String name
Object object
String classLoaderSource
RectangleEdge edge
String name
int targetDOW
int targetDOW
int targetDOW
int serial
int relative
int count
String name
int index
int index
String name
Number value
String name
ObjectInputStream stream
ObjectOutputStream stream
Object object
protected AbstractObjectList ( int initialCapacity ) { this ( initialCapacity , initialCapacity ) ; }
String name
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( file , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
Args . nullNotPermitted ( fillType , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( type , STRING_CONSTANT ) ; this . type = type ; fireDatasetChanged () ; }
Args . nullNotPermitted ( group , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( defaultGroup , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category2 = category ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category1 = category ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
Args . nullNotPermitted ( generator , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . remove ( RendererChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . add ( RendererChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . defaultLegendTextFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultNegativeItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultPositiveItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultItemLabelPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; setDefaultItemLabelFont ( font , true ) ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . defaultShape = shape ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultOutlineStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultOutlinePaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultFillPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( marker , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . domainGridlinePosition = position ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . rowRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . columnRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . renderingOrder = order ; fireChangeEvent () ; }
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ; this . orientation = orientation ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; this . value = value ; }
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; fireChangeEvent () ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( plot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( supplier , STRING_CONSTANT ) ; this . drawingSupplier = supplier ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . errorIndicatorPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . thermometerPaint = paint ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . xyBarPainter = painter ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemLabelPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLabelPaint = paint ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . crosshairPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baselinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; }
{ Args . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotOutlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendItemPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . chartBackgroundPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subtitlePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . titlePaint = paint ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . smallFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . regularFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . largeFont = font ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . extraLargeFont = font ; }
Args . nullNotPermitted ( name , STRING_CONSTANT ) ;
Args . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( chart , STRING_CONSTANT ) ; this . chart = chart ; }
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . data . getValue ( key ) ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . shapeLocation = location ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . shapeAnchor = anchor ; }
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ Args . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . obj = y ; }
Args . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . baseFormatter = formatter ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . separatorPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . separatorStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( color , STRING_CONSTANT ) ; this . centerTextColor = color ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . centerTextFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . centerTextFormatter = formatter ; }
{ Args . nullNotPermitted ( mode , STRING_CONSTANT ) ; this . centerTextMode = mode ; fireChangeEvent () ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateToFindZBounds ( dataset , visibleSeriesKeys , xRange , includeInterval ) ; return result ; }
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateZBounds ( dataset , includeInterval ) ; return result ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativeBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positiveBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . lastBarPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . firstBarPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( radialAxis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( composite , STRING_CONSTANT ) ; this . fillComposite = composite ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . guideLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . guideLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . minIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . maxIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . objectIcon = icon ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . groupStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . groupPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . xPosition = position ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( interval , STRING_CONSTANT ) ; this . intervals . add ( interval ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . valuePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . valueFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . tickLabelFormat = format ; fireChangeEvent () ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . needlePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; fireChangeEvent () ; }
Args . nullNotPermitted ( polygon , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( thresholdType , STRING_CONSTANT ) ; this . gapThresholdType = thresholdType ; fireChangeEvent () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( name , STRING_CONSTANT ) ; this . name = name ; }
Args . nullNotPermitted ( line , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( period , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
Args . nullNotPermitted ( maximumDate , STRING_CONSTANT ) ;
Args . nullNotPermitted ( date , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . add ( ChartMouseListener . class , listener ) ; }
Args . nullNotPermitted ( file , STRING_CONSTANT ) ;
Args . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
Args . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . zoomFillPaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . incompletePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . completePaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
Args . nullNotPermitted ( values , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelTextAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( adj , STRING_CONSTANT ) ; this . labelOffsetType = adj ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . labelOffset = offset ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( color , STRING_CONSTANT ) ; this . labelBackgroundColor = color ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( arrangement , STRING_CONSTANT ) ; this . arrangement = arrangement ; }
Args . nullNotPermitted ( arrangement , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( x , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . categoryAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category = category ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( subtask , STRING_CONSTANT ) ; this . subtasks . add ( subtask ) ; }
{ Args . nullNotPermitted ( description , STRING_CONSTANT ) ; this . description = description ; }
Args . nullNotPermitted ( description , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stripOutlineStroke = stroke ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . stripOutlinePaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . axisLocation = location ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . scale = scale ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( serialDate , STRING_CONSTANT ) ; this . serialDate = serialDate ; peg ( Calendar . getInstance () ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . rangeAxis = axis ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . domainAxis = axis ; fireChangeEvent () ; }
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . cornerTextItems . add ( text ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . angleLabelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . angleLabelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( unit , STRING_CONSTANT ) ; this . angleTickUnit = unit ; fireChangeEvent () ; }
Args . nullNotPermitted ( location , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( type , STRING_CONSTANT ) ; this . endType = type ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . sortOrder = order ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . itemLabelPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemPaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . itemFont = font ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . legendItemGraphicPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . legendItemGraphicAnchor = anchor ; }
{ Args . nullNotPermitted ( edge , STRING_CONSTANT ) ; this . legendItemGraphicEdge = edge ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( sources , STRING_CONSTANT ) ; this . sources = sources ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( title , STRING_CONSTANT ) ; this . title = title ; }
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . volumePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( ChartChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( ChartChangeListener . class , listener ) ; }
Args . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( renderingHints , STRING_CONSTANT ) ; this . renderingHints = renderingHints ; fireChartChanged () ; }
Args . nullNotPermitted ( plot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , stroke ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Stroke ) this . store . get ( key ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( t , STRING_CONSTANT ) ; this . gradientPaintTransformer = t ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . gradientTransformer = transformer ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ; this . dataset = dataset ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . anchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( label , STRING_CONSTANT ) ; this . label = label ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( label , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( edge , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( drawable , STRING_CONSTANT ) ;
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ; this . textAlignment = alignment ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
Args . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
Args . nullNotPermitted ( position , STRING_CONSTANT ) ;
Args . nullNotPermitted ( shape , STRING_CONSTANT ) ;
Args . nullNotPermitted ( rectangle , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . area = area ; }
Args . nullNotPermitted ( area , STRING_CONSTANT ) ;
Args . nullNotPermitted ( hour , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( coefficients , STRING_CONSTANT ) ; this . coefficients = ( double [] ) coefficients . clone () ; }
Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subLabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . subLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( subCategory , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( f , STRING_CONSTANT ) ; factory = f ; }
{ Args . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; }
{ Args . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; this . backgroundPaint = null ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( format , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( OverlayChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( OverlayChangeListener . class , listener ) ; }
{ Args . nullNotPermitted ( range , STRING_CONSTANT ) ; setRange ( Range . expand ( range , getLowerMargin () , getUpperMargin () ) , turnOffAutoRange , notify ) ; }
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ Args . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
Args . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ Args . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . y = y ; }
Args . nullNotPermitted ( location , STRING_CONSTANT ) ;
Args . nullNotPermitted ( tickType , STRING_CONSTANT ) ;
Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
Args . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( origin , STRING_CONSTANT ) ; this . quadrantOrigin = origin ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . seriesRenderingOrder = order ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . datasetRenderingOrder = order ; fireChangeEvent () ; }
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
Args . requireNonNegative ( index , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . mercuryPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . valueFormat = formatter ; fireChangeEvent () ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( f , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; fireChangeEvent () ; }
Args . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , paint ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Paint ) this . store . get ( key ) ; }
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
Args . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempOneTimeFilePrefix = prefix ; }
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempFilePrefix = prefix ; }
Args . nullNotPermitted ( shape , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendShape = shape ; fireChangeEvent () ; }
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( period , STRING_CONSTANT ) ;
Args . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . labelGenerator = generator ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . baseSeriesOutlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesOutlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
Args . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . aggregatedItemsPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; this . aggregatedItemsKey = key ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
Args . nullNotPermitted ( pieChart , STRING_CONSTANT ) ;
Args . nullNotPermitted ( directions , STRING_CONSTANT ) ;
Args . nullNotPermitted ( array , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return getCategoryIndex ( columnKey ) ; }
Args . nullNotPermitted ( categoryKeys , STRING_CONSTANT ) ;
Args . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . contentAlignmentPoint = anchor ; }
Args . nullNotPermitted ( paint , STRING_CONSTANT ) ;
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . advanceLineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . advanceLinePaint = paint ; }
Args . nullNotPermitted ( day , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
Args . nullNotPermitted ( categories , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelURLs . remove ( category ) != null ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelURLs . get ( category ) ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelURLs . put ( category , url ) ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelToolTips . remove ( category ) != null ) { fireChangeEvent () ; } }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelToolTips . get ( category ) ; }
{ Args . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelToolTips . put ( category , tooltip ) ; fireChangeEvent () ; }
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
Args . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return this . keys . indexOf ( columnKey ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( bar , STRING_CONSTANT ) ; this . legendBar = bar ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; XYBarRenderer.defaultBarPainter = painter ; }
Args . nullNotPermitted ( columnKey , STRING_CONSTANT ) ;
Args . nullNotPermitted ( rowKey , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( color , STRING_CONSTANT ) ;
Args . nullNotPermitted ( hotspot , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . valueAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( insets , STRING_CONSTANT ) ; this . insets = insets ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( value , STRING_CONSTANT ) ; this . templateValue = value ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . frameAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ super ( area , toolTipText , urlText ) ; Args . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . axis = axis ; }
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . noDataMessagePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . noDataMessageFont = font ; fireChangeEvent () ; }
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
Args . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ super ( source ) ; Args . nullNotPermitted ( annotation , STRING_CONSTANT ) ; this . annotation = annotation ; }
{ Args . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . line = line ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . linePaint = paint ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . lineStroke = stroke ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; }
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatter = format ; }
{ Args . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . sublabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . sublabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Args . nullNotPermitted ( image , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
Args . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . prefix = prefix ; }
Args . nullNotPermitted ( defaultPaint , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseHighlightPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseCenterPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rosePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( entity , STRING_CONSTANT ) ; this . entities . add ( entity ) ; }
Args . nullNotPermitted ( rect , STRING_CONSTANT ) ;
Args . nullNotPermitted ( scale , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( pointer , STRING_CONSTANT ) ; return this . pointers . indexOf ( pointer ) ; }
Args . nullNotPermitted ( pointer , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( layer , STRING_CONSTANT ) ; return this . layers . indexOf ( layer ) ; }
Args . nullNotPermitted ( layer , STRING_CONSTANT ) ;
Args . nullNotPermitted ( frame , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( task , STRING_CONSTANT ) ; this . tasks . add ( task ) ; fireSeriesChanged () ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . secondFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . secondSuffix = suffix ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . minuteSuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . minuteFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . hourSuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . hourFormatter = formatter ; }
{ Args . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . daySuffix = suffix ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . dayFormatter = formatter ; }
{ Args . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . positivePrefix = prefix ; }
{ Args . nullNotPermitted ( map , STRING_CONSTANT ) ; this . seriesToGroupMap = map ; fireChangeEvent () ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; Args . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . tickLabelFormatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . tickLabelFont = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . majorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . majorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
{ Args . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . rowKeys . indexOf ( key ) ; }
Args . nullNotPermitted ( item , STRING_CONSTANT ) ;
Args . nullNotPermitted ( date , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( painter , STRING_CONSTANT ) ; BarRenderer.defaultBarPainter = painter ; }
Args . nullNotPermitted ( c , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( bounds , STRING_CONSTANT ) ; this . bounds = bounds ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; }
{ Args . nullNotPermitted ( frame , STRING_CONSTANT ) ; this . frame = frame ; }
{ Args . nullNotPermitted ( margin , STRING_CONSTANT ) ; this . margin = margin ; }
Args . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( rangeType , STRING_CONSTANT ) ; this . rangeType = rangeType ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( group , STRING_CONSTANT ) ; this . group = group ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
Args . nullNotPermitted ( order , STRING_CONSTANT ) ;
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
Args . nullNotPermitted ( order , STRING_CONSTANT ) ;
Args . nullNotPermitted ( theme , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( data , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( source , STRING_CONSTANT ) ;
Args . nullNotPermitted ( input , STRING_CONSTANT ) ;
Args . nullNotPermitted ( input , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativePaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positivePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( id , STRING_CONSTANT ) ; this . id = id ; }
Args . nullNotPermitted ( locale , STRING_CONSTANT ) ;
Args . nullNotPermitted ( tasks , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
Args . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickMarkPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( location , STRING_CONSTANT ) ; this . labelLocation = location ; fireChangeEvent () ; }
Args . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
Args . nullNotPermitted ( font , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
Args . nullNotPermitted ( zone , STRING_CONSTANT ) ;
Args . nullNotPermitted ( last , STRING_CONSTANT ) ;
Args . nullNotPermitted ( first , STRING_CONSTANT ) ;
{ super ( size , minorTickCount ) ; Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ super ( size ) ; Args . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ Args . nullNotPermitted ( seriesKey , STRING_CONSTANT ) ; this . seriesKey = seriesKey ; this . itemIndex = itemIndex ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
Args . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( record , STRING_CONSTANT ) ; this . labels . add ( record ) ; }
Args . nullNotPermitted ( base , STRING_CONSTANT ) ;
Args . nullNotPermitted ( base , STRING_CONSTANT ) ;
Args . nullNotPermitted ( range , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
Args . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendLabelGenerator = generator ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( distributor , STRING_CONSTANT ) ; this . labelDistributor = distributor ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . simpleLabelOffset = offset ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . labelPadding = padding ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . labelLinkStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; fireChangeEvent () ; }
Args . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ Args . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultSectionOutlineStroke = stroke ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionOutlinePaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionPaint = paint ; fireChangeEvent () ; }
{ Args . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
final String name
Point2D anchorPoint = this . anchor . getAnchorPoint ( titleRect ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
Point2D pt2 = this . valueAnchor . getAnchorPoint ( bounds ) ;
Point2D anchorPoint = position . getCategoryAnchor () . getAnchorPoint ( area ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
return anchor . getAnchorPoint ( anchorRect ) ;
Point2D anchorPoint = anchor . getAnchorPoint ( shape . getBounds2D () ) ;
Point2D pt = this . textAnchor . getAnchorPoint ( area ) ;
Point2D anchorPoint = this . anchor . getAnchorPoint ( imageRect ) ;
g2 . setXORMode ( Color.ORANGE ) ;
g2 . setXORMode ( Color.ORANGE ) ;
if ( xor ) { g2 . setXORMode ( Color.GRAY ) ; }
this . overlays = new java.util.ArrayList < Overlay > () ;
if ( mep > NUMBER_CONSTANT ) { ep = getExplodePercent ( dataset . getKey ( section ) ) / mep ; }
if ( ! ChartUtils . isOrsonPDFAvailable () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
chart.subtitles = new ArrayList < Title > () ;
return this . subtitles . get ( index ) ;
this . subtitles = new ArrayList < Title > () ;
this . chartPanel = new ChartPanel ( chart , false ) ;
Null () { ; }
public ObjectUtils () { ; }
public BooleanUtils () { ; }
public CharUtils () { ; }
public ClassUtils () { ; }
public NumberUtils () { ; }
public ArrayUtils () { ; }
public Validate () { ; }
public WordUtils () { ; }
public StringEscapeUtils () { ; }
public CharSetUtils () { ; }
public RandomStringUtils () { ; }
public EnumUtils () { ; }
private Entry () { ; }
public ExceptionUtils () { ; }
private Entry () { ; }
public EnumUtils () { ; }
public NumberUtils () { ; }
public DateFormatUtils () { ; }
public DateUtils () { ; }
public StopWatch () { ; }
public RandomStringUtils () { super(); }
public StringEscapeUtils () { super(); }
public WordUtils () { super(); }
public CharSetUtils () { super(); }
public CharUtils () { super(); }
public NumberUtils () { super(); }
public EnumUtils () { super(); }
public ObjectUtils () { super(); }
public BooleanUtils () { super(); }
public ArrayUtils () { super(); }
public ClassUtils () { super(); }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) { ; } return createBigInteger ( numeric ) ; }
if ( last == CHAR_CONS ) { ; } else { lastIdx ++ ; }
public StringUtils () { super(); }
public SystemUtils () { super(); }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
public DateFormatUtils () { super(); }
Null () { super(); }
public DateUtils () { super(); }
TwoDigitMonthField () { super(); }
TwoDigitYearField () { super(); }
UnpaddedMonthField () { super(); }
public ExceptionUtils () { super(); }
public NumberUtils () { super(); }
public EnumUtils () { super(); }
suite . addTestSuite ( VariableFormatterTest . class ) ;
{ Object result = replaceObject ( source ) ; return result == null ? null : result . toString () ; }
sb . appendFixedWidthPadLeft ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class , Void.TYPE }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new DoubleRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new IntRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new LongRange ( nonComparableNumber ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparableNumber ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparableNumber ) ) ;
Range r = new FloatRange ( nonComparableNumber ) ;
{ return getTSVClone () ; }
{ return getCSVClone () ; }
int removeLen = endIndex - startIndex ;
{ return lastIndexOf ( str , size - NUMBER_CONSTANT ) ; }
{ return lastIndexOf ( ch , size - NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , length ) ; }
{ return new StringBuffer ( size ) . append ( buffer , NUMBER_CONSTANT , size ) ; }
{ return new String ( buffer , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buffer [ i + j ] ) { continue outer ; } }
{ if ( buffer [ i ] == ch ) { return i ; } }
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buffer , startIndex , endIndex - startIndex ) ; }
{ if ( buffer [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buffer [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buffer , endIndex , buffer , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buffer [ size ++ ] = padChar ; }
buffer [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buffer , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buffer , len , strLen ) ;
System . arraycopy ( str.buffer , NUMBER_CONSTANT , buffer , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buffer , len ) ;
System . arraycopy ( buffer , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buffer , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buffer [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buffer [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buffer = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
if ( pos + len > textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( VariableParser . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last != CharUtils.CR ) { lastIdx ++ ; }
private void setVarStartMatcher ( StrMatcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrMatcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrMatcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
StrMatcher trimmer
{ setIgnoredMatcher ( StrMatcher . charMatcher ( ignored ) ) ; }
StrMatcher ignored
{ setQuoteMatcher ( StrMatcher . charMatcher ( quote ) ) ; }
StrMatcher quote
start == len && delim . isMatch ( chars , start - NUMBER_CONSTANT , NUMBER_CONSTANT , len ) == NUMBER_CONSTANT
StrMatcher delim
StrMatcher delim
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . noneMatcher () ) ;
tok . setIgnoredMatcher ( StrMatcher . trimMatcher () ) ;
sb . replaceFirst ( CHAR_CONS , CHAR_CONS ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
assertEquals ( ArrayUtils . toString ( tokens ) , expected.length , tokens.length ) ;
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
public boolean isEmptyTokenAsNull () { return this . emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmerMatcher = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmerMatcher ; }
{ if ( ignored != null ) { this . ignoredMatcher = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignoredMatcher ; }
{ if ( quote != null ) { this . quoteMatcher = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quoteMatcher ; }
public StrMatcher getDelimiterMatcher () { return this . delimMatcher ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; this . cause = cause ; }
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
{ super ( msg == null ? DEFAULT_MESSAGE : msg ) ; }
public NotImplementedException () { super ( DEFAULT_MESSAGE ) ; }
private void tokenize () { if ( tokens == null ) { tokens = readTokens () ; } }
sb . clear () . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , LOCALE_EN } ) ;
{ return ! StringUtils . isEmpty ( str ) ; }
List list = new ArrayList () ;
List list = new ArrayList () ;
{ StrBuilder . this . append ( str , off , len ) ; }
{ StrBuilder . this . append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { StrBuilder . this . append ( cbuf ) ; }
public void write ( int c ) { StrBuilder . this . append ( ( char ) c ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
if ( index == INDEX_NOT_FOUND ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , valueToFind ) != INDEX_NOT_FOUND ; }
{ return indexOf ( array , objectToFind ) != INDEX_NOT_FOUND ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , ( String [] ) null )
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
String tokens [] = tok . getTokenArray () ;
public boolean hasPrevious () { checkTokenized () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { checkTokenized () ; return tokenPos < tokens.length ; }
checkTokenized () ;
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
public int size () { checkTokenized () ; return tokens.length ; }
assertEquals ( input , tok . getContent () ) ;
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return StrBuilder . this . charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName , buf , startPos , endPos ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , offset + length ) ; }
StrLookup variableResolver
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( StrLookup . mapLookup ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( StrLookup . systemPropertiesLookup () ) . replace ( source ) ; }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
return entry.map . get ( getName () ) ;
protected Entry () { super(); }
sub . replaceIn ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( cyclicCause ) ) ;
cyclicCause = null ;
cyclicCause = new ExceptionWithCause ( a ) ;
protected DefaultToStringStyle () { super(); }
DefaultToStringStyle () { super(); }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ StringWriter stringWriter = createStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = createStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
assertSame ( CharSet.EMPTY , CharSet . getInstance ( ( String ) null ) ) ;
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
CharSet chars = CharSet . getInstance ( set ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = - NUMBER_CONSTANT ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; java.util.Locale . setDefault ( java.util.Locale.US ) ; }
if ( StringUtils . containsNone ( str , CSV_SEARCH_CHARS ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern , locale ) ;
subformats . put ( INTEGER , createIntegerInstance ( getLocale () ) ) ;
getIntegerNumberFormat ( Locale.US )
{ return splitByWholeSeparatorWorker ( str , separator , - NUMBER_CONSTANT , false ) ; }
{ clazz = Class . forName ( toCanonicalName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , CSV_QUOTE_STR + CSV_QUOTE_STR , CSV_QUOTE_STR ) ; }
catch ( IllegalStateException e ) {}
if ( replaceChars == null ) { replaceChars = EMPTY ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , EMPTY , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale ) ; }
assertPatternsEqual ( null , pattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > > NUMBER_CONSTANT ;
osName . toLowerCase ( Locale.ENGLISH ) . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase ( Locale.ENGLISH ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
{ getRegistry () . remove ( new IDKey ( value ) ) ; }
{ getRegistry () . add ( new IDKey ( value ) ) ; }
{ return getRegistry () . contains ( new IDKey ( value ) ) ; }
roundUp = offset >= NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
this . startTime += ( System . nanoTime () - this . stopTime ) ;
this . stopTime = System . nanoTime () ;
this . stopTime = System . nanoTime () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . nanoTime () ; }
public static Test suite () { return new TestSuite ( NestableErrorTest . class ) ; }
public static Test suite () { return new TestSuite ( NestableExceptionTest . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTest . class ) ; }
public ExceptionUtilsTest ( String name ) { super ( name ) ; }
@ Override public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , ( Object [] ) null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = objects ;
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
{ if ( array == null ) { return null ; } return array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars . clone () ; }
{ checkTokenized () ; return tokens . clone () ; }
@ Override public Throwable getCause () { return cause ; }
@ Override public String toString () { return toString ; }
sb . appendln ( FOO ) ;
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
{ super ( msg ) ; this . cause = null ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( stringToSplitOnNulls , null ) ;
{ ObjectUtils . identityToString ( this . getStringBuffer () , object ) ; return this ; }
{ ObjectUtils . identityToString ( buffer , value ) ; }
String pBaseStr = STRING_CONSTANT ;
{ super ( DEFAULT_MESSAGE , cause ) ; }
final Throwable n = new UnhandledException ( t ) ;
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
String entityValue = Entities . getISO8859_1 ( i % Entities.ISO8859_1_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
String entityValue = Entities . getHTML40 ( i % Entities.HTML40_ARRAY_LENGTH , NUMBER_CONSTANT ) ;
Collection < > collection
Collection < > collection
Iterator < > iterator
Iterator < > iterator
Iterator < > it
Iterator < > it
List < String > tokens
List < String > tokens
List < String > list
public Byte toByte () { return Byte . valueOf ( byteValue () ) ; }
public Object getValue () { return Byte . valueOf ( this . value ) ; }
{ mutNum . compareTo ( Byte . valueOf ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , Byte . valueOf ( element ) , Byte.TYPE ) ; }
{ result [ i ] = Byte . valueOf ( array [ i ] ) ; }
Class < > type
Class < > type
Class < > type
Class < > clazz
Class < > clazz
List < String > list = getCauseMethodNameList () ;
List < String > list = getCauseMethodNameList () ;
Class < > clazz
Map < String , FormatFactory > registry
Map < String , FormatFactory > registry
String obj
String obj
Class < > lhsClass = lhs . getClass () ;
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls = target . getClass () ;
Class < > cls = target . getClass () ;
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > clazz
Class < > clazz
Class < > reflectUpToClass
Collection < String > collection
Collection < String > excludeFieldNames
Class < > reflectUpToClass
List < String > priorVariables
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > clss
Class < > clss = null ;
Class < > newArrayComponentType
Class < > cls
Class < > expected
Class < > clazz
Class < > reflectUpToClass
Collection < String > excludeFields
Collection < String > excludeFields
Class < > reflectUpToClass
Class < > clazz
Class < > cls
Class < > cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES_LOCK ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES_LOCK ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator < > it
Iterator < > it
Iterator < > it
assertNotNull ( ObjectUtils.NULL ) ;
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , Boolean . valueOf ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , Boolean . valueOf ( element ) , Boolean.TYPE ) ; }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Float . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = Double . compare ( lhs , rhs ) ; return this ; }
return Double . compare ( value , anotherVal ) ;
return Float . compare ( value , anotherVal ) ;
int compare = ( ( Comparable < Number > ) num1 ) . compareTo ( num2 ) ;
Map < , > map
Collection < > collection
Comparator < > comparator
Class < ? super T > clazz
T object
T object
T object
T object
T object
T object
Map < String , V > map
public String [] getExcludeFieldNames () { return this . excludeFieldNames . clone () ; }
{ UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ EscapeUtils.ESCAPE_JAVA . translate ( str , out ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
{ return UnescapeUtils . unescapeCsv ( str ) ; }
{ return EscapeUtils . escapeCsv ( str ) ; }
{ return UnescapeUtils . unescapeXml ( str ) ; }
{ return EscapeUtils . escapeXml ( str ) ; }
{ return UnescapeUtils . unescapeHtml4 ( str ) ; }
{ return EscapeUtils . escapeHtml4 ( str ) ; }
{ return UnescapeUtils . unescapeEcmaScript ( str ) ; }
{ return UnescapeUtils . unescapeJava ( str ) ; }
{ return EscapeUtils . escapeEcmaScript ( str ) ; }
{ return EscapeUtils . escapeJava ( str ) ; }
void setValue ( T value ) ;
T getValue ( ) ;
T value
T value
CharSequence str
CharSequence str
CharSequence str
CharSequence str
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
{ throw new NullPointerException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullPointerException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new RuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsNullPointerException ( null ) ;
catch ( IOException ioe ) { throw new RuntimeException ( ioe ) ; }
buffer = new char [ capacity * NUMBER_CONSTANT ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ result [ i ] = Float . valueOf ( array [ i ] ) ; }
{ result [ i ] = Double . valueOf ( array [ i ] ) ; }
{ result [ i ] = Short . valueOf ( array [ i ] ) ; }
{ result [ i ] = Integer . valueOf ( array [ i ] ) ; }
{ result [ i ] = Long . valueOf ( array [ i ] ) ; }
{ result [ i ] = Character . valueOf ( array [ i ] ) ; }
double . . . array2
float . . . array2
long . . . array2
int . . . array2
short . . . array2
byte . . . array2
char . . . array2
boolean . . . array2
object instanceof Map.Entry < , >
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
Iterator < > it = collection . iterator ()
if ( num1 instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable < > == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
oos . writeObject ( new ClassNotFoundSerialization () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
isSet ( PARAM.escapePlus )
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
uu = new UnicodeUnescaper ( UnicodeUnescaper.OPTION.escapePlus ) ;
isSet ( OPTION.escapePlus )
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder result = new StringBuilder () ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
StringBuilder classNameBuffer = new StringBuilder () ;
StringBuilder arrayPrefix = new StringBuilder () ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder ( strLen ) ;
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuilder buf = new StringBuilder ( outputLength ) ;
StringBuilder buf = new StringBuilder ( strLength ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( bufSize ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
StringBuilder buffer = new StringBuilder ( NUMBER_CONSTANT ) ;
toString = new StringBuilder ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder buf = new StringBuilder () ;
CharRange range = CharRange . is ( CHAR_CONS ) ;
Collection < > collection
Collection < > collection
Class < > cls
Map < , > map
Collection < > coll
Class < > cls
Class < > cls
Class < > [] parameterTypes
Class < > [] parameterTypes
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection < > ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator < > ) null , CHAR_CONS ) ) ;
Class < > exceptionType
Class < > c
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class < > ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class < > ) null ) ) ;
iMap = new HashMap < Object , Object > () ;
Class < > [] c
sb . appendWithSeparators ( ( Iterator < > ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection < > ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator < > ) null ) ;
sb . appendAll ( ( Collection < > ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Object value
Object value
StringBuffer buffer = new StringBuffer () ;
Class < > [] c
values = new HashMap < String , String > () ;
List < > list = tok . getTokenList () ;
Map < String , > map = null ;
Map < String , ? extends FormatFactory > registry
Map < String , > registry
Map < String , > registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection < String > ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList < String > () ) ;
Object object
Object object
Object object
Object object
Object object
Object object
{ this ( object , null , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils.UNESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.ESCAPE_CSV . translate ( value , writer ) ;
StringEscapeUtils.UNESCAPE_JAVA . translate ( original , writer ) ;
StringEscapeUtils.ESCAPE_JAVA . translate ( original , writer ) ;
Comparator < T > c
{ try { return initialize () ; } finally { if ( execFinally != null ) { execFinally . shutdown () ; } } }
{ execFinally = exec ; }
{ this . translators = ArrayUtils . clone ( translators ) ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
Object [] values2 = ArrayUtils . addAll ( values , Integer . valueOf ( i ) ) ;
Object [] values2 = ArrayUtils . add ( values , Integer . valueOf ( i ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Long . valueOf ( value ) ) ) ; } }
{ calendar . getTimeInMillis () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . maximum ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , this . minimum ) < NUMBER_CONSTANT ; }
return null ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EX_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EX_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EX_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EX_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EX_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EX_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EX_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EX_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EX_MESSAGE ) ; }
StrLookup < > variableResolver
StrLookup < > resolver = getVariableResolver () ;
StrLookup < > variableResolver
StrLookup < > variableResolver
StrLookup < > variableResolver
public StrSubstitutor () { this ( ( StrLookup < > ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! m . isSynthetic () ; }
validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
this . validateNullToStringStyleRegistry () ;
{ return REGISTRY . get () ; }
CharSequence str
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
if ( str == null || searchStrs == null ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == INDEX_NOT_FOUND
if ( at == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
if ( pos == INDEX_NOT_FOUND ) { return EMPTY ; }
if ( pos == INDEX_NOT_FOUND ) { return str ; }
return indexOfAnyBut ( cs , valid ) == INDEX_NOT_FOUND ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return INDEX_NOT_FOUND ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return INDEX_NOT_FOUND ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return INDEX_NOT_FOUND ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != INDEX_NOT_FOUND )
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
int searchChar
int searchChar
int searchChar
int searchChar
int searchChar
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
Object . . . args
Object . . . args
String . . . parsePatterns
String . . . parsePatterns
String . . . strs
CharSequence . . . css
Boolean . . . array
boolean . . . array
char . . . delimiters
char . . . delimiters
char . . . delimiters
char . . . delimiters
Class < > . . . parameterTypes
Class < > . . . parameterTypes
Object . . . args
Object . . . args
String . . . searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , compareTransients , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , oldValue , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( listener ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( ( String [] ) null ) ) ;
String [] results ;
String [] results ;
assertEquals ( null , StringUtils . concatWith ( null , ( String [] ) null ) ) ;
assertEquals ( null , StringUtils . concat ( ( String [] ) null ) ) ;
{ DateUtils . parseDate ( dateStr , ( String [] ) null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 )
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( JavaVersion.JAVA_1_5 ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ;
{ return isJavaVersionMatch ( JAVA_SPECIFICATION_VERSION , versionPrefix ) ; }
if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_3 ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
{ if ( SystemUtils . isJavaVersionAtLeast ( JAVA_1_4 ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return get ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( option ) ; }
assertEquals ( false , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( false , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
{ return Boolean . valueOf ( isEquals () ) ; }
public Integer build () { return Integer . valueOf ( toHashCode () ) ; }
{ return Integer . valueOf ( toComparison () ) ; }
EqualsBuilder . class
EqualsBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( StringUtils . subSequence ( cs , NUMBER_CONSTANT ) )
CharSequence cs
return str . subSequence ( start , end ) . toString () ;
return str . subSequence ( start , str . length () ) . toString () ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String . . . set
Object . . . array
Class < > . . . parameterTypes
Class < > . . . classes
Class < > . . . classes
Class < > . . . toClassArray
char . . . chars
char . . . chars
return types . toArray ( new Type [ types . size () ] ) ;
return frames . toArray ( new String [ frames . size () ] ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String . . . searchStrs
String . . . searchStrs
char . . . searchChars
String . . . strs
String input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
( idx = CharSequenceUtils . indexOf ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = CharSequenceUtils . lastIndexOf ( str , search , str . length () ) ;
tmp = CharSequenceUtils . indexOf ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , CharSequenceUtils . toCharArray ( searchChars ) ) ; }
{ if ( CharSequenceUtils . regionMatches ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchSeq , startPos ) ; }
return CharSequenceUtils . lastIndexOf ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . lastIndexOf ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return CharSequenceUtils . indexOf ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value != NUMBER_CONSTANT ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ; }
{ if ( bool == null ) { return null ; } return bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else { continue; }
String . . . excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
String . . . excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
String . . . excludeFieldNames
String . . . excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
String . . . excludeFields
{ this . excludeFieldNames = toNoNullStringArray ( excludeFieldNamesParam ) ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( this . getClass () . getSimpleName () ) ;
char . . . chars
@ Override public R getRightElement () { return right ; }
@ Override public L getLeftElement () { return left ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
public R getValue () { return getRight () ; }
public final L getKey () { return getLeft () ; }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
Calendar c = Calendar . getInstance ( mTimeZone , mLocale ) ;
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return cache . getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
{ return cache . getInstance ( pattern , null , locale ) ; }
{ return cache . getInstance ( pattern , timeZone , null ) ; }
{ return cache . getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , StringUtils.EMPTY ) ;
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return pad ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return repeat ( padChar , pads ) . concat ( str ) ;
return str . concat ( repeat ( padChar , pads ) ) ;
assertEquals ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
{ R result = getRight () ; setRight ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
@ Before
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return Character . valueOf ( str . charAt ( NUMBER_CONSTANT ) ) ; }
try { FieldUtils . writeField ( field , publicChild , Integer . valueOf ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer val = Integer . valueOf ( NUMBER_CONSTANT ) ;
sb . appendln ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
iInteger = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer value = Integer . valueOf ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
coll . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Integer . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( Integer . valueOf ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( Integer . valueOf ( NUMBER_CONSTANT ) ) ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( Integer . valueOf ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
mutNum . subtract ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Integer . valueOf ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , Integer . valueOf ( NUMBER_CONSTANT ) ) ;
public Integer getValue () { return Integer . valueOf ( this . value ) ; }
mutNum . subtract ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Long . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Long . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Long . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( Long . valueOf ( NUMBER_CONSTANT ) ) . longValue () ) ;
public Long getValue () { return Long . valueOf ( this . value ) ; }
public Short getValue () { return Short . valueOf ( this . value ) ; }
mutNum . subtract ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( Short . valueOf ( ( short ) NUMBER_CONSTANT ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , Double . valueOf ( value ) ) ) ; } }
public Float getValue () { return Float . valueOf ( this . value ) ; }
public Double getValue () { return Double . valueOf ( this . value ) ; }
try { FieldUtils . writeField ( field , publicChild , Double . valueOf ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Object [] args = new Object [] { Double . valueOf ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , Double . valueOf ( STRING_CONSTANT ) }
mutNum . subtract ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Float . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Float . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Float . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( Float . valueOf ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
mutNum . subtract ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
mutNum . add ( Double . valueOf ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == Double . valueOf ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( Double . valueOf ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( Double . valueOf ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( Double . valueOf ( NUMBER_CONSTANT ) ) . toString () ) ;
{ throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT + java6Exception + STRING_CONSTANT + sunException ) ; }
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . remove ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
separator = ObjectUtils . toString ( separator ) ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
for ( E constant : values ) { total |= NUMBER_CONSTANT < < constant . ordinal () ; }
int remainder = len - pos ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
root = root == null ? th : root ;
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
dev = observed [ i ] - expected [ i ] ;
pos + i >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return options == null ? false : options . contains ( option ) ; }
return result != null ? result : value ;
{ return initializer != null ? initializer . get () : null ; }
{ return schedFuture != null ? schedFuture : super . startTimer () ; }
int d2 = tmodd1 == NUMBER_CONSTANT ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( long ) x * ( long ) y ;
long m = ( long ) x * ( long ) y ;
power % NUMBER_CONSTANT == NUMBER_CONSTANT
{ return ( double ) numerator / ( double ) denominator ; }
{ return ( float ) numerator / ( float ) denominator ; }
{ return obj == null ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( object1 == null || object2 == null ) { return false ; }
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) NUMBER_CONSTANT ) ;
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
if ( allStringsNull || longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < middle . length () + NUMBER_CONSTANT ) { return str ; }
int noOfItems = endIndex - startIndex ;
int noOfItems = endIndex - startIndex ;
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || preserveAllTokens && lastMatch ) { list . add ( str . substring ( start , i ) ) ; }
if ( separator == null || EMPTY . equals ( separator ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < strLen - closeLen
if ( pos == INDEX_NOT_FOUND || pos == str . length () - separator . length () ) { return EMPTY ; }
if ( str . length () <= pos + len ) { return str . substring ( pos ) ; }
return ret == Integer.MAX_VALUE ? INDEX_NOT_FOUND : ret ;
startPos > str . length () - searchStr . length ()
int endLimit = str . length () - searchStr . length () + NUMBER_CONSTANT ;
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
int delimLen = delimiters == null ? - NUMBER_CONSTANT : delimiters.length ;
inputLineLength - offset > wrapLength
return super . equals ( o ) && b == rhs.b ;
return a == rhs.a ;
if ( cls == null ) { return ! toClass . isPrimitive () ; }
{ boolean b = ch >= CHAR_CONS && ch <= CHAR_CONS ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
if ( coll == null || coll . isEmpty () ) { return false ; }
assertEquals ( Boolean.TRUE , triple . getRight () ) ;
assertEquals ( Boolean.FALSE , triple . getRight () ) ;
assertTrue ( STRING_CONSTANT , flag == t . isDaemon () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , Long . valueOf ( NUMBER_CONSTANT ) )
Object [] original = new Object [] { Boolean.TRUE , Boolean.FALSE } ;
fdf = getInstance ( STRING_CONSTANT , NEW_YORK , Locale.US ) ;
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
emptyToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
if ( cls != null ) { return cls ; } else { throw cnfe ; }
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
new Runnable () { @ Override public void run () { endOfPeriod () ; } }
@ Override public Object getValue () { return null ; }
Locale getLocale ( ) ;
Locale getLocale ( ) ;
@ Before
@ Before public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertTrue ( rangea . isNegated () ) ;
assertFalse ( rangea . isNegated () ) ;
assertFalse ( new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertTrue ( hc2a != NUMBER_CONSTANT ) ;
assertTrue ( sb.buffer.length >= NUMBER_CONSTANT ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
assertFalse ( tok . hasNext () ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + super . hashCode () ; }
{ return parseDateStrictly ( str , null , parsePatterns ) ; }
{ return parseDate ( str , null , parsePatterns ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , GMT ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . equals ( FastDateParser.JAPANESE_IMPERIAL ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate + STRING_CONSTANT , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( Integer . valueOf ( dateStyle ) , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return Integer . valueOf ( ++ initializeCalls ) ;
return Integer . valueOf ( REPEAT ) ;
return Integer . valueOf ( initializeCalls ) ;
this . value instanceof StringBuilder
StringBuilder buffer = new StringBuilder () ;
StringBuilder expected = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder buffer = new StringBuilder () ;
StringBuilder result = new StringBuilder () ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
StringBuilder sb = new StringBuilder ( dstInit ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ System.out . println ( STRING_CONSTANT + javaVersion ) ; }
{ output = ( int [] ) ArrayUtils . removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( array , toRemove ) ;
return ( double [] ) removeAll ( array , toRemove ) ;
return ( float [] ) removeAll ( array , toRemove ) ;
return ( long [] ) removeAll ( array , toRemove ) ;
return ( char [] ) removeAll ( array , toRemove ) ;
return ( int [] ) removeAll ( array , toRemove ) ;
return ( short [] ) removeAll ( array , toRemove ) ;
return ( byte [] ) removeAll ( array , toRemove ) ;
result = ( T [] ) removeAll ( array , toRemove )
{ return printer . format ( millis ) ; }
Calendar c = newCalendar () ;
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( SPACE ) ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
if ( isEmpty ( padStr ) ) { padStr = SPACE ; }
{ out . write ( toUtf16Escape ( codepoint ) ) ; }
final MutableDouble other
final Object obj
final Number operand
final double operand
final Number operand
final double operand
final Number value
final double value
final String value
final Number value
final double value
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final boolean [] array
final Boolean [] array
final float [] array
final Float [] array
final double [] array
final Double [] array
final byte [] array
final Byte [] array
final short [] array
final Short [] array
final int [] array
final Integer [] array
final long [] array
final Long [] array
final char [] array
final Character [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final Object [] array
final Object array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Boolean [] array
final Float [] array
final Double [] array
final Byte [] array
final Character [] array
final Short [] array
final Integer [] array
final Long [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final String [] array
final Object [] array
final boolean [] array
final float [] array
final double [] array
final byte [] array
final char [] array
final short [] array
final int [] array
final long [] array
final T [] array
final Object [] array
final Object array
final Object array
final MutableByte other
final Object obj
final Number operand
final byte operand
final Number operand
final byte operand
final Number value
final byte value
final String value
final Number value
final byte value
final Object obj
@ Override public char charAt ( final int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( final CharSequence seq ) { this . seq = seq ; }
final int codepoint
final CharSequenceTranslator . . . translators
final CharSequence input
@ Override public char charAt ( final int arg0 ) { return value . charAt ( arg0 ) ; }
final String value
final MutableInt other
final Object obj
final Number operand
final int operand
final Number operand
final int operand
final Number value
final int value
final String value
final Number value
final int value
final String msg
DateParser getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final boolean flag
final BasicThreadFactory factory
final Callable < T > call
final Callable < T > call
DatePrinter getInstance ( final String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
final Formattable formattable
final Collection < > coll
final String language
final char [] str
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final String str
final Throwable cause
final String msg
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final Boolean . . . array
final boolean . . . array
final boolean bool
final boolean bool
final boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final String str
final String str
final Boolean bool
final boolean bool
final boolean bool
final Integer value
final int value
final int value
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Boolean bool
final Object obj2
final Object value
final String format
final long durationMillis
final long durationMillis
final boolean expression
final T iterable
final T [] array
final T chars
final T chars
final T map
final T collection
final T [] array
final T object
final boolean expression
final int nibble
final int nibble
final boolean [] src
final boolean [] src
final boolean [] src
final char hexDigit
final char hexDigit
final char hexDigit
final char hexDigit
final ObjectStreamClass desc
final byte [] objectData
final InputStream inputStream
final Serializable obj
final T object
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final Character ch
final char ch
final String str
final Character ch
final String str
final char ch
final Class < > clazz
final String . . . excludeFieldNamesParam
final boolean appendTransients
final boolean appendStatics
final Object array
final Field field
final Class < > clazz
final Field field
final Object object
final Object [] array
final Collection < String > collection
final Object object
final R right
final M middle
final L left
final Throwable cause
@ Override public boolean cancel ( final boolean mayInterruptIfRunning ) { return false ; }
final T value
final T value
final ConcurrentInitializer < T > initializer
final ConcurrentInitializer < T > initializer
final ExecutionException ex
final Throwable ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final ExecutionException ex
final OPTION option
final OPTION . . . options
final JavaVersion requiredVersion
final String property
final String osNamePrefix
final String versionPrefix
CollectionHolder ( final T collection ) { this . collection = collection ; }
final String replaceTemplate
public void testTwo ( final ChildInterface obj ) {}
public void testOne ( final GrandParentObject obj ) {}
public void testOne ( final Object obj ) {}
public void testOne ( final ParentObject obj ) {}
public void testTwo ( final GrandParentObject obj ) {}
public void testTwo ( final Object obj ) {}
final Class < > c
final Class < > [] c
@ Override public void setValue ( final Object value ) {}
public void oneParameter ( final String s ) {}
public String foo ( final Object o ) { return STRING_CONSTANT ; }
public String foo ( final String s ) { return STRING_CONSTANT ; }
public String foo ( final double d ) { return STRING_CONSTANT ; }
public String foo ( final Integer i ) { return STRING_CONSTANT ; }
public String foo ( final int i ) { return STRING_CONSTANT ; }
public static String bar ( final Object o ) { return STRING_CONSTANT ; }
public static String bar ( final String s ) { return STRING_CONSTANT ; }
public static String bar ( final Integer i ) { return STRING_CONSTANT ; }
final String canonicalName
final Class < > cls
final String canonicalName
final Class < > cls
final Object . . . array
final String className
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > . . . classes
final Class < > cls
final Class < > type
final Class < > type
final boolean autoboxing
final List < Class < > > classes
final List < String > classNames
final HashSet < Class < > > interfacesFound
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final Class < > cls
final int superHashCode
final short [] array
final short value
final Object [] array
final Object object
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object value
final Object value
final Object value
final String summaryObjectEndText
final String summaryObjectStartText
final String sizeEndText
final String sizeStartText
final String nullText
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final String fieldSeparator
final String fieldNameValueSeparator
final String contentEnd
final String contentStart
final String arraySeparator
final String arrayEnd
final String arrayStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final String format
final Object obj
final Pair < L , R > other
void warn ( final String msg ) { System.err . println ( msg ) ; }
final BitSet coll
final HashSet < Integer > coll
final int count
final int count
final int count
final int count
final int count
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( final TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( final int one ) { this . one = new TestObject ( one ) ; }
final Object o
public TestBCanEqualA ( final int b ) { this . b = b ; }
final Object o
public TestACanEqualB ( final int a ) { this . a = a ; }
final boolean testTransients
public void setT ( final int t ) { this . t = t ; }
public void setB ( final int b ) { this . b = b ; }
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final String name
final boolean enableSubstitutionInVariables
final StrLookup < > variableResolver
final String suffix
final char suffix
final StrMatcher suffixMatcher
final String prefix
final char prefix
final StrMatcher prefixMatcher
final char escapeCharacter
final StrBuilder source
final StringBuffer source
final Object source
final StrBuilder source
final StringBuffer source
final char [] source
final String source
final StrLookup < > variableResolver
final Map < String , V > valueMap
final Object source
final boolean isEquals
final boolean superEquals
final String toString
final String superToString
final Object object
final short [] array
final short value
final Object [] array
final Object obj
final long [] array
final long value
final int [] array
final int value
final float [] array
final float value
final double [] array
final double value
final char [] array
final char value
final byte [] array
final byte value
final boolean [] array
final boolean value
final Object object
final Object object
final Object object
final ToStringStyle style
final MutableFloat other
final Object obj
final Number operand
final float operand
final Number operand
final float operand
final Number value
final float value
final String value
final Number value
final float value
final int limit
final JavaVersion requiredVersion
final Object obj
final char ch
final String str
final String . . . set
final String . . . setStrs
final Object obj
@ Override public Date parse ( final String source ) throws ParseException { return parser . parse ( source ) ; }
final Calendar calendar
final Date date
final long millis
final int style
final int style
final String pattern
final String str
final char [] cbuf
final int c
@ Override public void mark ( final int readAheadLimit ) { mark = pos ; }
final int index
final int startIndex
final Object obj
final StrBuilder other
final StrBuilder other
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final StrMatcher matcher
final String str
final char ch
final int length
final int length
final int length
final int startIndex
final int start
final String str
final String str
final StrMatcher matcher
final StrMatcher matcher
final String str
final String str
final char ch
final char ch
final int startIndex
final boolean value
final int index
final char separator
final String separator
final Iterator < > it
final Iterable < > iterable
final Object [] array
final Iterator < > it
final Iterable < > iterable
final T . . . array
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final Object obj
final double value
final float value
final long value
final int value
final char ch
final boolean value
final char [] chars
final StrBuilder str
final StringBuilder str
final StringBuffer str
final String str
final CharSequence seq
final Object obj
final int startIndex
final int index
final int index
final int capacity
final int length
final String newLine
final String str
private void readObject ( final ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( final int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final MutableShort other
final Object obj
final Number operand
final short operand
final Number operand
final short operand
final Number value
final short value
final String value
final Number value
final short value
final String str
final String str
final Object array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final float [] array
final double [] array
final byte [] array
final short [] array
final int [] array
final long [] array
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final String str
final Field field
final String languageCode
final String countryCode
final Locale locale
final Locale locale
final String baseMessage
final String label
final String label
final Throwable cause
final String message
final ObjectInputStream objectInputStream
final ObjectOutputStream objectOutputStream
final L listener
final L listener
final Class < L > listenerInterface
final Class < T > listenerInterface
protected String toUtf16Escape ( final int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
final int codepoint
final int codepoint
public NestableException ( final Throwable t ) { super ( t ) ; }
public void setCause ( final Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( final Throwable cause ) { super(); setCause ( cause ) ; }
final String [] eventTypes
void warn ( final String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( final String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
public AClass ( final AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
public InspectingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( final TestFixture testFixture ) { this . testFixture = testFixture ; }
final String [] strings
final MutableBoolean other
final Object obj
final Boolean value
final boolean value
final Boolean value
final boolean value
final CharRange r
final Object obj
final CharRange range
final char ch
final char ch
final char ch
final boolean negated
final Throwable th
final Throwable th
final Throwable t
final String stackTrace
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final Throwable throwable
final int codepoint
final int codepoint
final int codepoint
final StrTokenizer tokenizer
final StrTokenizer tokenizer
final String data
final StrTokenizer tokenizer
final int loopCount
final int loopCount
final int loopCount
public static void main ( final String [] args ) { new CharUtilsPerfRun () . run () ; }
final MutableLong other
final Object obj
final Number operand
final long operand
final Number operand
final long operand
final Number value
final long value
final String value
final Number value
final long value
final Object obj
final T obj
final Object other
final Object _value
final T . . . items
final T . . . items
final T . . . values
final T . . . values
final Object obj
final Object object
final Object . . . objects
final Object obj
final T . . . values
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final Locale locale
int modify ( final int iValue ) { return iValue ; }
NumberStrategy ( final int field ) { this . field = field ; }
CopyQuotedStrategy ( final String formatField ) { this . formatField = formatField ; }
final int field
final Calendar definingCalendar
final int twoDigitYear
final String source
@ Override public Object parseObject ( final String source ) throws ParseException { return parse ( source ) ; }
final ObjectInputStream in
final Object obj
final byte holder
final short holder
final int holder
final byte holder
final short holder
final int holder
final int holder
final int holder
final short holder
final int holder
final short holder
final int holder
final int mask
final Annotation a
final java.lang.Class < > cls
final String formattedDate
final String input
final boolean ignoreEmptyTokens
final boolean emptyAsNull
final StrMatcher trimmer
final char ignored
final StrMatcher ignored
final char quote
final StrMatcher quote
final String delim
final char delim
final StrMatcher delim
final List < String > list
final String obj
final String obj
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final char [] input
final String input
final int codepoint
final int codepoint
CollectionHolder ( final T collection ) { this . collection = collection ; }
final Object obj
final T value
final T value
final CharSequence [] . . . lookup
final R value
final int unit
final Date date
final Object o
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
final R value
final R right
final L left
final String toString
final String toString
final String toString
final Type type
final Type type
final ParameterizedType parameterizedType
final WildcardType wildcardType
final WildcardType wildcardType
final TypeVariable < > typeVariable
final Type [] bounds
final ParameterizedType type
c = new Comparable () { @ Override public int compareTo ( final Object other ) { return NUMBER_CONSTANT ; } }
final Constructor < T > ctor
final Class < T > cls
final Class < T > cls
final Class < T > cls
final Class < T > cls
final String str
final String str
final String str
final char . . . delimiters
final String str
final String str
final CharSequenceTranslator . . . translators
final String [] [] array
final boolean testTransients
final boolean testTransients
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final Class < E > enumClass
final CharSequence cs
final String val
final String str
final String str
final String str
final String str
final String str
final String str
final float [] array
final double [] array
final float [] array
final double [] array
final String str
CharMatcher ( final char ch ) { super(); this . ch = ch ; }
final char chars []
final String str
final String chars
final char . . . chars
final char ch
final String name
final String name
final String name
final String name
final String name
final ExecutorService exec
final String format
final Object obj
final Range < T > other
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final Range < T > otherRange
final T element
final T element
final T element
final T element
final T element
final T element
final T element
final String str
final int threshold
final String . . . strs
final CharSequence . . . css
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final String str
final String str
final String str
final String str
final String str
final int size
final CharSequence cs
final String str
final String str
final String str
final String str
final T . . . elements
final String str
final String str
final String str
final String str
final String str
final String str
final CharSequence seq
final String input
final String . . . strs
final String stripChars
final String str
final String str
final String str
final String str
final String str
final CharSequence cs
final CharSequence cs
final CharSequence cs
final CharSequence cs
final String format
final Object obj
final ExecutorService exec
final ExecutorService execDestroy
final ExecutorService externalExecutor
final ExecutorService exec
final Throwable cause
final Class < > c
final Class < > [] c
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
public SimpleReflectionTestFixture ( final Object o ) { this . o = o ; }
final Object o
final Collection < > coll
final ParsePosition pos
final String desc
final Object obj
final String pattern
final String pattern
final Object obj
final Object . . . keys
final String pattern
final int count
final int count
final int count
final int count
final int count
final int superCompareTo
final Fraction other
final Object obj
final Fraction fraction
final Fraction fraction
final Fraction fraction
final Fraction fraction
final int power
public BackgroundInitializerTestImpl ( final ExecutorService exec ) { super ( exec ) ; }
final BackgroundInitializerTestImpl init
final boolean fieldSeparatorAtEnd
final boolean fieldSeparatorAtStart
final boolean arrayContentDetail
final boolean defaultFullDetail
final boolean useFieldNames
final boolean useIdentityHashCode
final boolean useShortClassName
final boolean useClassName
final Class < > cls
final Boolean fullDetailRequest
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final StringBuffer buffer
final Object value
final Object value
final Object value
final Object o
final TestObject rhs
public void setA ( final int a ) { this . a = a ; }
final Object o
public TestObject ( final int a ) { this . a = a ; }
private void assertGetClassThrowsClassNotFound ( final String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( final String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
final Class < > c
public void removePropertyChangeListener ( final PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( final VetoableChangeListener listener ) {}
final String property
public void addPropertyChangeListener ( final PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( final MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
final String eventName
final Class < L > listenerType
public void eventOccurred ( final PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( final PropertyChangeEvent e ) {} }
final Object obj
final boolean colon
final NumberRule rule
final NumberRule rule
TwoDigitNumberField ( final int field ) { mField = field ; }
UnpaddedNumberField ( final int field ) { mField = field ; }
final String value
CharacterLiteral ( final char value ) { mValue = value ; }
final ObjectInputStream in
final Object obj
final Calendar calendar
final Date date
final Calendar c
final long millis
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( final PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( final PropertyChangeEvent e ) {} } ) ;
final String key
final Map < String , V > map
final Map < String , V > map
final String baseMessage
final String label
final String label
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final String input
final boolean [] src
final Class < > destClass
final Member m
final int modifiers
final AccessibleObject o
final Thread.UncaughtExceptionHandler handler
final int prio
final boolean f
final String pattern
final ThreadFactory factory
final Thread t
final Runnable r
final Builder builder
{ for ( final String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
final long total = System . currentTimeMillis () - start ;
final char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
{ try { return cloneReset () ; } catch ( final CloneNotSupportedException ex ) { return null ; } }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ final StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
final IDKey idKey = ( IDKey ) other ;
catch ( final InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final int index = indexOf ( array , element ) ;
final Boolean b = array [ i ] ;
final Float b = array [ i ] ;
final Double b = array [ i ] ;
final Byte b = array [ i ] ;
final Short b = array [ i ] ;
final Integer b = array [ i ] ;
final Long b = array [ i ] ;
final Character b = array [ i ] ;
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
final CharSequence tmp = s ;
final int smallestIndexOfDiff = indexOfDifference ( strs ) ;
final int at = indexOfDifference ( str1 , str2 ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final int pads = size - str . length () ;
final int pads = size - str . length () ;
final char [] chars = str . toCharArray () ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . lastIndexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int pos = str . indexOf ( separator ) ;
final int strLen = seq . length () ;
{ final String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
final short anotherVal = other.value ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
final StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
final int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
for ( final Object name : coll ) { if ( name != null ) { return true ; } }
final char [] buffer = pattern . toCharArray () ;
final ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
final String toString = AnnotationUtils . toString ( testAnno ) ;
final byte anotherVal = other.value ;
{ final boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
final OctalUnescaper oue = new OctalUnescaper () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final ToStringStyle style = new ToStringStyleImpl () ;
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final EqualsBuilder equalsBuilder = new EqualsBuilder () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final String str = f . toProperString () ;
final String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( final ArithmeticException ex ) {}
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
{ final ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
final StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
final StrTokenizer tok = new StrTokenizer () ;
final String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( final NoSuchElementException ex ) {}
{ final float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
final int len = chars.length ;
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( final IllegalStateException istex ) { initializer . get () ; }
final ExecutorService exec = Executors . newCachedThreadPool () ;
final MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
final Object item = array [ i ] ;
for ( final char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
for ( final BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
final Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
final long millisPerUnit = getMillisPerUnit ( unit ) ;
final Calendar calendar = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
final Calendar gval = Calendar . getInstance () ;
{ final Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
final Calendar c = Calendar . getInstance () ;
final Calendar c = Calendar . getInstance () ;
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException iae ) {}
final NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
{ final DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ final DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ final DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
final Calendar cal = Calendar . getInstance () ;
final int gmt = msg . indexOf ( STRING_CONSTANT ) ;
final Object object = getObject () ;
final int part1 = name . hashCode () * NUMBER_CONSTANT ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
{ final BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
final CustomCharSequence other = ( CustomCharSequence ) obj ;
{ final BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
final StrLookup < > resolver = getVariableResolver () ;
final StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
final StrBuilder buf = new StrBuilder ( source ) ;
final int sz = cs . length () ;
final int sz = cs . length () ;
final T value
final T value
final StringBuffer buffer = new StringBuffer () ;
{ for ( final Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( final T val : values ) { if ( val != null ) { return val ; } } }
final StrBuilder buf = new StrBuilder () ;
final StrSubstitutor sub = new StrSubstitutor () ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ final StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final StrSubstitutor sub = new StrSubstitutor ( values ) ;
final FastDateFormat other = ( FastDateFormat ) obj ;
final Object obj = map . get ( key ) ;
catch ( final NoSuchMethodException e ) {}
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
final String src = STRING_CONSTANT ;
{ for ( final short element : array ) { append ( element ) ; } }
{ for ( final Object element : array ) { append ( element ) ; } }
{ for ( final long element : array ) { append ( element ) ; } }
{ for ( final int element : array ) { append ( element ) ; } }
{ for ( final float element : array ) { append ( element ) ; } }
{ for ( final double element : array ) { append ( element ) ; } }
{ for ( final char element : array ) { append ( element ) ; } }
{ for ( final byte element : array ) { append ( element ) ; } }
{ for ( final boolean element : array ) { append ( element ) ; } }
final Object key
final CompareToBuilder compareToBuilder = new CompareToBuilder () ;
final Type rawType = parameterizedType . getRawType () ;
final Type replacementType = typeVarAssigns . get ( type ) ;
final Type bound
catch ( final Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
final boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ final R result = getRight () ; setRight ( value ) ; return result ; }
final int properNumerator = getProperNumerator () ;
final Fraction other = ( Fraction ) obj ;
final Fraction f = this . multiplyBy ( this ) ;
final int gcd = greatestCommonDivisor ( numerator , denominator ) ;
final E value
final E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( final IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( final IllegalArgumentException ex ) { return false ; }
final TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
final TimeZone zone = calendar . getTimeZone () ;
{ final int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
final FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( final Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ final Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ final Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
final StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
final StrMatcher matcher = StrMatcher . noneMatcher () ;
final StrMatcher matcher = StrMatcher . quoteMatcher () ;
final StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
final StrMatcher matcher = StrMatcher . trimMatcher () ;
final StrMatcher matcher = StrMatcher . splitMatcher () ;
final StrMatcher matcher = StrMatcher . spaceMatcher () ;
final StrMatcher matcher = StrMatcher . tabMatcher () ;
final StrMatcher matcher = StrMatcher . commaMatcher () ;
final String oldValue = this . property ;
{ final Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( final RuntimeException e ) {}
final char pad = CHAR_CONS ;
final Token tok2 = ( Token ) obj2 ;
final int sz = tokens.length ;
final String str = super . getContent () ;
final char buf [] = buffer ;
final int strLen = str . length () ;
final char [] thisBuf = buffer ;
final char [] thisBuf = buffer ;
final int len = str . length () ;
final int len = str . length () ;
final char [] buf = buffer ;
final int newSize = size - removeLen + insertLen ;
final int len = endIndex - startIndex ;
final int len = chars.length ;
{ if ( iterable != null ) { for ( final Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( final Object element : array ) { append ( element ) ; } }
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final int len = length () ;
final char [] old = buffer ;
final char [] old = buffer ;
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
final FastDateParser other = ( FastDateParser ) obj ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
final long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
final long expectedValue = hours ;
final long expectedValue = hours ;
{ final long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ final long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
final long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ final long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
final long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ final long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
final CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
final CharRange rangea = CharRange . is ( CHAR_CONS ) ;
final boolean element
for ( final boolean element : array ) { if ( element ) { return true ; } }
for ( final boolean element : array ) { if ( ! element ) { return false ; } }
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
{ final String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
final String str = intRange . toString () ;
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ final DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( final NumberFormatException nfe ) {}
final String osName = System . getProperty ( STRING_CONSTANT ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
final File dir = SystemUtils . getUserHome () ;
final File dir = SystemUtils . getUserDir () ;
final File dir = SystemUtils . getJavaIoTmpDir () ;
final File dir = SystemUtils . getJavaHome () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ final BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( final IllegalArgumentException ex ) {}
{ final double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ final long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
final String o1 = STRING_CONSTANT ;
final String o1 = STRING_CONSTANT ;
{ final TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final long anotherVal = other.value ;
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
catch ( final NullPointerException ex ) {}
final StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
catch ( final IndexOutOfBoundsException ex ) {}
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
final StrBuilder sb = new StrBuilder () ;
{ for ( final L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
final BitSet toRemove = new BitSet () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Locale dflt = Locale . getDefault () ;
final Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( final NullPointerException npe ) {}
final GregorianCalendar cal = new GregorianCalendar () ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
final Date base = new Date ( MILLIS_TEST ) ;
catch ( final IllegalArgumentException ex ) {}
catch ( final IllegalArgumentException ex ) {}
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( final NoSuchMethodException e ) { return null ; } }
try { return Charset . isSupported ( name ) ; } catch ( final IllegalCharsetNameException ex ) { return false ; }
catch ( final SerializationException ex ) { return; }
{ final Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
catch ( final SerializationException ex ) { return; }
catch ( final SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( final IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( final IllegalArgumentException ex ) { return; } fail () ; }
final Exception ex = new Exception () ;
catch ( final IllegalStateException e ) {}
final Object obj = new Object () ;
final TestSubObject rhs = ( TestSubObject ) o ;
final TestObject rhs = ( TestObject ) o ;
final MessageFormat result = new MessageFormat ( pattern ) ;
for ( final Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
final CharSet other = ( CharSet ) obj ;
{ for ( final CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
final int sz = set.length ;
{ try { throw new ExceptionWithoutCause () ; } catch ( final Throwable t ) { return t ; } }
try { mutNum . compareTo ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( final NullPointerException ex ) {}
catch ( final IllegalArgumentException expected ) {}
final char cur = current ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final CharRange other = ( CharRange ) obj ;
if ( start > end ) { final char temp = start ; start = end ; end = temp ; }
catch ( final SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
final V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( final ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ final ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ final ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
{ final ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( final IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
final Person p = new Person () ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
final MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
{ final Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
final int anotherVal = other.value ;
final InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
final ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
final SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
final SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
final SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
final SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
final Outer outer = new Outer () ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final String baseStr = this . toBaseString ( array ) ;
final Character c = new Character ( CHAR_CONS ) ;
{ try { coll . add ( null ) ; fail () ; } catch ( final UnsupportedOperationException ex ) {} }
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( localeString ) ;
final Locale locale = LocaleUtils . toLocale ( language ) ;
final IllegalArgumentException ex
final long seed = System . currentTimeMillis () ;
final long seed = System . currentTimeMillis () ;
final String message = exceptionContext . getMessage () ;
final String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
try { return Short . parseShort ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( final NumberFormatException nfe ) { return defaultValue ; }
final int start = index + NUMBER_CONSTANT ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( final NullPointerException ex ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + str + STRING_CONSTANT + value ) ; }
{ return cache . getTimeInstance ( style , timeZone , locale ) ; }
{ return cache . getTimeInstance ( style , timeZone , null ) ; }
{ return cache . getTimeInstance ( style , null , locale ) ; }
{ return cache . getTimeInstance ( style , null , null ) ; }
{ return cache . getDateInstance ( style , timeZone , locale ) ; }
{ return cache . getDateInstance ( style , timeZone , null ) ; }
{ return cache . getDateInstance ( style , null , locale ) ; }
{ return cache . getDateInstance ( style , null , null ) ; }
return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
Strategy strategy = cache . get ( locale ) ;
if ( nullText != null && nullText . isEmpty () ) { nullText = null ; }
if ( str . isEmpty () ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . isEmpty () ) { return EMPTY ; }
return str . isEmpty () ? null : str ;
if ( str . isEmpty () || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . < Integer > stub () ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
assertNotSame ( empty , result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () { private static final long serialVersionUID = NUMBER_CONSTANT ; } )
{ if ( this . runningState == State.UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != SplitState.SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( Validate . notNull ( componentType , STRING_CONSTANT ) ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < ? extends E > values
final Iterable < ? extends E > values
{ return new FastDateParser ( format , timeZone , locale , null ) ; }
assertNull ( StringUtils . normalizeSpace ( null ) ) ;
assertNull ( StringUtils . difference ( null , null ) ) ;
assertNull ( StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . reverse ( null ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertNull ( StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertNull ( StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertNull ( StringUtils . deleteWhitespace ( null ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . splitPreserveAllTokens ( null ) ) ;
assertNull ( StringUtils . split ( null , CHAR_CONS ) ) ;
assertNull ( StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
( ( days - NUMBER_CONSTANT ) * DateUtils.MILLIS_PER_DAY )
assertNull ( StringUtils . swapCase ( null ) ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
DiffResult list = class1 . diff ( class2 ) ;
final Class < > context
final Class < > context
list0 = new ArrayList < Object > ( Arrays . asList ( new Object [ NUMBER_CONSTANT ] ) )
assertEquals ( STRING_CONSTANT , StringUtils . join ( new Object [ NUMBER_CONSTANT ] ) ) ;
return readField ( field , target , false ) ;
return readField ( field , target , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , target , value , false ) ;
writeField ( field , ( Object ) null , value , false ) ;
writeStaticField ( field , value , false ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( left , right , diffs , style ) ; }
{ this ( message , cause , null ) ; }
public NotImplementedException ( final Throwable cause ) { this ( cause , null ) ; }
{ this ( message , ( String ) null ) ; }
return Character . codePointCount ( input , NUMBER_CONSTANT , input . length () ) ;
{ pos += Character . charCount ( Character . codePointAt ( input , pos ) ) ; }
final Date centuryStart
{ return getFragment ( calendar , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( calendar , fragment , TimeUnit.MILLISECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.DAYS ) ; }
{ return getFragment ( date , fragment , TimeUnit.HOURS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MINUTES ) ; }
{ return getFragment ( date , fragment , TimeUnit.SECONDS ) ; }
{ return getFragment ( date , fragment , TimeUnit.MILLISECONDS ) ; }
return NOT_FOUND ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
regex . append ( STRING_CONSTANT ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase ( locale ) ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : lKeyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + srcPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
shift = i + dstPos ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
final Interfaces interfacesBehavior
final String [] zone
{ final int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
final Calendar definingCalendar
final SimpleClass obj
public SimpleClass ( final boolean booleanField ) { this . booleanField = booleanField ; }
{ final String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
protected BooleanDiff ( final String fieldName ) { super ( fieldName ) ; }
{ for ( final Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
final Field field
final Class < > cls
final StringBuilder sb = new StringBuilder () ;
final StringBuilder sb = new StringBuilder () ;
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
final GenericArrayType g
final WildcardType w
final ParameterizedType p
final TypeVariable < > v
final Class < > c
final TypeVariable < > var
final Type type
final Object obj
final Object obj
final Object obj
final Type componentType
final Type . . . bounds
final Type . . . bounds
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
final float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
final long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( final String t ) { super . consume ( t ) ; }
@ Override public void consume ( final T t ) {}
final Calendar c = Calendar . getInstance () ;
final Method m
final Method m
final char ch
final char ch
final Object obj
final StringBuilder source
final CharSequence source
final T value
final String fieldName
final TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( final Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
final TypeTestClass obj
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
final CharSequence . . . css
final CharSequence . . . css
final Locale locale
final Locale locale
final Locale locale
final String [] element
final String [] element
for ( final CharSequence searchString : searchStrings ) { if ( endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( startsWith ( string , searchString ) ) { return true ; } }
{ return isEmpty ( str ) ? defaultStr : str ; }
{ return isBlank ( str ) ? defaultStr : str ; }
{ return ! isBlank ( cs ) ; }
{ return ! isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( str . substring ( NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , ModifyType.CEILING ) ;
modify ( gval , field , ModifyType.CEILING ) ;
modify ( truncated , field , ModifyType.TRUNCATE ) ;
modify ( gval , field , ModifyType.TRUNCATE ) ;
modify ( rounded , field , ModifyType.ROUND ) ;
modify ( gval , field , ModifyType.ROUND ) ;
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
class Named {}
{ type = array . getClass () . getComponentType () ; }
appendQuotedString ( pattern , pos , sb ) ;
getQuotedString ( pattern , pos ) ;
appendQuotedString ( pattern , pos , stripCustom ) ;
{ regex . append ( pattern ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( value ) ; } }
exec . awaitTermination ( NUMBER_CONSTANT , TimeUnit.SECONDS ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && isOSVersionMatch ( osVersion , osVersionPrefix ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return getLength ( array ) == NUMBER_CONSTANT ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
{ return ! isEmpty ( array ) ; }
final int halflength = shorter . length () / NUMBER_CONSTANT + NUMBER_CONSTANT ;
( ! f . getName () . contains ( STRING_CONSTANT ) )
( ! field . getName () . contains ( STRING_CONSTANT ) )
( ! f . getName () . contains ( STRING_CONSTANT ) )
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( ! isEquals ) { return this ; }
{ if ( ! isEquals ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || modType == ModifyType.ROUND && roundUp
{ DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , Calendar.MAY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.OCTOBER , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.DECEMBER , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.JUNE , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , Calendar.FEBRUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , Calendar.JANUARY , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
text = DateFormatUtils . format ( cal , DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . getPattern () , timeZone ) ;
{ return format ( calendar . getTime () , buf ) ; }
final String actualValue = FastDateFormat . getInstance ( PATTERN , this . timeZone ) . format ( cal ) ;
if ( tokenLen == NUMBER_CONSTANT ) { rule = Iso8601_Rule.ISO8601_HOURS_COLON_MINUTES ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) { threadGroup . destroy () ; }
this . typeArguments = typeArguments . clone () ;
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
super ( checkNotNull ( object ) , style , buffer ) ;
{ super ( checkNotNull ( object ) , style , buffer ) ; }
{ super ( checkNotNull ( object ) , style ) ; }
{ super ( checkNotNull ( object ) ) ; }
@ Override public boolean test ( final Thread thread ) { return true ; }
@ Override public boolean test ( final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections . emptyList () ; }
tz = tzNames . get ( value . toLowerCase ( locale ) ) ;
{ regex . append ( validTimeZoneChars ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { simpleQuote ( regex , textKeyValue ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null ) ; }
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final DateParser fdp = getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuilder ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuilder ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toTitleCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; } }
if ( count == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
return new StringBuilder ( annotationType == null ? StringUtils.EMPTY : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = StringUtils.EMPTY ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = StringUtils.EMPTY ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = StringUtils.EMPTY ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = StringUtils.EMPTY ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = StringUtils.EMPTY ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = StringUtils.EMPTY ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = StringUtils.EMPTY ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = StringUtils.EMPTY ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = StringUtils.EMPTY ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = StringUtils.EMPTY ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = StringUtils.EMPTY ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = StringUtils.EMPTY ; } this . arrayStart = arrayStart ; }
{ return obj == null ? StringUtils.EMPTY : obj . toString () ; }
if ( pos >= count ) { addToken ( tokenList , StringUtils.EMPTY ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return StringUtils.EMPTY ; }
if ( th == null ) { return StringUtils.EMPTY ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , StringUtils.EMPTY ) ) ; }
if ( length <= NUMBER_CONSTANT || index >= size ) { return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
{ return StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
if ( str == null ) { str = StringUtils.EMPTY ; }
lKeyValues = appendDisplayNames ( definingCalendar , locale , field , regex ) ;
{ return parseDateWithLeniency ( str , locale , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; varArgs = null ; }
public TestBean () { toString = STRING_CONSTANT ; varArgs = null ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , indices ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , indices ) ; }
{ assertEquals ( str , toString ) ; assertArrayEquals ( args , varArgs ) ; }
{ return getCause ( throwable , null ) ; }
assertEquals ( STRING_CONSTANT , JAVA_9 , get ( STRING_CONSTANT ) ) ;
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_9 ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isCreatable ( val ) ;
if ( srcArgs.length < normalArgsLen ) { return Float.MAX_VALUE ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = lhs.length < rhs.length ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = firstChar == CHAR_CONS || firstChar == CHAR_CONS ;
final String javaVersion = SystemUtils.JAVA_VERSION ;
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
if ( ArrayUtils . isEmpty ( css ) ) { return false ; }
{ return new ImmutablePair <> ( left , right ) ; }
final Set < Locale > jdkLocaleSet = new HashSet <> ( jdkLocaleList ) ;
final List < Field > allFieldsInteger = new ArrayList <> ( fieldsInteger ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer <> ( call ) ;
{ new CallableBackgroundInitializer <> ( null ) ; }
tasks = new ArrayList <> ()
this . diffs = new ArrayList <> () ;
final HashSet < Integer > toRemove = new HashSet <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > frames = new ArrayList <> () ;
final List < Throwable > list = new ArrayList <> () ;
typeVarAssigns = new HashMap <> ()
final List < Field > annotatedFields = new ArrayList <> () ;
final List < Field > allFields = new ArrayList <> () ;
final Map < String , E > map = new LinkedHashMap <> () ;
final List < String > tokenList = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( tokens.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet <> () ) ;
final List < Class < > > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
{ return new ConstantFuture <> ( value ) ; }
{ return new MapStrLookup <> ( map ) ; }
final HashMap < Boolean , MutableInt > occurrences = new HashMap <> ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap <> ( values.length ) ;
final AtomicReference < InterruptedException > iex = new AtomicReference <> () ;
{ return new MutablePair <> ( left , right ) ; }
if ( m == null ) { REGISTRY . set ( new WeakHashMap <> () ) ; }
countries = new ArrayList <> () ;
langs = new ArrayList <> () ;
final List < Locale > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
final Set < Type > types = new HashSet <> ( bounds.length ) ;
{ priorVariables = new ArrayList <> () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap <> () ;
final Map < String , Object > map = new HashMap <> () ;
final Set < String > labels = new HashSet <> () ;
final List < Object > values = new ArrayList <> () ;
{ contextValues . add ( new ImmutablePair <> ( label , value ) ) ; return this ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap <> () ;
iMap = new HashMap <> () ;
this . listeners = new CopyOnWriteArrayList <> ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList <> () ;
{ return new EventListenerSupport <> ( listenerInterface ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList <> () ;
final List < Class < > > candidateClasses = new ArrayList <> () ;
final List < String > classNames = new ArrayList <> ( classes . size () ) ;
final List < Class < > > classes = new ArrayList <> () ;
final HashMap < Integer , String > map = new HashMap <> () ;
{ expectedSource = source ; changedValues = new ArrayList <> () ; }
final List < Object > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> ( array.length ) ;
final List < Method > annotatedMethods = new ArrayList <> () ;
final Set < Method > result = new LinkedHashSet <> () ;
this . eventTypes = new HashSet <> ( Arrays . asList ( eventTypes ) ) ;
if ( registry == null ) { registry = new HashSet <> () ; REGISTRY . set ( registry ) ; }
final MutableObject < String > obj = new MutableObject <> ( replaceTemplate ) ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
final Map < String , String > map = new HashMap <> () ;
values = new HashMap <> () ;
final HashMap < T , MutableInt > occurrences = new HashMap <> ( items.length ) ;
final TreeSet < T > sort = new TreeSet <> ( comparator ) ;
final TreeSet < T > sort = new TreeSet <> () ;
final List < ThreadGroup > result = new ArrayList <> ( count ) ;
final List < Thread > result = new ArrayList <> ( count ) ;
final Collection < Thread > result = new ArrayList <> () ;
{ return new ImmutablePair <> ( left , right ) ; }
final Map < DateParser , Integer > map = new HashMap <> () ;
final Set < String > sorted = new TreeSet <> ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap <> ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList <> () ;
final HashSet < Locale > testLocales = new HashSet <> () ;
final String s = new ConstantInitializer <> ( null ) . toString () ;
checkEquals ( new ConstantInitializer <> ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer <> ( VALUE ) ; }
triple = new MutableTriple <> ()
pair = new MutablePair <> ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair <> () ;
{ return new Range <> ( fromInclusive , toInclusive , comparator ) ; }
tasks = new ArrayList <> ()
List < TimeZone > timeZones = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final ArrayList < String > substrings = new ArrayList <> () ;
final List < String > list = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final List < String > excludeList = new ArrayList <> () ;
final Collection < String > coll = new ArrayList <> () ;
final Collection < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final List < String > coll = new ArrayList <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Map < String , Integer > map = new HashMap <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
final Collection < Integer > coll = new ArrayList <> () ;
final List < Rule > rules = new ArrayList <> () ;
public CircuitBreakingException ( final Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( final String message ) { super ( message ) ; }
public Customer ( final String name ) { this . name = name ; }
public Bank ( final String name ) { this . name = name ; }
final Object object
final Object object
final FastDateParser parser
final FastDateParser parser
final FastDateParser parser
@ Override int modify ( final FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
final int tokenLen
ISO8601TimeZoneStrategy ( final String pattern ) { createPattern ( pattern ) ; }
final FastDateParser parser
final FastDateParser parser
void createPattern ( final String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( final StringBuilder regex ) { createPattern ( regex . toString () ) ; }
final char c
final char c
final ListIterator < StrategyAndWidth > lt
public FastDatePrinterTimeZonesTest ( final TimeZone timeZone ) { this . timeZone = timeZone ; }
final int . . . args
final String . . . s
class LANG1261ParentObject { @ Override public boolean equals ( final Object o ) { return true ; } }
final Method method
final SystemDefaults defaults
final SystemDefaults defaults
final int len
final Constructor < > constructor
final Method method
private static Executable of ( final Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( final Method method ) { return new Executable ( method ) ; }
final Number . . . args
final String . . . args
final Number . . . args
final String . . . args
public static String numOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( final Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( final int . . . values ) { return values ; }
final PropertyChangeListener listener
final PropertyChangeListener listener
final State newState
final State state
final Boolean . . . values
final PropertyChangeEvent evt
final Object source
final long time
final TimeZone tz
final String valueAsString
final String valueAsString
final int spaces
final Long increment
final long threshold
final boolean [] array
final char [] array
final byte [] array
final short [] array
final long [] array
final int [] array
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final int offset
final TimeZone tz
final int tokenLen
final int value
final Object obj
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( final EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
final int delta
final State state
final State newState
final int increment
final Integer increment
private NotVisibleException ( final Throwable cause ) { this . cause = cause ; }
final boolean allowDuplicate
final Calendar calendar
final Calendar calendar
final Class < ? extends Throwable > type
final Throwable throwable
final Throwable throwable
final Throwable throwable
final String key
final long nanos
final int max
final StringBuilder decomposed
final int maxWidth
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
final ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
catch ( final UnsupportedOperationException e ) {}
final long randomResult = RandomUtils . nextLong () ;
final float randomResult = RandomUtils . nextFloat () ;
final double randomResult = RandomUtils . nextDouble () ;
final int randomResult = RandomUtils . nextInt () ;
final float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
final float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
final float result = mutNum . getAndDecrement () ;
final float result = mutNum . decrementAndGet () ;
final float result = mutNum . getAndIncrement () ;
final float result = mutNum . incrementAndGet () ;
final Calendar cal = Calendar . getInstance () ;
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( final Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
final byte result = mutNum . getAndDecrement () ;
final byte result = mutNum . decrementAndGet () ;
final byte result = mutNum . getAndIncrement () ;
final byte result = mutNum . incrementAndGet () ;
final short result = mutNum . getAndDecrement () ;
final short result = mutNum . decrementAndGet () ;
final short result = mutNum . getAndIncrement () ;
final short result = mutNum . incrementAndGet () ;
final double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
final double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
final double result = mutNum . getAndDecrement () ;
final double result = mutNum . decrementAndGet () ;
final double result = mutNum . getAndIncrement () ;
final double result = mutNum . incrementAndGet () ;
final StringBuilder sb = new StringBuilder () ;
final int result = mutNum . getAndDecrement () ;
final int result = mutNum . decrementAndGet () ;
final int result = mutNum . getAndIncrement () ;
final int result = mutNum . incrementAndGet () ;
catch ( final IllegalAccessException e ) { return null ; }
catch ( final Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( final Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
final Format fdf = FastDateFormat . getInstance ( pattern ) ;
{ final StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
final long time = now () ;
catch ( final InterruptedException iex ) {}
final StringBuilder regex = new StringBuilder () ;
final int sIdx = idx + pos . getIndex () ;
final char c = value . charAt ( i ) ;
final ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
final char c = pattern . charAt ( currentIdx ) ;
{ final int last = value ; this . value += operand . intValue () ; return last ; }
{ final int last = value ; this . value += operand ; return last ; }
{ final int last = value ; value -- ; return last ; }
{ final int last = value ; value ++ ; return last ; }
{ final short last = value ; this . value += operand . shortValue () ; return last ; }
{ final short last = value ; this . value += operand ; return last ; }
{ final short last = value ; value -- ; return last ; }
{ final short last = value ; value ++ ; return last ; }
{ final long last = value ; this . value += operand . longValue () ; return last ; }
{ final long last = value ; this . value += operand ; return last ; }
{ final long last = value ; value -- ; return last ; }
{ final long last = value ; value ++ ; return last ; }
final Calendar calendar = Calendar . getInstance () ;
final Calendar cal = Calendar . getInstance ( SWEDEN ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
{ final float last = value ; this . value += operand . floatValue () ; return last ; }
{ final float last = value ; this . value += operand ; return last ; }
{ final float last = value ; value -- ; return last ; }
{ final float last = value ; value ++ ; return last ; }
final ExecutorService exec = Executors . newSingleThreadExecutor () ;
final Locale save = Locale . getDefault () ;
final TimeZone save = TimeZone . getDefault () ;
{ final String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
final String encoding = STRING_CONSTANT ;
final String methodStr = m . toString () ;
final long result = mutNum . getAndDecrement () ;
final long result = mutNum . decrementAndGet () ;
final long result = mutNum . getAndIncrement () ;
final long result = mutNum . incrementAndGet () ;
final Exception ex
final StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
final int lastHold = start ;
final int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( final IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
final StringBuilder sb = new StringBuilder () ;
for ( final CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( final CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( final CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ try { return System . getProperty ( key ) ; } catch ( final SecurityException scex ) {} }
final int [] clonedIndices = clone ( indices ) ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final int n_offset = n - offset ;
final short aux = array [ offset1 ] ;
final Object aux = array [ offset1 ] ;
final long aux = array [ offset1 ] ;
final int aux = array [ offset1 ] ;
final float aux = array [ offset1 ] ;
final double aux = array [ offset1 ] ;
final char aux = array [ offset1 ] ;
final byte aux = array [ offset1 ] ;
final boolean aux = array [ offset1 ] ;
{ final StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
final Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ double balance = NUMBER_CONSTANT ; for ( final Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
final Calendar calendar = Calendar . getInstance () ;
final DateParser parser = getInstance ( YMD_SLASH ) ;
final Calendar cal = Calendar . getInstance ( tz ) ;
{ final byte last = value ; this . value += operand . byteValue () ; return last ; }
{ final byte last = value ; this . value += operand ; return last ; }
{ final byte last = value ; value -- ; return last ; }
{ final byte last = value ; value ++ ; return last ; }
{ final double last = value ; this . value += operand . doubleValue () ; return last ; }
{ final double last = value ; this . value += operand ; return last ; }
{ final double last = value ; value -- ; return last ; }
{ final double last = value ; value ++ ; return last ; }
final Diff < > diff
methodName . equals ( method . getName () ) && Objects . deepEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer <> ( computable ) ;
if ( ! isEquals ) { return this ; }
final StrategyParser fm = new StrategyParser ( definingCalendar ) ;
public void setCycle ( final TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( final int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( final int n ) { this . n = n ; }
final int offset
final boolean testRecursive
final String . . . excludeFields
final Class < > reflectUpToClass
final boolean testRecursive
final boolean testTransients
final Locale [] availableLocales = NumberFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , calendar . getWeekYear () ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d . doubleValue () ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () + offset ; }
@ SuppressWarnings ( { STRING_CONSTANT , STRING_CONSTANT } ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
@ SuppressWarnings ( STRING_CONSTANT ) final T . . . array
assertEquals ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ assertEquals ( baseStr + STRING_CONSTANT + System . lineSeparator () + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
{ if ( newLine == null ) { append ( System . lineSeparator () ) ; return this ; } return append ( newLine ) ; }
final String linebreak = System . lineSeparator () ;
final String linebreak = System . lineSeparator () ;
final String systemNewLine = System . lineSeparator () ;
final String systemNewLine = System . lineSeparator () ;
if ( newLineStr == null ) { newLineStr = System . lineSeparator () ; }
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ; }
assertFalse ( CharUtils . isAsciiPrintable ( CHAR_COPY ) ) ;
final GenericDeclaration d = var . getGenericDeclaration () ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameLocalTime ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameInstant ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , null ) ; }
{ DateUtils . isSameInstant ( null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , null ) ; }
{ DateUtils . isSameDay ( null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , null ) ; }
{ DateUtils . isSameDay ( null , new Date () ) ; }
assertNull ( LocaleUtils . toLocale ( null ) ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( BAR , ObjectUtils . toString ( null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( null ) ) ;
intRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( null ) ) ;
assertFalse ( BooleanUtils . isFalse ( null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( null ) ) ;
assertFalse ( BooleanUtils . isTrue ( null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( null ) ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( null ) ) ;
array = ArrayUtils . removeElement ( null , true ) ;
array = ArrayUtils . removeElement ( null , STRING_CONSTANT ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , null ) ;
sb . setNullText ( null ) ;
sb . setNewLineText ( null ) ;
final StrBuilder sb5 = new StrBuilder ( null ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( cyclicCause . getCause () . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( cyclicCause . getCause () . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( message ) ; } }
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
longRange = Range . between ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str ) ;
classes . add ( NUMBER_CONSTANT , cls ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertTrue ( trace . contains ( TEST_MESSAGE ) ) ;
assertTrue ( trace . contains ( STRING_CONSTANT ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertFalse ( stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertFalse ( contextMessage . contains ( TEST_MESSAGE ) ) ;
final HashSet < Integer > toRemove = new HashSet <> () ;
super . reflectionAppendArrayDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
static String getFieldName () { return STRING_CONSTANT ; }
SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher () ) ;
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . asList ( values ) ) ; }
{ return TypeUtils . wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . emptyMap () ; }
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertTrue ( StringUtils . containsOnly ( str , CHAR_CONS ) ) ;
assertNull ( ObjectUtils . firstNonNull () ) ;
void event2 ( PropertyChangeEvent e ) ;
void event1 ( PropertyChangeEvent e ) ;
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
final List < String > strColl = Arrays . asList ( STRING_CONSTANT ) ;
TestEmptySubObject ( final int a ) { super ( a ) ; }
TestSubObject () { super ( NUMBER_CONSTANT ) ; }
BackgroundInitializerTestImpl () { super(); }
@ SuppressWarnings ( STRING_CONSTANT ) NestableException () { super(); }
{ return options != null && options . contains ( option ) ; }
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
final List < Object > list = new ArrayList <> ( ARRAYLIST_INITIAL_CAPACITY ) ;
if ( isEmpty ( str ) || wrapChar == CharUtils.NUL ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CharUtils.NUL ) { return str ; } return wrapWith + str + wrapWith ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CharUtils.NUL ; }
assertNull ( StringUtils . unwrap ( null , CharUtils.NUL ) ) ;
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
if ( ! ( obj instanceof TypeLiteral ) ) { return false ; }
public boolean isFalse () { return ! value ; }
public boolean isTrue () { return value ; }
{ if ( ! expression ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( ! expression ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( ! ( obj instanceof FastDateFormat ) ) { return false ; }
if ( ! ( obj instanceof Fraction ) ) { return false ; }
if ( ! ( obj instanceof FastDatePrinter ) ) { return false ; }
if ( ! toClass . isPrimitive () ) { return false ; }
{ if ( ! isAsciiNumeric ( ch ) ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
if ( ! ( obj instanceof CharSet ) ) { return false ; }
I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getRight () , pair . getLeft () ) ;
if ( ! hasNext ) { throw new NoSuchElementException () ; }
if ( ! ( obj instanceof CharRange ) ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; fail ( STRING_CONSTANT ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( TimeZones.GMT_ID ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( TimeZones.GMT_ID ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase ( Locale.ROOT ) ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase ( Locale.ROOT ) ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase ( Locale.ROOT ) ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase ( Locale.ROOT ) ) ; }
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
TimeZone . setDefault ( FastTimeZone . getGmtTimeZone () ) ;
final TimeZone utc = FastTimeZone . getGmtTimeZone () ;
timeZone = FastTimeZone . getGmtTimeZone () ;
{ final TimeZone timeZone = FastTimeZone . getGmtTimeZone () ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
final Calendar c = Calendar . getInstance ( FastTimeZone . getGmtTimeZone () ) ;
assertNull ( StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertNull ( tok . getContent () ) ;
assertNull ( tokenizer . nextToken () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( tok . next () ) ;
assertNull ( ObjectUtils . identityToString ( null ) ) ;
assertNull ( StringUtils . strip ( null ) ) ;
assertNull ( StringUtils . trim ( null ) ) ;
assertNull ( BooleanUtils . toStringYesNo ( null ) ) ;
assertNull ( BooleanUtils . toStringOnOff ( null ) ) ;
assertNull ( BooleanUtils . toStringTrueFalse ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertNull ( BooleanUtils . toIntegerObject ( null ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertNull ( BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertNull ( StringEscapeUtils . unescapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJson ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeCsv ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertNull ( StringEscapeUtils . unescapeJava ( null ) ) ;
assertNull ( StringEscapeUtils . escapeJava ( null ) ) ;
assertNull ( new MutableObject <> () . getValue () ) ;
assertNull ( StringUtils . getDigits ( null ) ) ;
assertNull ( StringUtils . wrap ( null , null ) ) ;
assertNull ( StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
assertNull ( ClassUtils . getAllInterfaces ( null ) ) ;
assertNull ( ClassUtils . getAllSuperclasses ( null ) ) ;
assertNull ( WordUtils . swapCase ( null ) ) ;
assertNull ( WordUtils . initials ( null ) ) ;
assertNull ( WordUtils . uncapitalize ( null , null ) ) ;
assertNull ( WordUtils . uncapitalize ( null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null , null ) ) ;
assertNull ( WordUtils . capitalizeFully ( null ) ) ;
assertNull ( WordUtils . capitalize ( null , null ) ) ;
assertNull ( WordUtils . capitalize ( null ) ) ;
{ assertNull ( CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertNull ( CharUtils . toString ( null ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertNull ( ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertNull ( ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( ArrayUtils . toPrimitive ( null , false ) ) ;
assertNull ( ArrayUtils . toPrimitive ( b ) ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( array ) ;
assertNull ( ArrayUtils . toMap ( null ) ) ;
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertNull ( CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
{ assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
assertNotEquals ( summer . getTime () , standard . getTime () ) ;
assertEquals ( cal . getTime () , date ) ;
assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
{ watch . getStartTime () ; assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
@ Test public void testUTC () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ assertEquals ( REPEAT , future . get () . intValue () ) ; }
assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
assertEquals ( expected , hostName ) ;
assertEquals ( isoForm , printer . format ( vulgar ) ) ;
assertEquals ( vulgar . getTime () , cal . getTime () ) ;
final T object
{ super(); for ( final String s : set ) { add ( s ) ; } }
final boolean excludeNullValues
final StringBuilder builder = new StringBuilder ( count ) ;
catch ( final NoSuchMethodException expected ) {}
final TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
{ final boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
final Object other
@ Override public boolean inDaylightTime ( final Date date ) { return false ; }
@ Override public void setRawOffset ( final int offsetMillis ) { throw new UnsupportedOperationException () ; }
final Class < > anInterface
final ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
for ( final char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
final String group
final String group
final double [] array
final float [] array
final long [] array
final int [] array
final short [] array
final char [] array
final byte [] array
final boolean [] array
final Object [] array
final String . . . s
final CharRange a = CharRange . is ( CHAR_CONS ) ;
final CharSequence cs
final String value
{ list . add ( throwable ) ; throwable = throwable . getCause () ; }
assertTrue ( String . format ( STRING_CONSTANT , delta ) , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( increment ) ; }
this . typeArguments = Arrays . copyOf ( typeArguments , typeArguments.length , Type [] . class ) ;
daemon = null ;
{ daemon = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemon ;
public final Boolean getDaemonFlag () { return daemon ; }
daemon = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . endsWith ( getArrayEnd () ) ; }
{ return defaultString ( str , EMPTY ) ; }
final String sanitizedSeparator = defaultString ( separator ) ;
if ( str == null || suffix == null ) { return str == suffix ; }
if ( str == null || prefix == null ) { return str == prefix ; }
{ bypassReflectionClasses = new ArrayList <> () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
ArrayUtils . shuffle ( array1 , new Random ( SEED ) ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( JACOCO_DATA_FIELD_NAME ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( StringEscapeUtils . escapeJson ( value ) ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + StringEscapeUtils . escapeJson ( fieldName ) + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , EMPTY ) ; }
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = new StringBuilder ( STRING_BUILDER_SIZE ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
final StringBuilder buf = newStringBuilder ( noOfItems ) ;
int [] indexesToRemove = {} ;
return ! str . isEmpty () ;
if ( diffs . isEmpty () ) { return OBJECTS_SAME_STRING ; }
{ return IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
private Object readResolve () { return JSON_STYLE ; }
private Object readResolve () { return NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return MULTI_LINE_STYLE ; }
private Object readResolve () { return SIMPLE_STYLE ; }
private Object readResolve () { return SHORT_PREFIX_STYLE ; }
private Object readResolve () { return NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return DEFAULT_STYLE ; }
return replace ( source , valueMap ) ;
return getFraction ( numerator / gcd , denominator / gcd ) ;
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) deserialize ( serialize ( msg ) ) ; }
Throwable root = getRootCause ( th ) ;
final Throwable [] throwables = getThrowables ( throwable ) ;
final int srcLength = getLength ( array ) ;
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
private Object readResolve () { return NULL ; }
{ final int tmpHash = hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! equals ( object1 , object2 ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
{ return wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( getTypeArguments ( p ) ) ; }
notNull ( chars ) ;
notNull ( collection ) ;
notNull ( array ) ;
notNull ( iterable ) ;
notNull ( array ) ;
if ( isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( EMPTY ) ;
{ return iValue == NUMBER_CONSTANT ? Calendar.SUNDAY : iValue + NUMBER_CONSTANT ; }
{ _mask = mask ; _shift_count = mask == NUMBER_CONSTANT ? NUMBER_CONSTANT : Integer . numberOfTrailingZeros ( mask ) ; }
mRule . appendTo ( buffer , value == Calendar.SUNDAY ? NUMBER_CONSTANT : value - NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = NUMBER_CONSTANT ; return this ; }
try { retDT = new DateTime ( s ) ; } catch ( IllegalArgumentException pe ) {}
IllegalArgumentException e
final Object f
final Object f
final Object f
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final int minDigits
final DateTimeField field
final DateTimeField field
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( StrictMath . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
Chronology chrono = new LenientChronology ( ISOChronology . getInstanceUTC () ) ;
public int getMinimumValue ( long instant ) { return NUMBER_CONSTANT ; }
long value
final long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerYear () ) ; iChronology = chronology ; }
DateTime instant
public int get ( long instant ) { return BuddhistChronology.BE ; }
public String getNameKey ( long instant ) { return iNameKey ; }
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
IllegalArgumentException pe
{ return add ( millis , ( long ) value - get ( millis ) ) ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , long value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
{ Chronology chrono = getChronology () ; return ( chrono != null ? chrono . getDateTimeZone () : null ) ; }
protected AbstractInstant () { super(); }
catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( IllegalArgumentException pe ) { pe . printStackTrace () ; }
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
long value
if ( zone == null ) { zone = DateTimeZone . getDefault () ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getRoughMillisPerMonth () ) ; iChronology = chronology ; }
long value
public abstract boolean equals ( Object object ) ;
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
final char c
final char style
final char style
public RealMatrix copy () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
markNameProcessed ( nameNode . getQualifiedName () ) ;
{ if ( isNameProcessed ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator () ) ; }
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator () ) ; }
public int getThrowableCount () { return NUMBER_CONSTANT ; }
