{ super . moveDateTimeZone ( zone ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
if ( sm != null ) { sm . checkPermission ( new DateTimeZonePermission ( STRING_CONSTANT ) ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , null ) ; }
DurationField getLeapDurationField ( ) ;
boolean isSupported ( ) ;
DateTime result = new DateTime ( test . resolve ( dt . getMillis () ) ) ;
{ this ( instant , null ) ; }
{ this ( DateTimeUtils . currentTimeMillis () , chronology ) ; }
public TimeOfDay () { this ( DateTimeUtils . currentTimeMillis () , null ) ; }
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
return ( getMillis ( readableInstant ) < readableInstant . getMillis ( this ) ) ;
iInstantConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , PartialInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
PartialInstant instant
public abstract int getMaximumValue ( PartialInstant instant ) ;
PartialInstant instant
public abstract int getMinimumValue ( PartialInstant instant ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
PartialInstant partial
PartialInstant partial
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
{ return getField () . getMaximumValue ( getPartialInstant () ) ; }
{ return getField () . getMinimumValue ( getPartialInstant () ) ; }
{ return getField () . getAsShortText ( getPartialInstant () , get () , locale ) ; }
{ return getField () . getAsText ( getPartialInstant () , get () , locale ) ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMaximumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { throw unsupported () ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant partial
PartialInstant partial
{ test1 . millisOfSecond () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . millisOfSecond () . getPartialInstant () ) ;
{ test1 . secondOfMinute () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . secondOfMinute () . getPartialInstant () ) ;
{ test1 . minuteOfHour () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . minuteOfHour () . getPartialInstant () ) ;
{ test1 . hourOfDay () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . hourOfDay () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public int getMinimumValue ( PartialInstant instant ) { return NUMBER_CONSTANT ; }
PartialInstant instant
void validate ( PartialInstant instant ) ;
public DateTimeField getField () { return iInstant . getField ( iFieldIndex ) ; }
PartialInstant instant
PartialInstant instant
{ test1 . dayOfMonth () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . dayOfMonth () . getPartialInstant () ) ;
{ test1 . monthOfYear () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . monthOfYear () . getPartialInstant () ) ;
{ test1 . year () . compareTo ( ( PartialInstant ) null ) ; fail () ; }
assertSame ( test , test . year () . getPartialInstant () ) ;
assertEquals ( false , test1 . equals ( MockPartialInstant.EMPTY_INSTANCE ) ) ;
public int getMaximumValue ( PartialInstant instant , int [] values ) { return iField . getMaximumValue ( instant , values ) ; }
public int getMaximumValue ( PartialInstant instant ) { return iField . getMaximumValue ( instant ) ; }
public int getMinimumValue ( PartialInstant instant , int [] values ) { return iField . getMinimumValue ( instant , values ) ; }
public int getMinimumValue ( PartialInstant instant ) { return iField . getMinimumValue ( instant ) ; }
PartialInstant instant
PartialInstant instant
PartialInstant instant
PartialInstant instant
public String getAsShortText ( PartialInstant partial , Locale locale ) { return iField . getAsShortText ( partial , locale ) ; }
PartialInstant partial
public String getAsText ( PartialInstant partial , Locale locale ) { return iField . getAsText ( partial , locale ) ; }
PartialInstant partial
PartialInstant instant
{ t = new DateTimeFormatterBuilder ( iChrono ) . append ( hourMinuteSecondFraction () ) . append ( offsetElement () ) . toFormatter () ; }
iChronology = converter . getChronology ( instant , chronology ) ;
iChronology = converter . getChronology ( instant , zone ) ;
iChronology = converter . getChronology ( instant ) ;
{ return DurationType . getAverageYearMonthType () ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField.INSTANCE ; }
public DurationField millis () { return UnsupportedDurationField.INSTANCE ; }
public DurationField seconds () { return UnsupportedDurationField.INSTANCE ; }
public DurationField minutes () { return UnsupportedDurationField.INSTANCE ; }
public DurationField hours () { return UnsupportedDurationField.INSTANCE ; }
public DurationField days () { return UnsupportedDurationField.INSTANCE ; }
public DurationField weeks () { return UnsupportedDurationField.INSTANCE ; }
public DurationField months () { return UnsupportedDurationField.INSTANCE ; }
public DurationField years () { return UnsupportedDurationField.INSTANCE ; }
boolean isSupported ( ) ;
assertSame ( test , test . dayOfMonth () . getInstant () ) ;
assertSame ( test , test . monthOfYear () . getInstant () ) ;
assertSame ( test , test . year () . getInstant () ) ;
assertSame ( test , test . yearOfCentury () . getInstant () ) ;
assertSame ( test , test . centuryOfEra () . getInstant () ) ;
assertSame ( test , test . yearOfEra () . getInstant () ) ;
assertSame ( test , test . era () . getInstant () ) ;
{ return getField () . remainder ( getInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getInstant () . getMillis () ) ; }
return getField () . getDifferenceAsLong ( getInstant () . getMillis () , instant . getMillis () ) ;
return getField () . getDifference ( getInstant () . getMillis () , instant . getMillis () ) ;
{ return getField () . getAsShortText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getInstant () . getMillis () ) ; }
try { iChrono . era () . addWrapped ( SMALL_MILLIS , NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
iMillis = converter . getInstantMillis ( instant , chronology ) ;
iMillis = converter . getInstantMillis ( instant , zone ) ;
iMillis = converter . getInstantMillis ( instant ) ;
{ super(); iChronology = selectChronology ( chronology ) ; iMillis = instant ; }
{ setDateTime ( instant ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , } ) ;
LongConverter.INSTANCE . setInto ( m , null ) ;
{ long instant = getChronology () . getDateTimeMillis ( getMillis () , hour , minuteOfHour , secondOfMinute , millisOfSecond ) ; setTime ( instant ) ; }
withUTC () . getTimeOnlyMillis ( iCutoverMillis ) == NUMBER_CONSTANT
return getDateOnlyMillis ( year , monthOfYear , dayOfMonth ) + millisOfDay ;
assertEquals ( false , zone5 . equals ( zone5 ) ) ;
protected DateTimeUtils () {}
private DateTimeUtils () { super(); }
public int size () { return iConverters.length ; }
assertNotSame ( set , result ) ;
catch ( Exception ex ) {}
assertEquals ( NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY , test . monthOfYear () . remainder () ) ;
MutableDuration duration = new MutableDuration ( type , NUMBER_CONSTANT ) ;
public String toString () { return STRING_CONSTANT + getName () + CHAR_CONS ; }
{ if ( chrono == getChronology () ) { return this ; } return mask ( iType . withChronology ( chrono ) , iMask ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearWeekType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new YearMonthType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new AllType ( iChronology ) ; }
{ if ( chrono == iChronology ) { return this ; } return new DayHourType ( iChronology ) ; }
if ( isPrecise () ) { return instant += getTotalMillis () * scalar ; }
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
{ duration = duration . withDurationType ( type ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( startInstant , endInstant , type ) ; }
{ super ( startInstant , endInstant , null ) ; }
{ super ( duration , type ) ; }
{ super ( duration , null ) ; }
{ assertEquals ( NUMBER_CONSTANT , Duration.ZERO . getTotalMillis () ) ; assertEquals ( DurationType . getMillisType () , Duration.ZERO . getDurationType () ) ; }
public YearMonthType ( Chronology chrono ) { super ( chrono ) ; }
public AllType ( Chronology chrono ) { super ( chrono ) ; }
assertEquals ( DurationType . getMillisType () , test . getDurationType () ) ;
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
public void testGetDurationType_Object ( ) throws Exception { assertEquals ( DurationType . getMillisType () , NullConverter.INSTANCE . getDurationType ( null ) ) ; }
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( convId , null , offset , offset ) ; }
{ id = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return new FixedDateTimeZone ( id , null , offset , offset ) ; }
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearWeekType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getYearMonthType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getAllType () ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getDayHourType () ; }
type = ( type == null ? converter . getDurationType ( duration ) : type ) ;
assertEquals ( false , test1 . equals ( new Duration ( NUMBER_CONSTANT , DurationType . getAverageYearMonthType () ) ) ) ;
assertEquals ( type , type . withChronology ( ISOChronology . getInstanceUTC () ) ) ;
assertEquals ( null , type . getChronology () ) ;
ReadWritableDuration duration
{ return ( ( ReadableDuration ) object ) . getTotalMillis () ; }
{ return ( ( ReadableDuration ) object ) . isPrecise () ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
MutableDuration test = new MutableDuration ( STRING_CONSTANT ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( dt1 , dt2 ) ;
MutableDuration test = new MutableDuration ( length , null ) ;
MutableDuration test = new MutableDuration ( length ) ;
{ try { new MutableDuration ( DurationType . getAllType () , true ) ; fail () ; } catch ( IllegalArgumentException ex ) {} }
MutableDuration test = new MutableDuration ( null , false ) ;
MutableDuration test = new MutableDuration ( null , true ) ;
MutableDuration test = new MutableDuration () ;
Duration test = new Duration ( NUMBER_CONSTANT ) ;
Duration test = new Duration ( NUMBER_CONSTANT ) ;
{ Duration test = new Duration ( NUMBER_CONSTANT ) ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
MutableDuration test = new MutableDuration ( NUMBER_CONSTANT ) ;
MutableDuration test = new MutableDuration () ;
{ MutableDuration test = new MutableDuration () ; assertEquals ( DurationType . getAllType () , test . getDurationType () ) ; }
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
public void setInto ( ReadWritableDuration duration , Object object ) {}
c = ConverterManager . getInstance () . getDurationConverter ( new Duration ( DurationType . getMillisType () ) ) ;
Duration test = new Duration ( STRING_CONSTANT ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( dt1 , dt2 ) ;
Duration test = new Duration ( length , null ) ;
Duration test = new Duration ( length ) ;
Duration test = Duration.ZERO ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
{ DurationConverter [] array = ConverterManager . getInstance () . getDurationConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getDurationConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
assertEquals ( NUMBER_CONSTANT , m . getTotalMillis () ) ;
{ add ( new TimePeriod ( duration ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () ) ) ; } }
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
DurationType type
DurationType type
{ return new TimePeriod ( toDurationMillis () , getDurationType () ) ; }
DurationType type
DurationType type
DurationType type
DurationType type
suite . addTest ( TestDurationType . suite () ) ;
{ add ( new TimePeriod ( duration , getDurationType () ) ) ; }
{ if ( duration != null ) { add ( new TimePeriod ( duration . getMillis () , getDurationType () ) ) ; } }
{ if ( interval != null ) { add ( interval . toTimePeriod ( getDurationType () ) ) ; } }
final DurationType type = iType ;
DurationType type
DurationType type
DurationType type
DurationType type
int hash = getDurationType () . hashCode () ;
DurationType type = iType ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
public TestDurationType ( String name ) { super ( name ) ; }
DurationType type
DurationType type
DurationType type
DurationType type
DurationType type = period . getDurationType () ;
DurationType type
if ( ! mustParse && ! isSupported ( period . getDurationType () ) ) { return position ; }
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
TimePeriodConverter c = ConverterManager . getInstance () . getTimePeriodConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( DurationType . getMillisType () ) ) ;
MillisDuration base = new MillisDuration ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getDayHourType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getPreciseAllType () , test . getDurationType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ;
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
TimePeriod test3 = new TimePeriod ( NUMBER_CONSTANT , DurationType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
DurationType type
DurationType type
if ( pos < NUMBER_CONSTANT ) { parser . parseMutableTimePeriod ( period . getDurationType () , str ) ; }
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
assertEquals ( DurationType . getAllType () , test . getDurationType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
test . add ( new TimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getPreciseAllType () ) ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearWeekType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getPreciseYearMonthType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMillisRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withSecondsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMinutesRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withHoursRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withDaysRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withWeeksRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withMonthsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( DurationType . getAllType () . withYearsRemoved () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT , DurationType . getMillisType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
assertEquals ( test . getDurationType () , copy . getDurationType () ) ;
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
test = new MutableTimePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , DurationType . getAllType ( ISOChronology . getInstanceUTC () ) )
assertEquals ( false , test1 . equals ( new TimePeriod ( NUMBER_CONSTANT , DurationType . getDayHourType () ) ) ) ;
MutableTimePeriod m = new MutableTimePeriod ( DurationType . getMillisType () ) ;
ReadableTimePeriod period
ReadableTimePeriod period
c = ConverterManager . getInstance () . getDurationConverter ( new TimePeriod ( PeriodType . getMillisType () ) ) ;
MutableTimePeriod result = test . toMutableTimePeriod () ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ MutableTimePeriod test = new MutableTimePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
TimePeriod test = new TimePeriod ( STRING_CONSTANT ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( dt1 , dt2 ) ;
TimePeriod test = new TimePeriod ( length , null ) ;
TimePeriod test = new TimePeriod ( length ) ;
TimePeriod test = new TimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( NUMBER_CONSTANT ) ;
ReadableTimePeriod period
ReadableTimePeriod period
public void testSetDuration_RD () { setTimePeriod ( ( ReadableDuration ) null ) ; }
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ;
{ TimePeriod test = new TimePeriod ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
MutableTimePeriod test = new MutableTimePeriod ( STRING_CONSTANT ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( dt1 , dt2 ) ;
MutableTimePeriod test = new MutableTimePeriod ( length , null ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod ( length ) ;
MutableTimePeriod test = new MutableTimePeriod () ;
{ return STRING_CONSTANT + iInstantConverters . size () + STRING_CONSTANT + iDurationConverters . size () + STRING_CONSTANT + iTimePeriodConverters . size () + STRING_CONSTANT + iIntervalConverters . size () + STRING_CONSTANT ; }
ReadableTimePeriod period
ReadableTimePeriod period
TimePeriod duration ;
Class cls = ReadableTimePeriodConverter . class ;
public void testSetTotalMillis_2 () { setPeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public void testSetTotalMillis_1 () { setPeriod ( NUMBER_CONSTANT ) ; }
public void testSetDuration_RD () { setDuration ( null ) ; }
{ if ( chrono == iChronology ) { return this ; } return PeriodType . getYearWeekType ( chrono ) ; }
{ return PRECISE_ALL_TYPE ; }
{ return PRECISE_YEAR_WEEK_TYPE ; }
{ return PRECISE_YEAR_MONTH_TYPE ; }
public static PeriodType getPreciseYearDayType () { return PRECISE_YEAR_DAY_TYPE ; }
public static PeriodType getPreciseDayHourType () { return PRECISE_DAY_HOUR_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearWeekType () ; }
{ return YEAR_WEEK_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCYearMonthType () ; }
{ return YEAR_MONTH_TYPE ; }
public static PeriodType getYearDayType () { return YEAR_DAY_TYPE ; }
if ( chrono == null || chrono . equals ( ISOChronology . getInstanceUTC () ) ) { return getUTCAllType () ; }
{ return ALL_TYPE ; }
public static PeriodType getMillisType () { return MILLIS_TYPE ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getUTCAllType () ) ;
public Duration ( long duration ) { super ( duration ) ; }
public AbstractDuration () { super(); }
{ long durationMillis = DateTimeUtils . getDurationMillis ( duration ) ; setStartMillis ( FieldUtils . safeAdd ( getStartMillis () , - durationMillis ) ) ; }
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( dt1 , dt2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
Interval test = new Interval ( TEST_TIME1 , TEST_TIME2 ) ;
final Object duration
public Duration ( long duration ) { super(); iMillis = duration ; }
{ long endMillis = DateTimeUtils . getInstantMillis ( end ) ; setInterval ( iStartMillis , endMillis ) ; }
{ long startMillis = DateTimeUtils . getInstantMillis ( start ) ; setInterval ( startMillis , iEndMillis ) ; }
{ setInterval ( startInstant , iEndMillis ) ; }
public void normalize () { super . normalize () ; }
{ return new MutableDateTime ( this , chronology ) ; }
public MutableDateTime toMutableDateTime () { return new MutableDateTime ( this ) ; }
{ long instant = getChronology () . getDateTimeMillis ( year , monthOfYear , dayOfMonth , hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ; setDateTime ( instant ) ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ super(); iChronology = partial.iChronology ; iValues = values ; }
{ Chronology chrono = iChronology . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
GJYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
AbstractGJChronology chronology
AbstractGJChronology chronology
GJMonthOfYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
AbstractGJChronology chrono = iChronology ;
CopticYearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJWeekyearDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
AbstractGJChronology chronology
GJEraDateTimeField ( AbstractGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
NoWeekyearZeroField ( AbstractGJChronology chronology , DateTimeField field ) { super ( chronology , field ) ; }
AbstractGJChronology chronology
public static TestSuite suite () { return BulkTest . makeSuite ( TestParseISO . class ) ; }
public static TestSuite suite () { return BulkTest . makeSuite ( TestDateTimeConstants . class ) ; }
{ millis = getField ( i ) . set ( millis , getValue ( i ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendSuffix ( new SingularAffix ( text ) ) ; }
{ if ( text == null ) { throw new IllegalArgumentException () ; } return appendPrefix ( new SingularAffix ( text ) ) ; }
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix affix ;
DurationFieldAffix suffix
int scan ( String durationStr , int position ) ;
int parse ( String durationStr , int position ) ;
DurationFieldAffix suffix
DurationFieldAffix prefix
{ if ( iPrintZeroSetting == PRINT_ZERO_ALWAYS || getFieldValue ( period ) >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
public PeriodFormatterBuilder appendMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithOptionalMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSecondsWithMillis () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendSeconds () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMinutes () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendHours () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendDays () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendWeeks () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendMonths () { appendField ( NUMBER_CONSTANT ) ; return this ; }
public PeriodFormatterBuilder appendYears () { appendField ( NUMBER_CONSTANT ) ; return this ; }
DateTimeComparator c = DateTimeComparator . getInstance ( ISO . hourOfDay () , ISO . dayOfYear () ) ;
DateTimeField lowerLimit
public static DateTimeComparator getInstance () { return INSTANCE ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
if ( iParseField == null ) { iParseField = new PreciseDateTimeField ( STRING_CONSTANT , MillisDurationField.INSTANCE , iField . getDurationField () ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
super ( gregorianField . getName () ) ;
public TestGJYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , weeks ) ; iChronology = chronology ; }
private ISOYearOfEraDateTimeField () { super ( GregorianChronology . getInstanceUTC () . year () , STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
{ super ( field , field . getName () ) ; iDurationField = durationField ; iRangeDurationField = rangeDurationField ; iLeapDurationField = leapDurationField ; }
super ( field . getName () ) ;
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( STRING_CONSTANT , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , days ) ; iChronology = chronology ; }
{ super ( STRING_CONSTANT , months ) ; iChronology = chronology ; }
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
public DateTimeField era () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , eras () ) ; }
public DateTimeField centuryOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , centuries () ) ; }
public DateTimeField yearOfCentury () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField yearOfEra () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField year () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , years () ) ; }
public DateTimeField monthOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , months () ) ; }
public DateTimeField weekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weekyears () ) ; }
public DateTimeField weekOfWeekyear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , weeks () ) ; }
public DateTimeField dayOfYear () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
public DateTimeField dayOfMonth () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , days () ) ; }
{ return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public DateTimeField clockhourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfHalfday () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField clockhourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField hourOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , hours () ) ; }
public DateTimeField minuteOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField minuteOfHour () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , minutes () ) ; }
public DateTimeField secondOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField secondOfMinute () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , seconds () ) ; }
public DateTimeField millisOfDay () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
public DateTimeField millisOfSecond () { return UnsupportedDateTimeField . getInstance ( STRING_CONSTANT , millis () ) ; }
{ super ( yearField , STRING_CONSTANT ) ; iChronology = chronology ; }
LinkedDurationField ( DurationField durationField , ImpreciseCutoverField dateTimeField ) { super ( durationField , durationField . getName () ) ; iField = dateTimeField ; }
{ return UnsupportedDateTimeField . getInstance ( DateTimeFieldType . halfdayOfDay () , UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
public String toString () { return STRING_CONSTANT ; }
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . year () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , STRING_CONSTANT , chrono.MILLIS_PER_DAY , chrono ) ; }
super ( field . getName () ) ;
{ super ( DateTimeFieldType . year () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
public TestGJWeekyearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chrono . millisPerYear () , chrono ) ; }
{ super ( DateTimeFieldType . weekyear () , STRING_CONSTANT , chronology . getAverageMillisPerYear () ) ; iChronology = chronology ; }
fields.centuryOfEra = new DividedDateTimeField ( field , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
if ( ( iMask & ( NUMBER_CONSTANT < < NUMBER_CONSTANT ) ) != NUMBER_CONSTANT ) { return UnsupportedDurationField . getInstance ( STRING_CONSTANT ) ; }
{ super ( chrono ) ; iMonths = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
{ super ( chrono ) ; iYears = new ScaledDurationField ( chrono . days () , STRING_CONSTANT , NUMBER_CONSTANT ) ; }
fields.centuryOfEra = new DividedDateTimeField ( ISOYearOfEraDateTimeField.INSTANCE , DateTimeFieldType . centuryOfEra () , STRING_CONSTANT , NUMBER_CONSTANT ) ;
{ super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chronology . getAverageMillisPerMonth () ) ; iChronology = chronology ; }
public TestGJMonthOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . monthOfYear () , STRING_CONSTANT , chrono . millisPerMonth () , chrono ) ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int [] values = new int [ getFieldSize () ] ;
int i = NUMBER_CONSTANT , isize = getFieldSize ()
{ return getAsShortText ( partial , partial . get ( this ) , locale ) ; }
{ return getAsText ( partial , partial . get ( this ) , locale ) ; }
public int getFieldSize () { return NUMBER_CONSTANT ; }
int getFieldSize ( ) ;
partial . isSupported ( iField )
partial . isSupported ( iField )
partial . isSupported ( iField )
public int getFieldSize () { return getFields () . length ; }
public static DateTimeFieldType era () { return ERA ; }
public static DateTimeFieldType centuryOfEra () { return CENTURY_OF_ERA ; }
public static DateTimeFieldType yearOfCentury () { return YEAR_OF_CENTURY ; }
public static DateTimeFieldType yearOfEra () { return YEAR_OF_ERA ; }
public static DateTimeFieldType year () { return YEAR ; }
public static DateTimeFieldType monthOfYear () { return MONTH_OF_YEAR ; }
public static DateTimeFieldType weekyearOfCentury () { return WEEKYEAR_OF_CENTURY ; }
public static DateTimeFieldType weekyear () { return WEEKYEAR ; }
public static DateTimeFieldType weekOfWeekyear () { return WEEK_OF_WEEKYEAR ; }
public static DateTimeFieldType dayOfYear () { return DAY_OF_YEAR ; }
public static DateTimeFieldType dayOfMonth () { return DAY_OF_MONTH ; }
public static DateTimeFieldType dayOfWeek () { return DAY_OF_WEEK ; }
public static DateTimeFieldType halfdayOfDay () { return HALFDAY_OF_DAY ; }
public static DateTimeFieldType clockhourOfHalfday () { return CLOCKHOUR_OF_HALFDAY ; }
public static DateTimeFieldType hourOfHalfday () { return HOUR_OF_HALFDAY ; }
public static DateTimeFieldType clockhourOfDay () { return CLOCKHOUR_OF_DAY ; }
public static DateTimeFieldType hourOfDay () { return HOUR_OF_DAY ; }
public static DateTimeFieldType minuteOfDay () { return MINUTE_OF_DAY ; }
public static DateTimeFieldType minuteOfHour () { return MINUTE_OF_HOUR ; }
public static DateTimeFieldType secondOfDay () { return SECOND_OF_DAY ; }
public static DateTimeFieldType secondOfMinute () { return SECOND_OF_MINUTE ; }
public static DateTimeFieldType millisOfDay () { return MILLIS_OF_DAY ; }
public static DateTimeFieldType millisOfSecond () { return MILLIS_OF_SECOND ; }
int otherValue = chrono . getField ( getFieldType () ) . get ( instant . getMillis () ) ;
public static DurationFieldType eras () { return ERAS ; }
public static DurationFieldType centuries () { return CENTURIES ; }
public static DurationFieldType years () { return YEARS ; }
public static DurationFieldType months () { return MONTHS ; }
public static DurationFieldType weekyears () { return WEEKYEARS ; }
public static DurationFieldType weeks () { return WEEKS ; }
public static DurationFieldType days () { return DAYS ; }
public static DurationFieldType halfdays () { return HALFDAYS ; }
public static DurationFieldType hours () { return HOURS ; }
public static DurationFieldType minutes () { return MINUTES ; }
public static DurationFieldType seconds () { return SECONDS ; }
public static DurationFieldType millis () { return MILLIS ; }
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
assertEquals ( false , test . isAfter ( null ) ) ;
assertEquals ( false , test . isBefore ( null ) ) ;
{ if ( instant == null ) { return isAfter ( DateTimeUtils . currentTimeMillis () ) ; } return isAfter ( instant . getMillis () ) ; }
{ if ( instant == null ) { return isBefore ( DateTimeUtils . currentTimeMillis () ) ; } return isBefore ( instant . getMillis () ) ; }
{ if ( instant == null ) { return contains ( DateTimeUtils . currentTimeMillis () ) ; } return contains ( instant . getMillis () ) ; }
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period dur = new Period ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getAllTypeUTC () ) ;
Period result = test . withPeriodType ( PeriodType . getAllType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ Period test = new Period ( NUMBER_CONSTANT ) ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
iDurationConverters = new ConverterSet ( new Converter [] { ReadableDurationConverter.INSTANCE , ReadablePeriodConverter.INSTANCE , ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
p = new Period ( NUMBER_CONSTANT , PeriodType . getAllType () . withMillisRemoved () . withSecondsRemoved () ) ;
test = new MutablePeriod ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , PeriodType . getMillisType () ) ;
{ super . setMillis ( millis ) ; }
{ super . setSeconds ( seconds ) ; }
{ super . setMinutes ( minutes ) ; }
{ super . setHours ( hours ) ; }
{ super . setDays ( days ) ; }
{ super . setWeeks ( weeks ) ; }
{ super . setMonths ( months ) ; }
{ super . setYears ( years ) ; }
{ super . setPeriod ( duration ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
public MutablePeriod ( PeriodType type ) { super ( NUMBER_CONSTANT , type ) ; }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( false , test1 . equals ( new Period ( NUMBER_CONSTANT , PeriodType . getDayHourType () ) ) ) ;
{ MutablePeriod test = new MutablePeriod () ; assertEquals ( PeriodType . getAllType () , test . getPeriodType () ) ; }
{ super ( period , type ) ; }
{ super ( period , null ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar ) ) ; } }
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
assertEquals ( PeriodType . getAllType () , result . getPeriodType () ) ;
{ test1 . year () . compareTo ( null ) ; fail () ; }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setStartMillis ( period . addTo ( getEndMillis () , - NUMBER_CONSTANT , chrono ) ) ; }
{ chrono = DateTimeUtils . getChronology ( chrono ) ; setEndMillis ( period . addTo ( getStartMillis () , NUMBER_CONSTANT , chrono ) ) ; }
{ if ( period != null ) { setMillis ( period . addTo ( getMillis () , scalar , getChronology () ) ) ; } }
assertEquals ( PeriodType . time () , test . getPeriodType () ) ;
try { test . setYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( UnsupportedOperationException ex ) {}
return new Period ( new int [] { millis } , PeriodType . standard () ) ;
return new Period ( new int [] { seconds } , PeriodType . standard () ) ;
return new Period ( new int [] { minutes } , PeriodType . standard () ) ;
return new Period ( new int [] { hours } , PeriodType . standard () ) ;
return new Period ( new int [] { days } , PeriodType . standard () ) ;
return new Period ( new int [] { weeks } , PeriodType . standard () ) ;
return new Period ( new int [] { months } , PeriodType . standard () ) ;
new Period ( new int [] { years } , PeriodType . standard () )
{ duration . setPeriod ( NUMBER_CONSTANT , chrono ) ; }
iIntervalConverters = new ConverterSet ( new Converter [] { ReadableIntervalConverter.INSTANCE , StringConverter.INSTANCE , } ) ;
{ super . setEndMillis ( endInstant ) ; }
{ super . setStartMillis ( startInstant ) ; }
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getIntervalConverters () . length ) ;
{ IntervalConverter [] array = ConverterManager . getInstance () . getIntervalConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
Duration dur = new Interval ( dt1 , dt2 ) . getDuration () ;
public long getDurationMillis () { return ( NUMBER_CONSTANT - NUMBER_CONSTANT ) ; }
Instant getEndInstant ( ) ;
Instant getStartInstant ( ) ;
{ MutableInterval test = new MutableInterval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
Interval result = test . withEndInstant ( null ) ;
{ test . withEndInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withEndInstant ( new Instant ( TEST_TIME2 - NUMBER_CONSTANT ) ) ;
Interval result = test . withStartInstant ( null ) ;
{ test . withStartInstant ( new Instant ( TEST_TIME2 + NUMBER_CONSTANT ) ) ; fail () ; }
Interval result = test . withStartInstant ( new Instant ( TEST_TIME1 - NUMBER_CONSTANT ) ) ;
{ Interval test = new Interval ( TEST_TIME1 , TEST_TIME1 ) ; assertSame ( Duration.ZERO , test . getDuration () ) ; }
{ return ( ( ( ReadableInterval ) object ) ) . getDurationMillis () ; }
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( millis , chronology ) ;
iValues = initValues ( instant , chronology ) ;
long resolved = resolve ( instantMillis , chrono ) ;
{ Chronology chrono = getChronology () . withZone ( zone ) ; return resolve ( baseInstant , chrono ) ; }
{ if ( period != null ) { setMillis ( getChronology () . add ( getMillis () , period , scalar ) ) ; } }
if ( period == null ) { iStartMillis = iEndMillis ; } else { iStartMillis = chrono . add ( iEndMillis , period , - NUMBER_CONSTANT ) ; }
if ( period == null ) { iEndMillis = iStartMillis ; } else { iEndMillis = chrono . add ( iStartMillis , period , NUMBER_CONSTANT ) ; }
long instant = getChronology () . add ( getMillis () , period , scalar ) ;
{ if ( period == null ) { setPeriodInternal ( NUMBER_CONSTANT , null ) ; } else { setPeriodInternal ( period ) ; } }
long endMillis = chrono . add ( startMillis , this , NUMBER_CONSTANT ) ;
setPeriodInternal ( startMillis , endMillis , chrono ) ;
{ setStartMillis ( getChronology () . add ( getEndMillis () , period , - NUMBER_CONSTANT ) ) ; }
{ setEndMillis ( getChronology () . add ( getStartMillis () , period , NUMBER_CONSTANT ) ) ; }
{ if ( period != null ) { addPeriod ( period ) ; } }
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
assertEquals ( null , test . getChronology () ) ;
{ if ( partial == null ) { return this ; } return partial . resolveDateTime ( this ) ; }
DateTime result = test . resolveDateTime ( null ) ;
{ long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ; printTo ( null , out , millis ) ; }
long millis = partial . resolve ( NUMBER_CONSTANT , DateTimeZone.UTC ) ;
DateTime result = test . resolveDateTime ( null ) ;
{ return new Period ( getStartMillis () , getEndMillis () , type ) ; }
{ return new Period ( getStartMillis () , getEndMillis () ) ; }
{ return new MutableInterval ( getStartMillis () , getEndMillis () ) ; }
{ return new Interval ( getStartMillis () , getEndMillis () ) ; }
Interval test4 = new Interval ( TEST_TIME1 , TEST_TIME1 , Chronology . getGJ () ) ;
{ if ( endInstant == getEndMillis () ) { return this ; } return new Interval ( getStartMillis () , endInstant ) ; }
{ if ( startInstant == getStartMillis () ) { return this ; } return new Interval ( startInstant , getEndMillis () ) ; }
{ test . set ( ISOChronology . getInstance () . monthOfYear () , NUMBER_CONSTANT ) ; fail () ; }
test . set ( ISOChronology . getInstance () . year () , NUMBER_CONSTANT ) ;
final Object f
final Object f
final Object f
public DateTimeFormatterBuilder appendEraText () { return appendText ( iChronoUTC . era () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearShortText () { return appendShortText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendMonthOfYearText () { return appendText ( iChronoUTC . monthOfYear () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekShortText () { return appendShortText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendDayOfWeekText () { return appendText ( iChronoUTC . dayOfWeek () ) ; }
public DateTimeFormatterBuilder appendHalfdayOfDayText () { return appendText ( iChronoUTC . halfdayOfDay () ) ; }
final String text
final char c
final Object element
final DateTimeParser parser
final DateTimeParser parser
final DateTimePrinter printer
final DateTimeFormatter formatter
final Chronology chrono
final DateTimeZone zone
public MutableDateTime parseMutableDateTime ( final String text ) { return mParser . parseMutableDateTime ( text ) ; }
public DateTime parseDateTime ( final String text ) { return mParser . parseDateTime ( text ) ; }
public long parseMillis ( final String text ) { return mParser . parseMillis ( text ) ; }
public String print ( final long instant ) { throw unsupported () ; }
public String print ( final ReadableInstant instant ) { throw unsupported () ; }
FParser ( final DateTimeParser parser ) { super(); mParser = parser ; }
public MutableDateTime parseMutableDateTime ( final String text ) { throw unsupported () ; }
public DateTime parseDateTime ( final String text ) { throw unsupported () ; }
public long parseMillis ( final String text ) { throw unsupported () ; }
public String print ( final long instant ) { return mPrinter . print ( instant ) ; }
public String print ( final ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
FPrinter ( final DateTimePrinter printer ) { super(); mPrinter = printer ; }
iMillis = converter . getInstantMillis ( instant ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getInstantConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
{ PartialConverter [] array = ConverterManager . getInstance () . getPartialConverters () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
assertEquals ( NUMBER_CONSTANT , ConverterManager . getInstance () . getPartialConverters () . length ) ;
iPartialConverters = new ConverterSet ( new Converter [] { ReadableInstantConverter.INSTANCE , StringConverter.INSTANCE , CalendarConverter.INSTANCE , DateConverter.INSTANCE , LongConverter.INSTANCE , NullConverter.INSTANCE , } ) ;
throw new IllegalStateException () ;
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
public DateTimeField getField ( Chronology chronology ) { return UnsupportedDateTimeField . getInstance ( this , null ) ; }
throw new IllegalStateException () ;
try { MillisDurationField.INSTANCE . getDifferenceAsLong ( Long.MAX_VALUE , NUMBER_CONSTANT ) ; fail () ; } catch ( ArithmeticException ex ) {}
{ return value * getUnitMillis () ; }
{ return value * iUnitMillis ; }
BaseDateTimeField field = new MockBaseDateTimeField () ;
BaseDateTimeField field = new MockPreciseDateTimeField () ;
DateTimeParser dateTimeParser = ISODateTimeFormat . getInstance () . dateTimeParser () ;
{ assertEquals ( PARIS , DateTimeUtils . getZone ( PARIS ) ) ; assertEquals ( LONDON , DateTimeUtils . getZone ( null ) ) ; }
return offsetFormatter () . print ( instant , this ) ;
return offsetFormatter () . print ( instant , this ) ;
{ convId = offsetFormatter () . print ( NUMBER_CONSTANT , UTC , offset ) ; return fixedOffsetZone ( convId , offset ) ; }
PeriodParser [] parsers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
PeriodPrinter [] printers = iFormatters ;
Separator finish ( PeriodFormatter after ) { iAfter = after ; return this ; }
PeriodFormatter before
PeriodFormatter composite = createComposite ( formatters ) ;
DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder ( iChrono , iLocale ) ;
DateTimeParser p = ISODateTimeFormat . getInstance ( getLenientISOChronology () ) . hourMinuteSecondFraction () ;
return DateTimeFormat . getInstance ( getChronology () , locale ) . forPattern ( pattern ) . print ( this ) ;
return DateTimeFormat . getInstance ( getChronology () ) . forPattern ( pattern ) . print ( this ) ;
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( NUMBER_CONSTANT , chrono ) ;
DateTimeParserBucket bucket = new DateTimeParserBucket ( instantLocal , chrono ) ;
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
{ if ( permission instanceof JodaTimePermission ) { return false ; } return super . implies ( domain , permission ) ; }
iFieldType >= NUMBER_CONSTANT
{ return appendSeparator ( text , finalText , true , true ) ; }
{ return appendSeparator ( text , text , true , true ) ; }
int offset = - ( int ) offsetFormatter () . parseMillis ( convId ) ;
int offset = - ( int ) offsetFormatter () . parseMillis ( id ) ;
int itimeStyle = selectStyle ( dateStyle ) ;
DateTimeField field = iFieldType . getField ( chrono ) ;
return printTimeZone ( getOffset ( instant ) ) ;
return printTimeZone ( getOffset ( instant ) ) ;
String id = printTimeZone ( offset ) ;
return new MutableDateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new MutableDateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return new DateTime ( parseMillis ( text , millis , chrono ) , chrono ) ;
{ return new DateTime ( parseMillis ( text , chrono ) , chrono ) ; }
return print ( millis , chrono ) ;
printTo ( out , millis , chrono ) ;
printTo ( buf , millis , chrono ) ;
public MutableDateTime parseMutableDateTime ( String text , ReadableInstant instant ) { return mParser . parseMutableDateTime ( text , instant ) ; }
public MutableDateTime parseMutableDateTime ( String text , Chronology chrono ) { return mParser . parseMutableDateTime ( text , chrono ) ; }
public DateTime parseDateTime ( String text , ReadableInstant instant ) { return mParser . parseDateTime ( text , instant ) ; }
public DateTime parseDateTime ( String text , Chronology chrono ) { return mParser . parseDateTime ( text , chrono ) ; }
{ return mParser . parseMillis ( text , instant , chrono ) ; }
{ return mParser . parseInto ( instant , text , position ) ; }
public String print ( long instant , Chronology chrono ) { return mPrinter . print ( instant , chrono ) ; }
public String print ( long instant , DateTimeZone zone ) { return mPrinter . print ( instant , zone ) ; }
{ mPrinter . printTo ( out , instant , chrono ) ; }
{ mPrinter . printTo ( buf , instant , chrono ) ; }
{ mPrinter . printTo ( out , instant , zone ) ; }
{ mPrinter . printTo ( buf , instant , zone ) ; }
public void printTo ( Writer out , long instant ) throws IOException { mPrinter . printTo ( out , instant ) ; }
{ mPrinter . printTo ( out , instant ) ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
protected int estimateParsedLength () { return iParsedLengthEstimate ; }
BaseDateTimeFormatter [] elements = iPrinters ;
BaseDateTimeFormatter [] elements = iPrinters ;
protected int estimatePrintedLength () { return iPrintedLengthEstimate ; }
BaseDateTimeFormatter [] printers
protected int estimatePrintedLength () { return iShortFormat ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimateParsedLength () { return iMaxDigits ; }
protected int estimatePrintedLength () { return iMaxDigits ; }
protected int estimateParsedLength () { return estimatePrintedLength () ; }
protected int estimatePrintedLength () { return iShort ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return NUMBER_CONSTANT ; }
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimatePrintedLength () { return iMaxParsedDigits ; }
protected int estimateParsedLength () { return iMaxParsedDigits ; }
ParseBucket bucket
protected int estimateParsedLength () { return NUMBER_CONSTANT ; }
BasePeriodFormatter [] parsers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
BasePeriodFormatter [] printers = iFormatters ;
Separator finish ( BasePeriodFormatter after ) { iAfter = after ; return this ; }
BasePeriodFormatter before
BasePeriodFormatter composite = createComposite ( formatters ) ;
{ return getField () . remainder ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMaximumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getMinimumValue ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getLeapAmount ( getReadableInstant () . getMillis () ) ; }
{ return getField () . isLeap ( getReadableInstant () . getMillis () ) ; }
{ return getField () . getAsShortText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . getAsText ( getReadableInstant () . getMillis () , locale ) ; }
{ return getField () . get ( getReadableInstant () . getMillis () ) ; }
if ( value == NUMBER_CONSTANT ) { return this ; }
fields.era = BuddhistEraDateTimeField.INSTANCE ;
{ zone = DateTimeZone . getInstance ( cal . getTimeZone () ) ; }
DateTimeZone . setDefault ( DateTimeZone . getInstance ( STRING_CONSTANT ) ) ;
iChronology = ISOChronology . getInstance ( DateTimeZone . getInstance ( id ) ) ;
zones [ i ++ ] = new ZoneData ( id , DateTimeZone . getInstance ( id ) ) ;
z = DateTimeZone . getInstance ( str ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ;
{ DateTimeZone zone = DateTimeZone . getInstance ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , zone . getID () ) ; }
public TestGJDayOfMonthField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfMonth () , chrono.MILLIS_PER_DAY , chrono ) ; }
int dayOfWeek = ( int ) iChronology . mod ( iChronology . fixedFromMillis ( millis ) , NUMBER_CONSTANT ) ;
public TestGJDayOfWeekField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfWeek () , chrono.MILLIS_PER_DAY , chrono ) ; }
public TestGJDayOfYearField ( TestGJChronology chrono ) { super ( DateTimeFieldType . dayOfYear () , chrono.MILLIS_PER_DAY , chrono ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return - ( int ) offsetFormatter () . parseMillis ( str , chrono ) ;
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance ( locale ) . forPattern ( pattern ) . print ( this ) ; }
{ if ( pattern == null ) { return toString () ; } return DateTimeFormat . getInstance () . forPattern ( pattern ) . print ( this ) ; }
return cOffsetFormatter . print ( millis , iZone ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
DateTimeFormatter f = DateTimeFormat . getInstance ( Locale.UK ) . forPattern ( STRING_CONSTANT ) ;
parse ( ISODateTimeFormat . getInstance () . dateTimeParser () ) ;
DateTimeParser p
DateTimeFormatter [] printers
{ return append0 ( new TimeZoneOffsetFormatter ( zeroOffsetText , showSeparators , minFields , maxFields ) ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , true ) , null ) ; }
{ return append0 ( new TimeZonePrinter ( iLocale , false ) , null ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , true ) ) ; }
{ if ( fieldType == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( new TextField ( fieldType , iLocale , false ) ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter ) ; }
DateTimeParser p = ISODateTimeFormat . getInstance () . hourMinuteSecondFraction () ;
try { g . parseMutableDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { g . parseDateTime ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
bucket . saveField ( DateTimeFieldType . year () , year ) ;
iFormatters . add ( field ) ;
iFormatters . add ( literal ) ;
iFormatters . add ( formatter ) ;
PeriodFormatter formatter = toFormatter ( iFormatters ) ;
public PeriodParser toParser () { return toFormatter () ; }
public PeriodPrinter toPrinter () { return toFormatter () ; }
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
f = ISOPeriodFormat . getInstance () . standard () ;
{ return ISOPeriodFormat . getInstance () . standard () . print ( this ) ; }
PeriodFormatter periodParser = ISOPeriodFormat . getInstance () . standard () ;
PeriodFormatter parser = ISOPeriodFormat . getInstance () . standard () ;
InputStream in = new StringBufferInputStream ( data ) ;
PeriodFormatter parser = PeriodFormat . getInstance () . getDefault () ;
Locale iLocale
Locale iLocale
Locale iLocale
Locale iLocale
fields.year = new GJYearDateTimeField ( this ) ;
fields.year = new CopticYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
fields.year = new BasicYearDateTimeField ( this ) ;
{ if ( iZone == zone ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , false , iChrono , zone ) ; }
{ if ( iChrono == chrono ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , iOffsetParsed , chrono , iZone ) ; }
{ if ( iOffsetParsed == true ) { return this ; } return new DateTimeFormatter ( iPrinter , iParser , iLocale , true , iChrono , null ) ; }
return new DateTimeFormatter ( iPrinter , iParser , locale , iOffsetParsed , iChrono , iZone ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , test . getChronology () ) ;
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . weekyear () , pivot ) ) ; }
{ return append0 ( new TwoDigitYear ( DateTimeFieldType . year () , pivot ) ) ; }
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
catch ( NumberFormatException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT + getName () + STRING_CONSTANT + text ) ; }
FieldUtils . verifyValueBounds ( STRING_CONSTANT , millisOfDay , NUMBER_CONSTANT , DateTimeConstants.MILLIS_PER_DAY ) ;
{ if ( STRING_CONSTANT . equals ( text ) == false ) { throw new IllegalArgumentException ( STRING_CONSTANT + text ) ; } return instant ; }
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + text ) ;
suite . addTest ( TestSerialization . suite () ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
assertEquals ( STRING_CONSTANT , test . toString ( null ) ) ;
public final int getMinimumDaysInFirstWeek () { return iMinDaysInFirstWeek ; }
DateTimeZone test = PARIS ;
private DateTimeFormat () { super(); }
private PeriodFormat () {}
private ISOPeriodFormat () {}
cfg . setProperty ( STRING_CONSTANT , STRING_CONSTANT ) ;
fields.era = ThaiBuddhistEraDateTimeField.INSTANCE ;
Period test = new Period ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
Period test = new Period ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
OffsetDateTimeField field = new OffsetDateTimeField ( Chronology . getISO () . secondOfMinute () , NUMBER_CONSTANT ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
Chronology chrono = Chronology . getGJUTC () ;
assertEquals ( - NUMBER_CONSTANT , MillisDurationField.INSTANCE . compareTo ( Chronology . getISO () . seconds () ) ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
assertEquals ( - NUMBER_CONSTANT , iField . compareTo ( Chronology . getISO () . minutes () ) ) ;
assertEquals ( false , iField . hashCode () == Chronology . getISO () . minutes () . hashCode () ) ;
assertEquals ( false , iField . equals ( Chronology . getISO () . minutes () ) ) ;
{ FieldUtils . verifyValueBounds ( Chronology . getISO () . monthOfYear () , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail () ; }
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getISO ( ZONES [ i ] ) ;
Chronology chrono = Chronology . getGregorian () ;
actual = ReadablePartialConverter.INSTANCE . getPartialValues ( tod , new TimeOfDay ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , Chronology . getISO ( PARIS ) )
int [] actual = NullConverter.INSTANCE . getPartialValues ( tod , null , Chronology . getISO () ) ;
assertEquals ( new Interval ( TEST_TIME1 , TEST_TIME2 , Chronology . getISO () ) , test ) ;
test . add ( ms , Chronology . getISOUTC () ) ;
test . add ( ms , Chronology . getISO () ) ;
test . add ( NUMBER_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
assertEquals ( Chronology . getISO () , test . getChronology () ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
assertEquals ( Chronology . getISO () , m . getChronology () ) ;
int [] actual = StringConverter.INSTANCE . getPartialValues ( tod , STRING_CONSTANT , Chronology . getISO () ) ;
assertEquals ( Chronology . getISOUTC () , test . getChronology () ) ;
try { type . getField ( Chronology . getCopticUTC () ) ; fail () ; } catch ( InternalError ex ) {}
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( new Duration ( length ) , Chronology . getISO () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . standard () , Chronology . getISOUTC () ) ;
MutablePeriod test = new MutablePeriod ( length , PeriodType . time () . withMillisRemoved () , Chronology . getISO () ) ;
ReadableIntervalConverter.INSTANCE . setInto ( m , i , Chronology . getCoptic () ) ;
{ super ( Chronology . getISO ( zone ) ) ; }
public Chronology getChronology () { return Chronology . getISOUTC () ; }
iMillis = converter . getInstantMillis ( instant , Chronology . getISOUTC () ) ;
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = Chronology . getISO () ; }
{ return Chronology . getISO ( zone ) ; }
{ super ( Chronology . getISO ( zone ) ) ; }
this . iZone = zone ;
this . iZone = zone ;
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . add ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
{ newValues = getField ( index ) . addWrapPartial ( this , index , newValues , FieldUtils . safeMultiplyToInt ( period . getValue ( i ) , scalar ) ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
if ( dt == null ) { System.out . println ( STRING_CONSTANT ) ; }
cal . setTime ( toDate () ) ;
cal . setTime ( toDate () ) ;
{ out . write ( print ( instant , displayZone , locale ) ) ; }
{ buf . append ( print ( instant , displayZone , locale ) ) ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
{ iStartMillis = iEndMillis = DateTimeUtils . currentTimeMillis () ; iChronology = ChronologyType . iso () . getChronology () ; }
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
{ return ChronologyType . iso () . getChronology ( zone ) ; }
public Chronology getChronology () { return ChronologyType . iso () . getChronologyUTC () ; }
iMillis = converter . getInstantMillis ( instant , ChronologyType . iso () . getChronologyUTC () ) ;
{ super ( ChronologyType . iso () . getChronology ( zone ) ) ; }
return NUMBER_CONSTANT ;
return NUMBER_CONSTANT ;
FieldUtils . verifyValueBounds ( this , month , MIN , MAX ) ;
long difference = ( minuendYear - subtrahendYear ) * NUMBER_CONSTANT + minuendMonth - subtrahendMonth ;
{ return set ( instant , FieldUtils . getWrappedValue ( get ( instant ) , months , MIN , MAX ) ) ; }
assertEquals ( true , EthiopicChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestEthiopicChronology . class ) ; }
assertEquals ( true , CopticChronology . getInstanceUTC () . months () . isPrecise () ) ;
public static TestSuite suite () { SKIP = NUMBER_CONSTANT * DateTimeConstants.MILLIS_PER_DAY ; return new TestSuite ( TestCopticChronology . class ) ; }
fields.monthOfYear = new BasicMonthOfYearDateTimeField ( this , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
assertEquals ( NUMBER_CONSTANT + OFFSET , test . getHourOfDay () ) ;
fields.monthOfYear = new IslamicMonthOfYearDateTimeField ( this ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
assertEquals ( cal . get ( Calendar.HOUR_OF_DAY ) , test . getHourOfDay () ) ;
assertEquals ( date . getHours () , test . getHourOfDay () ) ;
BaseGJChronology chronology
GJEraDateTimeField ( BaseGJChronology chronology ) { super ( DateTimeFieldType . era () ) ; iChronology = chronology ; }
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
BaseGJChronology chronology
GJMonthOfYearDateTimeField ( BaseGJChronology chronology ) { super ( chronology , NUMBER_CONSTANT ) ; }
BaseGJChronology chronology
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
Constructor con = cls . getDeclaredConstructor ( null ) ;
{ int len = parser . estimateParsedLength () ; if ( len > est ) { len = est ; } }
long instant = chronology . getDateTimeMillis ( hourOfDay , minuteOfHour , secondOfMinute , millisOfSecond ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstanceUTC () , result . getChronology () ) ;
LocalTime test = LocalTime . forInstant ( ( Object ) null , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( date , JULIAN ) ;
LocalTime test = LocalTime . forInstant ( TEST_TIME2 , JULIAN ) ;
LocalTime test = LocalTime . now ( JULIAN ) ;
LocalTime test = LocalTime . fromMillisOfDay ( TEST_TIME1 , JULIAN ) ;
assertEquals ( true , test . isSupported ( DurationFieldType . eras () ) ) ;
DateMidnight test = base . toDateMidnightDefaultZone () ;
DateTime test = base . toDateTimeAtCurrentTimeDefaultZone () ;
DateTime test = base . toDateTimeAtMidnightDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . nowDefaultZone () ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
LocalDate test = LocalDate . now ( COPTIC_PARIS ) ;
public void testSize () { LocalDate test = LocalDate . nowDefaultZone () ; assertEquals ( NUMBER_CONSTANT , test . size () ) ; }
LocalDate test = LocalDate . nowDefaultZone () ;
DateTime test = base . toDateTimeTodayDefaultZone () ;
long getApproxMillisAtEpoch () { return - MILLIS_YEAR_1 ; }
long millis = bucket . computeMillis ( true ) ;
long millis = bucket . computeMillis ( true ) ;
{ if ( newPos >= text . length () ) { return bucket . computeMillis ( true ) ; } }
instant . setMillis ( bucket . computeMillis () ) ;
public long computeMillis () { return computeMillis ( false ) ; }
test = new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( false , test1 . equals ( new DateMidnight ( TEST_TIME1_UTC , GregorianChronology . getInstance () ) ) ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
test = new DateTime ( TEST_TIME1 , GregorianChronology . getInstance ( PARIS ) ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance ( PARIS ) , result . getChronology () ) ;
assertEquals ( ISOChronology . getInstance () , test . getChronology () ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
long millis = converter . getInstantMillis ( instant , chronology ) ;
{ super ( instant , DateTimeUtils . getChronology ( chronology ) ) ; }
{ super ( instant , null ) ; }
int index = dateStyle * NUMBER_CONSTANT + timeStyle ;
public LocalDateTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
public LocalDate withMinimumValue () { return withValue ( getMinimumValue () ) ; }
{ return withValue ( getMaximumValue () ) ; }
public LocalTime withMinimumValue () { return withValue ( getMinimumValue () ) ; }
public LocalTime withMaximumValue () { return withValue ( getMaximumValue () ) ; }
LocalDateTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalDateTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . millisOfSecond () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . secondOfMinute () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . minuteOfHour () . withValue ( STRING_CONSTANT ) ;
LocalTime copy = test . hourOfDay () . withValue ( STRING_CONSTANT ) ;
assertEquals ( true , interval33 . contains ( new Instant ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( true , interval33 . containsNow () ) ;
assertEquals ( true , interval33 . contains ( NUMBER_CONSTANT ) ) ;
return ( getChronology () == other . getChronology () ) ;
public synchronized Set getAvailableIDs () { return Collections . unmodifiableSet ( iZoneInfoMap . keySet () ) ; }
if ( value >= min && value < getMaximumValue ( instant ) ) { return super . set ( instant , value ) ; }
DateTimeZone tz = builder . toDateTimeZone ( STRING_CONSTANT ) ;
builder . writeTo ( out ) ;
super ( createMessage ( fieldName , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
super ( createMessage ( fieldType . getName () , value , lowerBound , upperBound ) ) ;
try { test . minusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . plusYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { test . withYears ( NUMBER_CONSTANT ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
{ checkPrinter () ; printTo ( out , instant , null ) ; }
{ checkPrinter () ; printTo ( buf , instant , null ) ; }
DateTime now = new DateTime () ;
offsetLocal < NUMBER_CONSTANT
{ t = new DateTimeFormatterBuilder () . append ( hourMinuteSecondMillis () ) . append ( offsetElement () ) . toFormatter () ; }
DateTime start = base . toDateTimeAtMidnight ( LONDON ) ;
DateTime start = base . toDateTimeAtMidnight ( TOKYO ) ;
DateTime start = base . toDateTimeAtMidnight () ;
DateFormatSymbols dfs = new DateFormatSymbols ( locale ) ;
String [] [] zoneStrings = new DateFormatSymbols ( locale ) . getZoneStrings () ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
throw new IllegalArgumentException ( STRING_CONSTANT + id ) ;
{ Hibernate.DATE . nullSafeSet ( preparedStatement , ( ( LocalDate ) value ) . toDateMidnight () . toDate () , index ) ; }
Object partial
Object readableInstant
Object durationField
Collection fields
Collection fields
Collection fields
Collection fields
Collection fields
List list
List elementPairs
List elementPairs
List pairs = iElementPairs ;
if ( iElementPairs == null ) { iElementPairs = new ArrayList () ; } else { iElementPairs . clear () ; }
Map ruleSets
{ iRules = new ArrayList () ; iRules . add ( rule ) ; }
public int compareTo ( Object durationField ) { return iField . compareTo ( durationField ) ; }
Class type
Class type
iRules = new ArrayList ( rs.iRules ) ;
RuleSet () { iRules = new ArrayList ( NUMBER_CONSTANT ) ; iUpperYear = Integer.MAX_VALUE ; }
Object partial
f = ( DateTimeFormatter ) cCache . get ( key ) ;
formatter = ( DateTimeFormatter ) cPatternedCache . get ( pattern ) ;
Object partial
Map zimap
iZoneInfoMap . put ( id , new SoftReference ( tz ) ) ;
public int compareTo ( Object durationField ) { return NUMBER_CONSTANT ; }
List list
public DateTimeFormatterBuilder () { super(); iElementPairs = new ArrayList () ; }
HashMap converted
HashMap converted
HashMap converted
HashMap converted
TreeMap map
TreeMap map
symbols = ( GJLocaleSymbols ) cCache . get ( locale ) ;
Object obj
chrono = ( ISOChronology ) cCache . get ( zone ) ;
try { Single . between ( start , new TimeOfDay () , zero ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
assertEquals ( STRING_CONSTANT , f . withZone ( UTC ) . print ( dt ) ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withZone ( UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.KOREAN ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.FRANCE ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
DateTimeFormatter dateFormatter = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withPivotYear ( NUMBER_CONSTANT ) . withZone ( DateTimeZone.UTC ) ;
{ if ( ldp == null ) { ldp = dateElementParser () . withZone ( DateTimeZone.UTC ) ; } return ldp ; }
{ if ( value == null ) return null ; return new Instant ( value ) ; }
{ return ( int [] ) iValues . clone () ; }
{ return ( int [] ) iValues . clone () ; }
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
{ locale = Locale . getDefault () ; zone = DateTimeZone . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.ENGLISH ) ;
java.util.TimeZone . setDefault ( LONDON . toTimeZone () ) ;
Locale . setDefault ( Locale.UK ) ;
Locale . setDefault ( Locale.UK ) ;
public YearMonth getYearMonth () { return iYearMonth ; }
protected ReadablePartial getReadablePartial () { return iYearMonth ; }
public DateTimeField getField () { return iYearMonth . getField ( iFieldIndex ) ; }
{ super(); iYearMonth = partial ; iFieldIndex = fieldIndex ; }
Map < String , Object > map = new TreeMap < String , Object > ( String.CASE_INSENSITIVE_ORDER ) ;
DateTimeZone . setDefault ( LONDON ) ;
return iBase . getZone () . convertLocalToUTC ( localInstant , false ) ;
{ super ( duration , null , null ) ; }
{ super ( duration , null , null ) ; }
Object timestamp = Hibernate.STRING . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object value = Hibernate.LONG . nullSafeGet ( resultSet , name ) ;
Object value = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , name ) ;
Object timestamp = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.INTEGER . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.DATE . nullSafeGet ( resultSet , string ) ;
Object date = Hibernate.TIME . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
Object timestamp = Hibernate.TIMESTAMP . nullSafeGet ( resultSet , string ) ;
String s = ( String ) Hibernate.STRING . nullSafeGet ( resultSet , strings [ NUMBER_CONSTANT ] ) ;
{ if ( period != null ) { iValues = addPeriodInto ( getValues () , period ) ; } }
{ if ( period != null ) { iValues = mergePeriodInto ( getValues () , period ) ; } }
iValues = newValues ;
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ integers [ i ] = new Integer ( i ) ; }
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
array = new Object [] { validValues , new Integer ( maxLength ) } ;
{ return withPivotYear ( new Integer ( pivotYear ) ) ; }
DateTimeFormatter printer = ISODateTimeFormat . dateHourMinuteSecondFraction () ;
protected void setUp ( ) throws Exception { originalLocale = Locale . getDefault () ; Locale . setDefault ( Locale.UK ) ; }
convId = zone . getDisplayName () ;
catch ( ArrayIndexOutOfBoundsException e ) { throw new IOException ( STRING_CONSTANT ) ; }
try { readZoneInfoMap ( din , map ) ; } finally { try { din . close () ; } catch ( IOException e ) {} }
StringBuffer msg = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer () ;
if ( tokenLen >= NUMBER_CONSTANT ) { builder . appendTimeZoneName () ; } else { builder . appendTimeZoneShortName () ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( true , ex . getMessage () . startsWith ( STRING_CONSTANT ) ) ; }
try { localDateTime . toDateTime ( this ) ; return false ; } catch ( IllegalArgumentException ex ) { return true ; }
throw new IllegalArgumentException ( message ) ;
{ if ( divisor == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeDivide ( getMillis () , divisor ) ) ; }
{ if ( multiplicand == NUMBER_CONSTANT ) return this ; return new Duration ( FieldUtils . safeMultiply ( getMillis () , multiplicand ) ) ; }
{ appendable . append ( print ( instant ) ) ; }
f2 = new DateTimeFormatter ( null , f . getParser () ) ;
DateTimePrinter [] elements = iPrinters ;
DateTimePrinter [] elements = iPrinters ;
{ printTo ( appendable , null , instant , chrono ) ; }
f instanceof DateTimePrinter
DateTimePrinter printer
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( printer , parser ) ; }
{ checkPrinter ( printer ) ; return append0 ( printer , null ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter () , formatter . getParser () ) ; }
{ DateTimePrinter p = getFormatter ( locale ) . getPrinter () ; p . printTo ( appendable , partial , locale ) ; }
DateTimePrinter p = getFormatter ( locale ) . getPrinter () ;
return ( ( StyleFormatter ) formatter . getPrinter () ) . getPattern ( locale ) ;
DateTimePrinter printer = requirePrinter () ;
DateTimePrinter printer = requirePrinter () ;
{ printTo ( out , instant , null ) ; }
DateTimePrinter printer
catch ( IllegalArgumentException ex ) {}
{ return computeMillis ( resetFields , null ) ; }
{ return computeMillis ( false , null ) ; }
{ saveField ( new SavedField ( fieldType . getField ( iChrono ) , value ) ) ; }
{ saveField ( new SavedField ( field , value ) ) ; }
String text
f2 = new DateTimeFormatter ( ( InternalPrinter ) null , f . getParser () ) ;
{ reset () ; return doParseMillis ( parser , text ) ; }
String text
String text
String text
f instanceof DateTimeParser
DateTimeParser parser
{ checkPrinter ( printer ) ; checkParser ( parser ) ; return append0 ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
{ checkParser ( parser ) ; return append0 ( null , parser ) ; }
{ if ( formatter == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return append0 ( formatter . getPrinter0 () , formatter . getParser () ) ; }
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
DateTimeParser parser = requireParser () ;
public DateTimeParser getParser () { return iParser ; }
DateTimeParser parser
DateTimeParser parser
{ this ( DateTimePrinterInternalPrinter . of ( printer ) , parser ) ; }
iMillis = FieldUtils . safeAdd ( endMillis , - startMillis ) ;
{ super(); iMillis = FieldUtils . safeAdd ( endInstant , - startInstant ) ; }
try { builder . appendSuffix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
try { builder . appendPrefix ( null , null ) ; fail () ; } catch ( IllegalArgumentException ex ) {}
iSuffixes = texts ;
new PeriodFormatterBuilder () . appendDays () . appendSuffix ( STRING_CONSTANT ) . appendSuffix ( STRING_CONSTANT , STRING_CONSTANT )
new PeriodFormatterBuilder () . appendPrefix ( STRING_CONSTANT ) . appendPrefix ( STRING_CONSTANT , STRING_CONSTANT )
if ( periodStr . regionMatches ( true , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
if ( periodStr . regionMatches ( false , pos , text , NUMBER_CONSTANT , textLength ) ) { if ( ! matchesOtherAffix ( textLength , periodStr , pos ) ) { return pos ; } }
synchronized ( DateTimeZone . class ) { cDefault = zone ; }
{ return new TreeSet < String > ( iZoneInfoMap . keySet () ) ; }
public Set < String > getAvailableIDs () { return Collections . singleton ( STRING_CONSTANT ) ; }
public static Set < String > getAvailableIDs () { return cAvailableIDs ; }
DateTimeZone zone = cProvider . getZone ( id ) ;
assertSame ( zone , result ) ;
int curMonth0 = partial . getValue ( NUMBER_CONSTANT ) - NUMBER_CONSTANT ;
if ( ZoneInfoCompiler . verbose () ) { System.out . println ( STRING_CONSTANT + tz . getID () ) ; }
cVerbose . set ( verbose ) ;
Interval interval = new Interval ( start , end ) ;
int compare = csCompare ( value , text , position ) ;
{ return FieldUtils . safeAdd ( getEndMillis () , - getStartMillis () ) ; }
{ millis = iField . set ( millis , iValue ) ; }
str = str . toLowerCase () ;
assertEquals ( STRING_CONSTANT , str ) ;
DateTimeFormatter f = DateTimeFormat . forPattern ( STRING_CONSTANT ) . withLocale ( Locale.UK ) ;
DateTimeFormatter fmt = DateTimeFormat . forPattern ( STRING_CONSTANT ) ;
{ Provider provider = new ZoneInfoProvider ( STRING_CONSTANT ) ; return validateProvider ( provider ) ; }
{ return getCumPct ( new Character ( v ) ) ; }
{ return getCumFreq ( new Character ( v ) ) ; }
{ return getPct ( new Character ( v ) ) ; }
{ return getCount ( new Character ( v ) ) ; }
public IntegratorException ( Throwable cause ) { super ( cause ) ; }
double initialStepSize
SecondOrderDifferentialEquations equations
public DerivativeException ( Throwable cause ) { super ( cause ) ; }
super ( minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ super ( c , a , b , new GillStepInterpolator () , step ) ; }
{ super ( c , a , b , new MidpointStepInterpolator () , step ) ; }
{ super ( c , a , b , new EulerStepInterpolator () , step ) ; }
{ super ( c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( cm ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableStepHandler () ) ;
integ . setStepHandler ( new KeplerStepHandler ( pb ) ) ;
integrator . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new VariableHandler () ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( new KeplerHandler ( pb ) ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
integ . setStepHandler ( handler ) ;
handler = DummyStepHandler . getInstance () ;
FirstOrderIntegrator integrator
regression . addData ( y , x , omega ) ;
regression . addData ( y , x , omega ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
CombinedEventsManager manager = addEndTimeChecker ( t , eventsHandlersManager ) ;
{ maxValueError = NUMBER_CONSTANT ; maxTimeError = NUMBER_CONSTANT ; lastError = NUMBER_CONSTANT ; expectedStepStart = problem . getInitialTime () ; }
ComplexFormat cf = new ComplexFormat () ;
ComplexFormat cf = ComplexFormat . getInstance ( getLocale () ) ;
this . step = step ;
stepSize = step ;
this . step = step ;
stepSize = step ;
this . step = step ;
{ if ( qr == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ System . arraycopy ( b [ i ] , NUMBER_CONSTANT , root . getDataRef () [ swap [ i ] ] , NUMBER_CONSTANT , rank ) ; }
{ new QRDecompositionImpl () . isFullRank () ; fail ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isFullRank () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
cachedQ == null
RealMatrix sse = u . transpose () . multiply ( Omega . inverse () ) . multiply ( u ) ;
{ RealMatrix XTX = X . transpose () . multiply ( X ) ; return XTX . inverse () ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isNonSingular () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
MatrixIndexException ex = new MatrixIndexException ( msg ) ;
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( singular ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! matrix . isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
catch ( IndexOutOfBoundsException e ) { throw new MatrixIndexException ( e . getMessage () ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
throw new RuntimeException ( STRING_CONSTANT ) ;
catch ( Exception e ) { throw new RuntimeException ( e . getMessage () ) ; }
{ return ( Object [] ) arguments . clone () ; }
{ super(); this . pattern = null ; this . arguments = new Object [ NUMBER_CONSTANT ] ; }
{ return ( Object [] ) arguments . clone () ; }
MatrixIndexException ex = new MatrixIndexException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
InvalidMatrixException ex = new InvalidMatrixException ( msg , new Object [ NUMBER_CONSTANT ] ) ;
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
assertNull ( ex . getMessage ( Locale.FRENCH ) ) ;
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
throw new MathRuntimeException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ;
public Double getZ () { throw new MathRuntimeException () ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
if ( o == null ) { throw new MathException ( STRING_CONSTANT , new Object [ NUMBER_CONSTANT ] ) ; }
{ super(); this . pattern = null ; this . arguments = null ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
catch ( Exception e ) { throw new IOException ( e . getMessage () ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
catch ( IOException ioe ) { assertNull ( ioe . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
try { setInterpolatedTime ( t ) ; } catch ( DerivativeException e ) { throw new IOException ( e . getMessage () ) ; }
{ if ( qrt == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ if ( lu == null ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return iterationCount ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
{ if ( resultComputed ) { return result ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
if ( ! loaded ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
assertEquals ( NUMBER_CONSTANT , vTv . subtract ( id ) . getNorm () , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
{ assertEquals ( refValues [ i ] , eigenValues [ eigenValues.length - NUMBER_CONSTANT - i ] , NUMBER_CONSTANT ) ; }
orthoTridiag = null ;
lu = null ;
lu = null ;
{ copyIn ( d ) ; lu = null ; }
lu = null ;
public int [] getPivot ( ) throws IllegalStateException { checkDecomposed () ; return pivot . clone () ; }
{ checkDecomposed () ; return eigenvalues [ i ] ; }
public double [] getEigenvalues ( ) throws InvalidMatrixException { checkDecomposed () ; return eigenvalues . clone () ; }
EigenDecomposition ed = new EigenDecompositionImpl ( distinct ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( repeated ) ;
RealMatrix v = new EigenDecompositionImpl ( matrix ) . getV () ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
EigenDecomposition ed = new EigenDecompositionImpl ( matrix ) ;
public double getNorm ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues [ NUMBER_CONSTANT ] ; }
public double [] getSingularValues ( ) throws InvalidMatrixException { checkDecomposed () ; return singularValues . clone () ; }
ds = null ;
ds = null ;
{ copyIn ( d ) ; ds = null ; }
ds = null ;
EigenDecomposition ed = new DecompositionSolver ( distinct ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( repeated ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( m ) . eigenDecompose () ;
RealMatrix v = new DecompositionSolver ( matrix ) . eigenDecompose () . getV () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
EigenDecomposition ed = new DecompositionSolver ( matrix ) . eigenDecompose () ;
public DescriptiveStatistics ( int window ) { super(); setWindowSize ( window ) ; }
{ return stat . evaluate ( eDA . getValues () , eDA . start () , eDA . getNumElements () ) ; }
double [] [] in
RealVectorImpl v
double [] v
RealMatrixImpl m
RealMatrixImpl m
RealMatrixImpl m
double [] v
{ setup ( f ) ; return factory . newDefaultSolver ( f ) . solve ( x0 , x1 ) ; }
UnivariateRealSolver solver = factory . newSecantSolver ( function ) ;
UnivariateRealSolver solver = factory . newBrentSolver ( function ) ;
UnivariateRealSolver solver = factory . newNewtonSolver ( function ) ;
UnivariateRealSolver solver = factory . newBisectionSolver ( function ) ;
try { iterator . next () ; } catch ( ConcurrentModificationException cme ) {}
RealMatrixImpl m_outerProduct = v1 . outerProduct ( v2 ) ;
cachedV = transformer . getV () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
cachedU = transformer . getU () . multiply ( new RealMatrixImpl ( iData , false ) ) ;
RealMatrix covRM = new RealMatrixImpl ( cov , false ) ;
return new RealMatrixImpl ( bp , false ) ;
return new RealMatrixImpl ( dData , false ) ;
return new RealMatrixImpl ( data , false ) ;
return new RealMatrixImpl ( xData , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealMatrixImpl ( y ) ; }
RealMatrixImpl matrix = new RealMatrixImpl ( testSquare , false ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
RealMatrixImpl matrix = new RealMatrixImpl ( testData , false ) ;
return new RealMatrixImpl ( invData , false ) ;
return new RealMatrixImpl ( bp , false ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
@ Test ( expected = IllegalArgumentException . class )
assertTrue ( solver . isNonSingular () ) ;
{ return new RealVectorImpl ( solve ( b . getData () ) , false ) ; }
{ this . decomposition = decomposition ; }
{ this . X = new DenseRealMatrix ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ this . Omega = MatrixUtils . createRealMatrix ( omega ) ; this . OmegaInverse = null ; }
{ this . X = MatrixUtils . createRealMatrix ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
@ Test ( expected = ArrayIndexOutOfBoundsException . class )
return MatrixUtils . createRealMatrix ( data ) ;
public boolean isSingular ( ) ;
return new RealMatrixImpl ( data , false ) ;
{ this . decomposition = decomposition ; }
{ eigenvectors [ i ] = findEigenvector ( eigenvalues [ i ] , d , l ) ; }
{ eigenvalues [ index ] = main [ index ] ; }
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( eigenvalues , eigenvectors ) ; }
{ double determinant = NUMBER_CONSTANT ; for ( double lambda : eigenvalues ) { determinant *= lambda ; } return determinant ; }
{ if ( cachedD == null ) { cachedD = MatrixUtils . createRealDiagonalMatrix ( eigenvalues ) ; } return cachedD ; }
double [] observed = ed . getEigenvalues () ;
double lambda = ed . getEigenvalue ( i ) ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
double [] eigenValues = ed . getEigenvalues () ;
assertEquals ( NUMBER_CONSTANT , ed . getEigenvalue ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
singularValues = eigenDecomposition . getEigenvalues () ;
{ if ( eigenvectors == null ) { findEigenVectors () ; } return new Solver ( realEigenvalues , eigenvectors ) ; }
if ( n == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ return fht ( f ) ; }
{ OpenIntToDoubleHashMap map = new OpenIntToDoubleHashMap () ; assertEquals ( NUMBER_CONSTANT , map . remove ( NUMBER_CONSTANT ) ) ; }
this . entries = new OpenIntToDoubleHashMap () ;
double previous = NUMBER_CONSTANT ;
values [ index ] = NUMBER_CONSTANT ;
return new LUSolver ( new LUDecompositionImpl ( XTX ) ) . getInverse () ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
assertEquals ( new RealMatrixImpl ( reference ) , new RealMatrixImpl ( sub ) ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
assertEquals ( new RealMatrixImpl ( reference ) , sub ) ;
RealMatrix m = new RealMatrixImpl ( subTestData ) ;
rDiag = new double [ n ] ;
return new LUSolver ( new LUDecompositionImpl ( XTOIX ) ) . getInverse () ;
{ if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; } }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
if ( lu == null ) { lu = new LUSolver ( new LUDecompositionImpl ( this , MathUtils.SAFE_MIN ) ) ; }
private double getDeterminant ( RealMatrix m ) { return new LUSolver ( new LUDecompositionImpl ( m ) ) . getDeterminant () ; }
{ clearResult () ; return localmin ( min , max , relativeAccuracy , absoluteAccuracy , f ) ; }
assertEquals ( Float.NaN , MathUtils . sign ( Float.NaN ) , delta ) ;
{ vals [ i ] = values [ i ] ; }
computeOmega ( - f.length ) ;
computeOmega ( - f.length ) ;
computeOmega ( f.length ) ;
{ computeOmega ( f.length ) ; return fft ( f ) ; }
{ for ( int i = NUMBER_CONSTANT ; i < virtualSize ; i ++ ) { set ( i , value ) ; } }
{ set ( i , Math . log ( getEntry ( i ) ) ) ; }
{ set ( i , Math . log10 ( getEntry ( i ) ) ) ; }
{ set ( i , NUMBER_CONSTANT / getEntry ( i ) ) ; }
{ set ( i , getEntry ( i ) + d ) ; }
{ set ( i , Math . acos ( getEntry ( i ) ) ) ; }
{ res . set ( i + virtualSize , a [ i ] ) ; }
{ RealVector res = new SparseRealVector ( this , NUMBER_CONSTANT ) ; res . set ( virtualSize , d ) ; return res ; }
{ set ( index , v.data ) ; }
w . set ( i , w . getEntry ( i ) / si ) ;
assertClose ( STRING_CONSTANT , m3 . multiply ( m4 ) , m5 , entryTolerance ) ;
MatrixIndexException ex = new MatrixIndexException ( msg , null ) ;
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , null ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT , null ) ; }
final Object [] parts
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , cause ) ;
FunctionEvaluationException ex = new FunctionEvaluationException ( NUMBER_CONSTANT , pattern , arguments , cause ) ;
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
{ super ( STRING_CONSTANT , new Object [] { rows , columns } ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
Object [] arguments
catch ( DimensionMismatchException dme ) { throw new MathRuntimeException ( STRING_CONSTANT , null , dme ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
Object [] parts
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT + STRING_CONSTANT , null ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
Object [] arguments
Object [] parts
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT , null ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } return isForward ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
final Object [] arguments
{ return buildMessage ( pattern , arguments , locale ) ; }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , null ) ; }
Object [] arguments
MathException ex = new MathException ( pattern , arguments , cause ) ;
{ super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT , null ) ; }
MathConfigurationException ex = new MathConfigurationException ( pattern , arguments , cause ) ;
Object [] arguments
ConvergenceException ex = new ConvergenceException ( pattern , arguments , cause ) ;
{ return buildMessage ( pattern , arguments , locale ) ; }
{ throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , null ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
final Object [] parts
final Object [] arguments
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , null ) ; }
final Object [] parts
if ( b.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( ! isSquare () ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT , null ) ; }
catch ( DerivativeException de ) { throw new MathRuntimeException ( STRING_CONSTANT , null , de ) ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isNaN ( iter . value () ) ) return true ; }
while ( iter . hasNext () ) { iter . advance () ; if ( Double . isInfinite ( iter . value () ) ) return true ; }
if ( delta > max ) max = delta ;
{ virtualSize = values.length ; fromDoubleArray ( values ) ; }
{ if ( data.length != n ) { throw new IllegalArgumentException ( STRING_CONSTANT + data.length + STRING_CONSTANT + n + STRING_CONSTANT ) ; } }
if ( d.length == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
epsilon = DEFAULT_ZERO_TOLERANCE ;
public void setConvergenceChecker ( ConvergenceChecker checker ) { optimizer . setConvergenceChecker ( checker ) ; }
final Optimizer optimizer
final Comparator < PointValuePair > comparator
public void setConvergenceChecker ( ConvergenceChecker checker ) { this . checker = checker ; }
final MultiObjectiveFunction function
final MultiObjectiveFunction function
final MultiObjectiveFunction function
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildArray ( m , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , buildChebyquadArray ( n , factor ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( m , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; if ( theoreticalStartCost > NUMBER_CONSTANT ) { setCostAccuracy ( NUMBER_CONSTANT ) ; setParamsAccuracy ( NUMBER_CONSTANT ) ; } }
{ super ( NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , x0 ) , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , theoreticalMinCost , theoreticalMinParams ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( NUMBER_CONSTANT , startParams , theoreticalStartCost , NUMBER_CONSTANT , buildArray ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
{ super ( m , buildArray ( n , x0 ) , theoreticalStartCost , theoreticalMinCost , null ) ; }
final double residual = objective [ i ] - target [ i ] ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( NUMBER_CONSTANT ) ;
optimizer . setMaxEvaluations ( maxCostEval ) ;
incrementJacobianEvaluationsCounter () ;
{ setConvergenceChecker ( new SimpleVectorialValueChecker () ) ; setMaxEvaluations ( DEFAULT_MAX_EVALUATIONS ) ; }
{ super ( cause , pattern , arguments ) ; this . argument = argument ; }
{ super ( cause ) ; this . argument = argument ; }
{ super ( pattern , arguments ) ; this . argument = argument ; }
assertEquals ( NUMBER_CONSTANT , ex . getArgument () , NUMBER_CONSTANT ) ;
assertEquals ( Math.PI , ex . getArgument () , NUMBER_CONSTANT ) ;
final VectorialObjectiveFunction function
public void setConvergenceChecker ( ScalarConvergenceChecker checker ) { this . checker = checker ; }
catch ( ObjectiveException oe ) { assertTrue ( exceptionExpected ) ; }
{ if ( numerator == NUMBER_CONSTANT ) { return ZERO ; } return new BigFraction ( numerator , denominator ) . reduce () ; }
{ if ( format == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
public FractionFormat () { this ( getDefaultNumberFormat () ) ; }
{ return subtract ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return subtract ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return multiply ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( l , NUMBER_CONSTANT ) ) ; }
{ return add ( new BigFraction ( i , NUMBER_CONSTANT ) ) ; }
final ArrayList < Fraction > coefficients
assertEquals ( ci , l40 [ i ] , ci * NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , new BigFraction ( Double.MIN_NORMAL ) . getNumeratorAsLong () ) ;
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected String getResourceName () { return STRING_CONSTANT ; }
protected Locale getLocale () { return Locale.US ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.FRENCH ; }
protected Locale getLocale () { return Locale.US ; }
UnivariateRealSolver solver = factory . newDefaultSolver () ;
{ setup ( f ) ; return factory . newDefaultSolver () . solve ( f , x0 , x1 ) ; }
{ logSum += Math . log ( ( double ) i ) ; }
double n0 = ( double ) n ;
double n0 = ( double ) n ;
{ return ( StorelessUnivariateStatistic [] ) meanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) geoMeanImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumLogImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) maxImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) minImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumSqImpl . clone () ; }
{ return ( StorelessUnivariateStatistic [] ) sumImpl . clone () ; }
double degreesOfFreedom = ( double ) ( n1 + n2 - NUMBER_CONSTANT ) ;
{ return ( sumY - slope * sumX ) / ( ( double ) n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
{ if ( n < NUMBER_CONSTANT ) { return Double.NaN ; } return getSumSquaredErrors () / ( double ) ( n - NUMBER_CONSTANT ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( RealPointValuePair [] ) optima . clone () ; }
double n = ( double ) length ;
{ dest.variance = ( Variance ) source.variance . copy () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return ( VectorialPointValuePair [] ) optima . clone () ; }
{ dest.incMoment = source.incMoment ; dest.moment = ( FirstMoment ) source.moment . copy () ; }
double sampleSize = ( double ) length ;
{ dest.moment = ( FourthMoment ) source.moment . copy () ; dest.incMoment = source.incMoment ; }
{ return ( NumberTransformer ) map . get ( key ) ; }
{ return sumDifference ( sample1 , sample2 ) / ( double ) sample1.length ; }
{ dest.sumOfLogs = ( SumOfLogs ) source.sumOfLogs . copy () ; }
{ return Math . exp ( sumOfLogs . evaluate ( values , begin , length ) / ( double ) length ) ; }
{ return Math . exp ( sumOfLogs . getResult () / ( double ) sumOfLogs . getN () ) ; }
{ result [ i - NUMBER_CONSTANT ] = ( double ) i * coefficients [ i ] ; }
double n0 = ( double ) n ;
{ dest.moment = new ThirdMoment ( ( ThirdMoment ) source.moment . copy () ) ; dest.incMoment = source.incMoment ; }
{ return ( Object [] [] ) contents . clone () ; }
{ dest.moment = ( SecondMoment ) source.moment . copy () ; dest.isBiasCorrected = source.isBiasCorrected ; dest.incMoment = source.incMoment ; }
double len = ( double ) length ;
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
return Math . sqrt ( sum / ( double ) v.length ) ;
{ super ( problem ) ; e = problem.e ; y = ( double [] ) problem.y . clone () ; }
{ super ( problem ) ; y = ( double [] ) problem.y . clone () ; }
{ dY [ i ] = ( double ) y [ i ] ; }
{ dX [ i ] = ( double ) x [ i ] ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( asBigDecimal ( testVector ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () . doubleValue () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( InvalidMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
{ super ( problem ) ; a = problem.a ; y = ( double [] ) problem.y . clone () ; }
return sum / ( double ) v.length ;
try { randomData . nextExponential ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextSecureLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { randomData . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
SimplexTableau tableau = new SimplexTableau ( f , constraints , GoalType.MAXIMIZE , false ) ;
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative ) ;
{ return ( sumY - slope * sumX ) / ( n ) ; }
Math . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / n ) + ( xbar * xbar ) / sumXX ) )
Math . sqrt ( ( accum - ( Math . pow ( accum2 , NUMBER_CONSTANT ) / ( length ) ) ) / ( length - NUMBER_CONSTANT ) )
double degreesOfFreedom = ( n1 + n2 - NUMBER_CONSTANT ) ;
{ checkSufficientData ( matrix ) ; nObs = matrix . getRowDimension () ; correlationMatrix = computeCorrelation ( matrix ) ; }
{ checkSufficientData ( matrix ) ; n = matrix . getRowDimension () ; covarianceMatrix = computeCovariance ( matrix , biasCorrected ) ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { testGenerator . nextInt ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { regression . getSlopeConfidenceInterval ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
catch ( IllegalStateException ex ) { ; }
{ try { vs . getNext () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ex ) { ; } }
catch ( IllegalArgumentException ex ) { ; }
try { m . preMultiply ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
try { m . getTrace () ; fail ( STRING_CONSTANT ) ; } catch ( NonSquareMatrixException ex ) { ; }
catch ( IllegalArgumentException ex ) { ; }
try { m . add ( m2 ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) { ; }
Iterator it = f . valuesIterator () ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nRows ) ;
final T [] out = buildArray ( nCols ) ;
final T [] [] data = buildArray ( getRowDimension () , getColumnDimension () ) ;
final T [] [] out = buildArray ( nRows , getColumnDimension () ) ;
final T [] out = buildArray ( nCols ) ;
final T [] out = buildArray ( nRows ) ;
data = buildArray ( subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( nRows , nCols ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
final T [] [] outData = buildArray ( rowCount , columnCount ) ;
{ return ( FieldVectorImpl < T > ) subtract ( ( T [] ) v.data ) ; }
{ return ( FieldVectorImpl < T > ) add ( ( T [] ) v.data ) ; }
super ( ( Field < T > ) extractField ( v ) ) ;
super ( ( Field < T > ) extractField ( d ) ) ;
{ super ( ( Field < T > ) extractField ( d ) ) ; copyIn ( d ) ; }
nextAction = handler . eventOccurred ( t , y ) ;
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + n ) ; }
if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( f == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
return null ;
if ( Double . doubleToLongBits ( test ) != Double . doubleToLongBits ( iter . value () ) ) { return false ; }
double [] hatResiduals = I . subtract ( hat ) . multiply ( model.Y ) . getColumn ( NUMBER_CONSTANT ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( row , endRow , column , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
{ this . Y = new RealMatrixImpl ( y ) ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException () ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
if ( n < NUMBER_CONSTANT || n != sample2.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . mean = mean ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( n <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = num ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . alpha = alpha ; }
checkMultiplicationCompatible ( m ) ;
checkMultiplicationCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
checkColumnIndex ( col ) ;
checkColumnIndex ( col ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
if ( r < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ClassCastException ex ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkColumnIndex ( column ) ;
checkColumnIndex ( column ) ;
checkRowIndex ( row ) ;
checkRowIndex ( row ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkSubMatrixIndex ( selectedRows , selectedColumns ) ;
checkSubMatrixIndex ( startRow , endRow , startColumn , endColumn ) ;
checkMultiplicationCompatible ( m ) ;
checkSubtractionCompatible ( m ) ;
checkAdditionCompatible ( m ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfSuccesses = successes ; }
{ if ( values == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . degreesOfFreedom = degreesOfFreedom ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean.length != standardDeviation.length ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } numberOfTrials = trials ; }
{ if ( realFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
throw new IllegalArgumentException ( STRING_CONSTANT ) ;
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } standardDeviation = sd ; }
if ( normProduct == NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } scale = s ; }
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( x0 > x1 ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( len <= NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + p ) ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + alpha ) ; }
Object obj1 = null ;
SparseRealVector v1 = new SparseRealVector ( vec1 ) ;
return new SparseRealVector ( out ) ;
{ Assert . assertEquals ( expected [ i ] , observed [ i ] , tolerance ) ; }
final int dimension = currentState.length ;
final int dimension = currentState.length ;
final MultistepStepInterpolator prototype
equations = null ;
equations = null ;
{ super(); yDotK = null ; equations = null ; }
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
interpolator . reinitialize ( new DummyEquations () , y , yDot , true ) ;
equations . computeDerivatives ( t0 + h , y1 , yDot1 ) ;
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
assertEquals ( MatrixUtils . createColumnRealMatrix ( col ) , new DenseRealMatrix ( colMatrix ) ) ;
assertEquals ( MatrixUtils . createRowRealMatrix ( row ) , new DenseRealMatrix ( rowMatrix ) ) ;
assertEquals ( new DenseRealMatrix ( testData ) , MatrixUtils . createRealMatrix ( testData ) ) ;
RealMatrix mA = new DenseRealMatrix ( a ) ;
RealMatrix result = new DenseRealMatrix ( dimension , dimension ) ;
return new DenseRealMatrix ( matrixData ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new DenseRealMatrix ( testDataInv ) ) , identity , entryTolerance ) ;
{ DenseRealMatrix m = new DenseRealMatrix ( testData ) ; assertEquals ( m , TestUtils . serializeAndRecover ( m ) ) ; }
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
assertEquals ( new DenseRealMatrix ( reference ) , new DenseRealMatrix ( sub ) ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
assertEquals ( new DenseRealMatrix ( reference ) , sub ) ;
RealMatrix m = new DenseRealMatrix ( subTestData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( testData ) ;
RealMatrix m = new DenseRealMatrix ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this . factors = new DenseRealMatrix ( factors ) ; this . target = target ; }
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
{ return computeCorrelationMatrix ( new DenseRealMatrix ( data ) ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( nVars , nVars ) ;
return new DenseRealMatrix ( out ) ;
return new DenseRealMatrix ( out ) ;
{ this ( new DenseRealMatrix ( data ) ) ; }
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
assertEquals ( new DenseFieldMatrix < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new DenseFieldMatrix < Fraction > ( testData ) ;
{ return computeCovarianceMatrix ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
RealMatrix outMatrix = new DenseRealMatrix ( dimension , dimension ) ;
{ this ( new DenseRealMatrix ( data ) , biasCorrected ) ; }
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new FieldMatrixImpl < Fraction > ( testData ) ;
{ setColumn ( column , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ setRow ( row , ( ( RealVectorImpl ) vector ) . getDataRef () ) ; }
return new RealVectorImpl ( outData , false ) ;
{ return new RealVectorImpl ( getColumn ( column ) , false ) ; }
{ return new RealVectorImpl ( getRow ( row ) , false ) ; }
eigenvectors = new RealVectorImpl [ m ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl v = eigenvectors [ i ] ;
final RealVectorImpl [] eigenvectors
{ this . X = new RealMatrixImpl ( x ) ; }
{ this . Y = new RealVectorImpl ( y ) ; }
return new RealVectorImpl ( data , false ) ;
{ m . setColumnVector ( NUMBER_CONSTANT , new RealVectorImpl ( NUMBER_CONSTANT ) ) ; fail ( STRING_CONSTANT ) ; }
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
{ super ( STRING_CONSTANT , new RealVectorImpl ( argument ) ) ; this . argument = argument . clone () ; }
return new FieldMatrixImpl < Fraction > ( out ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
return new FieldVectorImpl < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
assertEquals ( new FieldMatrixImpl < Fraction > ( reference ) , sub ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new FieldMatrixImpl < Fraction > ( testData ) ;
{ this ( new RealVectorImpl ( coefficients ) , constantTerm ) ; }
this . coefficients = new RealVectorImpl ( sub , false ) ;
{ this ( new RealVectorImpl ( coefficients ) , relationship , value ) ; }
return new RealMatrixImpl ( matrixData ) ;
RealMatrix repeatedColumns = new RealMatrixImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
this . tableau = new RealMatrixImpl ( matrix ) ;
this . tableau = new RealMatrixImpl ( createTableau ( goalType == GoalType.MAXIMIZE ) ) ;
nordsieck = new RealMatrixImpl ( nData , false ) ;
{ setColumn ( column , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
{ setRow ( row , ( ( FieldVectorImpl < T > ) vector ) . getDataRef () ) ; }
return new FieldVectorImpl < T > ( outData , false ) ;
return new RealVectorImpl ( x ) ;
{ this . X = new RealMatrixImpl ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrixImpl augI = new RealMatrixImpl ( n , n ) ;
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new RealMatrixImpl ( x , false ) ;
{ this . Omega = new RealMatrixImpl ( omega ) ; this . OmegaInverse = null ; }
{ return new FieldVectorImpl < T > ( getColumn ( column ) , false ) ; }
{ return new FieldVectorImpl < T > ( getRow ( row ) , false ) ; }
return new RealVectorImpl ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new RealVectorImpl ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new RealVectorImpl ( testVector ) ) . getData () , entryTolerance ) ;
RealVector lhs = new RealVectorImpl ( numCoefficients ) ;
final RealMatrix matrix = new RealMatrixImpl ( data , false ) ;
final RealVector vector = new RealVectorImpl ( data , false ) ;
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
RealMatrix getConvertedMatrix () { return new RealMatrixImpl ( data , false ) ; }
{ return new FieldVectorImpl < T > ( data , true ) ; }
{ return new RealVectorImpl ( data , true ) ; }
return new FieldMatrixImpl < T > ( d , false ) ;
new FieldMatrixImpl < T > ( data )
new FieldMatrixImpl < T > ( field , rows , columns )
{ es . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
decompMatrix = new RealMatrixImpl ( decomp ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
RealMatrix triangularMatrix = new RealMatrixImpl ( lowerTriangularMatrix ) ;
solver . solve ( new RealMatrixImpl ( m3 ) , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } ) ;
solver . decompose ( new RealMatrixImpl ( m7 ) ) ;
return new FieldVectorImpl < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new FieldVectorImpl < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new FieldVectorImpl < Fraction > ( testVector ) ) . getData () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new FieldMatrixImpl < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new RealMatrixImpl ( bp , false ) ;
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
{ solver . solve ( new RealVectorImplTest.RealVectorTestImpl ( b . getColumn ( NUMBER_CONSTANT ) ) ) ; fail ( STRING_CONSTANT ) ; }
return new FieldMatrixImpl < BigFraction > ( pData , false ) ;
FieldMatrix < BigFraction > bigMSupdate = bigMStoN . multiply ( new FieldMatrixImpl < BigFraction > ( shiftedP , false ) ) ;
return coefficients.msToN . multiply ( new RealMatrixImpl ( multistep , false ) ) ;
FieldMatrix < T > identity = new FieldMatrixImpl < T > ( field , m , m ) ;
return new FieldMatrixImpl < T > ( bp , false ) ;
cachedP = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedU = new FieldMatrixImpl < T > ( field , m , m ) ;
cachedL = new FieldMatrixImpl < T > ( field , m , m ) ;
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , simplex.length ) ; }
{ Arrays . fill ( corrected , NUMBER_CONSTANT ) ; }
f . set ( this , NordsieckTransformer . getInstance ( nSteps ) ) ;
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
final RealMatrix nordsieck
if ( interpolator.nordsieck != null ) { nordsieck = interpolator.nordsieck . copy () ; }
nordsieck = transformer . initializeHighOrderDerivatives ( scaled , multistep ) ;
TestProblem1 pb2 = ( TestProblem1 ) pb1 . clone () ;
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
v instanceof SparseFieldVector
! ( original instanceof RandomKey )
if ( ! ( another instanceof RandomKey ) ) return false ;
{ addMeasurement ( new LocalMeasurement ( x , y , w ) ) ; }
{ measurements [ i ] = new MinpackMeasurement ( i ) ; }
Object v
Object v
Object v
final long curN = current . getN () ;
StatisticalSummaryValues observed
StatisticalSummaryValues aggregatedStats = AggregateSummaryStatistics . aggregate ( aggregate ) ;
optimizer . setConvergenceChecker ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
optimizer . setConvergenceChecker ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
final DescriptiveStatistics dstat = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
DescriptiveStatistics stats = new DescriptiveStatistics () ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
MultivariateSummaryStatistics u = new MultivariateSummaryStatistics ( NUMBER_CONSTANT , true ) ;
{ super ( m , startParams , theoreticalMinCost , theoreticalMinParams ) ; }
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
OpenMapRealVector res = ( OpenMapRealVector ) copy () ;
this . constraints = constraints ;
return factorials [ n ] ;
{ super ( STRING_CONSTANT , c , a , b , new ThreeEighthesStepInterpolator () , step ) ; }
{ super ( STRING_CONSTANT , c , a , b , new EulerStepInterpolator () , step ) ; }
public static DummyStepHandler getInstance () { return instance ; }
{ super ( STRING_CONSTANT , c , a , b , new MidpointStepInterpolator () , step ) ; }
{ return percentile . evaluate ( values , begin , length , p ) ; }
{ return percentile . evaluate ( values , p ) ; }
{ return min . evaluate ( values , begin , length ) ; }
{ return min . evaluate ( values ) ; }
{ return max . evaluate ( values , begin , length ) ; }
{ return max . evaluate ( values ) ; }
{ return variance . evaluate ( values , mean ) ; }
{ return variance . evaluate ( values , mean , begin , length ) ; }
{ return variance . evaluate ( values , begin , length ) ; }
{ return variance . evaluate ( values ) ; }
{ return geometricMean . evaluate ( values , begin , length ) ; }
{ return geometricMean . evaluate ( values ) ; }
{ return mean . evaluate ( values , begin , length ) ; }
{ return mean . evaluate ( values ) ; }
{ return sumLog . evaluate ( values , begin , length ) ; }
{ return sumLog . evaluate ( values ) ; }
{ return prod . evaluate ( values , begin , length ) ; }
{ return prod . evaluate ( values ) ; }
{ return sumSq . evaluate ( values , begin , length ) ; }
{ return sumSq . evaluate ( values ) ; }
{ return sum . evaluate ( values , begin , length ) ; }
{ return sum . evaluate ( values ) ; }
{ super ( STRING_CONSTANT , c , a , b , new ClassicalRungeKuttaStepInterpolator () , step ) ; }
@ Override public Object [] [] getContents () { return contents . clone () ; }
{ super ( STRING_CONSTANT , c , a , b , new GillStepInterpolator () , step ) ; }
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { return null ; }
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
{ return row * columnDimension + column ; }
@ Override public int getRowDimension () { return rowDimension ; }
@ Override public int getColumnDimension () { return columnDimension ; }
final SimplexTableau tableau = new SimplexTableau ( f , constraints , goalType , restrictToNonNegative , epsilon ) ;
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . beta = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . alpha = alpha ; }
{ final double residual = residuals [ i ] ; chiSquare += residual * residual / weights [ i ] ; }
{ final double residual = residuals [ i ] ; criterion += weights [ i ] * residual * residual ; }
final double factor = - Math . sqrt ( weights [ i ] ) ;
catch ( Exception e ) { throw new MathException ( e , STRING_CONSTANT , e . getMessage () ) ; }
public UnivariateMatrixFunction derivative ( ) ;
public UnivariateRealFunction derivative ( ) ;
public double getMean ( ) ;
public double getExponent ( ) ;
public int getNumberOfElements ( ) ;
public boolean isNaN ( ) ;
public UnivariateVectorialFunction derivative ( ) ;
public abstract long getN ( ) ;
public int getDimension ( ) ;
public double fitness ( ) ;
public int getDimension ( ) ;
public int getDimension ( ) ;
public abstract int getSampleSize ( ) ;
public abstract int getPopulationSize ( ) ;
public abstract int getNumberOfSuccesses ( ) ;
public abstract double getSum ( ) ;
public abstract long getN ( ) ;
public abstract double getMin ( ) ;
public abstract double getMax ( ) ;
public double getCurrentTime ( ) ;
public double getPreviousTime ( ) ;
public abstract void resetRelativeAccuracy ( ) ;
public abstract double getRelativeAccuracy ( ) ;
public abstract void resetAbsoluteAccuracy ( ) ;
public abstract double getAbsoluteAccuracy ( ) ;
public abstract int getMaximalIterationCount ( ) ;
public void reset ( ) ;
public static DummyStepHandler getInstance () { return INSTANCE ; }
{ super(); this . randomData = randomData ; }
RandomGenerator generator
return ( anovaPValue ( categoryData ) < alpha ) ;
{ return ( internalArray ) ; }
{ return ( internalArray ) ; }
synchronized int getInternalLength () { return ( internalArray.length ) ; }
double dx = ( x2 - x1 ) ;
return ( isForward ) ? omegaImaginaryForward [ k ] : omegaImaginaryInverse [ k ] ;
isForward = ( n > NUMBER_CONSTANT ) ;
return ( stdDev ) ;
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sampleStats1 , sampleStats2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( homoscedasticTTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( sample1 , sample2 ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sampleStats ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( tTest ( mu , sample ) < alpha ) ; }
{ checkSignificanceLevel ( alpha ) ; return ( pairedTTest ( sample1 , sample2 ) < alpha ) ; }
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
{ g0Positive = ( g0 >= NUMBER_CONSTANT ) ; nextAction = EventHandler.CONTINUE ; }
increasing = ( gb >= ga ) ;
{ t0 = tStart ; g0 = handler . g ( tStart , yStart ) ; g0Positive = ( g0 >= NUMBER_CONSTANT ) ; }
final boolean forward = ( t > t0 ) ;
final boolean forward = ( t > t0 ) ;
{ sum += ( values [ i ] * weights [ i ] ) ; }
final boolean forward = ( t > t0 ) ;
{ return ( o1 . compareTo ( ( T ) o2 ) ) ; }
return ( chiSquareTestDataSetsComparison ( observed1 , observed2 ) < alpha ) ;
unequalCounts = ( countSum1 != countSum2 ) ;
return ( chiSquareTest ( counts ) < alpha ) ;
return ( chiSquareTest ( expected , observed ) < alpha ) ;
return ( stdDev ) ;
i < this . getRowDimension ()
{ correction += ( values [ i ] - xbar ) ; }
public boolean isSquare () { return ( getColumnDimension () == getRowDimension () ) ; }
return ( super . equals ( stat ) && aggregateStatistics . equals ( stat.aggregateStatistics ) ) ;
final boolean forward = ( t > t0 ) ;
forward = ( interpolator . getCurrentTime () >= lastTime ) ;
final boolean forward = ( t > t0 ) ;
Complex N1 = new Complex ( ( n - NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , solution . getValue () , NUMBER_CONSTANT ) ;
while ( ! isOptimal ( tableau ) ) { doIteration ( tableau ) ; }
while ( ! isPhase1Solved ( tableau ) ) { doIteration ( tableau ) ; }
Integer pivotRow = getPivotRow ( pivotCol , tableau ) ;
tableau . discardArtificialVariables () ;
assertTrue ( fitResidualSum < noisyResidualSum ) ;
double [] bounds = empiricalDistribution2 . getUpperBounds () ;
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = microsphereElements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
super ( buildMessage ( Locale.US , pattern , arguments ) , rootCause ) ;
catch ( Exception e ) { throw new MathRuntimeException ( e ) ; }
Math . sqrt ( NUMBER_CONSTANT * Math.PI * x )
double f = ( PI_2 * x * ( n - x ) ) / n ;
double d = ( x - mu ) ;
flipIfWarranted ( deflatedEnd , NUMBER_CONSTANT )
flipIfWarranted ( n , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( BigInteger.ZERO . equals ( den ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
int negativeVarColumn = columnLabels . indexOf ( STRING_CONSTANT ) ;
if ( ! restrictToNonNegative ) { columnLabels . add ( STRING_CONSTANT ) ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ super ( STRING_CONSTANT , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( STRING_CONSTANT , argument ) ; this . argument = new double [] { argument } ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , j , j + NUMBER_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d.length ) ; } }
int value = ( Integer ) decoded . get ( i ) ;
return mapDivide ( getNorm () ) ;
public ArrayRealVector ( ArrayRealVector v ) { data = v.data . clone () ; }
if ( isZero ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
! isZero ( value )
{ this ( values , DEFAULT_ZERO_TOLERANCE ) ; }
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ; }
public void setEntry ( int index , double value ) throws MatrixIndexException { throw unsupported () ; }
{ try { return mapToSelf ( UnivariateRealFunctions.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP1M ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( UnivariateRealFunctions.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
Iterator < Entry > it = sparseIterator () ;
setDefault ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE ) ;
{ this ( values , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
setDefault ( NUMBER_CONSTANT , epsilon ) ;
public OpenMapRealVector ( int dimension ) { this ( dimension , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ this ( NUMBER_CONSTANT , DEFAULT_ZERO_TOLERANCE , NUMBER_CONSTANT ) ; }
{ return new BigReal ( d . divide ( a.d ) ) ; }
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
return new ArrayRealVector ( out ) ;
if ( lcm == Integer.MIN_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return new Solver ( singularValues , getUT () , getV () , getRank () == singularValues.length ) ; }
public void unitize () { throw unsupported () ; }
public RealVector unitVector () { throw unsupported () ; }
public RealVector mapCoshToSelf () { throw unsupported () ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
{ dest.n = source.n ; dest.m1 = source.m1 ; dest.dev = source.dev ; dest.nDev = dest.nDev ; }
{ new LoessInterpolator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ new LoessInterpolator ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , yMin , yMax ) ; }
assertEquals ( NUMBER_CONSTANT , es . solve ( b ) . subtract ( xRef ) . getNorm () , NUMBER_CONSTANT ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
{ super ( interpolator ) ; }
{ super(); }
public BadStepInterpolator ( double [] y , boolean forward ) { super ( y , forward ) ; }
DummyStepInterpolator interpolator = new DummyStepInterpolator ( y , true ) ;
{ interpolator = new DummyStepInterpolator ( yTmp , forward ) ; }
{ interpolator = new DummyStepInterpolator ( y , forward ) ; }
{ handler . handleStep ( new StepInterpolatorWrapper ( interpolator , ode . getDimension () , ode . getParametersDimension () ) , isLast ) ; }
final ParameterizedODEWithJacobians ode
{ super(); setMean ( mean ) ; setStandardDeviation ( sd ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setTolerance ( NUMBER_CONSTANT ) ; }
{ super ( f , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( p < NUMBER_CONSTANT ) { return getMean () ; } else { return Double.MAX_VALUE ; } }
{ ret = - getMean () * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / getMean () ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMean ( mean ) ; }
{ return getUpperDomain ( getSampleSize () , getNumberOfSuccesses () ) ; }
{ return getLowerDomain ( getPopulationSize () , getNumberOfSuccesses () , getSampleSize () ) ; }
{ ret = Beta . regularizedBeta ( getProbabilityOfSuccess () , getNumberOfSuccesses () , x + NUMBER_CONSTANT ) ; }
{ super(); setNumberOfSuccesses ( r ) ; setProbabilityOfSuccess ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getAlpha () * getBeta () ; } else { ret = Double.MAX_VALUE ; }
{ ret = Gamma . regularizedGammaP ( getAlpha () , x / getBeta () ) ; }
{ super(); setAlpha ( alpha ) ; setBeta ( beta ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - Math . pow ( x / getScale () , getShape () ) ) ; }
{ super(); setShape ( alpha ) ; setScale ( beta ) ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedom ( degreesOfFreedom ) ; }
{ return Double.MIN_VALUE * getGamma () . getBeta () ; }
{ return getGamma () . cumulativeProbability ( x ) ; }
if ( x <= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( x >= getNumberOfElements () ) { return NUMBER_CONSTANT ; }
if ( x <= NUMBER_CONSTANT || x > getNumberOfElements () ) { return NUMBER_CONSTANT ; }
{ setNumberOfElements ( numberOfElements ) ; setExponent ( exponent ) ; }
double d = getDenominatorDegreesOfFreedom () ;
{ super(); setNumeratorDegreesOfFreedom ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedom ( denominatorDegreesOfFreedom ) ; }
x < NUMBER_CONSTANT || x > getNumberOfTrials ()
{ return getNumberOfTrials () ; }
{ super(); setNumberOfTrials ( trials ) ; setProbabilityOfSuccess ( p ) ; }
if ( p < NUMBER_CONSTANT ) { ret = getMean () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMean () ; }
if ( p < NUMBER_CONSTANT ) { ret = getMedian () ; } else { ret = Double.MAX_VALUE ; }
if ( p < NUMBER_CONSTANT ) { ret = - Double.MAX_VALUE ; } else { ret = getMedian () ; }
{ super(); setMedian ( median ) ; setScale ( s ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
protected void setDistribution ( ContinuousDistribution distribution ) { this . distribution = distribution ; }
public TDistributionImpl ( double degreesOfFreedom ) { super(); setDegreesOfFreedomInternal ( degreesOfFreedom ) ; }
{ super(); setNumeratorDegreesOfFreedomInternal ( numeratorDegreesOfFreedom ) ; setDenominatorDegreesOfFreedomInternal ( denominatorDegreesOfFreedom ) ; }
{ super(); setShapeInternal ( alpha ) ; setScaleInternal ( beta ) ; }
{ super(); setAlphaInternal ( alpha ) ; setBetaInternal ( beta ) ; }
public ExponentialDistributionImpl ( double mean ) { super(); setMeanInternal ( mean ) ; }
{ super(); setMedianInternal ( median ) ; setScaleInternal ( s ) ; }
final double [] row = aInv [ i ] ;
{ p = interpolator . interpolate ( xval , wyval , zval ) ; Assert . fail ( STRING_CONSTANT ) ; }
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
int length = eliminateZeroMassPoints ( densityPoints , densityValues ) ;
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 < NUMBER_CONSTANT ) { rank = k ; return; }
if ( ak2 == NUMBER_CONSTANT ) { rank = k ; return; }
assertTrue ( MathUtils . equals ( Double.NaN , Double.NaN , NUMBER_CONSTANT ) ) ;
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( residuals.length != observations.length ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , residuals.length , observations.length ) ; }
if ( observations.length != scale . getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , scale . getColumnDimension () ) ; }
if ( observations.length != weights.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , observations.length , weights.length ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
catch ( DuplicateSampleAbscissaException e ) { throw new FunctionEvaluationException ( e , z , e . getPattern () , e . getArguments () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , value , p , q ) ; }
{ super ( STRING_CONSTANT , value , maxIterations ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
final String specifier
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , url ) ; }
if ( r < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , r ) ; }
if ( b.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != getColumnDimension () ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || zval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( pattern , arguments ) ; }
String specifier
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
{ if ( newDegreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newDegreesOfFreedom ) ; } this . degreesOfFreedom = newDegreesOfFreedom ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new MathRuntimeException ( new UnsupportedOperationException () , STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( successes < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , successes ) ; } numberOfSuccesses = successes ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( beta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , beta ) ; } this . scale = beta ; }
{ if ( alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha ) ; } this . shape = alpha ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
public Double getZ () { throw new MathRuntimeException ( STRING_CONSTANT ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( observations.length < NUMBER_CONSTANT ) { throw new OptimizationException ( STRING_CONSTANT , observations.length , NUMBER_CONSTANT ) ; }
if ( e . compareTo ( BigInteger.ZERO ) < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
{ if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; } return k . pow ( e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( e < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , k , e ) ; }
if ( lcm == Long.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( lcm == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , a , b ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREE_MESSAGE , n ) ; }
if ( ! ( f instanceof PolynomialFunction ) ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( f instanceof PolynomialFunction ) { p = ( PolynomialFunction ) f ; } else { throw MathRuntimeException . createIllegalArgumentException ( NON_POLYNOMIAL_FUNCTION_MESSAGE ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( offset > NUMBER_CONSTANT ) { throw new EventException ( STRING_CONSTANT , t ) ; }
{ throw new DerivativeException ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( ( c1 / c2 < NUMBER_CONSTANT ) || ( c2 / c3 < NUMBER_CONSTANT ) ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
{ super ( FAILED_EVALUATION_MESSAGE , new ArrayRealVector ( argument ) ) ; this . argument = argument . clone () ; }
{ super ( FAILED_EVALUATION_MESSAGE , argument ) ; this . argument = new double [] { argument } ; }
{ super ( cause , pattern , arguments ) ; }
{ super ( pattern , arguments ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( target.length != weights.length ) { throw new OptimizationException ( STRING_CONSTANT , target.length , weights.length ) ; }
if ( rows <= cols ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
catch ( InvalidMatrixException ime ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( objective.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , objective.length , rows ) ; }
if ( jacobian.length != rows ) { throw new FunctionEvaluationException ( point , STRING_CONSTANT , jacobian.length , rows ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , pos , size , d.length ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , abscissa , i1 , i2 ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , nRows , nCols ) ; }
{ double d = getDimension () ; if ( d != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , d , n ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
{ super ( pattern , arguments ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( ( minimalIterationCount <= NUMBER_CONSTANT ) || ( maximalIterationCount <= minimalIterationCount ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , minimalIterationCount , maximalIterationCount ) ; } }
{ if ( resultComputed ) { return result ; } else { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw new IntegratorException ( STRING_CONSTANT , minStep , Math . abs ( h ) ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( c.length < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EMPTY_ARRAY_MESSAGE ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ if ( data.length != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , data.length , n ) ; } }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length < pos + size ) { throw MathRuntimeException . createIllegalArgumentException ( NON_FITTING_POSITION_AND_SIZE_MESSAGE , pos , size , d.length ) ; }
if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( NON_BRACKETING_MESSAGE , min , max , yMin , yMax ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( newMean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newMean ) ; } this . mean = newMean ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; } quantile = p ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
{ if ( getDimension () != n ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , getDimension () , n ) ; } }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; }
if ( n == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( omegaCount == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( MISSING_ROOTS_OF_UNITY_MESSAGE ) ; } return isForward ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , o.length ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw MathRuntimeException . createIllegalArgumentException ( NOT_POWER_OF_TWO_MESSAGE , d.length ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } this . exponent = s ; }
{ if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; } this . numberOfElements = n ; }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT , index ) ; }
if ( expansion <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , expansion ) ; }
if ( numElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . numeratorFormat = format ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . denominatorFormat = format ; }
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , name ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new OptimizationException ( STRING_CONSTANT , rows , cols ) ; }
public CardanEulerSingularityException ( boolean isCardan ) { super ( isCardan ? STRING_CONSTANT : STRING_CONSTANT ) ; }
if ( arrayDimension != expected ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , arrayDimension , expected ) ; }
if ( n != startConfiguration.length ) { throw MathRuntimeException . createIllegalArgumentException ( DIMENSION_MISMATCH_MESSAGE , n , startConfiguration.length ) ; }
if ( steps [ j ] == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( EQUAL_VERTICES_MESSAGE , j , j + NUMBER_CONSTANT ) ; }
{ if ( microsphereElements < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , microsphereElements ) ; } this . microsphereElements = elements ; }
{ if ( brightnessExponent < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , brightnessExponent ) ; } this . brightnessExponent = brightnessExponent ; }
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
throw new OptimizationException ( STRING_CONSTANT ) ;
if ( nRows == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( nCols == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( sigma <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sigma ) ; }
if ( mean <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , upper , lower ) ; }
if ( len <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , len ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( Double . isInfinite ( norm2 ) || Double . isNaN ( norm2 ) ) { throw new EstimationException ( STRING_CONSTANT , rows , cols ) ; }
{ if ( sd <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , sd ) ; } standardDeviation = sd ; }
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( STRING_CONSTANT , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; }
{ if ( newBeta <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newBeta ) ; } this . beta = newBeta ; }
{ if ( newAlpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , newAlpha ) ; } this . alpha = newAlpha ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . denominatorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( degreesOfFreedom <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( NON_POSITIVE_DEGREES_OF_FREEDOM_MESSAGE , degreesOfFreedom ) ; } this . numeratorDegreesOfFreedom = degreesOfFreedom ; }
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT , getN () ) ; } }
catch ( InvalidMatrixException e ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ super . verifyIterationCount () ; if ( maximalIterationCount > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f.length ) ; }
{ if ( size < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } sampleSize = size ; }
{ if ( size <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , size ) ; } populationSize = size ; }
{ if ( num < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , num ) ; } numberOfSuccesses = num ; }
final String pattern
if ( xval.length != yval.length ) { throw new MathException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , xval.length , yval.length ) ; }
{ if ( s <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , s ) ; } scale = s ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( optima [ NUMBER_CONSTANT ] == null ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
String pattern
String pattern
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , x0 , x1 ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
catch ( ClassCastException cce ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , nCols ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( vector . getDimension () != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( vector . getDimension () != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , vector . getDimension () , NUMBER_CONSTANT , nCols ) ; }
{ if ( d.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return d [ NUMBER_CONSTANT ] . getField () ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nRows ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTHS_MISMATCH , v.length , nCols ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( NO_ENTRY_MESSAGE , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , b.length , m ) ; }
{ throw new InvalidMatrixException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p ) ; }
throw new NotARotationMatrixException ( STRING_CONSTANT , i - NUMBER_CONSTANT ) ;
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( norm == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( BigInteger.ZERO . equals ( fraction.numerator ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; } return multiply ( fraction . reciprocal () ) ; }
if ( BigInteger.ZERO . equals ( bg ) ) { throw MathRuntimeException . createArithmeticException ( FORBIDDEN_ZERO_DENOMINATOR ) ; }
{ if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } }
if ( y0 * y1 >= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , min , max , y0 , y1 ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ if ( format == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . wholeFormat = format ; }
{ super ( STRING_CONSTANT , dimension1 , dimension2 ) ; this . dimension1 = dimension1 ; this . dimension2 = dimension2 ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FUNCTION_MESSAGE ) ; } }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ if ( trials < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , trials ) ; } numberOfTrials = trials ; }
{ if ( ! isSequence ( lower , initial , upper ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , initial , upper ) ; } }
{ if ( ! resultComputed ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( f [ NUMBER_CONSTANT ] != NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , f [ NUMBER_CONSTANT ] ) ; }
{ if ( realFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . realFormat = realFormat ; }
{ if ( imaginaryFormat == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; } this . imaginaryFormat = imaginaryFormat ; }
if ( imaginaryCharacter == null || imaginaryCharacter . length () == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v . getClass () . getName () ) ; }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( NULL_FRACTION ) ; }
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( OVERFLOW_MESSAGE , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
{ super ( STRING_CONSTANT , rows , columns ) ; }
final String specifier
if ( m <= p ) { throw new EstimationException ( STRING_CONSTANT , m , p ) ; }
catch ( InvalidMatrixException ime ) { throw new EstimationException ( STRING_CONSTANT ) ; }
if ( ++ costEvaluations > maxCostEval ) { throw new EstimationException ( STRING_CONSTANT , maxCostEval ) ; }
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
{ if ( in [ i ] <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , i , in [ i ] ) ; } }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( ( alpha <= NUMBER_CONSTANT ) || ( alpha > NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , obj . getClass () . getName () ) ;
if ( Double . isNaN ( optima [ NUMBER_CONSTANT ] ) ) { throw new OptimizationException ( STRING_CONSTANT , starts ) ; }
{ if ( optimaValues == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optimaValues . clone () ; }
{ if ( optima == null ) { throw MathRuntimeException . createIllegalStateException ( STRING_CONSTANT ) ; } return optima . clone () ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , v.length , columns ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
catch ( ArrayIndexOutOfBoundsException e ) { throw new MatrixIndexException ( STRING_CONSTANT , row , column , getRowDimension () , getColumnDimension () ) ; }
if ( array.length != nRows ) { throw new InvalidMatrixException ( STRING_CONSTANT , array.length , NUMBER_CONSTANT , nRows , NUMBER_CONSTANT ) ; }
if ( array.length != nCols ) { throw new InvalidMatrixException ( STRING_CONSTANT , NUMBER_CONSTANT , array.length , NUMBER_CONSTANT , nCols ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , columns , length ) ; }
catch ( InvalidMatrixException e ) { throw new OptimizationException ( STRING_CONSTANT ) ; }
if ( b . getDimension () != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b . getDimension () , m ) ; }
if ( b.length != m ) { throw MathRuntimeException . createIllegalArgumentException ( VECTOR_LENGTH_MISMATCH_MESSAGE , b.length , m ) ; }
if ( xval.length == NUMBER_CONSTANT || xval [ NUMBER_CONSTANT ] == null ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( sampleSize <= NUMBER_CONSTANT ) { MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT ) ; }
if ( p < NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_POINT , p , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
if ( x0 > x1 ) { throw MathRuntimeException . createIllegalArgumentException ( WRONG_ORDER_ENDPOINTS_MESSAGE , x0 , x1 ) ; }
catch ( IllegalAccessException e2 ) { throw MathRuntimeException . createIllegalArgumentException ( ILLEGAL_ACCESS_MESSAGE , SET_QUANTILE_METHOD_NAME , percentileImpl . getClass () . getName () ) ; }
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , windowSize ) ; } }
if ( n <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , n ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , mean.length , standardDeviation.length ) ; }
{ throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT , i , k , x [ i ] ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + original . getClass () . getSimpleName () ) ; }
throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( sum == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( STRING_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( OUT_OF_RANGE_ROOT_INDEX_MESSAGE , k , NUMBER_CONSTANT , omegaCount - NUMBER_CONSTANT ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
{ if ( lower >= upper ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , lower , upper ) ; } }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
catch ( NoSuchMethodException e1 ) { throw MathRuntimeException . createIllegalArgumentException ( STRING_CONSTANT , percentileImpl . getClass () . getName () ) ; }
if ( parsePosition . getIndex () == NUMBER_CONSTANT ) { throw MathRuntimeException . createParseException ( parsePosition . getErrorIndex () , STRING_CONSTANT , source ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( LocalizedFormats.NOT_STRICTLY_POSITIVE , value ) ; }
public NotPositiveException ( Number value ) { super ( LocalizedFormats.NOT_POSITIVE , value ) ; }
if ( xval.length == NUMBER_CONSTANT || yval.length == NUMBER_CONSTANT || fval.length == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NO_DATA ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( x.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( x.length , NUMBER_CONSTANT , true ) ; }
if ( mean.length != standardDeviation.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , mean.length , standardDeviation.length ) ; }
if ( n < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_UPPER_BOUND , n ) ; }
{ return value . clone () ; }
{ return point . clone () ; }
{ return point . clone () ; }
final double [] scale = new double [ y0.length ] ;
catch ( IllegalStateException ise ) {}
{ super ( specific , LocalizedFormats.NO_DATA , null ) ; }
a [ i ] [ j ] [ k ] = aV [ i + N * j + N2 * k ]
{ return ( value == null ? null : value . clone () ) ; }
{ return ( point == null ? null : point . clone () ) ; }
super ( specific , ( boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED ) , wrong , min ) ;
startConfiguration == null || startConfiguration.length != startPoint.length
{ return ( point == null ? null : point . clone () ) ; }
public GoalType getGoalType () { return goal ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , column , NUMBER_CONSTANT , getColumnDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , row , NUMBER_CONSTANT , getRowDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
{ throw new MatrixIndexException ( STRING_CONSTANT , index , NUMBER_CONSTANT , getDimension () - NUMBER_CONSTANT ) ; }
public void remove () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps + NUMBER_CONSTANT , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ; }
{ super ( STRING_CONSTANT , nSteps , nSteps , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ; }
if ( populationLimit < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ ret = addAndCheck ( a , - b , msg ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
{ return addAndCheck ( a , b , STRING_CONSTANT ) ; }
if ( s < Integer.MIN_VALUE || s > Integer.MAX_VALUE ) { throw new ArithmeticException ( STRING_CONSTANT ) ; }
catch ( ArithmeticException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
{ checkOrder ( val , Order.Direction.INCREASING , true ) ; }
{ this ( wrong , previous , index , MathUtils.Order.Direction.INCREASING , true ) ; }
if ( e [ i + NUMBER_CONSTANT ] == NUMBER_CONSTANT && i >= j ) continue;
arguments = flatten ( args ) . toArray () ;
public void remove () { throw MathRuntimeException . createUnsupportedOperationException ( LocalizedFormats.UNSUPPORTED_OPERATION ) ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( idxStep == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( observations == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( d == NUMBER_CONSTANT ) { throw new ZeroNotAllowedException () ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( fraction == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FRACTION ) ; }
if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
@ Test ( expected = ZeroNotAllowedException . class )
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , xArray.length , yArray.length ) ; }
if ( covarianceMatrix == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_COVARIANCE_MATRIX ) ; }
{ if ( f == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; } }
if ( function == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_FUNCTION ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } incrementAll ( values , NUMBER_CONSTANT , values.length ) ; }
{ if ( values == null ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NULL_INPUT_ARRAY ) ; } return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
final double [] grad = jacobian [ i ] ;
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( cause , argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
{ this ( argument , new DummyLocalizable ( pattern ) , argument ) ; }
step *= Math . max ( NUMBER_CONSTANT , yA / yB )
return Math . sqrt ( sum / v.length ) ;
{ return Math . sqrt ( getChiSquare () / rows ) ; }
double wi = Math . sqrt ( residualsWeights [ i ] ) ;
{ this . h = Math . abs ( h ) ; this . handler = handler ; reset () ; }
double invR3 = NUMBER_CONSTANT / ( r2 * Math . sqrt ( r2 ) ) ;
double expected = Math . random () ;
double expected = Math . random () ;
return Math . sqrt ( sum2 ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double t = Math . abs ( rValues . getEntry ( i , j ) ) / stdErrors . getEntry ( i , j ) ;
assertEquals ( n + STRING_CONSTANT + degree + STRING_CONSTANT + i , reference , result , NUMBER_CONSTANT * ( NUMBER_CONSTANT + Math . abs ( reference ) ) ) ;
NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( ( x - mean ) / ( standardDeviation * Math . sqrt ( NUMBER_CONSTANT ) ) ) )
return Math . sqrt ( dx * dx + dy * dy ) ;
assertTrue ( Math . sqrt ( m.length ) * estimator . getRMS ( problem ) > NUMBER_CONSTANT ) ;
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
assertTrue ( Math . sqrt ( problem.target.length ) * optimizer . getRMS () > NUMBER_CONSTANT ) ;
{ sumLog += Math . log ( values [ i ] ) ; }
{ value += Math . log ( d ) ; n ++ ; }
{ ret = - mean * Math . log ( NUMBER_CONSTANT - p ) ; }
{ ret = NUMBER_CONSTANT - Math . exp ( - x / mean ) ; }
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } return Math . exp ( - x / mean ) / mean ; }
{ sum += Math . abs ( p1 [ i ] - p2 [ i ] ) ; }
{ return ( Math . exp ( x ) - Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
float factor = ( float ) Math . pow ( NUMBER_CONSTANT , scale ) * sign ;
{ return Math . log ( x ) / Math . log ( base ) ; }
return Math . abs ( u ) + Math . abs ( v ) ;
return Math . abs ( u ) + Math . abs ( v ) ;
final boolean isEqual = Math . abs ( xInt - yInt ) <= maxUlps ;
{ return equalsIncludingNaN ( x , y ) || ( Math . abs ( y - x ) <= eps ) ; }
{ return equals ( x , y , NUMBER_CONSTANT ) || Math . abs ( y - x ) <= eps ; }
{ return ( Math . exp ( x ) + Math . exp ( - x ) ) / NUMBER_CONSTANT ; }
return Math . floor ( result + NUMBER_CONSTANT ) ;
double sigma = NUMBER_CONSTANT + Math . random () ;
double mu = Math . random () ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double x = NUMBER_CONSTANT / Math . sqrt ( NUMBER_CONSTANT ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , true ) , scaling_coefficient ) ; }
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ;
double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( n ) ;
{ double scaling_coefficient = NUMBER_CONSTANT / Math . sqrt ( f.length ) ; return scaleArray ( fft ( f , false ) , scaling_coefficient ) ; }
{ return Math . atan2 ( getImaginary () , getReal () ) ; }
Math . abs ( c ) < Math . abs ( d )
Math . abs ( dt ) <= Math . ulp ( stepStart )
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
assertEquals ( Math.PI , x , accuracy ) ;
{ double x = UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; assertEquals ( Math.PI , x , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
Assert . assertEquals ( STRING_CONSTANT , expected , result , Math . ulp ( NUMBER_CONSTANT ) ) ;
{ singularValues [ i ] = Math . sqrt ( Math . abs ( singularValues [ i ] ) ) ; }
{ result [ i ] = Math . sqrt ( sigma * betaVariance [ i ] [ i ] ) ; }
double fpos = Math . floor ( pos ) ;
final double dist = Math . abs ( z - x [ i ] ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
setMaxGrowth ( Math . pow ( NUMBER_CONSTANT , - exp ) ) ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double tolerance = Math . max ( relativeAccuracy * z . abs () , absoluteAccuracy ) ;
double sqrt = Math . sqrt ( c [ ir ] [ ir ] ) ;
int k = Math . max ( N , seed.length )
{ values [ i ] = Math . pow ( values [ i ] , d ) ; }
double t = Math . abs ( t ( m , mu , v , n ) ) ;
{ return ( m - mu ) / Math . sqrt ( v / n ) ; }
{ stepStart = Double.NaN ; stepSize = Math . sqrt ( minStep * maxStep ) ; }
{ assertEquals ( msg , expected , actual , Math . abs ( tolerance * actual ) ) ; }
Gamma . digamma ( Math . pow ( NUMBER_CONSTANT , - n ) )
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
double absAi = Math . abs ( coefficients [ i ] ) ;
{ ret = median + scale * Math . tan ( Math.PI * ( p - NUMBER_CONSTANT ) ) ; }
return ( NUMBER_CONSTANT / Math.PI ) * ( scale / ( dev * dev + scale * scale ) ) ;
Double pi = Double . valueOf ( Math.PI ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
final int pEnd = Math . min ( pStart + BLOCK_SIZE , rows ) ;
{ stdDev [ i ] = Math . sqrt ( matrix . getEntry ( i , i ) ) ; }
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
( int ) ( Math . abs ( NUMBER_CONSTANT * x + NUMBER_CONSTANT * y ) ) % NUMBER_CONSTANT == NUMBER_CONSTANT
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( Math . abs ( walk ) < NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( NUMBER_CONSTANT ) ) , sample . getStandardDeviation () , NUMBER_CONSTANT ) ;
if ( value != i ) { res += Math . abs ( value - i ) ; }
{ value += NUMBER_CONSTANT / Math . pow ( k , m ) ; }
return ( NUMBER_CONSTANT / Math . pow ( x , exponent ) ) / generalizedHarmonic ( numberOfElements , exponent ) ;
widthSufficient = Math . min ( lowerBinMass , upperBinMass ) * sampleSize >= minExpectedCount ;
return Math . sqrt ( criterion / wm.length ) ;
double factor = - Math . sqrt ( wm . getWeight () ) ;
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
public double end () { return Math . sqrt ( sum ) ; }
{ return Math . atan2 ( x , y ) ; }
{ return Math . pow ( x , y ) ; }
accum3 /= variance * Math . sqrt ( variance ) ;
( n0 * moment.m3 ) / ( ( n0 - NUMBER_CONSTANT ) * ( n0 - NUMBER_CONSTANT ) * Math . sqrt ( variance ) * variance )
assertEquals ( Math . exp ( NUMBER_CONSTANT ) , u . getGeometricMean () , NUMBER_CONSTANT ) ;
{ return Math . asin ( z / getNorm () ) ; }
{ return Math . atan2 ( y , x ) ; }
double x = Math . random () ;
assertTrue ( Math . abs ( generated [ NUMBER_CONSTANT ] - NUMBER_CONSTANT ) > NUMBER_CONSTANT ) ;
{ return new HarmonicFunction ( a * omega , omega , phi + Math.PI / NUMBER_CONSTANT ) ; }
{ return a * Math . cos ( omega * x + phi ) ; }
Complex sqrtz = ComplexUtils . polar2Complex ( Math . sqrt ( r ) , theta / NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new Complex ( Math . acos ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) , Complex.ZERO . acos () , NUMBER_CONSTANT ) ;
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
long index = Math . round ( ( Math . random () ) * testArray.length ) ;
{ length = list . size () - Math . max ( NUMBER_CONSTANT , list . size () - windowSize ) ; }
double c = t2 + NUMBER_CONSTANT * ( Math . exp ( - NUMBER_CONSTANT * t2 ) - NUMBER_CONSTANT ) ;
double t = NUMBER_CONSTANT * Math.PI ;
double t = NUMBER_CONSTANT * Math.PI ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , e1 . distanceFrom ( e2 ) , NUMBER_CONSTANT ) ;
error = Math . sqrt ( error / scale.length ) * errfac [ currentDegree - NUMBER_CONSTANT ] ;
Math . log ( x ) - NUMBER_CONSTANT / x
double expected = Math . random () ;
double expected = Math . random () ;
final double power = Math . pow ( normalizedAbscissa , order ) ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , Vector3D . distance ( v1 , v2 ) , NUMBER_CONSTANT ) ;
assertEquals ( Math . sqrt ( NUMBER_CONSTANT ) , new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getNorm () , NUMBER_CONSTANT ) ;
{ return Math . exp ( sumOfLogs . getResult () / sumOfLogs . getN () ) ; }
{ Assert . assertEquals ( Math . pow ( NUMBER_CONSTANT , x ) , f . value ( x ) , NUMBER_CONSTANT ) ; }
this . convergence = Math . abs ( convergence ) ;
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
double fl = Math . floor ( x ) ;
{ return cumulativeProbability ( ( int ) Math . floor ( x ) ) ; }
{ assertTrue ( Math . abs ( value - reference ) < NUMBER_CONSTANT ) ; }
{ double absError = Math . abs ( expected ) * relativeError ; Assert . assertEquals ( msg , expected , actual , absError ) ; }
return - mean * Math . log ( unif ) ;
double sigma = Math . sqrt ( mean ) ;
if ( Math . abs ( x1 - x0 ) <= absoluteAccuracy ) { setResult ( x1 , i ) ; return x1 ; }
double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ;
{ double delta = Math . abs ( getEntry ( i ) - v [ i ] ) ; max += delta ; }
return Math . sqrt ( res ) ;
return Math . sqrt ( res ) ;
{ return Math . abs ( value ) < epsilon ; }
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
{ assertTrue ( Math . abs ( value - expected ) < NUMBER_CONSTANT ) ; }
new Fraction ( Math.PI , NUMBER_CONSTANT )
{ new Fraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
max = Math . max ( max , Math . abs ( delta ) ) ;
max = Math . max ( max , Math . abs ( delta ) ) ;
{ final double delta = data [ i ] - v [ i ] ; sum += Math . abs ( delta ) ; }
sum += Math . abs ( delta ) ;
return Math . sqrt ( sum ) ;
return Math . sqrt ( sum ) ;
for ( double a : data ) { max = Math . max ( max , Math . abs ( a ) ) ; }
for ( double a : data ) { sum += Math . abs ( a ) ; }
return Math . sqrt ( sum ) ;
{ data [ i ] = Math . ulp ( data [ i ] ) ; }
{ data [ i ] = Math . signum ( data [ i ] ) ; }
{ data [ i ] = Math . rint ( data [ i ] ) ; }
{ data [ i ] = Math . floor ( data [ i ] ) ; }
{ data [ i ] = Math . ceil ( data [ i ] ) ; }
{ data [ i ] = Math . cbrt ( data [ i ] ) ; }
{ data [ i ] = Math . sqrt ( data [ i ] ) ; }
{ data [ i ] = Math . abs ( data [ i ] ) ; }
{ data [ i ] = Math . atan ( data [ i ] ) ; }
{ data [ i ] = Math . asin ( data [ i ] ) ; }
{ data [ i ] = Math . acos ( data [ i ] ) ; }
{ data [ i ] = Math . tan ( data [ i ] ) ; }
{ data [ i ] = Math . sin ( data [ i ] ) ; }
{ data [ i ] = Math . cos ( data [ i ] ) ; }
{ data [ i ] = Math . tanh ( data [ i ] ) ; }
{ data [ i ] = Math . sinh ( data [ i ] ) ; }
{ data [ i ] = Math . cosh ( data [ i ] ) ; }
{ data [ i ] = Math . log1p ( data [ i ] ) ; }
{ data [ i ] = Math . log10 ( data [ i ] ) ; }
{ data [ i ] = Math . log ( data [ i ] ) ; }
{ data [ i ] = Math . expm1 ( data [ i ] ) ; }
{ data [ i ] = Math . exp ( data [ i ] ) ; }
{ data [ i ] = Math . pow ( data [ i ] , d ) ; }
i < Math . min ( rows , columns )
final double inv = NUMBER_CONSTANT / Math . sqrt ( norm2 ) ;
{ if ( Math . abs ( value - searchArray [ i ] ) < tolerance ) { found = true ; } i ++ ; }
Math . abs ( dt ) <= Math . ulp ( stepStart )
this . step = Math . abs ( step ) ;
final int p = Math . min ( m , n ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double range = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ return ( int ) Math . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
normal . setStandardDeviation ( Math . sqrt ( p ) ) ;
if ( unequalCounts ) { weight = Math . sqrt ( ( double ) countSum1 / ( double ) countSum2 ) ; }
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double s17 = Math . sqrt ( NUMBER_CONSTANT ) ;
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
{ norm = Math . max ( norm , Math . abs ( e . getValue () ) ) ; }
{ norm += Math . abs ( e . getValue () ) ; }
return Math . sqrt ( sum ) ;
return Math . sqrt ( d ) ;
return Math . sqrt ( dx * dx + dy * dy ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getM () ) * rms , NUMBER_CONSTANT ) ;
return a * Math . cos ( omega * x + phi ) ;
final double f = NUMBER_CONSTANT / Math . sqrt ( normSq ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double scalAbsoluteTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
assertTrue ( Math . abs ( h ) < minStep ) ;
double maxStep = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) ;
{ if ( getN () > NUMBER_CONSTANT ) { stdDev = Math . sqrt ( getVariance () ) ; } else { stdDev = NUMBER_CONSTANT ; } }
double [] y0 = { Math . sin ( a ) , Math . cos ( a ) } ;
new double [] { - Math . sqrt ( NUMBER_CONSTANT ) , - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT }
{ new BigReal ( NUMBER_CONSTANT ) , BigReal.ONE , BigReal.ZERO , new BigReal ( NUMBER_CONSTANT ) , new BigReal ( Math.PI ) , new BigReal ( - NUMBER_CONSTANT ) }
if ( deltaNorm > NUMBER_CONSTANT * Math . max ( NUMBER_CONSTANT , initialNorm ) ) { return false ; }
assertEquals ( Math.PI , MathUtils . scalb ( Math.PI , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
MathUtils . hash ( new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
assertEquals ( i + STRING_CONSTANT , Math . log ( factorial ( i ) ) , MathUtils . factorialLog ( i ) , NUMBER_CONSTANT ) ;
new double [] { MathUtils . nextAfter ( MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT ) }
MathUtils . equals ( new double [] { NUMBER_CONSTANT } , new double [] { MathUtils . nextAfter ( NUMBER_CONSTANT , NUMBER_CONSTANT ) } )
ret = Math . exp ( p1 + p2 - p3 ) ;
{ return Math . min ( k , m ) ; }
{ return Math . max ( NUMBER_CONSTANT , m - ( n - k ) ) ; }
{ return NUMBER_CONSTANT * ( NUMBER_CONSTANT - distribution . cumulativeProbability ( Math . abs ( getSlope () ) / getSlopeStdErr () ) ) ; }
{ return Math . sqrt ( getMeanSquareError () / sumXX ) ; }
double result = Math . sqrt ( getRSquare () ) ;
if ( Math . abs ( sumXX ) < NUMBER_CONSTANT * Double.MIN_VALUE ) { return Double.NaN ; }
@ Override public double value ( double d ) { return Math . ulp ( d ) ; }
@ Override public double value ( double d ) { return Math . signum ( d ) ; }
@ Override public double value ( double d ) { return Math . rint ( d ) ; }
@ Override public double value ( double d ) { return Math . cosh ( d ) ; }
@ Override public double value ( double d ) { return Math . acos ( d ) ; }
@ Override public double value ( double d ) { return Math . cos ( d ) ; }
@ Override public double value ( double d ) { return Math . log10 ( d ) ; }
@ Override public double value ( double d ) { return Math . log ( d ) ; }
@ Override public double value ( double d ) { return Math . floor ( d ) ; }
@ Override public double value ( double d ) { return Math . ceil ( d ) ; }
@ Override public double value ( double d ) { return Math . cbrt ( d ) ; }
@ Override public double value ( double d ) { return Math . tanh ( d ) ; }
@ Override public double value ( double d ) { return Math . tan ( d ) ; }
@ Override public double value ( double d ) { return Math . atan ( d ) ; }
@ Override public double value ( double d ) { return Math . asin ( d ) ; }
@ Override public double value ( double d ) { return Math . expm1 ( d ) ; }
@ Override public double value ( double d ) { return Math . exp ( d ) ; }
@ Override public double value ( double d ) { return Math . sinh ( d ) ; }
@ Override public double value ( double d ) { return Math . sqrt ( d ) ; }
@ Override public double value ( double d ) { return Math . sin ( d ) ; }
@ Override public double value ( double d ) { return Math . abs ( d ) ; }
new BigFraction ( Math.PI , NUMBER_CONSTANT )
{ new BigFraction ( ( NUMBER_CONSTANT + Math . sqrt ( NUMBER_CONSTANT ) ) / NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
double step = Math . abs ( pb . getFinalTime () - pb . getInitialTime () ) * NUMBER_CONSTANT ;
FastFourierTransformer . scaleArray ( x , Math . sqrt ( NUMBER_CONSTANT * ( x.length - NUMBER_CONSTANT ) ) ) ;
double c = Math . exp ( t0 - t ) ;
assertEquals ( NUMBER_CONSTANT , Math . sqrt ( circle . getN () ) * optimizer . getRMS () , NUMBER_CONSTANT ) ;
{ product *= Math . pow ( values [ i ] , weights [ i ] ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / Math . sqrt ( x2.length ) ) ;
assertNotSame ( v , new ArrayRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( n - NUMBER_CONSTANT ) ) ;
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / ( f.length - NUMBER_CONSTANT ) ) ;
if ( Math . abs ( fn1 - fn ) <= threshold ) return o ;
assertNotSame ( v , new OpenMapRealVector ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT + Math . ulp ( NUMBER_CONSTANT ) } ) ) ;
Math . sin ( i * Math.PI / n ) * ( f [ i ] + f [ n - i ] )
double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / n ) ;
{ double scaling_coefficient = Math . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , scaling_coefficient ) ; }
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
double absTolerance = Math . pow ( NUMBER_CONSTANT , i ) ;
Math . abs ( max - min ) <= absoluteAccuracy
assertEquals ( ci , l40 [ i ] , Math . abs ( ci ) * NUMBER_CONSTANT ) ;
Math . abs ( Tk . value ( x ) ) < ( NUMBER_CONSTANT + NUMBER_CONSTANT )
double tmp2 = Math . exp ( tmp1 ) ;
double tmp2 = Math . sqrt ( tmpSquare ) ;
assertEquals ( mi , vi , paramsAccuracy * ( NUMBER_CONSTANT + Math . abs ( mi ) ) ) ;
assertEquals ( theoreticalMinCost , Math . sqrt ( m ) * rms , threshold ) ;
{ assertTrue ( Math . abs ( result [ i ] - y [ i ] ) < NUMBER_CONSTANT ) ; }
final int capacity = ( int ) Math . ceil ( expectedSize / LOAD_FACTOR ) ;
{ return Math . sqrt ( variance . evaluate ( values , mean ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , mean , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values , begin , length ) ) ; }
{ return Math . sqrt ( variance . evaluate ( values ) ) ; }
@ Override public double getResult () { return Math . sqrt ( variance . getResult () ) ; }
minor < Math . min ( m , n )
j < Math . min ( i + NUMBER_CONSTANT , n )
int row = Math . min ( m , n ) - NUMBER_CONSTANT
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException e ) { assertTrue ( ( ! solvable ) && ( degree > NUMBER_CONSTANT ) ) ; }
RealConvergenceChecker convergenceChecker
public GoalType getGoalType () { return optimizationGoal ; }
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
optimizer . setMaxIterations ( NUMBER_CONSTANT ) ;
catch ( OptimizationException ee ) {}
assertTrue ( Double . isNaN ( sum . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public SumOfSquares () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( sumSq . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Sum () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
assertTrue ( Double . isNaN ( statistic . getResult () ) ) ;
@ Override public void clear () { value = Double.NaN ; n = NUMBER_CONSTANT ; }
public Product () { n = NUMBER_CONSTANT ; value = Double.NaN ; }
assertTrue ( Double . isNaN ( product . getResult () ) ) ;
{ return NUMBER_CONSTANT + ( sign < < NUMBER_CONSTANT ) + ( nans < < NUMBER_CONSTANT ) + exp + mant . hashCode () ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
@ Override protected int getNumberOfRegressors () { return x [ NUMBER_CONSTANT ] . length ; }
final boolean isMinim = ( getGoalType () == GoalType.MINIMIZE ) ;
public Well44497b ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well44497b ( int seed ) { super ( seed ) ; }
public Well44497b () {}
public Well19937c ( long seed ) { super ( seed ) ; }
{ super ( seed ) ; }
public Well19937c ( int seed ) { super ( seed ) ; }
public Well19937c () {}
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
v [ indexRm2 ] &= mp ;
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , wrong , expected ) ; dimension = expected ; }
if ( v.length != rows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , rows ) ; }
if ( v.length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , columns ) ; }
if ( length != columns ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.DIFFERENT_ROWS_LENGTHS , columns , length ) ; }
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
dist . setMean ( NUMBER_CONSTANT ) ;
{ this ( p , new NormalDistributionImpl () ) ; }
distribution . setDegreesOfFreedom ( df ) ;
{ distribution . setDegreesOfFreedom ( expected.length - NUMBER_CONSTANT ) ; return NUMBER_CONSTANT - distribution . cumulativeProbability ( chiSquare ( expected , observed ) ) ; }
double density ( Double x ) ;
( FastMath . max ( FastMath . abs ( mij ) , Math . abs ( mji ) ) * eps )
protected AbstractContinuousDistribution () { super(); }
org.apache.commons.math.distribution.FDistributionImpl fd = new org.apache.commons.math.distribution.FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( alpha >= NUMBER_CONSTANT || alpha <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUND_SIGNIFICANCE_LEVEL , alpha , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
if ( n > NUMBER_CONSTANT ) { distribution . setDegreesOfFreedom ( n - NUMBER_CONSTANT ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) private RandomAdaptor () {}
return a . dotrap ( DfpField.FLAG_INVALID , STRING_CONSTANT , a , a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.QNAN ) ) ;
if ( ia > NUMBER_CONSTANT ) { return a . newInstance ( ( byte ) NUMBER_CONSTANT , ( byte ) Dfp.INFINITE ) ; }
protected AbstractIntegerDistribution () { super(); }
public int [] getSizes () { return Arrays . copyOf ( size , dimension ) ; }
this . size = Arrays . copyOf ( size , dimension ) ;
public int [] getCounts () { return Arrays . copyOf ( counter , dimension ) ; }
final double [] d = Arrays . copyOf ( direc [ i ] , n ) ;
AbstractMultipleLinearRegression regression = ( AbstractMultipleLinearRegression ) createRegression () ;
{ try { ExponentialDistribution distribution = new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; } catch ( NotStrictlyPositiveException e ) {} }
{ realVectorFormat . parseObject ( STRING_CONSTANT ) ; }
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { MatrixUtils . createRealIdentityMatrix ( NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
zb += ( za - temp2 ) ;
if ( v . getDimension () != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nRows ) ; }
if ( v.length != nRows ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nRows ) ; }
if ( v . getDimension () != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v . getDimension () , nCols ) ; }
if ( v.length != nCols ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.VECTOR_LENGTH_MISMATCH , v.length , nCols ) ; }
{ setQuantile ( p ) ; }
if ( isDefaultValue ( norm ) ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
{ this ( n , DEFAULT_RHO , DEFAULT_KHI , DEFAULT_GAMMA , DEFAULT_SIGMA ) ; }
public MultiDirectionalSimplex ( final int n ) { this ( n , DEFAULT_KHI , DEFAULT_GAMMA ) ; }
catch ( FunctionEvaluationException ee ) { assertTrue ( shouldFail ) ; }
try { es . getInverse () ; fail ( STRING_CONSTANT ) ; } catch ( InvalidMatrixException ime ) {}
catch ( FunctionEvaluationException oe ) {}
{ super ( LocalizedFormats.DIMENSIONS_MISMATCH_SIMPLE , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
catch ( InvalidMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotPositiveDefiniteMatrixException . class )
@ Test ( expected = NotSymmetricMatrixException . class )
catch ( InvalidMatrixException ime ) {}
catch ( InvalidMatrixException ime ) {}
catch ( NotPositiveDefiniteMatrixException e ) { fail ( STRING_CONSTANT ) ; }
public LaguerreSolver () { super ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; p = null ; }
{ return MessageFactory . buildMessage ( locale , pattern , LocalizedFormats.USER_EXCEPTION , arguments ) ; }
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
assertEquals ( pattern , ex . getLocalizablePattern () ) ;
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( FunctionEvaluationException fe ) { assertTrue ( exceptionExpected ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
try { finalizeStep () ; } catch ( DerivativeException e ) { throw MathRuntimeException . createIOException ( e ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
{ try { return mapToSelf ( ComposableFunction.ULP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TANH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.TAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SQRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SINH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.SIGNUM ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.RINT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
try { return mapToSelf ( BinaryFunction.MULTIPLY . fix1stArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.LOG1P ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG10 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.LOG ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.INVERT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.FLOOR ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXPM1 ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.EXP ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
try { return mapToSelf ( BinaryFunction.DIVIDE . fix2ndArgument ( d ) ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; }
{ try { return mapToSelf ( ComposableFunction.COSH ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.COS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CEIL ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.CBRT ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ATAN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ASIN ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ACOS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
{ try { return mapToSelf ( ComposableFunction.ABS ) ; } catch ( FunctionEvaluationException e ) { throw new IllegalArgumentException ( e ) ; } }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
catch ( DerivativeException de ) { fail ( STRING_CONSTANT ) ; }
{ return x + y ; }
Circle circle = new Circle () ;
Circle circle = new Circle () ;
Circle circle = new Circle () ;
ConvergenceException ex
assertTrue ( handler . getMaximalValueError () < NUMBER_CONSTANT ) ;
public RealVector mapPowToSelf ( double d ) { return mapToSelf ( BinaryFunction.POW . fix2ndArgument ( d ) ) ; }
{ if ( d != NUMBER_CONSTANT ) { return mapToSelf ( BinaryFunction.ADD . fix1stArgument ( d ) ) ; } return this ; }
{ if ( ++ iterations > maxIterations ) { throw new OptimizationException ( new MaxIterationsExceededException ( maxIterations ) ) ; } }
throw new MaxIterationsExceededException ( maximalIterationCount ) ;
{ throw new MaxIterationsExceededException ( maxIterations ) ; }
if ( n >= maxIterations ) { throw new MaxIterationsExceededException ( maxIterations , LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION , x ) ; }
if ( dimension == NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.TOO_LARGE_CUTOFF_SINGULAR_VALUE , minSingularValue , singularValues [ NUMBER_CONSTANT ] ) ; }
{ return solve ( f , Double.NaN , Double.NaN , startValue ) ; }
StringBuffer buffer
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer out = new StringBuffer ( msg ) ;
StringBuffer messageBuffer = new StringBuffer () ;
StringBuffer s = new StringBuffer () ;
final StringBuffer buff = new StringBuffer ( STRING_CONSTANT ) ;
StringBuffer msgBuffer = new StringBuffer () ;
StringBuffer sb = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
StringBuffer outBuffer = new StringBuffer () ;
Assert . assertEquals ( FastMath.PI , solver . solve ( f , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , solver . getAbsoluteAccuracy () ) ;
result = solver . solve ( f , min , max ) ;
{ this ( new SimpleVectorialValueChecker () , Integer.MAX_VALUE ) ; }
{ this ( new SimpleScalarValueChecker () , Integer.MAX_VALUE ) ; }
@ Test ( expected = java.lang.IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = java.lang.IllegalArgumentException . class )
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
if ( p <= NUMBER_CONSTANT || p > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
if ( ( p > NUMBER_CONSTANT ) || ( p <= NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.OUT_OF_BOUNDS_QUANTILE_VALUE , p ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
if ( x1 < x0 ) { throw new NumberIsTooSmallException ( LocalizedFormats.LOWER_ENDPOINT_ABOVE_UPPER_ENDPOINT , x0 , x1 , true ) ; }
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new BlockRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new BlockRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ if ( a < NUMBER_CONSTANT ) { ret = a - b ; } else { throw new ArithmeticException ( msg ) ; } }
try { optimizer . getOptima () ; fail ( STRING_CONSTANT ) ; } catch ( IllegalStateException ise ) {}
{ if ( numerator == Integer.MIN_VALUE ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.OVERFLOW_IN_FRACTION , numerator , denominator ) ; } return new Fraction ( - numerator , denominator ) ; }
catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
{ try { UnivariateRealSolverUtils . solve ( sin , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {} }
{ try { UnivariateRealSolverUtils . solve ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail () ; } catch ( IllegalArgumentException ex ) {} }
try { m . preMultiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( createSparseMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( createSparseMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
if ( begin + length > values.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.SUBARRAY_ENDS_AFTER_ARRAY_END ) ; }
try { m . preMultiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . operate ( testVector ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . multiply ( new Array2DRowRealMatrix ( bigSingular ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { m . subtract ( new Array2DRowRealMatrix ( testData2 ) ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException ex ) {}
{ NumberFormat f = getDefaultNumberFormat ( locale ) ; return new ComplexFormat ( f ) ; }
public ComplexFormat ( String imaginaryCharacter ) { this ( imaginaryCharacter , getDefaultNumberFormat () ) ; }
{ return new Vector3DFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
if ( ! found ) { Assert . fail ( msg + STRING_CONSTANT + ComplexFormat . formatComplex ( z ) ) ; }
formatDouble ( vector . getEntry ( i ) , format , toAppendTo , pos ) ;
{ return new RealVectorFormat ( getDefaultNumberFormat ( locale ) ) ; }
{ this ( prefix , suffix , separator , getDefaultNumberFormat () ) ; }
Class type
{ this ( imaginaryCharacter , format , ( NumberFormat ) format . clone () ) ; }
if ( normProduct == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( threshold == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.ZERO_NORM ) ; }
if ( s == NUMBER_CONSTANT ) { throw MathRuntimeException . createArithmeticException ( LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR ) ; }
throw MathRuntimeException . createInternalError ( null ) ;
throw MathRuntimeException . createInternalError ( null ) ;
try { alg = MessageDigest . getInstance ( STRING_CONSTANT ) ; } catch ( NoSuchAlgorithmException ex ) { throw MathRuntimeException . createInternalError ( ex ) ; }
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
{ super . addStepHandler ( handler ) ; denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ; initializeArrays () ; }
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
denseOutput = requiresDenseOutput () || ( ! eventsHandlersManager . isEmpty () ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
stepStart = acceptStep ( interpolator , stepHandlers , y , yDot , t ) ;
final double temp = sinEpsA * NUMBER_CONSTANT ;
final double tmp = hiPrec [ NUMBER_CONSTANT ] * NUMBER_CONSTANT ;
if ( x >= NUMBER_CONSTANT || x <= - NUMBER_CONSTANT ) { return x ; }
if ( y >= NUMBER_CONSTANT || y <= - NUMBER_CONSTANT ) { return pow ( - x , y ) ; }
final double epsilon = xa - EIGHTHES [ idx ] ;
final double epsilon = xa - EIGHTHES [ idx ] ;
final boolean fatal = false ;
final boolean fatal = true ;
if ( invx == NUMBER_CONSTANT ) { if ( x > NUMBER_CONSTANT ) { return y ; } else { return getSign ( y ) * Math.PI ; } }
if ( xa == NUMBER_CONSTANT ) { return leftPlane ? getSign ( xa ) * Math.PI : xa ; }
@ Test
{ return Math . round ( x ) ; }
final double [] d = copyOf ( direc [ i ] , n ) ;
public int [] getSizes () { return copyOf ( size , dimension ) ; }
this . size = copyOf ( size , dimension ) ;
public int [] getCounts () { return copyOf ( counter , dimension ) ; }
{ return oneWayAnova . anovaTest ( categoryData , alpha ) ; }
{ return oneWayAnova . anovaPValue ( categoryData ) ; }
{ return oneWayAnova . anovaFValue ( categoryData ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 , alpha ) ; }
{ return unknownDistributionChiSquareTest . chiSquareTestDataSetsComparison ( observed1 , observed2 ) ; }
{ return unknownDistributionChiSquareTest . chiSquareDataSetsComparison ( observed1 , observed2 ) ; }
{ return chiSquareTest . chiSquareTest ( counts ) ; }
{ return chiSquareTest . chiSquareTest ( counts , alpha ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed ) ; }
{ return chiSquareTest . chiSquareTest ( expected , observed , alpha ) ; }
{ return chiSquareTest . chiSquare ( counts ) ; }
{ return chiSquareTest . chiSquare ( expected , observed ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . tTest ( sampleStats1 , sampleStats2 , alpha ) ; }
{ return tTest . tTest ( sample1 , sample2 ) ; }
{ return tTest . tTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . tTest ( mu , sampleStats ) ; }
{ return tTest . tTest ( mu , sampleStats , alpha ) ; }
{ return tTest . tTest ( mu , sample ) ; }
{ return tTest . tTest ( mu , sample , alpha ) ; }
{ return tTest . t ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . t ( sample1 , sample2 ) ; }
{ return tTest . t ( mu , sampleStats ) ; }
{ return tTest . t ( mu , observed ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 ) ; }
{ return tTest . pairedTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . pairedT ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 ) ; }
{ return tTest . homoscedasticTTest ( sample1 , sample2 , alpha ) ; }
{ return tTest . homoscedasticT ( sampleStats1 , sampleStats2 ) ; }
{ return tTest . homoscedasticT ( sample1 , sample2 ) ; }
protected TestUtils () { super(); }
return ( double ) y ;
RealMatrix arzneg = selectColumns ( arz , Arrays . copyOf ( arReverseIndex , mu ) ) ;
double numer = ( bits & NUMBER_CONSTANT ) ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
statesInitialized = false ;
ParametricRealFunction sif = new SimpleInverseFunction () ;
ParametricRealFunction sif = new SimpleInverseFunction () ;
final ParametricRealFunction f
final ParametricRealFunction f
final ParametricRealFunction f
final double g = Gaussian . this . value ( x ) ;
{ fitter = new CurveFitter ( optimizer ) ; }
final boolean fatal = false ;
{ super ( null , specific , LocalizedFormats.ILLEGAL_STATE , args ) ; }
{ super ( null , null , specific , general , args ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , new Integer ( position ) ) ; }
{ assertEquals ( reference , p . toString () ) ; }
{ assertEquals ( reference , p . toString () ) ; }
assertEquals ( reference , p . multiply ( q ) . toString () ) ;
this . n = n ;
return isMinimize ? penalty : - penalty ;
if ( boundaries == null ) return true ;
return _isMinimize ? penalty : - penalty ;
if ( _boundaries == null ) return true ;
final FitnessFunction fitfun = new FitnessFunction ( boundaries , isMinimize ) ;
if ( result == - NUMBER_CONSTANT ) { throw new MathArithmeticException ( STRING_CONSTANT ) ; }
catch ( IOException ioe ) { assertEquals ( NUMBER_CONSTANT , ioe . getMessage () . length () ) ; }
super ( specific , LocalizedFormats.SAME_SIGN_AT_ENDPOINTS , lo , hi , fLo , fHi , args ) ;
{ this ( null , lo , hi , fLo , fHi ) ; }
{ super ( specific , LocalizedFormats.NO_DATA , ( Object [] ) null ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_LARGE : LocalizedFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED , wrong , max ) ;
{ this ( null , wrong , max , boundIsAllowed ) ; }
{ super ( specific , LocalizedFormats.OUT_OF_RANGE_SIMPLE , wrong , lo , hi ) ; this . lo = lo ; this . hi = hi ; }
{ this ( null , wrong , lo , hi ) ; }
super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ;
{ this ( null , wrong , expected ) ; }
{ this ( cause , LocalizedFormats.USER_EXCEPTION ) ; }
{ super ( specific , LocalizedFormats.DIMENSIONS_MISMATCH , wrong , expected ) ; dimension = expected ; }
public ZeroException ( Localizable specific ) { super ( specific , LocalizedFormats.ZERO_NOT_ALLOWED , NUMBER_CONSTANT ) ; }
super ( specific , boundIsAllowed ? LocalizedFormats.NUMBER_TOO_SMALL : LocalizedFormats.NUMBER_TOO_SMALL_BOUND_EXCLUDED , wrong , min ) ;
{ this ( null , wrong , min , boundIsAllowed ) ; }
{ super ( specific , LocalizedFormats.NOT_FINITE_NUMBER , wrong , args ) ; }
{ this ( null , wrong , args ) ; }
{ super ( specific , LocalizedFormats.MAX_COUNT_EXCEEDED , max , args ) ; this . max = max ; }
public MaxCountExceededException ( Number max ) { this ( null , max ) ; }
public MathInternalError ( final Throwable cause ) { super ( LocalizedFormats.INTERNAL_ERROR , REPORT_URL ) ; }
{ super ( null , null , LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
{ ++ count ; assertEquals ( i + j / NUMBER_CONSTANT , value , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , l . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
{ assertEquals ( NUMBER_CONSTANT , m . getEntry ( i , j ) , NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , NUMBER_CONSTANT ) ;
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException ( LocalizedFormats.SIMPLE_MESSAGE , null ) ; }
@ Override protected void doFinalize ( ) throws MathUserException { throw new MathUserException () ; }
catch ( IOException ioe ) {}
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION , null ) ; }
private Erf () { super(); }
private Beta () { super(); }
private Gamma () { super(); }
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
@ Override
{ assertEquals ( a1 , MathUtils . normalizeAngle ( a2 , a1 ) , NUMBER_CONSTANT ) ; }
@ Override public void tearDown () { refValues = null ; matrix = null ; }
@ Override
{ assertTrue ( isIncludedColumn ( eigenVector , ed . getV () , tolerance ) ) ; }
@ Override
@ Override public void setUp () { f = new Frequency () ; }
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
assertTrue ( bestFinal . compareTo ( bestInitial ) > NUMBER_CONSTANT ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertTrue ( Double . isNaN ( statistic . getResult () ) ) ; }
{ double variance = regression . estimateRegressandVariance () ; assertTrue ( variance > NUMBER_CONSTANT ) ; }
{ double [] [] variance = regression . estimateRegressionParametersVariance () ; assertEquals ( getNumberOfRegressors () , variance.length ) ; }
{ double [] e = regression . estimateResiduals () ; assertEquals ( getSampleSize () , e.length ) ; }
{ double [] beta = regression . estimateRegressionParameters () ; assertEquals ( getNumberOfRegressors () , beta.length ) ; }
{ FractionField field = FractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Fraction.ONE , FractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Fraction.ZERO , FractionField . getInstance () . getZero () ) ; }
assertTrue ( fitnessCalls <= neededCalls ) ;
assertEquals ( NUMBER_CONSTANT , numDifferent ) ;
{ try { new DummyBinaryChromosome ( repr ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
assertEquals ( c3 , population . getFittestChromosome () ) ;
{ assertEquals ( expected , actual , NUMBER_CONSTANT ) ; }
{ assertEquals ( null , expected , actual , delta ) ; }
{ BigRealField field = BigRealField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigReal.ONE , BigRealField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigReal.ZERO , BigRealField . getInstance () . getZero () ) ; }
assertTrue ( uniquePointIsCenter ) ;
assertEquals ( p , TestUtils . serializeAndRecover ( p ) ) ;
assertEquals ( STRING_CONSTANT , s . getN () , u . getN () ) ;
assertEquals ( expected . getN () , observed . getN () ) ;
try { new Fraction ( a , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( ConvergenceException ce ) {}
{ assertEquals ( y [ i ] , iResult [ i ] ) ; }
assertTrue ( FastMath . abs ( h ) < minStep ) ;
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
catch ( FractionConversionException fce ) { fail ( fce . getMessage () ) ; }
{ DummyRandomKey drk = new DummyRandomKey ( RandomKey . randomPermutation ( NUMBER_CONSTANT ) ) ; assertNotNull ( drk ) ; }
assertEquals ( NUMBER_CONSTANT , nextGeneration . getPopulationSize () ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( STRING_CONSTANT + p , expected , actual , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT + x , expected , actual , NUMBER_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
@ Override public void tearDown () { pb = null ; integ = null ; }
@ Override
{ BigFractionField field = BigFractionField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( BigFraction.ONE , BigFractionField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( BigFraction.ZERO , BigFractionField . getInstance () . getZero () ) ; }
fail ( STRING_CONSTANT ) ;
@ Override protected void checkClearValue ( StorelessUnivariateStatistic statistic ) { assertEquals ( NUMBER_CONSTANT , statistic . getResult () , NUMBER_CONSTANT ) ; }
assertEquals ( approYDot , yDot [ i ] , threshold ) ;
{ ComplexField field = ComplexField . getInstance () ; assertTrue ( field == TestUtils . serializeAndRecover ( field ) ) ; }
@ Test public void testOne () { assertEquals ( Complex.ONE , ComplexField . getInstance () . getOne () ) ; }
@ Test public void testZero () { assertEquals ( Complex.ZERO , ComplexField . getInstance () . getZero () ) ; }
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
@ Override public void setUp () { tooShortStats = new SummaryStatistics () ; tooShortStats . addValue ( NUMBER_CONSTANT ) ; }
assertTrue ( maxError < NUMBER_CONSTANT ) ;
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
if ( isLast ) { assertTrue ( maxError > NUMBER_CONSTANT ) ; }
assertEquals ( NUMBER_CONSTANT , changes ) ;
{ if ( column > row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
{ if ( column < row ) { assertEquals ( NUMBER_CONSTANT , value , entryTolerance ) ; } }
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertEquals ( NUMBER_CONSTANT , norm , normTolerance ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
assertTrue ( FastMath . abs ( walk ) < NUMBER_CONSTANT ) ;
public NoDataException ( Localizable specific ) { super ( specific , null ) ; }
double [] param
double [] param
final double [] parameters
double [] parameters
double [] param
double [] param
double [] param
double [] param
double [] param
double [] param
double [] doubles
double [] parameters
double [] param
double [] param
UnivariateRealIntegrator integrator = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
public void setMinimalIterationCount ( int count ) { minimalIterationCount = count ; }
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
final double [] z = concatinateSamples ( x , y ) ;
public double getRelativeAccuracy ( ) ;
public double getAbsoluteAccuracy ( ) ;
public int getMaximalIterationCount ( ) ;
public Set < String > getContextKeys () { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
public Object getContext ( String key ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
{ throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
Assert . assertEquals ( new PearsonsCorrelation () . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ new PearsonsCorrelation () . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( new PearsonsCorrelation () . correlation ( noVariance , values ) ) ) ;
Assert . assertEquals ( PearsonsCorrelation . correlation ( x , y ) , corrInstance . getCorrelationMatrix () . getEntry ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , Double.MIN_VALUE ) ;
{ PearsonsCorrelation . correlation ( one , two ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertTrue ( Double . isNaN ( PearsonsCorrelation . correlation ( noVariance , values ) ) ) ;
normps = norm ( ps ) ;
normps = norm ( ps ) ;
{ this ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; }
final SimplexTableau tableau = new SimplexTableau ( function , linearConstraints , goal , nonNegative , epsilon ) ;
if ( MathUtils . compareTo ( entry , minValue , getEpsilon ( entry ) ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , getEpsilon ( entry ) ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( LocalizedFormats.CANNOT_PARSE , wrong , Integer . valueOf ( position ) ) ; }
{ super ( LocalizedFormats.MAX_COUNT_EXCEEDED , max ) ; this . max = max ; }
{ super ( cause ) ; addMessage ( pattern , arguments ) ; }
{ addMessage ( pattern , arguments ) ; }
{ super ( cause ) ; addMessage ( LocalizedFormats.USER_EXCEPTION ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( cause ) ; addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ addMessage ( pattern , args ) ; }
{ super ( LocalizedFormats.EVALUATIONS , max ) ; }
this . field = data [ NUMBER_CONSTANT ] . getField () ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayFieldVector < T > ( out ) ;
return new ArrayRealVector ( out ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
{ super ( extractField ( d ) ) ; copyIn ( d ) ; }
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > matrix = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
return new Array2DRowFieldMatrix < T > ( outData , false ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( testDataInv ) ) , identity , entryTolerance ) ;
return new Array2DRowFieldMatrix < BigFraction > ( Hdata ) ;
return new Array2DRowFieldMatrix < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
{ return projection ( new ArrayFieldVector < T > ( v , false ) ) ; }
return new Array2DRowFieldMatrix < T > ( d , false ) ;
Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( fractionColMatrix ) , MatrixUtils . createFieldMatrix ( fractionColMatrix ) ) ;
return new ArrayFieldVector < T > ( outData , false ) ;
return new ArrayFieldVector < T > ( outData , false ) ;
String source
{ this ( prefix , suffix , separator , CompositeFormat . getDefaultNumberFormat () ) ; }
public Vector3DFormat ( final NumberFormat format ) { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , format ) ; }
public Vector3DFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
final BSPTreeVisitor visitor
void visitLeafNode ( BSPTree node ) ;
BSPTree node
BSPTree node
Hyperplane other
Point point
final Hyperplane other
final Point2D p
final Hyperplane other
final Point2D p
final Point2D tmp = loop [ min ] ;
final Point2D [] bLoop
Point3D point = p . intersection ( l ) ;
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
public BoundaryProjector () { projected = new PolygonsSet ( new BSPTree ( Boolean.FALSE ) ) ; }
final BSPTree tree
Point3D [] points
final BSPTree tree
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final Hyperplane other
final Point point
final Point3D p
origin = new Point3D ( - originOffset , w ) ;
public Order visitOrder ( final BSPTree node ) { return Order.MINUS_SUB_PLUS ; }
final BSPTree tree
public abstract SplitSubHyperplane < S > split ( Hyperplane < S > hyperplane ) ;
public abstract Side side ( Hyperplane < S > hyperplane ) ;
{ if ( in [ i ] < NUMBER_CONSTANT ) { throw new NotPositiveException ( in [ i ] ) ; } }
{ if ( val < NUMBER_CONSTANT || val > NUMBER_CONSTANT ) { throw new InvalidRepresentationException ( STRING_CONSTANT ) ; } }
for ( int i : chromosomeRepresentation ) { if ( i < NUMBER_CONSTANT || i > NUMBER_CONSTANT ) throw new InvalidRepresentationException ( STRING_CONSTANT ) ; }
clusters = transformer . cluster ( Arrays . asList ( points ) , NUMBER_CONSTANT , NUMBER_CONSTANT )
public RealVector getInitialStateEstimate () { return initialStateEstimate ; }
if ( t == NUMBER_CONSTANT && i >= j ) continue;
{ if ( maxGenerations <= NUMBER_CONSTANT ) throw new IllegalArgumentException ( STRING_CONSTANT ) ; this . maxGenerations = maxGenerations ; }
if ( ! forward ) h = - h ;
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( remA > NUMBER_CONSTANT ) break;
if ( x * x == NUMBER_CONSTANT ) return Double.NaN ;
{ for ( Chromosome anotherChr : population ) { if ( this . isSame ( anotherChr ) ) return anotherChr ; } return null ; }
if ( y . equals ( py ) ) break;
if ( x < NUMBER_CONSTANT ) return NUMBER_CONSTANT ;
if ( boundaries == null ) return x ;
if ( boundaries == null ) return x ;
if ( negccov > negcovMax ) negccov = negcovMax ;
{ numElements -= i ; if ( front ) startIndex += i ; }
{ super ( relativeAccuracy , absoluteAccuracy , Method.SECANT ) ; }
public SecantSolver ( final double absoluteAccuracy ) { super ( absoluteAccuracy , Method.SECANT ) ; }
{ this . allowedSolutions = allowedSolutions ; return super . solve ( maxEval , f , min , max , startValue ) ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowedSolutions = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ se [ i ] = FastMath . sqrt ( rank ) ; continue; }
if ( ! Double . isNaN ( var ) && var > Double.MIN_VALUE ) { return FastMath . sqrt ( rank ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
{ if ( isNaN () ) { return Complex.NaN ; } return createComplex ( FastMath . log ( abs () ) , FastMath . atan2 ( imaginary , real ) ) ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () ) { return Complex.NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( - real , - imaginary ) ; }
if ( isNaN () || Double . isNaN ( rhs ) ) { return NaN ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
if ( isNaN () ) { return NUMBER_CONSTANT ; }
if ( isNaN () || rhs . isNaN () ) { return NaN ; }
{ if ( isNaN () ) { return NaN ; } return createComplex ( real , - imaginary ) ; }
if ( isNaN () ) { return Double.NaN ; }
{ if ( rng . nextBoolean () ) { throw new MathRuntimeException () ; } }
Assert . assertEquals ( w . getReal () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ include ( Arrays . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT || index >= this . parameters . length ) { throw new IndexOutOfBoundsException ( STRING_CONSTANT ) ; }
{ return outerProduct ( ( ArrayRealVector ) v ) ; }
{ return getLInfDistance ( ( ArrayRealVector ) v ) ; }
{ return getL1Distance ( ( ArrayRealVector ) v ) ; }
{ return getDistance ( ( ArrayRealVector ) v ) ; }
{ return dotProduct ( ( ArrayRealVector ) v ) ; }
{ return ebeDivide ( ( ArrayRealVector ) v ) ; }
{ return ebeMultiply ( ( ArrayRealVector ) v ) ; }
{ return subtract ( ( ArrayRealVector ) v ) ; }
{ return add ( ( ArrayRealVector ) v ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , Method.PEGASUS ) ; }
Assert . assertTrue ( z . isNaN () ) ;
{ return ( ( Integer ) node . getElement () ) . intValue () ; }
if ( numberOfVariables < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
{ addEventHandler ( handler , maxCheckInterval , convergence , maxIterationCount , new BrentSolver ( convergence ) ) ; }
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.ABOVE_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.BELOW_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.RIGHT_SIDE ) ;
double solution = getSolution ( solver , NUMBER_CONSTANT , f , left , right , AllowedSolutions.LEFT_SIDE ) ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
this . allowed = AllowedSolutions.ANY_SIDE ;
{ return solve ( maxEval , f , min , max , startValue , AllowedSolutions.ANY_SIDE ) ; }
{ super ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( relativeAccuracy , absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
{ super ( absoluteAccuracy ) ; this . allowed = AllowedSolutions.ANY_SIDE ; this . method = method ; }
double x = FastMath . random () ;
double dot = dotProduct ( v1 , v2 ) ;
{ return new Solver ( singularValues , getUT () , getV () , getRank () == Math . max ( m , n ) ) ; }
tol = FastMath . max ( FastMath . max ( m , n ) * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
{ super . setEntry ( row - NUMBER_CONSTANT , col - NUMBER_CONSTANT , value ) ; }
{ super . setEntry ( index - NUMBER_CONSTANT , value ) ; }
fsave = fval . getEntry ( NUMBER_CONSTANT ) ;
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
Vector3D . dotProduct ( crossP , otherPlane . getNormal () ) < NUMBER_CONSTANT
double scaled = area * Vector3D . dotProduct ( facetB , plane . getNormal () ) ;
final Vector3D n = new Vector3D ( NUMBER_CONSTANT , d , - Vector3D . dotProduct ( d , direction ) , direction ) ;
{ return Vector3D . dotProduct ( ( Vector3D ) point , w ) + originOffset ; }
{ setNormal ( normal ) ; originOffset = - Vector3D . dotProduct ( p , w ) ; setFrame () ; }
public Line revert () { return new Line ( zero , direction . negate () ) ; }
if ( nRows < NUMBER_CONSTANT || nCols < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSUFFICIENT_ROWS_AND_COLUMNS , nRows , nCols ) ; }
{ setResult ( t ) ; return result ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( s ) ; return result ; }
if ( ( delta <= rLimit ) || ( delta <= absoluteAccuracy ) ) { setResult ( t ) ; return result ; }
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u . copy () ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
RealVector v = AbstractRealVector . unmodifiableRealVector ( u ) ;
final RealVector x = new ArrayRealVector ( dim ) ;
final RealVector x = new ArrayRealVector ( dim ) ;
final double [] actual = x . getData () ;
final double [] actual = z . getData () ;
double [] d2 = w . getData () ;
{ return coefficients . dotProduct ( point ) + constantTerm ; }
dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT , null ) ;
public EmpiricalDistributionImpl ( int binCount ) { this ( binCount , null ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount ) ;
return NUMBER_CONSTANT * ( NUMBER_CONSTANT + Erf . erf ( dev / ( standardDeviation * FastMath . sqrt ( NUMBER_CONSTANT ) ) ) ) ;
{ setConvergenceChecker ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
@ Test ( expected = TooManyEvaluationsException . class )
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ es . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ solver . solve ( b . getColumn ( NUMBER_CONSTANT ) ) ; Assert . fail ( STRING_CONSTANT ) ; }
Assert . assertEquals ( z , Complex.NaN ) ;
Assert . assertEquals ( z , Complex.INF ) ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext cOut = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
final ExceptionContext c = new ExceptionContext () ;
@ Test ( expected = MathUserException . class )
@ Test ( expected = MathUserException . class )
MathUserException e
MathUserException e
int i = NUMBER_CONSTANT
final double [] x = b . getData () ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . getData () ;
final double objectiveValue = computeObjectiveValue ( currentBest . getData () ) ;
f = computeObjectiveValue ( currentBest . getData () ) ;
final double [] actual = x . getData () ;
final double [] actual = x . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
final double [] actual = x . combine ( a , b , y ) . getData () ;
Assert . assertNotSame ( STRING_CONSTANT , v1.data , v_copy . getData () ) ;
{ double sum = NUMBER_CONSTANT ; for ( double coefficient : coefficients . getData () ) { sum -= coefficient ; } return sum ; }
assertClose ( m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
assertClose ( testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , m . preMultiply ( new ArrayRealVector ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( STRING_CONSTANT , testVector , m . operate ( new ArrayRealVector ( testVector ) ) . getData () , entryTolerance ) ;
public double [] getStateEstimation () { return stateEstimation . getData () ; }
double [] y = u . add ( x . operate ( b ) ) . getData () ;
TestUtils . assertEquals ( new double [] { - NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
TestUtils . assertEquals ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT , - NUMBER_CONSTANT , NUMBER_CONSTANT } , b . getData () , NUMBER_CONSTANT ) ;
return e . getData () ;
{ RealVector b = calculateBeta () ; return b . getData () ; }
if ( x instanceof ArrayRealVector ) { return ( ( ArrayRealVector ) x ) . getDataRef () ; } else { return x . getData () ; }
if ( ltI [ i ] < absolutePositivityThreshold ) { throw new NonPositiveDefiniteMatrixException ( i , absolutePositivityThreshold ) ; }
{ return getIntercept ( getSlope () ) ; }
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
int i = FACT_LEN - NUMBER_CONSTANT
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
CholeskyDecomposition llt = new CholeskyDecompositionImpl ( matrix ) ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( s ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new CholeskyDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
final RealMatrix matrix = EigenDecompositionImplTest . createTestMatrix ( new Random ( NUMBER_CONSTANT ) , refValues ) ;
EigenDecomposition eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
EigenDecompositionImpl eig = new EigenDecompositionImpl ( C , NUMBER_CONSTANT ) ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecompositionImpl ( m , MathUtils.SAFE_MIN ) . getSolver () ;
EigenDecompositionImpl ed
EigenDecompositionImpl ed
RealMatrix v = new EigenDecompositionImpl ( matrix , MathUtils.SAFE_MIN ) . getV () ;
int max = val.length ;
int max = val.length ;
int max = val.length ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
throw new IllegalArgumentException () ;
double slope
double slope
double alpha
FieldDecompositionSolver < BigFraction > pSolver = new FieldLUDecompositionImpl < BigFraction > ( bigP ) . getSolver () ;
{ return new FieldLUDecompositionImpl < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecompositionImpl < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
catch ( NonMonotonousSequenceException iae ) {}
@ Test ( expected = NonMonotonousSequenceException . class )
@ Test ( expected = NonMonotonousSequenceException . class )
catch ( NonMonotonousSequenceException iae ) {}
final DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( jTj ) , threshold ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( singular ) ) . getSolver () ;
DecompositionSolver solver = new LUDecompositionImpl ( MatrixUtils . createRealMatrix ( testData ) ) . getSolver () ;
DecompositionSolver solver = useLU ? new LUDecompositionImpl ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
return new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix inverse = new LUDecompositionImpl ( XTOIX ) . getSolver () . getInverse () ;
RealMatrix Rinv = new LUDecompositionImpl ( Raug ) . getSolver () . getInverse () ;
DecompositionSolver solver = useLU ? new LUDecomposition ( mA ) . getSolver () : new QRDecompositionImpl ( mA ) . getSolver () ;
{ super . newXSampleData ( x ) ; qr = new QRDecompositionImpl ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecompositionImpl ( X ) ; }
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
RealMatrix x = new QRDecompositionImpl ( a ) . getSolver () . solve ( b ) ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3Singular ) ) . getSolver () ;
DecompositionSolver solver = new QRDecompositionImpl ( MatrixUtils . createRealMatrix ( testData3x3NonSingular ) ) . getSolver () ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
final RectangularCholeskyDecomposition decomposition = new RectangularCholeskyDecompositionImpl ( covariance , small ) ;
SingularValueDecomposition svd = new SingularValueDecompositionImpl ( rm ) ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( m ) . getSolver () ;
DecompositionSolver solver = new SingularValueDecompositionImpl ( MatrixUtils . createRealMatrix ( testSquare ) ) . getSolver () ;
{ g0Positive = g0 >= NUMBER_CONSTANT ; nextAction = EventHandler.CONTINUE ; }
nextAction = EventHandler.CONTINUE ;
FirstOrderDifferentialEquations equations
final FirstOrderDifferentialEquations equations
final FirstOrderDifferentialEquations equations
{ out . writeDouble ( polynoms [ k ] [ l ] ) ; }
final double e = polynoms [ currentDegree ] [ i ] / scale [ i ] ;
Array . newInstance ( field . getZero () . getClass () , new int [] { m , nColB } )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
bp = ( T [] ) Array . newInstance ( field . getZero () . getClass () , m )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
array = ( T [] ) Array . newInstance ( field . getZero () . getClass () , length )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
( T [] [] ) Array . newInstance ( zero . getClass () , new int [] { dimension , dimension } )
{ return ( T [] ) Array . newInstance ( field . getZero () . getClass () , length ) ; }
solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
solver . solve ( a , m , b , null , false ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
final RealVector x = solver . solve ( a , b , x0 , false ) ;
final RealVector x = solver . solve ( a , b , x0 , true ) ;
final RealVector x = solver . solve ( a , b , null , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
solver . solve ( a , b , x , false ) ;
if ( nSteps <= NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INTEGRATION_METHOD_NEEDS_AT_LEAST_TWO_PREVIOUS_POINTS , name ) ; }
throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.N_POINTS_GAUSS_LEGENDRE_INTEGRATOR_NOT_SUPPORTED , n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
catch ( ArithmeticException e ) {}
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
catch ( ParseException ex ) { Assert . fail ( ex . getMessage () ) ; }
try { f1 . divide ( f2 ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
{ if ( getN () > NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.VALUES_ADDED_BEFORE_CONFIGURING_STATISTIC , getN () ) ; } }
if ( i < NUMBER_CONSTANT ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INDEX_NOT_POSITIVE , i ) ; }
{ throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INITIAL_CAPACITY_NOT_POSITIVE , initialCapacity ) ; }
if ( expansionMode != MULTIPLICATIVE_MODE && expansionMode != ADDITIVE_MODE ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.UNSUPPORTED_EXPANSION_MODE , expansionMode , MULTIPLICATIVE_MODE , STRING_CONSTANT , ADDITIVE_MODE , STRING_CONSTANT ) ; }
if ( index < NUMBER_CONSTANT ) { throw MathRuntimeException . createArrayIndexOutOfBoundsException ( LocalizedFormats.CANNOT_SET_AT_NEGATIVE_INDEX , index ) ; }
catch ( ClassCastException ex ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INSTANCES_NOT_COMPARABLE_TO_EXISTING_VALUES , v . getClass () . getName () ) ; }
MathException cause = new MathConfigurationException ( inMsg ) ;
{ evaluations . incrementCount () ; equations . computeDerivatives ( t , y , yDot ) ; }
{ this . equations = equations ; }
allocateInterpolatedArrays ( y.length , primaryMapper , secondaryMappers ) ;
allocateInterpolatedArrays ( - NUMBER_CONSTANT , null , null ) ;
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + p + STRING_CONSTANT + ex . getMessage () ) ; }
catch ( MathException ex ) { Assert . fail ( STRING_CONSTANT + mean + STRING_CONSTANT + x + STRING_CONSTANT + ex . getMessage () ) ; }
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
@ Test ( expected = NonPositiveDefiniteLinearOperatorException . class )
@ Test ( expected = NonSquareLinearOperatorException . class )
if ( ( str = filePointer . readLine () ) == null ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , valuesFileURL ) ; }
if ( ( empiricalDistribution == null ) || ( empiricalDistribution . getBinStats () . size () == NUMBER_CONSTANT ) ) { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.DIGEST_NOT_INITIALIZED ) ; }
if ( sampleStats . getN () == NUMBER_CONSTANT ) { throw MathRuntimeException . createEOFException ( LocalizedFormats.URL_CONTAINS_NO_DATA , url ) ; }
catch ( IOException e ) { throw new MathRuntimeException ( e ) ; }
catch ( EOFException eof ) {}
catch ( EOFException eof ) {}
final ArrayList < BigFraction > coefficients
final ArrayList < BigFraction > coefficients
double y = x * NUMBER_CONSTANT - NUMBER_CONSTANT ;
if ( FastMath . abs ( m ) <= tol || MathUtils . equals ( fb , NUMBER_CONSTANT ) ) { return b ; }
Assert . assertTrue ( MathUtils . equals ( binomial , jacobi . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ) ;
if ( mode == StepNormalizerMode.MULTIPLES && MathUtils . equals ( nextTime , lastTime , NUMBER_CONSTANT ) ) { nextTime += h ; }
{ Assert . assertTrue ( MathUtils . equals ( out [ i ] , expectedSample [ i ] , NUMBER_CONSTANT ) ) ; }
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distanceInf ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
Assert . assertTrue ( MathUtils . equals ( NUMBER_CONSTANT , MathUtils . distance1 ( p1 , p2 ) , NUMBER_CONSTANT ) ) ;
if ( MathUtils . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
isLastStep = isLastStep || MathUtils . equals ( currentT , tEnd , NUMBER_CONSTANT ) ;
! MathUtils . equalsIncludingNaN ( expected [ i ] , observed [ i ] , tolerance )
for ( double value : values ) { if ( MathUtils . equals ( value , x , epsilon ) ) { return; } }
MathUtils . equalsIncludingNaN ( stat . getN () , getN () )
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { return false ; }
if ( MathUtils . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { columnsToDrop . add ( i ) ; }
{ if ( this . parameters == null ) { return null ; } return MathUtils . copyOf ( parameters ) ; }
MathUtils . checkOrder ( knots ) ;
public int [] getOrderOfRegressors () { return MathUtils . copyOf ( vorder ) ; }
{ include ( MathUtils . copyOf ( x , x.length ) , NUMBER_CONSTANT , y ) ; }
MathUtils . checkOrder ( x ) ;
{ this ( wrong , previous , index , MathUtils.OrderDirection.INCREASING , true ) ; }
MathUtils . checkOrder ( xval ) ;
final double [] d = MathUtils . copyOf ( direc [ i ] ) ;
MathUtils . checkOrder ( x ) ;
{ return MathUtils . distance ( point , p . getPoint () ) ; }
RealMatrix arzneg = selectColumns ( arz , MathUtils . copyOf ( arReverseIndex , mu ) ) ;
return MathUtils . checkOrder ( x , MathUtils.OrderDirection.INCREASING , true , abort ) ;
MathUtils . sortInPlace ( xNew , yNew ) ;
MathUtils . sortInPlace ( this . x , this . y ) ;
public int [] getSizes () { return MathUtils . copyOf ( size ) ; }
this . size = MathUtils . copyOf ( size ) ;
public int [] getCounts () { return MathUtils . copyOf ( counter ) ; }
Assert . assertEquals ( expectedValue () , variance . evaluate ( testArray , MathUtils . normalizeArray ( identicalWeightsArray , testArray.length ) , NUMBER_CONSTANT , testArray.length ) , getTolerance () ) ;
int gcd = MathUtils . gcd ( numerator , denominator ) ;
final int d = MathUtils . gcd ( num , den ) ;
long lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
int lcm = FastMath . abs ( mulAndCheck ( a / gcd ( a , b ) , b ) ) ;
{ coeff [ i ] [ j ] = ( int ) MathUtils . binomialCoefficient ( i , j ) ; }
double binomial = MathUtils . binomialCoefficient ( v + i , i ) ;
double binomial = ArithmeticsUtils . binomialCoefficient ( v + i , i ) ;
int gcd = ArithmeticsUtils . gcd ( numerator , denominator ) ;
final int d = ArithmeticsUtils . gcd ( num , den ) ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticsUtils . binomialCoefficient ( i , j ) ; }
MathUtils . sign ( y0 ) + MathUtils . sign ( ym ) == NUMBER_CONSTANT
{ return FastMath . abs ( x ) < NUMBER_CONSTANT ? NUMBER_CONSTANT : FastMath . sin ( x ) / x ; }
if ( n < MathUtils.EPSILON ) { return zero ; }
if ( n < MathUtils.SAFE_MIN ) { return distance ( line.zero ) ; }
tol = FastMath . max ( m * singularValues [ NUMBER_CONSTANT ] * EPS , FastMath . sqrt ( MathUtils.SAFE_MIN ) ) ;
if ( d > - MathUtils.SAFE_MIN && d < MathUtils.SAFE_MIN ) { return d ; }
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) . getSolver () ;
final double eps = NUMBER_CONSTANT * rows * columns * MathUtils.EPSILON ;
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
if ( FastMath . abs ( diag ) < MathUtils.SAFE_MIN ) { throw new MathArithmeticException ( LocalizedFormats.ZERO_DENOMINATOR ) ; }
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( initialStepBoundFactor , costRelativeTolerance , parRelativeTolerance , orthoTolerance , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( indefinite , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , MathUtils.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , MathUtils.SAFE_MIN ) ;
if ( FastMath . abs ( tmp ) > MathUtils.EPSILON ) { w = ( di * w ) / dpi ; }
{ this ( numberOfVariables , includeConstant , MathUtils.EPSILON ) ; }
FastMath . abs ( sumXX ) > MathUtils.SAFE_MIN
@ Test ( expected = OutOfRangeException . class )
{ this ( numberOfInterpolationPoints , null , null ) ; }
this . stopfitness = stopfitness ;
this . stopfitness = stopFitness ;
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public boolean isInfinite () { throw unsupported () ; }
public boolean isNaN () { throw unsupported () ; }
public void unitize () { throw unsupported () ; }
public double getLInfNorm () { throw unsupported () ; }
public double getL1Norm () { throw unsupported () ; }
public double getNorm () { throw unsupported () ; }
double [] bounds = ( ( EmpiricalDistributionImpl ) empiricalDistribution2 ) . getGeneratorUpperBounds () ;
FieldDecompositionSolver solver ;
double floatn = ( double ) v.length ;
final double [] eventY = interpolator . getInterpolatedState () ;
final double [] yTmp = new double [ y0.length ] ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
BetaDistributionImpl betaDistribution = new BetaDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
BetaDistribution d = new BetaDistributionImpl ( alpha , beta ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new BinomialDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new CauchyDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
ChiSquaredDistribution d = new ChiSquaredDistributionImpl ( df ) ;
setDistribution ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
@ Override public ChiSquaredDistribution makeDistribution () { return new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new ChiSquaredDistributionImpl ( NUMBER_CONSTANT ) ) ;
FDistributionImpl fd = new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new FDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
GammaDistribution distribution = new GammaDistributionImpl ( a , b ) ;
@ Override public ExponentialDistribution makeDistribution () { return new ExponentialDistributionImpl ( NUMBER_CONSTANT ) ; }
FDistribution fdist = new FDistributionImpl ( a.dfbg , a.dfwg ) ;
{ gamma = new GammaDistributionImpl ( degreesOfFreedom / NUMBER_CONSTANT , NUMBER_CONSTANT ) ; solverAbsoluteAccuracy = inverseCumAccuracy ; }
HypergeometricDistribution dist = new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new HypergeometricDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NormalDistribution normal = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution distribution = new NormalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
NormalDistribution d = new NormalDistributionImpl ( mean , sd ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
setDistribution ( new PascalDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
normal = new NormalDistributionImpl ( p , FastMath . sqrt ( p ) ) ;
TDistribution tDistribution = new TDistributionImpl ( NUMBER_CONSTANT ) ;
FastMath . sqrt ( getMeanSquareError () * ( ( NUMBER_CONSTANT / ( double ) n ) + ( xbar * xbar ) / sumXX ) )
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
TDistribution distribution = new TDistributionImpl ( degreesOfFreedom ) ;
TDistribution td = new TDistributionImpl ( df ) ;
setDistribution ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
{ TDistributionImpl td = new TDistributionImpl ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; td . cumulativeProbability ( NUMBER_CONSTANT ) ; }
@ Override public TDistribution makeDistribution () { return new TDistributionImpl ( NUMBER_CONSTANT ) ; }
double [] quartiles = TestUtils . getDistributionQuartiles ( new WeibullDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
double [] quartiles = TestUtils . getDistributionQuartiles ( new TDistributionImpl ( NUMBER_CONSTANT ) ) ;
PoissonDistribution poissonDistribution = new PoissonDistributionImpl ( mean ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
PoissonDistribution dist = new PoissonDistributionImpl ( mean ) ;
{ PoissonDistribution dist = new PoissonDistributionImpl ( NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , dist . getMean () , NUMBER_CONSTANT ) ; }
@ Test ( expected = NotStrictlyPositiveException . class ) public void testNegativeMean () { new PoissonDistributionImpl ( - NUMBER_CONSTANT ) ; }
PoissonDistribution dist = new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ;
@ Override public IntegerDistribution makeDistribution () { return new PoissonDistributionImpl ( DEFAULT_TEST_POISSON_PARAMETER ) ; }
dist = new ZipfDistributionImpl ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( windowSize < NUMBER_CONSTANT ) { if ( windowSize != INFINITE_WINDOW ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.NOT_POSITIVE_WINDOW_SIZE , windowSize ) ; } }
if ( sign >= NUMBER_CONSTANT && magnitude == Long.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( long ) - magnitude ; }
if ( sign >= NUMBER_CONSTANT && magnitude == Integer.MIN_VALUE ) { throw new MathArithmeticException ( LocalizedFormats.OVERFLOW ) ; } else { return ( int ) - magnitude ; }
if ( c . isAssignableFrom ( UnivariateRealFunction . class ) ) { return new Sin () ; } else { throw new IllegalArgumentException ( STRING_CONSTANT + c ) ; }
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new XMinus5Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final DifferentiableUnivariateRealFunction f
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
ParametricUnivariateRealFunction sif = new SimpleInverseFunction () ;
UnivariateRealFunction f
UnivariateRealFunction func
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Gaussian () ;
final UnivariateRealFunction f = new Gaussian () ;
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
DifferentiableUnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = i . interpolate ( x , y ) ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction dfdx = f . derivative () ;
final UnivariateRealFunction f = new Sigmoid () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f
UnivariateRealFunction f
final UnivariateRealFunction f
DifferentiableUnivariateRealFunction f = new QuinticFunction () ;
DifferentiableUnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f
UnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final ParametricUnivariateRealFunction f
final UnivariateRealFunction f
final UnivariateRealFunction f
UnivariateRealFunction p = interpolator . interpolate ( x , y ) ;
final UnivariateRealFunction dfdx = f . derivative () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new Expm1Function () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
final UnivariateRealFunction f
final UnivariateRealFunction lsf = new LineSearchFunction ( searchDirection ) ;
DifferentiableUnivariateRealFunction f
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new QuinticFunction () ;
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction function
UnivariateRealFunction function
UnivariateRealFunction f = new SinFunction () ;
UnivariateRealFunction f = new SinFunction () ;
@ Override public RealVector mapToSelf ( UnivariateRealFunction function ) { throw unsupported () ; }
@ Override public RealVector map ( UnivariateRealFunction function ) { throw unsupported () ; }
public MonitoredFunction ( UnivariateRealFunction f ) { callsCount = NUMBER_CONSTANT ; this . f = f ; }
UnivariateRealFunction dSpline = spline . derivative () ;
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
MultivariateRealFunction coll = FunctionUtils . collector ( bi , NUMBER_CONSTANT ) ;
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
final DifferentiableMultivariateRealFunction f
DifferentiableMultivariateRealFunction func
DifferentiableMultivariateRealFunction func
MultivariateRealFunction func
final MultivariateRealFunction evaluationFunction
final MultivariateRealFunction evaluationFunction
MultivariateRealFunction func
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
resetEvaluations () ;
public KeplerStepHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
public KeplerHandler ( TestProblem3 pb ) { this . pb = pb ; reset () ; }
final DifferentiableMultivariateVectorialFunction f
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
final MultivariateVectorialFunction function
# optimize ( int , MultivariateVectorialFunction , double [] , double [] , double [] )
DifferentiableMultivariateVectorialFunction problem
result = transformer . inversetransform ( f , min , max , N ) ;
if ( forward ) { temp = transform2 ( temp ) ; } else { temp = inversetransform2 ( temp ) ; }
double dResult [] = transformer . inversetransform ( dY ) ;
Object o []
double d []
Complex f []
double f []
Complex f []
double f []
double f []
double f []
double f []
double f []
int x []
double x []
int f []
double f []
double f []
double f []
double f []
double f []
double f []
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . sign ( w ) , d )
final int bits
if ( seed == null ) { setSeed ( System . currentTimeMillis () ) ; return; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
catch ( Exception e ) { fail ( STRING_CONSTANT ) ; }
double x
p = dist . cumulativeProbability ( x ) ;
ContinuousDistribution distribution
ContinuousDistribution distribution
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastFourierTransformer transformer = new FastFourierTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
FastCosineTransformer transformer = new FastCosineTransformer () ;
DifferentiableMultivariateVectorialOptimizer optimizer
{ DifferentiableMultivariateVectorialOptimizer optimizer = new GaussNewtonOptimizer ( true ) ; checkUnsolvableProblem ( optimizer , false ) ; }
final DifferentiableMultivariateVectorialOptimizer optimizer
public HarmonicFitter ( final DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
final DifferentiableMultivariateVectorialOptimizer optimizer
public GaussianFitter ( DifferentiableMultivariateVectorialOptimizer optimizer ) { super ( optimizer ) ; }
final BaseMultivariateRealOptimizer < FUNC > optimizer
MultivariateRealOptimizer optim
final DifferentiableMultivariateRealOptimizer optimizer
final MultivariateRealOptimizer optimizer
@ Override public void setSeed ( int seed ) { ran . setSeed ( seed ) ; }
{ if ( rand == null ) { rand = new JDKRandomGenerator () ; } rand . setSeed ( seed ) ; }
FastSineTransformer transformer = new FastSineTransformer () ;
FastSineTransformer transformer = new FastSineTransformer () ;
Assert . assertEquals ( - NUMBER_CONSTANT , dist . inverseCumulativeProbability ( NUMBER_CONSTANT ) ) ;
setInverseCumulativeTestValues ( new int [] { - NUMBER_CONSTANT , - NUMBER_CONSTANT } ) ;
setInverseCumulativeTestValues ( new int [] { Integer.MAX_VALUE - NUMBER_CONSTANT , Integer.MAX_VALUE - NUMBER_CONSTANT } ) ;
{ return getNumberOfTrials () * getProbabilityOfSuccess () ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_PLUS_ONE , Integer . valueOf ( f.length ) ) ; }
{ if ( ! isPowerOf2 ( o.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( o.length ) ) ; } }
{ if ( ! isPowerOf2 ( d.length ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO_CONSIDER_PADDING , Integer . valueOf ( d.length ) ) ; } }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
if ( ! FastFourierTransformer . isPowerOf2 ( n ) ) { throw new MathIllegalArgumentException ( LocalizedFormats.NOT_POWER_OF_TWO , Integer . valueOf ( n ) ) ; }
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ;
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return inverseTransform ( data ) ; }
{ final double [] data = FastFourierTransformer . sample ( f , min , max , n ) ; return transform ( data ) ; }
final double [] unscaled = fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ;
{ return fht ( FastFourierTransformer . sample ( f , min , max , n ) ) ; }
final double [] data = sample ( f , min , max , n ) ;
final double [] data = sample ( f , min , max , n ) ;
return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ;
return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ;
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / n ) ; return FastFourierTransformer . scaleArray ( fst ( data ) , s ) ; }
{ final double s = FastMath . sqrt ( NUMBER_CONSTANT / f.length ) ; return FastFourierTransformer . scaleArray ( fst ( f ) , s ) ; }
FastFourierTransformer . scaleArray ( x2 , NUMBER_CONSTANT / FastMath . sqrt ( x2.length ) ) ;
return scaleArray ( transformed , NUMBER_CONSTANT ) ;
return scaleArray ( fft ( f ) , s ) ;
return scaleArray ( fft ( data , true ) , s ) ;
return scaleArray ( fft ( f , true ) , s ) ;
{ final double s = NUMBER_CONSTANT / FastMath . sqrt ( f.length ) ; return scaleArray ( fft ( f ) , s ) ; }
return scaleArray ( fft ( data , false ) , s ) ;
return scaleArray ( fft ( f , false ) , s ) ;
FastFourierTransformer . scaleArray ( x , FastMath . sqrt ( x.length / NUMBER_CONSTANT ) ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s1 ) ;
return FastFourierTransformer . scaleArray ( fct ( f ) , s ) ;
return FastFourierTransformer . scaleArray ( unscaled , NUMBER_CONSTANT / n ) ;
{ return FastFourierTransformer . scaleArray ( fht ( f ) , NUMBER_CONSTANT / f.length ) ; }
{ for ( double diag : rDiag ) { if ( diag == NUMBER_CONSTANT ) { return false ; } } return true ; }
public DecompositionSolver getSolver () { return new Solver ( qrt , rDiag ) ; }
@ Test ( expected = NonMonotonicSequenceException . class )
final UnivariateRealSolver solver
final UnivariateRealSolver solver
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolver solver = new MullerSolver () ;
UnivariateRealSolverUtils . verifyInterval ( lower , upper ) ;
{ return super . solve ( maxEval , f , UnivariateRealSolverUtils . midpoint ( min , max ) ) ; }
final UnivariateRealSolver lineSearchSolver
final UnivariateRealSolver lineSearchSolver
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new RiddersSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new BrentSolver () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
UnivariateRealSolver solver = new MullerSolver2 () ;
double x = UnivariateRealSolverUtils . solve ( toSolve , lowerBound , upperBound , getSolverAbsoluteAccuracy () ) ;
UnivariateRealSolver solver
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
UnivariateRealSolver solver = getSolver () ;
final UnivariateRealSolver solver = new RegulaFalsiSolver () ;
final UnivariateRealSolver solver
int populationLimit
Chromosome chromosome
List < Chromosome > chromosomes
int arity
Population population
Chromosome original
Chromosome another
Chromosome another
int l
java.util.List < Double > chromosomeRepresentation
Chromosome another
List < T > sequence
Double [] representation
Population current
RandomGenerator random
{ if ( maxGenerations <= NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.TOO_SMALL_GENERATION_COUNT , maxGenerations , NUMBER_CONSTANT , true ) ; } this . maxGenerations = maxGenerations ; }
if ( elitismRate < NUMBER_CONSTANT || elitismRate > NUMBER_CONSTANT ) { throw new OutOfRangeException ( LocalizedFormats.OUT_OF_RANGE_ELITISM_RATE , elitismRate , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
partialDerivatives = new BivariateRealFunction [ [ [ NUMBER_CONSTANT ] [ lastI ] [ lastJ ] ;
BivariateRealFunction div = new Divide () ;
BivariateRealFunction bi = new Add () ;
BivariateRealFunction bi = new Add () ;
final BivariateRealFunction f
final BivariateRealFunction f
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final BivariateRealFunction combiner
final IterativeLinearSolverEvent event = createEvent ( state ) ;
{ return x . ebeMultiply ( diag ) ; }
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
final InvertibleRealLinearOperator m = JacobiPreconditioner . create ( a ) ;
roots . computeOmega ( - f.length ) ;
roots . computeOmega ( f.length ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
BivariateRealGridInterpolator interpolator = new SmoothingPolynomialBicubicSplineInterpolator ( NUMBER_CONSTANT ) ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
MultivariateRealInterpolator interpolator = new MicrosphereInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator i = new LinearInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
UnivariateRealInterpolator interpolator = new NevilleInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
BivariateRealGridInterpolator interpolator = new BicubicSplineInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
UnivariateRealInterpolator interpolator = new DividedDifferenceInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
TrivariateRealGridInterpolator interpolator = new TricubicSplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
UnivariateRealInterpolator i = new SplineInterpolator () ;
roots . computeOmega ( f.length ) ;
roots . computeOmega ( - f.length ) ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
UnivariateRealIntegrator integrator = new TrapezoidIntegrator () ;
LegendreGaussIntegrator integrator = new LegendreGaussIntegrator ( n , UnivariateRealIntegratorImpl.DEFAULT_RELATIVE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_ABSOLUTE_ACCURACY , UnivariateRealIntegratorImpl.DEFAULT_MIN_ITERATIONS_COUNT , NUMBER_CONSTANT ) ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new SimpsonIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
UnivariateRealIntegrator integrator = new RombergIntegrator () ;
final UnivariateRealIntegratorImpl baseIntegrator
{ allocArrays () ; setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { allocArrays () ; setSeed ( seed ) ; }
{ if ( incMoment ) { moment . increment ( d ) ; } else { throw MathRuntimeException . createIllegalStateException ( LocalizedFormats.CANNOT_INCREMENT_STATISTIC_CONSTRUCTED_FROM_EXTERNAL_MOMENTS ) ; } }
final double fact2 = ( n ) / ( n - NUMBER_CONSTANT ) ;
final double fact2 = ( n ) / ( NUMBER_CONSTANT + n ) ;
public void init ( double t0 , double [] y0 , double t ) {}
try { t . transform ( input ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathException e ) {}
catch ( MathException e ) { e . printStackTrace () ; }
if ( ( nvars + NUMBER_CONSTANT ) * nobs != data.length ) { throw MathRuntimeException . createIllegalArgumentException ( LocalizedFormats.INVALID_REGRESSION_ARRAY , data.length , nobs , nvars ) ; }
empiricalDistribution = new EmpiricalDistributionImpl ( binCount , randomData ) ;
{ computeDistribution ( EmpiricalDistributionImpl.DEFAULT_BIN_COUNT ) ; }
EmpiricalDistributionImpl dist = new EmpiricalDistributionImpl ( NUMBER_CONSTANT ) ;
{ new EmpiricalDistributionImpl () . load ( ( File ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( URL ) null ) ; }
{ new EmpiricalDistributionImpl () . load ( ( double [] ) null ) ; }
EmpiricalDistribution dist = new EmpiricalDistributionImpl () ;
new EmpiricalDistributionImpl () . load ( x ) ;
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
dataRI = new double [] [] { Arrays . copyOf ( f , f.length ) , new double [ f.length ] }
Collection < double [] > categoryData
Collection < double [] > categoryData
Collection < double [] > categoryData
boolean exactPValue
double dResult [] = transformer . inverseTransform ( dY ) ;
double dResult [] = transformer . transform ( dX ) ;
protected BaseAbstractMultivariateSimpleBoundsOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
UnivariateRealPointValuePair [] optima = optimizer . getOptima () ;
public SimplexOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
RealPointValuePair expected
protected AbstractScalarDifferentiableOptimizer ( ConvergenceChecker < RealPointValuePair > checker ) { super ( checker ) ; }
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < UnivariateRealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < UnivariateRealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
ConvergenceChecker < RealPointValuePair > checker
RealPointValuePair [] points
RealPointValuePair point
final Comparator < RealPointValuePair > comparator
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
org.apache.commons.math.stat.inference.ChiSquareTestImpl csti = new org.apache.commons.math.stat.inference.ChiSquareTestImpl () ;
ChiSquareTest chiSquareTest = new ChiSquareTestImpl () ;
VectorialPointValuePair optimum
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
ConvergenceChecker < VectorialPointValuePair > checker
protected AbstractLeastSquaresOptimizer ( ConvergenceChecker < VectorialPointValuePair > checker ) { super ( checker ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleRealPointChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer underlying = new SimplexOptimizer ( new SimpleScalarValueChecker ( - NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new BrentSolver () , preconditioner ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer optimizer = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
SimplexOptimizer optimizer = new SimplexOptimizer ( new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
NonLinearConjugateGradientOptimizer underlying = new NonLinearConjugateGradientOptimizer ( ConjugateGradientFormula.POLAK_RIBIERE , new SimpleScalarValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ this ( lambda , inputSigma , boundaries , maxIterations , stopFitness , isActiveCMA , diagonalOnly , checkFeasableCount , random , generateStatistics , new SimpleScalarValueChecker () ) ; }
{ this ( new SimpleScalarValueChecker ( rel , abs ) ) ; }
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
DifferentiableMultivariateVectorOptimizer underlyingOptimizer = new GaussNewtonOptimizer ( true , new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
GaussNewtonOptimizer optimizer = new GaussNewtonOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
LevenbergMarquardtOptimizer optimizer = new LevenbergMarquardtOptimizer ( new SimpleVectorialValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
{ throw new UnsupportedOperationException () ; }
FastSineTransformer transformer = FastSineTransformer . create () ;
FastSineTransformer transformer = FastSineTransformer . create () ;
{ throw new NumberIsTooSmallException ( LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION , minStep , FastMath . abs ( h ) , true ) ; }
if ( variablesToInclude == null || variablesToInclude.length == NUMBER_CONSTANT ) { throw new MathIllegalArgumentException ( LocalizedFormats.ARRAY_ZERO_LENGTH_OR_NULL_NOTALLOWED ) ; }
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer optimizer = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
UnivariateRealOptimizer underlying = new BrentOptimizer ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
static double [] [] loadLnMant () { return LN_MANT . clone () ; }
static double [] loadExpFracB () { return EXP_FRAC_B . clone () ; }
static double [] loadExpFracA () { return EXP_FRAC_A . clone () ; }
static double [] loadExpIntB () { return EXP_INT_B . clone () ; }
static double [] loadExpIntA () { return EXP_INT_A . clone () ; }
@ Test ( expected = MultiDimensionMismatchException . class )
@ Test ( expected = MultiDimensionMismatchException . class )
StringBuffer imAppendTo = new StringBuffer () ;
{ if ( this . fitness == Double.MIN_VALUE ) { this . fitness = fitness () ; } return this . fitness ; }
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
setStepsizeControl ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
( n * ( n + NUMBER_CONSTANT ) * moment.m4 - NUMBER_CONSTANT * moment.m2 * moment.m2 * ( n - NUMBER_CONSTANT ) )
double [] hatResiduals = I . subtract ( hat ) . operate ( model.Y ) . toArray () ;
{ RealVector b = calculateBeta () ; return Y . subtract ( X . operate ( b ) ) ; }
return residuals . dotProduct ( residuals ) / ( X . getRowDimension () - X . getColumnDimension () ) ;
RealVector e = Y . subtract ( X . operate ( b ) ) ;
this . Y = new ArrayRealVector ( y ) ;
return t / ( X . getRowDimension () - X . getColumnDimension () ) ;
int p = X . getColumnDimension () ;
{ return qr . getSolver () . solve ( Y ) ; }
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( X ) ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( X ) ; }
final RealMatrix x = ols.X . copy () ;
final int length = b . getDataRef () . length ;
final double epsa = ( s + SymmLQ.MACH_PREC ) * SymmLQ.CBRT_MACH_PREC ;
@ Override public RealVector getRightHandSideVector () { return RealVector . unmodifiableRealVector ( state.b ) ; }
this . x . set ( NUMBER_CONSTANT ) ;
this . x = x ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
solver = new ConjugateGradient ( maxIterations , NUMBER_CONSTANT , true ) ;
double array []
double [] [] householderMatrix
{ key = k ; value = v ; }
{ this ( entry , false ) ; }
{ this ( k , v , false ) ; }
throw new RuntimeException ( STRING_CONSTANT ) ;
throw new RuntimeException ( STRING_CONSTANT ) ;
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( alpha , x / beta ) ; }
{ return getAlpha () * getBeta () ; }
v . walkInDefaultOrder ( visitor , expectedStart , expectedEnd ) ;
{ ret = innerCumulativeProbability ( domain [ NUMBER_CONSTANT ] , x , NUMBER_CONSTANT , populationSize , numberOfSuccesses , sampleSize ) ; }
{ recurseBuildBoundary ( tree ) ; }
SimplexOptimizer optimizer = new SimplexOptimizer () ;
@ Override public RealVector create ( final double [] data ) { return new OpenMapRealVector ( data ) ; }
TestVectorImpl ( double [] values ) { this . values = values ; }
catch ( IllegalArgumentException e ) {}
final ParametricUnivariateFunction f
final ParametricUnivariateFunction f
final double n1n2prod = n1 * n2 ;
{ create ( data1 ) . addToEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
{ create ( data1 ) . setEntry ( - NUMBER_CONSTANT , getPreferredEntryValue () ) ; }
@ Override public RealVector createAlien ( double [] data ) { return new RealVectorTestImpl ( data ) ; }
final RealVector x = new TestVectorImpl ( v . clone () ) ;
@ Override public RealVector createAlien ( double [] data ) { return new TestVectorImpl ( data ) ; }
@ Override public RealVector create ( final double [] data ) { return new TestVectorImpl ( data ) ; }
SparseRealVectorTestImpl v7_i = new SparseRealVectorTestImpl ( vec1 ) ;
@ Override public RealVector createAlien ( double [] data ) { return new SparseRealVectorTestImpl ( data ) ; }
Assert . assertEquals ( STRING_CONSTANT + i + STRING_CONSTANT + j + STRING_CONSTANT , expected , actual , NUMBER_CONSTANT ) ;
private ComplexUtils () { super(); }
Object obj
int n = coefficients.length - NUMBER_CONSTANT ;
ed = new EigenDecomposition ( indefinite , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( distinct , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( repeated , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( m , Precision.SAFE_MIN ) ;
RealMatrix v = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getV () ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( symmetric , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( createTestMatrix ( r , bigValues ) , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( t . getMainDiagonalRef () , t . getSecondaryDiagonalRef () , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
decomposition = new EigenDecomposition ( mainTridiagonal , secondaryTridiagonal , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
ed = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) ;
{ return ( int ) FastMath . min ( randomData . nextPoisson ( mean ) , Integer.MAX_VALUE ) ; }
{ double n = randomData . nextGaussian ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return FastMath . exp ( scale + shape * n ) ; }
EigenDecomposition eig = new EigenDecomposition ( C , NUMBER_CONSTANT ) ;
BaseRuleFactory factory
final GaussIntegrator g = factory . legendreHighPrecision ( numberOfPoints , a , b ) ;
{ this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , format ) ; }
public RealMatrixFormat () { this ( DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ROW_SEPARATOR , DEFAULT_COLUMN_SEPARATOR , CompositeFormat . getDefaultNumberFormat () ) ; }
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( matrix , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
DecompositionSolver es = new EigenDecomposition ( m , Precision.SAFE_MIN ) . getSolver () ;
{ double multiplier = tableau . getEntry ( i , pivotCol ) ; tableau . subtractRow ( i , pivotRow , multiplier ) ; }
if ( Precision . compareTo ( entry , minValue , maxUlps ) < NUMBER_CONSTANT ) { minValue = entry ; minPos = i ; }
if ( Precision . compareTo ( p , NUMBER_CONSTANT , epsilon ) < NUMBER_CONSTANT ) { s = - s ; }
catch ( Exception e ) { throw new MathIllegalStateException () ; }
{ if ( ! Precision . equals ( imagEigenvalues [ i ] , NUMBER_CONSTANT , epsilon ) ) { return true ; } }
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
Assert . assertNull ( STRING_CONSTANT + source + STRING_CONSTANT , new RealMatrixFormat () . parse ( source , pos ) ) ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
DifferentiableUnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new Expm1Function () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
final UnivariateFunction f = new SinFunction () ;
UnivariateFunction f = new SinFunction () ;
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
{ return nextInversionDeviate ( new ZipfDistribution ( numberOfElements , exponent ) ) ; }
{ return nextInversionDeviate ( new WeibullDistribution ( shape , scale ) ) ; }
{ return nextInversionDeviate ( new TDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new PascalDistribution ( r , p ) ) ; }
{ return nextInversionDeviate ( new HypergeometricDistribution ( populationSize , numberOfSuccesses , sampleSize ) ) ; }
{ return nextInversionDeviate ( new FDistribution ( numeratorDf , denominatorDf ) ) ; }
{ return nextInversionDeviate ( new ChiSquaredDistribution ( df ) ) ; }
{ return nextInversionDeviate ( new CauchyDistribution ( median , scale ) ) ; }
{ return nextInversionDeviate ( new BinomialDistribution ( numberOfTrials , probabilityOfSuccess ) ) ; }
{ return nextInversionDeviate ( new BetaDistribution ( alpha , beta ) ) ; }
{ return nextUniform ( lower , upper , false ) ; }
{ super(); this . rand = rand ; }
double dotProduct = new LegendreGaussIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . integrate ( NUMBER_CONSTANT , f , a , b ) ;
FastMath . exp ( Gamma . logGamma ( shape ) )
@ Override public int hashCode () { throw new UnsupportedOperationException () ; }
{ throw new UnsupportedOperationException () ; }
double x = randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
fillBinStats ( in ) ;
final UnivariateDifferentiable sPrime = new Sqrt () ;
final UnivariateDifferentiable f = new QuinticFunction () ;
UnivariateDifferentiable f = new Sin () ;
final UnivariateDifferentiable f
final UnivariateDifferentiable f
UnivariateDifferentiable f
final UnivariateDifferentiable q = new QuinticFunction () ;
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
catch ( final MathArithmeticException e ) { throw new MathArithmeticException ( LocalizedFormats.ENTRY , i ) ; }
final DifferentiableMultivariateVectorFunction problem ;
public CircleScalar () { points = new ArrayList < Point2D.Double > () ; }
{ gradient = f . gradient () ; return super . optimize ( maxEval , f , goalType , startPoint ) ; }
DifferentiableMultivariateVectorFunction problem
public CircleVectorial () { points = new ArrayList < Point2D.Double > () ; }
final Quaternion product = Quaternion . product ( inverseQ , q ) ;
final double normSquareRef = Quaternion . product ( q , q . getConjugate () ) . getScalarPart () ;
{ return product ( this , q ) ; }
optimum = new PointValuePair ( fitfun . decode ( bestArx . getColumn ( NUMBER_CONSTANT ) ) , isMinimize ? bestFitness : - bestFitness ) ;
double tmp = wxi * xi / di ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = sparseIterator () ;
Iterator < Entry > it = v . sparseIterator () ;
Iterator < Entry > it = v . sparseIterator () ;
public double [] getStartPoint () { return start . clone () ; }
{ return optimize ( maxEval , f , goalType , startPoint , null , null ) ; }
public double [] getUpperBound () { return upperBound . clone () ; }
public double [] getLowerBound () { return lowerBound . clone () ; }
Math . max ( NUMBER_CONSTANT , NUMBER_CONSTANT - dimension / ( NUMBER_CONSTANT + Math . min ( maxIterations , getMaxEvaluations () / lambda ) ) )
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final int dim = getDimensions () ;
final double [] [] out = new double [ [ sampleSize ] [ numDimensions ] ;
{ random = rng ; numDimensions = n ; }
final int dim = d . getDimensions () ;
final int dim = d . getDimensions () ;
double [] insigma = point ( DIM + NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
double [] insigma = null ;
double [] insigma = null ;
double [] insigma = null ;
final double [] f
jF = new JacobianFunction ( f ) ;
{ distribution . get ( i ) . reseedRandomGenerator ( seed ) ; }
MultivariateFunction f
MultivariateFunction f
final RealMatrix d = createDiagonalMatrix ( eigenValues , n , n ) ;
RealMatrix m = createDiagonalMatrix ( diagonal , diagonal.length , diagonal.length ) ;
{ x = list . remove ( list . size () - NUMBER_CONSTANT ) . getLower () ; }
final double [] sigma = optim . getSigma () ;
double [] currentPoint = getStartPoint () ;
final double [] [] covMatrix = optimizer . getCovariances () ;
final double [] [] covarMatrix = optimizer . getCovariances () ;
qrDecomposition ( computeJacobian ( currentPoint ) ) ;
final RealMatrix j = computeJacobian ( params ) ;
final RealMatrix weightedJacobian = computeJacobian ( currentPoint ) ;
try { testStatistic . gTestGoodnessOfFit ( expected , observed , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( OutOfRangeException ex ) {}
try { testStatistic . gTestGoodnessOfFitPValue ( expected , observed ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NotStrictlyPositiveException ex ) {}
final double residual = - currentResiduals [ i ] ;
{ super . testAdd1000 () ; Assert . assertEquals ( STRING_CONSTANT + STRING_CONSTANT , NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getInternalLength () ) ; }
ResizableDoubleArray other = ( ResizableDoubleArray ) object ;
{ ResizableDoubleArray result = new ResizableDoubleArray () ; copy ( this , result ) ; return result ; }
hashData [ NUMBER_CONSTANT ] = expansionMode ;
expansionMode == MULTIPLICATIVE_MODE
expansionMode == MULTIPLICATIVE_MODE
{ if ( initialDoubleArray != null ) { eDA = new ResizableDoubleArray ( initialDoubleArray ) ; } }
{ if ( initialDoubleArray != null ) { eDA = new StatArray ( initialDoubleArray ) ; } }
{ this ( DEFAULT_INITIAL_CAPACITY , DEFAULT_EXPANSION_FACTOR , NUMBER_CONSTANT + DEFAULT_EXPANSION_FACTOR , ExpansionMode.MULTIPLICATIVE , initialArray ) ; }
hashData [ NUMBER_CONSTANT ] = new Float ( contractionCriteria ) . hashCode () ;
result = result && ( other.contractionCriteria == contractionCriteria ) ;
dest.contractionCriteria = source.contractionCriteria ;
{ checkContractExpand ( getContractionCriteria () , expansionFactor ) ; synchronized ( this ) { this . expansionFactor = expansionFactor ; } }
{ checkContractExpand ( contractionCriteria , getExpansionFactor () ) ; synchronized ( this ) { this . contractionCriteria = contractionCriteria ; } }
public double getContractionCriterion () { return contractionCriteria ; }
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleVectorValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleValueChecker () {}
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimplePointChecker () {}
NaturalRanking ranking = new NaturalRanking ( TiesStrategy.MINIMUM ) ;
{ super ( relativeThreshold , absoluteThreshold ) ; }
@ Deprecated public SimpleUnivariateValueChecker () {}
logBeta ( a , b , epsilon , maxIterations )
RandomDataImpl randomData
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
RandomDataImpl randomData
this . q0 = NUMBER_CONSTANT ;
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
if ( diagonalOnly <= NUMBER_CONSTANT ) { updateCovariance ( hsig , bestArx , arz , arindex , xold ) ; } else { updateCovarianceDiagonalOnly ( hsig , bestArz , xold ) ; }
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
final CodyWaite cw = new CodyWaite ( xa , xb ) ;
@ Override public void reseedRandomGenerator ( long seed ) { randomData . reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataGenerator () ) ; }
@ Override public void reseedRandomGenerator ( long seed ) { reSeed ( seed ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , ( RandomGenerator ) null ) ; }
public EmpiricalDistribution ( int binCount ) { this ( binCount , new RandomDataImpl () ) ; }
filePointer = new BufferedReader ( new InputStreamReader ( valuesFileURL . openStream () ) ) ;
new Weight ( w )
new Weight ( weights )
new Weight ( weights )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( w )
new Weight ( problem . weight () )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( new double [] { NUMBER_CONSTANT } )
new Weight ( circle . weight () )
new Weight ( weights )
new Weight ( weights )
new Weight ( function . getWeight () )
new Weight ( w )
new Weight ( w )
new Weight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( function . getWeight () )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( new double [] { NUMBER_CONSTANT } )
new NonCorrelatedWeight ( circle . weight () )
new NonCorrelatedWeight ( weights )
new NonCorrelatedWeight ( w )
new NonCorrelatedWeight ( problem . weight () )
{ data = d . clone () ; }
public SimplexSolver ( final double epsilon ) { this ( epsilon , DEFAULT_ULPS ) ; }
if ( FastMath . abs ( result ) < CUTOFF_THRESHOLD ) { result = NUMBER_CONSTANT ; }
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , DEFAULT_ULPS ) ; }
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nRows ) ;
final T [] out = buildArray ( field , nCols ) ;
final T [] [] data = buildArray ( field , getRowDimension () , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , columns ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , rows ) ;
final T [] out = buildArray ( getField () , columns ) ;
final T [] outData = buildArray ( getField () , rows ) ;
final T [] outData = buildArray ( getField () , columns ) ;
final T [] [] data = buildArray ( getField () , getRowDimension () , getColumnDimension () ) ;
{ blocks = buildArray ( getField () , blockRows * blockColumns , - NUMBER_CONSTANT ) ; }
final T [] out = buildArray ( data.length + NUMBER_CONSTANT ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
T [] out = buildArray ( data.length ) ;
data = buildArray ( v1.length + v2.length ) ;
data = buildArray ( v1.length + v2.data.length ) ;
data = buildArray ( v1.data.length + v2.length ) ;
data = buildArray ( v1.data.length + v2.data.length ) ;
data = buildArray ( v . getDimension () ) ;
data = buildArray ( size ) ;
data = buildArray ( size ) ;
final T [] [] out = buildArray ( getField () , nRows , getColumnDimension () ) ;
final T [] out = buildArray ( getField () , nCols ) ;
final T [] out = buildArray ( getField () , nRows ) ;
data = buildArray ( getField () , subMatrix.length , nCols ) ;
final T [] [] outData = buildArray ( getField () , nRows , nCols ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
final T [] [] outData = buildArray ( getField () , rowCount , columnCount ) ;
data = buildArray ( getField () , nRows , NUMBER_CONSTANT ) ;
{ super ( field , rowDimension , columnDimension ) ; data = buildArray ( field , rowDimension , columnDimension ) ; }
T [] res = buildArray ( virtualSize ) ;
int exponent = ( int ) ( y . log10 () * NUMBER_CONSTANT ) ;
{ return new Decimal64 ( value % a.value ) ; }
{ return new Decimal64 ( value % a ) ; }
return ePlus . add ( eMinus ) . divide ( ePlus . subtract ( eMinus ) ) ;
DerivativeStructure ref = dsX . subtract ( x - ( x % y ) ) ;
DerivativeStructure sAccurate = u1 . dotProduct ( u2 ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( - NUMBER_CONSTANT , r . getAxis () . dotProduct ( reverted . getAxis () ) . getReal () , NUMBER_CONSTANT ) ;
randomData = new RandomDataImpl ( randomGenerator ) ;
{ super(); this . tiesStrategy = TiesStrategy.RANDOM ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl ( randomGenerator ) ; }
{ super(); this . nanStrategy = nanStrategy ; this . tiesStrategy = tiesStrategy ; randomData = new RandomDataImpl () ; }
{ super(); this . tiesStrategy = tiesStrategy ; nanStrategy = DEFAULT_NAN_STRATEGY ; randomData = new RandomDataImpl () ; }
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
T extends ExtendedFieldElement < T >
@ Test ( expected = MathUnsupportedOperationException . class )
{ getRan () . setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ getRan () . setSeed ( seed ) ; }
final RandomGenerator generator = getRan () ;
{ return new FDistribution ( getRan () , numeratorDf , denominatorDf , FDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ChiSquaredDistribution ( getRan () , df , ChiSquaredDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new CauchyDistribution ( getRan () , median , scale , CauchyDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new BinomialDistribution ( getRan () , numberOfTrials , probabilityOfSuccess ) . sample () ; }
{ return new BetaDistribution ( getRan () , alpha , beta , BetaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ZipfDistribution ( getRan () , numberOfElements , exponent ) . sample () ; }
{ return new WeibullDistribution ( getRan () , shape , scale , WeibullDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new TDistribution ( getRan () , df , TDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new PascalDistribution ( getRan () , r , p ) . sample () ; }
{ return new HypergeometricDistribution ( getRan () , populationSize , numberOfSuccesses , sampleSize ) . sample () ; }
{ return new GammaDistribution ( getRan () , shape , scale , GammaDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
{ return new ExponentialDistribution ( getRan () , mean , ExponentialDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) . sample () ; }
return sigma * getRan () . nextGaussian () + mu ;
{ return new PoissonDistribution ( getRan () , mean , PoissonDistribution.DEFAULT_EPSILON , PoissonDistribution.DEFAULT_MAX_ITERATIONS ) . sample () ; }
RandomGenerator ran = getRan () ;
{ return randomData . nextGaussian ( stats . getMean () , stats . getStandardDeviation () ) ; }
@ Test public void testReciprocalZero () { Assert . assertEquals ( Complex.ZERO . reciprocal () , Complex.NaN ) ; }
{ return ( ( Float . floatToIntBits ( f ) > > > NUMBER_CONSTANT ) & NUMBER_CONSTANT ) - NUMBER_CONSTANT ; }
final long bits = Double . doubleToLongBits ( d ) ;
final long bits = Double . doubleToLongBits ( d ) ;
return abs ( x - Double . longBitsToDouble ( Double . doubleToLongBits ( x ) ^ NUMBER_CONSTANT ) ) ;
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
{ long bits = Double . doubleToLongBits ( x ) ; if ( bits < NUMBER_CONSTANT ) { return - NUMBER_CONSTANT ; } return NUMBER_CONSTANT ; }
long inbits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long bits = Double . doubleToLongBits ( x ) ;
long xl = Double . doubleToLongBits ( d ) ;
File file = new File ( url . getFile () ) ;
{ return Double . longBitsToDouble ( Long.MAX_VALUE & Double . doubleToRawLongBits ( x ) ) ; }
{ return Float . intBitsToFloat ( Integer.MAX_VALUE & Float . floatToRawIntBits ( x ) ) ; }
double [] [] matrix
{ this ( lower , upper , DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ; }
{ fit ( initialMixture , defaultMaxIterations , defaultThreshold ) ; }
sum += FastMath . pow ( distA / distB , NUMBER_CONSTANT / ( fuzzyness - NUMBER_CONSTANT ) ) ;
final double u = FastMath . pow ( membershipMatrix [ i ] [ j ] , fuzzyness ) ;
final long grayCode = i ^ ( i / NUMBER_CONSTANT ) ;
int count = ( samples / centers ) * centers ;
{ this . a [ i ] [ j ] = a [ i + N * j ] ; }
assertArrayEquals ( expected , actual , NUMBER_CONSTANT ) ;
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ double tEnd = test ( NUMBER_CONSTANT ) ; assertEquals ( NUMBER_CONSTANT , tEnd , NUMBER_CONSTANT ) ; }
{ final double midPoint = NUMBER_CONSTANT * diff ; return diff * computeObjectiveValue ( midPoint ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
{ dist = new WeibullDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
incrementValue ( entry . getKey () , entry . getValue () ) ;
Assert . assertEquals ( false , random . nextBoolean () ) ;
{ result [ i ] = r . call () ; }
final int uniDimIndex = iter . next () ;
{ super ( specific , value , NUMBER_CONSTANT , true ) ; }
public NotPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , true ) ; }
{ super ( specific , NUMBER_CONSTANT , arguments ) ; }
{ return expected [ index ] ; }
{ return wrong [ index ] ; }
{ super ( specific , value , NUMBER_CONSTANT , false ) ; }
public NotStrictlyPositiveException ( Number value ) { super ( value , NUMBER_CONSTANT , false ) ; }
{ super ( specific , wrong , expected ) ; dimension = expected ; }
{ secRand = SecureRandom . getInstance ( algorithm , provider ) ; }
SecureRandom secRan = getSecRan () ;
T withConvergenceChecker ( ConvergenceChecker < PointVectorValuePair > checker ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / ArithmeticUtils . factorial ( orders [ k ] ) ; }
RandomDataImpl randomData = new RandomDataImpl () ;
{ coeff [ i ] [ j ] = ( int ) ArithmeticUtils . binomialCoefficient ( i , j ) ; }
long expected = ArithmeticUtils . binomialCoefficient ( i + j , i ) ;
double binomial = ArithmeticUtils . binomialCoefficient ( v + i , i ) ;
double refDer = - ArithmeticUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * ArithmeticUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
double inv = NUMBER_CONSTANT / ArithmeticUtils . factorial ( i ) ;
AbstractOptimizer other
{ return Double . valueOf ( o . toString () ) . doubleValue () ; }
return Double . valueOf ( str ) . doubleValue () ;
{ val = Double . valueOf ( str ) . doubleValue () ; sampleStats . addValue ( val ) ; }
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < Edge > edges = new ArrayList < Edge > () ;
final List < Segment > segments = new ArrayList < Segment > () ;
final List < EventHandler > list = new ArrayList < EventHandler > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > () ;
List < int [] > row = new ArrayList < int [] > () ;
final List < Segment > segments = new ArrayList < Segment > () ;
double [] vectorData = null ;
{ this ( value , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , f . getCount ( THREEE ) ) ;
f . addValue ( THREEE ) ;
{ return new Combinations ( n , k , Combinations.IterationOrder.LEXICOGRAPHIC ) . iterator () ; }
int [] index = getNatural ( n ) ;
{ final int [] natural = MathArrays . natural ( NUMBER_CONSTANT ) ; Assert . assertEquals ( natural.length , NUMBER_CONSTANT ) ; }
AbstractLeastSquaresOptimizer other
if ( a0 > overflow ) { throw new FractionConversionException ( value , a0 , NUMBER_CONSTANT ) ; }
{ return NUMBER_CONSTANT + NUMBER_CONSTANT * + NUMBER_CONSTANT * MathUtils . hash ( value ) + NUMBER_CONSTANT * derivatives . hashCode () ; }
mult . multInPlace ( var1 ) ;
{ return MathArrays . test ( values , weights , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , weights , begin , length , false ) ; }
{ return MathArrays . test ( values , begin , length , allowEmpty ) ; }
{ return MathArrays . test ( values , begin , length , false ) ; }
w = w - NUMBER_CONSTANT ;
num = num % den ;
if ( i > NUMBER_CONSTANT ) { randInt = randInt > > NUMBER_CONSTANT ; }
for ( final T a : data ) { h = h ^ a . hashCode () ; }
rhs [ m ] = rhs [ m ] / X ;
coeff1 = coeff1 / pc2 ;
bits = bits & NUMBER_CONSTANT ;
den = den + NUMBER_CONSTANT ;
trial = trial * NUMBER_CONSTANT ;
den = den + NUMBER_CONSTANT ;
{ bytes [ i ++ ] = ( byte ) ( random & NUMBER_CONSTANT ) ; random = random > > NUMBER_CONSTANT ; }
if ( result == NUMBER_CONSTANT ) { result = result * x ; }
za = za * ya ;
e = e > > NUMBER_CONSTANT ;
z = z * lnb ;
xl = xl & MASK_30BITS ;
r = r * rnd ;
extra = extra - rh * RADIX ;
{ while ( NUMBER_CONSTANT == n % p ) { n = n / p ; factors . add ( p ) ; } }
n = n | NUMBER_CONSTANT ;
xx = xx + NUMBER_CONSTANT / NUMBER_CONSTANT ;
iter = iter + NUMBER_CONSTANT ;
{ data [ i ] = data [ i ] / d ; }
{ data [ i ] = data [ i ] * d ; }
{ data [ i ] = data [ i ] - d ; }
{ data [ i ] = data [ i ] + d ; }
k = k + m ;
coeff1 = coeff1 / pc2 ;
{ c [ NUMBER_CONSTANT ] = c [ NUMBER_CONSTANT ] + NUMBER_CONSTANT ; return ret ; }
coeff1 = coeff1 / pc2 ;
{ m = m > > NUMBER_CONSTANT ; ++ k ; }
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
e = e > > NUMBER_CONSTANT ;
v = v * v ;
{ ret = scale * FastMath . pow ( - FastMath . log ( NUMBER_CONSTANT - p ) , NUMBER_CONSTANT / shape ) ; }
( a * FastMath . log ( x ) ) + ( b * FastMath . log ( NUMBER_CONSTANT - x ) )
return ( FastMath . exp ( ss ) - NUMBER_CONSTANT ) * FastMath . exp ( NUMBER_CONSTANT * scale + ss ) ;
{ correct ( new ArrayRealVector ( z ) ) ; }
{ predict ( new ArrayRealVector ( u ) ) ; }
minadj /= ( divisor.mant [ mant.length - NUMBER_CONSTANT ] + NUMBER_CONSTANT ) ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
final double max = Math.PI ;
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , NUMBER_CONSTANT , Math.PI , - NUMBER_CONSTANT ) ; }
{ FunctionUtils . sample ( new Sin () , Math.PI , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
double x = Math . random () * NUMBER_CONSTANT ;
double x = Math . random () ;
- NUMBER_CONSTANT / ( a * a ) - NUMBER_CONSTANT + Math . cos ( a )
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
minDiff = Math . min ( minDiff , boundDifference [ i ] ) ;
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
{ d [ r ] [ c ] = Math . sqrt ( m . getEntry ( r , c ) ) ; }
{ d [ r ] [ c ] = Math . log ( m . getEntry ( r , c ) ) ; }
double diff = Math . abs ( x [ i ] - repaired [ i ] ) ;
( NUMBER_CONSTANT - ccovmu ) * NUMBER_CONSTANT * mueff / ( Math . pow ( dimension + NUMBER_CONSTANT , NUMBER_CONSTANT ) + NUMBER_CONSTANT * mueff )
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
double diff = Math . abs ( constantValue - filter . getStateEstimation () [ NUMBER_CONSTANT ] ) ;
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
source = { Double.NEGATIVE_INFINITY , - Double.MAX_VALUE , - NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MIN_VALUE , Math . ulp ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , Double.MAX_VALUE , Double.POSITIVE_INFINITY }
for ( k = NUMBER_CONSTANT ; k < DIM ; ++ k ) basis [ i ] [ k ] /= Math . sqrt ( sp ) ;
{ double f = Math . pow ( new DiffPow () . value ( x ) , NUMBER_CONSTANT ) ; return f ; }
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
f += Math . pow ( factor , i / ( x.length - NUMBER_CONSTANT ) ) * x [ i ] * x [ i ] ;
a1 = FastMath . sqrt ( FastMath.PI * twolpd ) * FastMath . exp ( NUMBER_CONSTANT / NUMBER_CONSTANT * lambda )
ret += c [ i ] * ArithmeticUtils . pow ( n , ( long ) i ) ;
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { sample [ i ] = Math . random () ; }
System . arraycopy ( seed , NUMBER_CONSTANT , v , NUMBER_CONSTANT , Math . min ( seed.length , v.length ) ) ;
expected = Math . abs ( period ) - delta ;
final int shift = Math . min ( aTwos , bTwos ) ;
double xabs = Math . abs ( v [ i ] ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Float.MAX_VALUE ) ;
int shift = Math . max ( numerator . bitLength () , denominator . bitLength () ) - FastMath . getExponent ( Double.MAX_VALUE ) ;
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
final int k = ( int ) Math . ceil ( n * d ) ;
{ return NUMBER_CONSTANT - NUMBER_CONSTANT * Math . pow ( NUMBER_CONSTANT - d , n ) ; }
double err = Math . abs ( actual - expected ) / Math . ulp ( expected ) ;
double denom = Math . abs ( val ) < EPS_MIN ? NUMBER_CONSTANT * EPS_MIN : NUMBER_CONSTANT * val ;
{ return Math . exp ( x ) - Math . pow ( Math.PI , NUMBER_CONSTANT ) ; }
new Fraction ( ( ( Math . abs ( w ) * d ) + n ) * MathUtils . copySign ( NUMBER_CONSTANT , w ) , d )
num = Math . abs ( num ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
h += p_i * Math . log ( p_i ) ;
h += p_ij * Math . log ( p_ij ) ;
if ( Math . abs ( sumExpected - sumObserved ) > NUMBER_CONSTANT ) { ratio = sumObserved / sumExpected ; rescale = true ; }
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
final double delta = NUMBER_CONSTANT * Math . abs ( expected ) ;
public double estimateRegressionStandardError () { return Math . sqrt ( estimateErrorVariance () ) ; }
Assert . assertTrue ( STRING_CONSTANT , Math . abs ( v - randomData . nextUniform ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) > NUMBER_CONSTANT ) ;
System . arraycopy ( seed , NUMBER_CONSTANT , rsl , NUMBER_CONSTANT , Math . min ( seedLen , rslLen ) ) ;
Math . sqrt ( d [ col ] ) < tol [ col ]
Math . sqrt ( d [ i ] ) < tol [ i ]
final double result = NUMBER_CONSTANT * Erf . erfc ( ref [ i ] [ NUMBER_CONSTANT ] / Math . sqrt ( NUMBER_CONSTANT ) ) ;
final double originalDelta = Math . random () ;
final double gn = factor1 * Math . log ( qExp1 ) * oneOverN ;
{ public double value ( double x ) { return NUMBER_CONSTANT / ( NUMBER_CONSTANT * Math . sqrt ( x ) ) ; } }
f = new UnivariateFunction () { public double value ( double x ) { return Math . sqrt ( x ) ; } }
{ minValue = entry ; minPos = i ; if ( pivotSelection == PivotSelectionRule.Bland && isValidPivotColumn ( tableau , i ) ) { break; } }
this . pivotSelection = PivotSelectionRule.Dantzig ;
solution = new SimplexSolver () . optimize ( DEFAULT_MAX_ITER , f , new DeterministicLinearConstraintSet ( constraints ) , GoalType.MINIMIZE , new NonNegativeConstraint ( true ) , PivotSelectionRule.BLAND )
{ this ( f , constraints , goalType , restrictToNonNegative , epsilon , SimplexSolver.DEFAULT_ULPS , SimplexSolver.DEFAULT_CUT_OFF ) ; }
if ( Precision . compareTo ( entry , NUMBER_CONSTANT , maxUlps ) > NUMBER_CONSTANT ) { return true ; }
final Vector < S > point
final Vector < Euclidean2D > point
final Vector < Euclidean2D > point
final Vector < Euclidean2D > point
final Vector < Euclidean1D > point
final Vector < Euclidean2D > point
Vector < S > point
final Vector < Euclidean3D > point
final Vector < Euclidean3D > point
final Vector < Euclidean1D > point
final Vector < Euclidean3D > point
final Vector < S > point
{ final Vector2D v2 = ( Vector2D ) v ; return x * v2.x + y * v2.y ; }
final Vector < S > barycenter
final Vector < S > point
final Vector < S > point
final Vector < Euclidean1D > point
public ArcsSet wholeSpace () { return new ArcsSet () ; }
{ return Vector3D . angle ( pole , direction ) - radius ; }
public SphericalPolygonsSet wholeSpace () { return new SphericalPolygonsSet () ; }
public SubCircle wholeHyperplane () { return new SubCircle ( this , new ArcsSet () ) ; }
{ this ( circle.pole , circle.x , circle.y , circle.radius , circle.cos , circle.sin ) ; }
{ return new ArcsSet ( tree ) ; }
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final Vector1D x = thisLine . toSubSpace ( crossing ) ;
final double offset = plane . getOffset ( point ) ;
Vector < Euclidean2D > p
Vector < Euclidean1D > p
Vector < Euclidean3D > v
final Vector3D point = line . toSpace ( Vector1D.ZERO ) ;
public SubChord copySelf () { return new SubChord ( chord , limits ) ; }
{ this . upper = NUMBER_CONSTANT * FastMath.PI + lower ; }
Arc arc = new Arc ( NUMBER_CONSTANT , FastMath . nextAfter ( NUMBER_CONSTANT , Double.POSITIVE_INFINITY ) ) ;
{ return buildNew ( hyperplane , remainingRegion ) ; }
Segment segment = new Segment ( p1 , p2 , new Line ( p1 , p2 ) ) ;
final EdgesBuilder visitor = new EdgesBuilder ( root , tolerance ) ;
{ return new SphericalPolygonsSet ( tree , tolerance ) ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public SphericalPolygonsSet ( final double tolerance ) { this . tolerance = tolerance ; }
return getRemainingRegion () . side ( new OrientedPoint ( x , direct ) ) ;
public SubLine wholeLine () { return new SubLine ( this , new IntervalsSet () ) ; }
{ return distance ( p ) < NUMBER_CONSTANT ; }
final BSPTree < S > cell = node . getCell ( point ) ;
{ return new PolyhedronsSet ( tree ) ; }
public IntervalsSet wholeSpace () { return new IntervalsSet () ; }
{ add ( new NestedLoops ( bLoop ) ) ; }
return new OrientedPoint ( newLoc , op . isDirect () ) . wholeHyperplane () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
public PolygonsSet wholeSpace () { return new PolygonsSet () ; }
public SubLine wholeHyperplane () { return new SubLine ( this , new IntervalsSet () ) ; }
if ( FastMath . abs ( d ) < NUMBER_CONSTANT ) { return null ; }
{ return new PolygonsSet ( tree ) ; }
if ( line == null ) { line = new Line ( start . getLocation () , end . getLocation () ) ; }
{ return new ArcsSet ( tree , tolerance ) ; }
{ return new LimitAngle ( new S1Point ( alpha ) , true , tolerance ) . wholeHyperplane () ; }
{ return new LimitAngle ( new S1Point ( alpha ) , false , tolerance ) . wholeHyperplane () ; }
{ super ( boundary ) ; this . tolerance = tolerance ; }
{ super ( tree ) ; this . tolerance = tolerance ; }
public ArcsSet ( final double tolerance ) { this . tolerance = tolerance ; }
Segment segment = new Segment ( start , end , new Line ( start , end ) ) ;
{ return new Line ( start , end ) . wholeHyperplane () ; }
return new PolygonsSet ( edges ) ;
final BoundaryProjector projector = new BoundaryProjector () ;
public PolyhedronsSet wholeSpace () { return new PolyhedronsSet () ; }
public SubPlane wholeHyperplane () { return new SubPlane ( this , new PolygonsSet () ) ; }
final Plane plane = new Plane ( origin . add ( translation ) , w ) ;
PolyhedronsSet tree = new PolyhedronsSet ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new IntervalsSet ( tree ) ; }
boundary . add ( new LimitAngle ( new S1Point ( MathUtils.TWO_PI ) , true , NUMBER_CONSTANT ) . wholeHyperplane () ) ;
( Boolean ) getTree ( false ) . getAttribute ()
Assert . assertTrue ( projection . get0riginal () == v ) ;
List < P > points
final List < P > points
ConvexHull2D hull = generator . generate ( points ) ;
GrahamScan2D generator = new GrahamScan2D () ;
RandomGenerator random = new MersenneTwister ( NUMBER_CONSTANT ) ;
@ Before public void setUp () { generator = createConvexHullGenerator () ; random = new MersenneTwister ( NUMBER_CONSTANT ) ; }
final Collection < Vector2D > points
checkConvexHull ( points , hull ) ;
ConvexHullGenerator2D generator = new MonotoneChain () ;
public Segment [] getLineSegments () { return lineSegments . clone () ; }
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_I ) . ballOnSupport ( support ) ;
cap = new SphericalCapGenerator ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . ballOnSupport ( support )
cap = new SphericalCapGenerator ( new Vector3D ( - NUMBER_CONSTANT , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) . ballOnSupport ( support )
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
EnclosingBall < Sphere2D , S2Point > cap = new SphericalCapGenerator ( Vector3D.MINUS_K ) . ballOnSupport ( support ) ;
{ return new EnclosingBall < Sphere2D , S2Point > ( new S2Point ( outside . negate () ) , - NUMBER_CONSTANT ) ; }
@ Override protected ConvexHullGenerator2D createConvexHullGenerator ( boolean includeCollinearPoints ) { return new GrahamScan ( includeCollinearPoints ) ; }
{ return getOptimizer ( points ) . optimize () . getPoint () ; }
boolean useLU
{ return LevenbergMarquardtOptimizer . create () ; }
optimizer = LevenbergMarquardtOptimizer . create () . withInitialStepBoundFactor ( initialStepBoundFactor ) . withCostRelativeTolerance ( costRelativeTolerance ) . withParameterRelativeTolerance ( parRelativeTolerance ) . withOrthoTolerance ( orthoTolerance ) . withRankingThreshold ( Precision.SAFE_MIN )
{ return new LeastSquaresProblemImpl ( maxEvaluations , maxIterations , checker , observed , model , jacobian , start ) ; }
public RealMatrix computeJacobian () { return MatrixUtils . createRealMatrix ( this . jacobian ) ; }
public double [] computeValue () { return this . values ; }
@ Test public void testGaussNewtonQR ( ) throws Exception { check ( new GaussNewtonOptimizer ( false ) ) ; }
@ Test public void testGaussNewtonLU ( ) throws Exception { check ( new GaussNewtonOptimizer ( true ) ) ; }
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
final ConvergenceChecker < PointVectorValuePair > checker
{ return new LeastSquaresBuilder () . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxEvaluations ( NUMBER_CONSTANT ) . maxIterations ( getMaxIterations () ) ; }
builder ( circle ) . checker ( new SimpleVectorValueChecker ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ) . maxIterations ( Integer.MAX_VALUE )
function . checkTheoreticalMinParams ( optimum . getPoint () ) ;
double [] point
double [] computeValue ( ) ;
double [] point
double [] getStart ( ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
final double [] point
final double [] point
final double [] start
final double [] target
public RealVector computeValue () { return unweighted . computeValue () ; }
catch ( NonPositiveDefiniteMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
catch ( SingularMatrixException e ) { throw new ConvergenceException ( LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertTrue ( optimum . computeRMS () > NUMBER_CONSTANT ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
Assert . assertEquals ( NUMBER_CONSTANT , optimum . computeRMS () , TOl ) ;
RealVector computeValue ( ) ;
final double cost = lsp . evaluate ( params ) . computeCost () ;
final RealVector sigma = lsp . evaluate ( regress ) . computeSigma ( NUMBER_CONSTANT ) ;
final RealVector sigma = lsp . evaluate ( init ) . computeSigma ( NUMBER_CONSTANT ) ;
function . checkTheoreticalMinCost ( optimum . computeRMS () ) ;
final double [] asymptoticStandardErrorFound = optimum . computeSigma ( NUMBER_CONSTANT ) . toArray () ;
final RealMatrix covarMatrix = optimum . computeCovariances ( NUMBER_CONSTANT ) ;
final double actual = lsp . evaluate ( lsp . getStart () ) . computeRMS () ;
final double cost = lsp . evaluate ( lsp . getStart () ) . computeCost () ;
Assert . assertArrayEquals ( evaluation . computeResiduals () . toArray () , new double [] { NUMBER_CONSTANT , - NUMBER_CONSTANT } , Precision.EPSILON ) ;
Assert . assertNotSame ( STRING_CONSTANT , v1 . getDataRef () , v_copy . getData () ) ;
{ return new LeastSquaresProblemImpl ( model , observed , start , checker , maxEvaluations , maxIterations ) ; }
assertEquals ( TOl , optimum . getValue () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
line = new LineSearch ( lineRel , lineAbs ) ;
line = new LineSearch ( this , lineRel , lineAbs ) ;
{ this ( updateFormula , checker , NUMBER_CONSTANT , NUMBER_CONSTANT , new IdentityPreconditioner () ) ; }
penalty += diff * valueRange ;
public FitnessFunction () { valueRange = NUMBER_CONSTANT ; isRepairMode = true ; }
{ super . newSampleData ( data , nobs , nvars ) ; qr = new QRDecomposition ( getX () ) ; }
public RealVector getResiduals () { return this . residuals ; }
public RealVector getPoint () { return this . point ; }
public RealMatrix getJacobian () { return this . jacobian ; }
super ( null ) ;
@ Override protected RealDistribution getKernel ( SummaryStatistics bStats ) { return new ConstantDistribution ( bStats . getMean () ) ; }
return new Median () . withEstimationtype ( type ) . withNaNStrategy ( strategy ) ;
double result = new Percentile ( p ) . withEstimationtype ( e ) . withNaNStrategy ( nanStrategy ) . evaluate ( data ) ;
{ new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.LEGACY ) . withNaNStrategy ( null ) ; Assert . fail ( STRING_CONSTANT + STRING_CONSTANT ) ; }
new Percentile ( NUMBER_CONSTANT ) . withEstimationtype ( Percentile.EstimationType.R_9 ) . withNaNStrategy ( NaNStrategy.FAILED ) . evaluate ( specialValues , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Percentile ( quantile ) . withEstimationtype ( type ) . withNaNStrategy ( nanStrategy ) . withPivotingStrategy ( pivotingStrategy ) ; }
final BicubicSplineInterpolator bsi = new BicubicSplineInterpolator () ;
return new BicubicSplineInterpolatingFunction ( xval , yval , fval , dFdX , dFdY , d2FdXdY ) ;
final FieldMatrix < BigFraction > H = this . createH ( d , n ) ;
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
Percentile p = getUnivariateStatistic () ;
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testWeightedConsistency () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegment () ; } }
{ for ( Percentile.EstimationType e : Percentile.EstimationType . values () ) { reset ( quantile , e ) ; testEvaluateArraySegmentWeighted () ; } }
UnivariateStatistic percentile = getUnivariateStatistic () ;
UnivariateStatistic percentile = getUnivariateStatistic () ;
Percentile percentile = new Percentile ( NUMBER_CONSTANT ) ;
{ return new Median ( getEstimationType () , newNaNStrategy , getPivotingStrategy () ) ; }
{ return new Median ( newEstimationType , getNaNStrategy () , getPivotingStrategy () ) ; }
return work.length == NUMBER_CONSTANT ? Double.NaN : estimationType . evaluate ( work , pivotsHeap , p , pivotingStrategy ) ;
pivotingStrategy = original . getPivotingStrategy () ;
final double Umin = x.length * y.length - Umax ;
{ return new LazyUnweightedEvaluation ( model , target , p ) ; }
Assert . assertEquals ( NUMBER_CONSTANT , ( ( ResizableDoubleArray ) da ) . getContractionCriteria () , NUMBER_CONSTANT ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
ResizableDoubleArray testDa = new ResizableDoubleArray ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , ResizableDoubleArray.ADDITIVE_MODE ) ;
RandomDataImpl random = new RandomDataImpl () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData ) ;
{ this . randomData = new RandomDataImpl ( generator ) ; }
{ this . randomData = randomData ; }
{ return ( FastMath.PI * FastMath.PI / NUMBER_CONSTANT ) * ( NUMBER_CONSTANT / ( s * s ) ) ; }
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final FDistribution fdist = new FDistribution ( a.dfbg , a.dfwg ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( expected.length - NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( numberOfTrials , probability ) ;
{ super . newXSampleData ( x ) ; qr = new QRDecomposition ( getX () ) ; }
t . insertInTree ( parentTree , isPlusChild ) ;
return ( sin * otherL.sin + cos * otherL.cos ) >= NUMBER_CONSTANT ;
tree = region1 . getTree ( false ) . merge ( region2 . getTree ( false ) , new DifferenceMerger () )
{ originOffset = offset ; }
if ( p == NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else if ( p == NUMBER_CONSTANT ) { return Double.POSITIVE_INFINITY ; }
{ vals = Arrays . copyOf ( b , b.length ) ; nVals = n ; }
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
org.apache.commons.math3.stat.inference.ChiSquareTest csti = new org.apache.commons.math3.stat.inference.ChiSquareTest () ;
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
cachedTransform = org.apache.commons.math3.geometry.euclidean.twod.Line . getTransform ( at ) ;
@ Test ( expected = org.apache.commons.math3.linear.SingularMatrixException . class )
( numIterations < maximumIterations ) && ( a > lowerBound || b > upperBound )
public Well19937c ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937c ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well512a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497b ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well1024a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well1024a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well44497a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( long seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
{ super ( K , M1 , M2 , M3 , seed ) ; }
public Well19937a ( int seed ) { super ( K , M1 , M2 , M3 , seed ) ; }
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest , normTolerance ) ;
TestUtils . assertEquals ( m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . getData () ) , preMultTest ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
x = new UniformRealDistribution ( rng , lo , hi , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
tP = new UniformRealDistribution ( rng , NUMBER_CONSTANT , MathUtils.TWO_PI , UniformRealDistribution.DEFAULT_INVERSE_ABSOLUTE_ACCURACY ) ;
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
{ double actual = getDistribution () . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . assertEquals ( NUMBER_CONSTANT , actual , NUMBER_CONSTANT ) ; }
distribution . cumulativeProbability ( lower [ i ] , upper [ i ] )
final double withinBinKernelMass = kernel . cumulativeProbability ( lower , upper ) ;
try { distribution . cumulativeProbability ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
( ( AbstractRealDistribution ) distribution ) . logDensity ( cumulativeTestPoints [ i ] )
@ Test ( expected = MathIllegalArgumentException . class ) public void testNullFunction () { UnivariateSolverUtils . bracket ( null , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
try { StatUtils . min ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . max ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . variance ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
try { StatUtils . mean ( x , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathIllegalArgumentException ex ) {}
@ Test ( expected = MathIllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
tournamentPopulation = new ListPopulation ( this . arity ) { public Population nextGeneration () { return null ; } }
delta = ( max - min ) / ( ( double ) binCount ) ;
T reciprocal ( ) ;
delta = ( max - min ) / ( binCount ) ;
protected double getSolverAbsoluteAccuracy () { return solverAbsoluteAccuracy ; }
SparseGradient sgY2 = sgX . compose ( poly . value ( x ) , poly . derivative () . value ( x ) ) ;
Assert . assertEquals ( f . polynomialDerivative () . derivative () . value ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , tolerance ) ;
UnivariateFunction dSpline = spline . derivative () ;
{ return FastMath . abs ( getOffset ( p ) ) < NUMBER_CONSTANT ; }
if ( direction . getNorm () < NUMBER_CONSTANT ) { return null ; }
test ( values , weights , begin , length , true )
test ( values , begin , length , true )
m . evaluate ( values ) ;
test ( values , begin , length , true )
test ( values , begin , length , true )
test ( values , begin , length ) && length > NUMBER_CONSTANT
test ( values , start , length ) ;
test ( values , begin , length )
test ( values , begin , length )
test ( values , begin , length ) ;
test ( values , weights , begin , length , true )
{ test ( values , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; return evaluate ( values , NUMBER_CONSTANT , values.length ) ; }
ptile . evaluate ( d ) ;
test ( values , weights , begin , length )
test ( values , begin , length )
test ( values , weights , begin , length )
test ( values , begin , length )
m . evaluate ( values ) ;
catch ( IllegalArgumentException iae ) {}
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
catch ( IllegalArgumentException iae ) { return true ; }
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
try { stats . setWindowSize ( - NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
{ try { new DummyBinaryChromosome ( repr ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {} }
catch ( IllegalArgumentException iae ) {}
final double Hs = generalizedHarmonic ( N , s ) ;
final double Hs = generalizedHarmonic ( N , s ) ;
return generalizedHarmonic ( x , exponent ) / generalizedHarmonic ( numberOfElements , exponent ) ;
return - FastMath . log ( x ) * exponent - FastMath . log ( generalizedHarmonic ( numberOfElements , exponent ) ) ;
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x ) { return Double.NaN ; }
if ( x != x || y != y ) { return Double.NaN ; }
if ( x != x || x == NUMBER_CONSTANT ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
if ( x != x ) { return x ; }
{ super ( LocalizedFormats.UNKNOWN_PARAMETER ) ; this . name = name ; }
final int exponent
MultivariateInterpolator interpolator = new MicrosphereInterpolator () ;
int brightnessExponent
{ return ( BigInteger.ZERO . compareTo ( numerator ) <= NUMBER_CONSTANT ) ? this : negate () ; }
final long numCalls = numberOfCalls . incrementAndGet () ;
final Gaussian neighbourhoodDecay = new Gaussian ( currentLearning , NUMBER_CONSTANT , NUMBER_CONSTANT / currentNeighbourhood ) ;
{ return new Fraction ( numerator , denominator * i ) ; }
{ return new Fraction ( numerator * i , denominator ) ; }
TestUtils . assertRelativelyEquals ( expected , ZipfRejectionSampler . helper2 ( testValue ) * testValue , tol ) ;
evaluations . setMaximalCount ( maxEvaluations ) ;
int rowOffset = NUMBER_CONSTANT ;
int swaps = NUMBER_CONSTANT ;
{ if ( x < NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return FastMath . pow ( NUMBER_CONSTANT - probabilityOfSuccess , x ) * probabilityOfSuccess ; } }
SQRT_TWO_PI / x * FastMath . pow ( y , absX + NUMBER_CONSTANT ) * FastMath . exp ( - y )
return new CorrelatedRandomVectorGenerator ( new double [ cov.length ] , matrix , small , new GaussianRandomGenerator ( new JDKRandomGenerator () ) ) ;
public BigFractionMatrixConverter () { super ( BigFraction.ZERO ) ; }
public FractionMatrixConverter () { super ( Fraction.ZERO ) ; }
final FieldUnivariateFunction < T > f
final FieldUnivariateFunction < T > f
FieldUnivariateFunction < Dfp > f
final EnumeratedRealDistribution dist = new EnumeratedRealDistribution ( combined ) ;
public JDKRandomGenerator ( int seed ) { setSeed ( seed ) ; }
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
starter . addStepHandler ( new NordsieckInitializer ( nSteps , y0.length ) ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
StepInterpolatorTestUtils . checkDerivativesConsistency ( integ , pb , NUMBER_CONSTANT ) ;
{ evaluations . incrementCount () ; expandable . computeDerivatives ( t , y , yDot ) ; }
evaluations . resetCount () ;
catch ( InitializationCompletedMarkerException icme ) { getEvaluationsCounter () . incrementCount ( starter . getEvaluations () ) ; }
FieldVector3D < DerivativeStructure > axis = r . getAxis () ;
FieldVector3D < Dfp > axis = r . getAxis () ;
Vector3D axis = r . getAxis () ;
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
{ return r1 . applyInverseTo ( r2 ) . getAngle () ; }
final Rotation composite = r3 . applyTo ( r2 . applyTo ( r1 ) ) ;
{ try { return super . nextInt ( n ) ; } catch ( IllegalArgumentException e ) { throw new NotStrictlyPositiveException ( n ) ; } }
{ setSeed ( RandomGeneratorFactory . convertToLong ( seed ) ) ; }
{ setSeed ( ( long ) seed ) ; }
setSeed ( seed ) ;
{ setSeed ( seed ) ; }
public ISAACRandom ( long seed ) { setSeed ( seed ) ; }
{ setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( seed ) ; }
{ mt = new int [ N ] ; setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ bits = ( nextInt () > > > NUMBER_CONSTANT ) ; val = bits % n ; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
if ( seed == null ) { setSeed ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeed ( new int [] { seed } ) ; }
return computeInterpolatedStateAndDerivatives ( equations , theta , oneMinusThetaH ) ;
equations = null ;
yDotK [ NUMBER_CONSTANT ] = stepStart . getDerivative () ;
mainSetDimension = eqn . getState () . length ;
final FieldBracketingNthOrderBrentSolver < T > solver
final FieldBracketingNthOrderBrentSolver < T > solver
FieldBracketingNthOrderBrentSolver < T > solver
public TestProblem5 () { super(); setFinalConditions ( NUMBER_CONSTANT * t0 - t1 ) ; }
i < n
i < n
i < n
for ( int i = NUMBER_CONSTANT ; i < n ; ++ i ) { y [ i ] = c ; }
i < n
currentState = y . clone () ;
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
super ( field , METHOD_NAME , false , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , false , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
start . subtract ( problem . getInitialTime () ) . divide ( integrator . getCurrentSignedStepsize () ) . abs () . getReal () > NUMBER_CONSTANT
{ super ( field ) ; setFinalConditions ( getInitialTime () . multiply ( NUMBER_CONSTANT ) . subtract ( getFinalTime () ) ) ; }
super ( field , METHOD_NAME , true , minStep , maxStep , vecAbsoluteTolerance , vecRelativeTolerance ) ;
super ( field , METHOD_NAME , true , minStep , maxStep , scalAbsoluteTolerance , scalRelativeTolerance ) ;
{ return new EulerFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new GillFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T one = time . getField () . getOne () ;
{ return new MidpointFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new LutherFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new ThreeEighthesFieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return new DormandPrince853FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ finalizeStep () ; return doCopy () ; }
final T coeffDot1 = time . getField () . getOne () . subtract ( coeffDot2 ) ;
final T one = time . getField () . getOne () ;
{ return new HighamHall54FieldStepInterpolator < T > ( this , forward , mapper ) ; }
{ return integrator . getField () . getOne () . multiply ( p ) . divide ( q ) ; }
d = MathArrays . buildArray ( integrator . getField () , NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
{ return new ClassicalRungeKuttaFieldStepInterpolator < T > ( this , forward , mapper ) ; }
final T two = getField () . getOne () . multiply ( NUMBER_CONSTANT ) ;
{ return getField () . getOne () . multiply ( p ) . divide ( q ) ; }
{ return new EulerFieldStepInterpolator <> ( field , forward , mapper ) ; }
mapper = new FieldEquationsMapper <> ( mapper , secondary . getDimension () ) ;
FieldFirstOrderDifferentialEquations < T > eqn = new SinCos <> ( field ) ;
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos <> ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
integrator . integrate ( new FieldExpandableODE <> ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( equations ) , new FieldODEState < T > ( t0 , y0 ) , t ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
integ . integrate ( new FieldExpandableODE <> ( pb ) , pb . getInitialState () , pb . getFinalTime () ) ;
steps . add ( interpolator . copy () ) ;
for ( FieldStepInterpolator < T > interpolator : model.steps ) { steps . add ( interpolator . copy () ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryDerivative ( index - NUMBER_CONSTANT ) , yDot ) ; }
while ( ++ index < getNumberOfEquations () ) { insertEquationData ( index , state . getSecondaryState ( index - NUMBER_CONSTANT ) , y ) ; }
{ System . arraycopy ( mapper.start , NUMBER_CONSTANT , start , NUMBER_CONSTANT , index ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
@ Test public void testDerivativesConsistency () { doTestDerivativesConsistency ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testUnstableDerivative () { doTestUnstableDerivative ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testTooLargeFirstStep () { doTestTooLargeFirstStep ( Decimal64Field . getInstance () ) ; }
@ Test public void testSingleStep () { doTestSingleStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testStepSize () { doTestStepSize ( Decimal64Field . getInstance () , NUMBER_CONSTANT ) ; }
@ Test public void testKepler () { doTestKepler ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testBackward () { doTestBackward ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testBigStep () { doTestBigStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testSmallStep () { doTestSmallStep ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ; }
@ Test public void testDecreasingSteps () { doTestDecreasingSteps ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testSanityChecks () { doTestSanityChecks ( Decimal64Field . getInstance () ) ; }
@ Test public void testMissedEndEvent () { doTestMissedEndEvent ( Decimal64Field . getInstance () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
@ Test public void testNonFieldIntegratorConsistency () { doTestNonFieldIntegratorConsistency ( Decimal64Field . getInstance () ) ; }
FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > eqn
final FieldFirstOrderDifferentialEquations < T > eqn
final FieldFirstOrderIntegrator < T > integrator
final FieldFirstOrderDifferentialEquations < T > equations
final FieldFirstOrderDifferentialEquations < T > primary
@ Test ( expected = MaxCountExceededException . class ) public void exceedMaxEvaluations () { doExceedMaxEvaluations ( Decimal64Field . getInstance () ) ; }
{ return taylor ( getPreviousState () , time , scalingH , scaled , nordsieck ) ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ setSeedInternal ( new int [] { seed } ) ; }
if ( seed == null ) { setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; return; }
{ bits = nextInt () > > > NUMBER_CONSTANT ; val = bits % n ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( seed ) ; }
{ mt = new int [ N ] ; setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
{ setSeedInternal ( seed ) ; }
public ISAACRandom ( long seed ) { setSeedInternal ( seed ) ; }
{ setSeedInternal ( System . currentTimeMillis () + System . identityHashCode ( this ) ) ; }
setSeedInternal ( seed ) ;
{ return timeAndReport ( title , DEFAULT_REPEAT_CHUNK , DEFAULT_REPEAT_STAT , false , methods ) ; }
double sample ( ) ;
random = new Well44497b ( seed ) ;
{ this ( cityList , numNeuronsPerCity , new Well44497b () . nextLong () ) ; }
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , ( double ) observed1.length - NUMBER_CONSTANT ) ;
final ChiSquaredDistribution distribution = new ChiSquaredDistribution ( null , expected.length - NUMBER_CONSTANT ) ;
{ final double u = random . nextDouble () ; return u * upper + ( NUMBER_CONSTANT - u ) * lower ; }
return empiricalDistribution . getNextValue () ;
empiricalDistribution = new EmpiricalDistribution ( binCount , randomData . getRandomGenerator () ) ;
{ super ( null ) ; this . value = value ; }
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final FDistribution fdist = new FDistribution ( null , a.dfbg , a.dfwg ) ;
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , degreesOfFreedom ) ;
final TDistribution distribution = new TDistribution ( null , n - NUMBER_CONSTANT ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final KolmogorovSmirnovTest test = new KolmogorovSmirnovTest ( new Well19937c ( NUMBER_CONSTANT ) ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final NormalDistribution standardNormal = new NormalDistribution ( null , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final BinomialDistribution distribution = new BinomialDistribution ( null , numberOfTrials , probability ) ;
{ randomSource = RandomSource.WELL_19937_C ; }
return complexSolver . solve ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
return complexSolver . solveAll ( ComplexUtils . convertToComplex ( coefficients ) , new Complex ( initial , NUMBER_CONSTANT ) ) ;
final Complex c [] = ComplexUtils . convertToComplex ( getCoefficients () ) ;
RandomGenerator rng = new Well19937c ( NUMBER_CONSTANT ) ;
NormalDistribution distribution
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
if ( shuffle ) { Collections . shuffle ( points ) ; }
for ( int i = NUMBER_CONSTANT ; i < dim ; i ++ ) { normalVals [ i ] = random . nextGaussian () ; }
cachedD = MatrixUtils . createRealDiagonalMatrix ( realEigenvalues ) ;
ComplexFormat cf = ComplexFormat . getInstance () ;
ComplexFormat cf = ComplexFormat . getInstance () ;
RandomGenerator randomGenerator
public NaturalRanking ( RandomGenerator randomGenerator ) { this ( DEFAULT_NAN_STRATEGY , TiesStrategy.RANDOM , randomGenerator ) ; }
{ this ( nanStrategy , tiesStrategy , new Well19937c () ) ; }
{ this ( DEFAULT_NAN_STRATEGY , tiesStrategy , new Well19937c () ) ; }
final RandomGenerator random
final RandomGenerator random
{ this ( k , maxIterations , measure , new JDKRandomGenerator () ) ; }
final RandomGenerator random
{ this ( k , fuzziness , maxIterations , measure , DEFAULT_EPSILON , new JDKRandomGenerator () ) ; }
final RandomGenerator random = new JDKRandomGenerator () ;
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
RandomGenerator randGen = getRandomGenerator () ;
final RandomGenerator random
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
{ d [ r ] [ c ] = random . nextGaussian () ; }
for ( int i = NUMBER_CONSTANT ; i < size ; i ++ ) { randn [ i ] = random . nextGaussian () ; }
final RandomGenerator generator
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
UnitSphereRandomVectorGenerator random = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , new Well1024a ( NUMBER_CONSTANT ) ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
final double comp = rand . nextGaussian () ;
{ this ( dimension , new MersenneTwister () ) ; }
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator generator = new Well1024a ( NUMBER_CONSTANT ) ;
{ field = new DfpField ( NUMBER_CONSTANT ) ; generator = new MersenneTwister ( NUMBER_CONSTANT ) ; }
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well19937a ( NUMBER_CONSTANT ) ;
final RandomGenerator r
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator r = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
Well1024a random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator random = new Well1024a ( NUMBER_CONSTANT ) ;
RandomGenerator rng = new Well1024a ( NUMBER_CONSTANT ) ;
new PivotingStrategyInterface [] { new MedianOf3PivotingStrategy () , new CentralPivotingStrategy () , new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) }
kthSelector = new KthSelector ( new RandomPivotingStrategy ( RandomSource . create ( RandomSource.WELL_1024_A , NUMBER_CONSTANT ) ) ) ;
final RandomGenerator rng = new MersenneTwister () ;
return TestUtils . gTest ( expected , observed ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) ) ; }
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) ) ; }
this . rng = new Well19937c ( seed ) ;
rng = new Well19937c ( seed ) ;
RandomGenerator random = new MersenneTwister () ;
final RandomGenerator random = GeneticAlgorithm . getRandomGenerator () ;
final Collection < Neuron > exclude = new ArrayList < Neuron > () ;
ArrayFieldVector < T > out = new ArrayFieldVector < T > ( field , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , v ) ; }
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
final FieldMatrix < T > out = new Array2DRowFieldMatrix < T > ( field , m , n ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
return new ArrayFieldVector < T > ( field , out , false ) ;
{ return new ArrayFieldVector < T > ( this , true ) ; }
{ components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ; firstIndex = primary . getDimension () ; }
this . components = new ArrayList < ExpandableStatefulODE.SecondaryComponent > () ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
DescriptiveStatistics u = new ListUnivariateImpl ( new ArrayList < Object > () , transformers ) ;
List < Object > externalList = new ArrayList < Object > () ;
List < Double > valuesList = new ArrayList < Double > () ;
List < Chromosome > popList = new LinkedList < Chromosome > () ;
return new Array2DRowFieldMatrix < Fraction > ( out ) ;
Array2DRowFieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new Array2DRowFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( testData ) ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
Collection < StatisticalSummary > aggregate = new ArrayList < StatisticalSummary > () ;
Collection < SummaryStatistics > aggregate = new ArrayList < SummaryStatistics > () ;
return new FieldODEStateAndDerivative < T > ( time , y , yDot ) ;
this . interpolator = new PerfectInterpolator < T > ( problem ) ;
this . circles = new ArrayList < Circle > () ;
ContinuousOutputFieldModel < T > otherCm = new ContinuousOutputFieldModel < T > () ;
ContinuousOutputFieldModel < T > cm = new ContinuousOutputFieldModel < T > () ;
{ new SparseFieldMatrix < Fraction > ( field , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
return new ArrayFieldVector < Fraction > ( data , false ) ;
assertClose ( STRING_CONSTANT , m . preMultiply ( new ArrayFieldVector < Fraction > ( testVector ) . toArray () ) , preMultTest , normTolerance ) ;
assertClose ( STRING_CONSTANT , testVector , m . operate ( new ArrayFieldVector < Fraction > ( testVector ) ) . toArray () , entryTolerance ) ;
assertClose ( STRING_CONSTANT , m . multiply ( new Array2DRowFieldMatrix < Fraction > ( FractionField . getInstance () , testDataInv ) ) , identity , entryTolerance ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
List < SubHyperplane < Sphere1D > > boundary = new ArrayList < SubHyperplane < Sphere1D > > () ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
singletons = new ArrayList < T > ( pmf . size () ) ;
{ return new GillFieldIntegrator < T > ( field , field . getOne () ) ; }
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > clusterer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final DBSCANClusterer < DoublePoint > transformer = new DBSCANClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
HashSet < Object > sampSet = new HashSet < Object > () ;
final List < double [] > coordinatesList = new ArrayList < double [] > () ;
final List < Neuron > list = new ArrayList < Neuron > () ;
final List < City > cityList = new ArrayList < City > () ;
public CircleVectorial () { points = new ArrayList < Vector2D > () ; }
{ return new MidpointFieldIntegrator < T > ( field , field . getOne () ) ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
this . convexCellsInsidePoints = new ArrayList < Vector3D > () ;
root = new BSPTree < S > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
{ parametersNames = new ArrayList < String > () ; parametersNames . addAll ( names ) ; }
parametersNames = new ArrayList < String > () ;
return new Array2DRowFieldMatrix < T > ( field , d , false ) ;
{ map = new HashMap < Class < > , NumberTransformer > () ; defaultTransformer = new DefaultTransformer () ; }
final Set < T > oneSet = new HashSet < T > ( one ) ;
final List < T > neighbors = new ArrayList < T > () ;
List < T > seeds = new ArrayList < T > ( neighbors ) ;
final List < Segment > segments = new ArrayList < Segment > ( list . size () ) ;
return new Pair < RealMatrix , RealVector > ( normal , jTr ) ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
List < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
Collection < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
ArrayList < LinearConstraint > constraints = new ArrayList < LinearConstraint > () ;
{ points = new ArrayList < double [] > () ; sigma = error ; }
final List < Long > linkEnd = new ArrayList < Long > () ;
List < Chromosome > chromosomes = new ArrayList < Chromosome > ( population . getChromosomes () ) ;
List < Comparable < > > modeList = new ArrayList < Comparable < > > () ;
this . features = new AtomicReference < double [] > ( features . clone () ) ;
List < Vector3D > reducedSupport = new ArrayList < Vector3D > () ;
List < Vector3D > points = new ArrayList < Vector3D > () ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean3D , Vector3D > encloser = new WelzlEncloser < Euclidean3D , Vector3D > ( NUMBER_CONSTANT , generator ) ;
TreeSet < Double > values = new TreeSet < Double > () ;
final List < PairDoubleInteger > list = new ArrayList < PairDoubleInteger > ( len ) ;
return new Array2DRowFieldMatrix < BigFraction > ( pData , false ) ;
KMeansPlusPlusClusterer < DoublePoint > transformer = new KMeansPlusPlusClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final List < double [] > paramsAndChi2 = new ArrayList < double [] > ( gridSize * gridSize ) ;
{ return new ThreeEighthesFieldIntegrator < T > ( field , step ) ; }
p2 = new Pair < String , Integer > ( STRING_CONSTANT , NUMBER_CONSTANT )
List < Chromosome > popList = new LinkedList < Chromosome > () ;
final List < Neuron > neuronList = new ArrayList < Neuron > () ;
final List < Neuron > neurons = new ArrayList < Neuron > () ;
{ copy.linkMap . put ( e . getKey () , new HashSet < Long > ( e . getValue () ) ) ; }
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < Dfp > interpolator = new FieldHermiteInterpolator < Dfp > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
FieldHermiteInterpolator < BigFraction > interpolator = new FieldHermiteInterpolator < BigFraction > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final List < WeightedObservedPoint > points = new ArrayList < WeightedObservedPoint > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
final ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
ArrayList < Chromosome > chromosomes = new ArrayList < Chromosome > () ;
List < Vector2D > reducedSupport = new ArrayList < Vector2D > () ;
List < Vector2D > list = new ArrayList < Vector2D > ( coordinates.length / NUMBER_CONSTANT ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
WelzlEncloser < Euclidean2D , Vector2D > encloser = new WelzlEncloser < Euclidean2D , Vector2D > ( NUMBER_CONSTANT , generator ) ;
mapper = new FieldEquationsMapper < T > ( mapper , secondary . getDimension () ) ;
Map < String , String > referenceRules = new HashMap < String , String > () ;
Map < String , String > referenceRules = new HashMap < String , String > () ;
FirstOrderFieldDifferentialEquations < T > eqn = new SinCos < T > ( field ) ;
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
setUpInterpolator ( field , new SinCos < T > ( field ) , NUMBER_CONSTANT , new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } , NUMBER_CONSTANT )
return new Array2DRowFieldMatrix < T > ( pData , false ) ;
{ innerDistribution = new EnumeratedDistribution < Integer > ( createDistribution ( singletons , probabilities ) ) ; }
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , step ) ; }
{ return new FieldLUDecomposition < Fraction > ( m ) . getDeterminant () . doubleValue () ; }
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( singular ) ) . getSolver () ;
solver = new FieldLUDecomposition < Fraction > ( createFractionMatrix ( testData ) ) . getSolver () ;
List < Chromosome > popList = new ArrayList < Chromosome > () ;
NPointCrossover < Integer > npc = new NPointCrossover < Integer > ( order ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
return new Array2DRowFieldMatrix < T > ( getField () , outData , false ) ;
{ return new Array2DRowFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , nCols , nRows ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
return new ArrayFieldVector < T > ( getField () , outData , false ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , NUMBER_CONSTANT ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , NUMBER_CONSTANT , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , m.columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
final BlockFieldMatrix < T > out = new BlockFieldMatrix < T > ( getField () , rows , columns ) ;
{ return new BlockFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
loops = new ArrayList < Vertex > () ;
final List < Integer > factors = new ArrayList < Integer > ( NUMBER_CONSTANT ) ;
return new SparseFieldVector < Fraction > ( field , t ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
final SparseFieldVector < Fraction > v = new SparseFieldVector < Fraction > ( field , data ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
SparseFieldVector < Fraction > v1 = new SparseFieldVector < Fraction > ( field , vec1 ) ;
{ return new FieldODEState < T > ( t0 , y0 ) ; }
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
List < SubHyperplane < Sphere2D > > boundary = new ArrayList < SubHyperplane < Sphere2D > > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
RegionFactory < Sphere2D > factory = new RegionFactory < Sphere2D > () ;
final ArrayList < Integer > nonZeroPositions = new ArrayList < Integer > () ;
{ this . tolerance = tolerance ; this . segments = new ArrayList < ConnectableSegment > () ; }
final List < Segment > loop = new ArrayList < Segment > () ;
loops = new ArrayList < List < Segment > > ()
this . lines = new ArrayList < Line > () ;
this . representation = Collections . unmodifiableList ( copyList ? new ArrayList < T > ( representation ) : representation ) ;
newClusters = new ArrayList < CentroidCluster < T > > ( k )
microsphereData = new ArrayList < FacetData > ( size ) ;
final Set < Neuron > list = new HashSet < Neuron > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
this . listeners = new CopyOnWriteArrayList < IterationListener > () ;
List < Integer > minRatioPositions = new ArrayList < Integer > () ;
{ innerDistribution = new EnumeratedDistribution < Double > ( createDistribution ( singletons , probabilities ) ) ; }
final List < Interval > list = new ArrayList < Interval > () ;
{ return new LutherFieldIntegrator < T > ( field , step ) ; }
final FuzzyKMeansClusterer < DoublePoint > clusterer = new FuzzyKMeansClusterer < DoublePoint > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new SparseFieldMatrix < T > ( getField () , rowDimension , columnDimension ) ; }
{ return new SparseFieldMatrix < T > ( this ) ; }
entries = new OpenIntToFieldHashMap < T > ( getField () ) ;
entries = new OpenIntToFieldHashMap < T > ( other.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
steps = new ArrayList < StepInterpolator > () ;
output = new ArrayList < Double > () ;
@ Before public void setUp () { evaluator = new SumOfClusterVariances < DoublePoint > ( new EuclideanDistance () ) ; }
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > generated = new HashMap < Integer , Fraction > () ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field , NUMBER_CONSTANT ) ;
OpenIntToFieldHashMap < Fraction > map = new OpenIntToFieldHashMap < Fraction > ( field ) ;
Map < Integer , Fraction > map = new HashMap < Integer , Fraction > () ;
final List < Field > fields = new ArrayList < Field > () ;
RegionFactory < Euclidean1D > factory = new RegionFactory < Euclidean1D > () ;
{ return new ArrayList < WeightedObservedPoint > ( observations ) ; }
final HashMap < Neuron , Integer > hit = new HashMap < Neuron , Integer > () ;
final List < PairNeuronDouble > list = new ArrayList < PairNeuronDouble > () ;
List < CentroidCluster < T > > newClusters = new ArrayList < CentroidCluster < T > > () ;
List < Object [] > list = new ArrayList < Object [] > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
{ return new GillFieldIntegrator < T > ( field , step ) ; }
return new FieldRotation < DerivativeStructure > ( mds , threshold ) ;
FieldRotation < DerivativeStructure > quat = new FieldRotation < DerivativeStructure > ( u1 , u2 , v1 , v2 ) ;
return new ArrayFieldVector < Fraction > ( t ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
final ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( data ) ;
ArrayFieldVector < Fraction > v = new ArrayFieldVector < Fraction > ( vec1 ) ;
ArrayFieldVector < Fraction > v1 = new ArrayFieldVector < Fraction > ( vec1 ) ;
return new FieldVectorTestImpl < T > ( out ) ;
final List < Object > orig = new ArrayList < Object > () ;
this . hParam = new HashMap < String , Double > () ;
regions = new ArrayList < Region < T > > ( NUMBER_CONSTANT )
return new BoundaryProjection < S > ( original , projected , offset ) ;
binStats = new ArrayList < SummaryStatistics > () ;
{ return new MidpointFieldIntegrator < T > ( field , step ) ; }
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
{ this . surrounded = new ArrayList < NestedLoops > () ; this . tolerance = tolerance ; }
return new FieldODEStateAndDerivative < S > ( time , estimatedState , estimatedDerivatives ) ;
this . nordsieck = new Array2DRowFieldMatrix < T > ( nordsieck . getData () , false ) ;
boundary = new ArrayList < SubHyperplane < Euclidean3D > > ()
{ return new BSPTree < Euclidean3D > ( Boolean.FALSE ) ; }
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
FieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldMatrix < T > res = new SparseFieldMatrix < T > ( field , virtualSize , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( field , n ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
SparseFieldVector < T > res = new SparseFieldVector < T > ( this ) ;
{ return new SparseFieldVector < T > ( this ) ; }
FieldVector < T > res = new SparseFieldVector < T > ( this , NUMBER_CONSTANT ) ;
FieldVector < T > res = new SparseFieldVector < T > ( this , n ) ;
entries = new OpenIntToFieldHashMap < T > ( v . getEntries () ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
entries = new OpenIntToFieldHashMap < T > ( field , expectedSize ) ;
entries = new OpenIntToFieldHashMap < T > ( v.entries ) ;
entries = new OpenIntToFieldHashMap < T > ( field ) ;
{ return new ClassicalRungeKuttaFieldIntegrator < T > ( field , field . getOne () ) ; }
public ListUnivariateImpl () { this ( new ArrayList < Object > () ) ; }
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
this . jacobianProviders = new ArrayList < ParameterJacobianProvider > () ;
{ return new LutherFieldIntegrator < T > ( field , field . getOne () ) ; }
List < Frequency > coll = new ArrayList < Frequency > () ;
{ return new ThreeEighthesFieldIntegrator < T > ( field , field . getOne () ) ; }
List < Integer > newRepr = new ArrayList < Integer > ( origChrom . getRepresentation () ) ;
final RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final SimplePointChecker < PointValuePair > checker = new SimplePointChecker < PointValuePair > ( NUMBER_CONSTANT , NUMBER_CONSTANT , max ) ;
final Collection < SummaryStatistics > categoryDataSummaryStatistics = new ArrayList < SummaryStatistics > ( categoryData . size () ) ;
final ArrayList < String > lines = new ArrayList < String > () ;
List < Number > components = new ArrayList < Number > () ;
{ return new EulerFieldIntegrator < T > ( field , step ) ; }
final ArrayList < Double > list = new ArrayList < Double > () ;
List < Vector3D > support = new ArrayList < Vector3D > () ;
public CircleScalar () { points = new ArrayList < Vector2D > () ; }
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < Integer > seq = new ArrayList < Integer > () ;
final List < EventHandler > list = new ArrayList < EventHandler > ( eventsStates . size () ) ;
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
this . chromosomes = new ArrayList < Chromosome > ( populationLimit ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
BlockFieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
return new ArrayFieldVector < Fraction > ( data , false ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
{ Assert . assertEquals ( new BlockFieldMatrix < Fraction > ( reference ) , sub ) ; }
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( subTestData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
FieldMatrix < Fraction > m = new BlockFieldMatrix < Fraction > ( testData ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
RegionFactory < Sphere1D > factory = new RegionFactory < Sphere1D > () ;
return new ArrayList < Edge > ( edgeToNode . keySet () ) ;
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
ListUnivariateImpl u = new ListUnivariateImpl ( new ArrayList < Object > () ) ;
List < Object > list = new ArrayList < Object > () ;
List < Object > externalList = new ArrayList < Object > () ;
final FieldODEStateAndDerivative < T > state0 = new FieldODEStateAndDerivative < T > ( t0 , y0 , y0Dot ) ;
RegionFactory < Euclidean3D > factory = new RegionFactory < Euclidean3D > () ;
integrator . integrate ( new FieldExpandableODE < T > ( problem ) , problem . getInitialState () , problem . getFinalTime () ) ;
points = new ArrayList < double [] > () ;
{ return new FieldVector3D < T > ( NUMBER_CONSTANT , this , factor , v ) ; }
final List < Object > list = new ArrayList < Object > () ;
final List < Complex > result = new ArrayList < Complex > () ;
return new FieldRotation < Dfp > ( mds , threshold ) ;
FieldRotation < Dfp > quat = new FieldRotation < Dfp > ( u1 , u2 , v1 , v2 ) ;
OnePointCrossover < Integer > opc = new OnePointCrossover < Integer > () ;
BSPTree < Sphere1D > tree = new BSPTree < Sphere1D > ( Boolean.FALSE ) ;
final List < Arc > list = new ArrayList < Arc > () ;
List < Double > newRepr = new ArrayList < Double > ( repr ) ;
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
Map < Integer , Double > generated = new HashMap < Integer , Double > () ;
Set < Integer > keysInMap = new HashSet < Integer > ( javaMap . keySet () ) ;
Map < Integer , Double > map = new HashMap < Integer , Double > () ;
final Set < Integer > usedBasicRows = new HashSet < Integer > () ;
final Set < Integer > columnsToDrop = new TreeSet < Integer > () ;
List < LinearConstraint > normalized = new ArrayList < LinearConstraint > ( originalConstraints . size () ) ;
final ArrayList < Object [] > parameters = new ArrayList < Object [] > () ;
{ return new Pair < K , V > ( k , v ) ; }
public Cluster () { points = new ArrayList < T > () ; }
close = new ArrayList < BSPTree < S > > ()
return new FieldODEStateAndDerivative < T > ( time , interpolatedState , interpolatedDerivatives ) ;
final HashSet < Double > values = new HashSet < Double > () ;
return new Array2DRowFieldMatrix < BigFraction > ( BigFractionField . getInstance () , Hdata ) ;
TestFieldProblem3 < T > pb = new TestFieldProblem3 < T > ( field ) ;
final BoundarySizeVisitor < S > visitor = new BoundarySizeVisitor < S > () ;
final BoundaryProjector < S , T > projector = new BoundaryProjector < S , T > ( point ) ;
{ tree = new BSPTree < S > ( Boolean.FALSE ) ; }
{ this . tree = new BSPTree < S > ( Boolean.TRUE ) ; this . tolerance = tolerance ; }
List < Integer > baseSequence = new ArrayList < Integer > ( l ) ;
List < S > origDataCopy = new ArrayList < S > ( originalData ) ;
List < S > sortedData = new ArrayList < S > ( data ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > repr = new ArrayList < Double > ( l ) ;
List < Double > sortedRepr = new ArrayList < Double > ( getRepresentation () ) ;
distribution = new ArrayList < T > () ;
List < Vector2D > quadrilateral = new ArrayList < Vector2D > () ;
final List < Vector2D > reducedPoints = new ArrayList < Vector2D > ( quadrilateral ) ;
List < Integer > rList = new ArrayList < Integer > ( length ) ;
context = new HashMap < String , Object > () ;
List < Vector2D > support = new ArrayList < Vector2D > () ;
final ArrayList < Double > integrationTestPoints = new ArrayList < Double > () ;
edges = new ArrayList < SubHyperplane < Euclidean2D > > ()
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
return new FieldODEState < T > ( state . getTime () , y ) ;
ArrayList < Integer > out = new ArrayList < Integer > () ;
FieldMatrix < Fraction > m = new Array2DRowFieldMatrix < Fraction > ( fData , false ) ;
FieldMatrix < BigFraction > m = new Array2DRowFieldMatrix < BigFraction > ( bfData , false ) ;
{ return new ArrayList < String > () ; }
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
FieldBracketingNthOrderBrentSolver < Dfp > solver = new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ;
{ new FieldBracketingNthOrderBrentSolver < Dfp > ( relativeAccuracy , absoluteAccuracy , functionValueAccuracy , NUMBER_CONSTANT ) ; }
List < Vector2D > points = new ArrayList < Vector2D > ( size ) ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
List < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
final Collection < Vector2D > points = new ArrayList < Vector2D > () ;
ArrayList < SubHyperplane < Euclidean2D > > edges = new ArrayList < SubHyperplane < Euclidean2D > > () ;
RegionFactory < Euclidean2D > factory = new RegionFactory < Euclidean2D > () ;
final List < WeightedObservedPoint > observations = new ArrayList < WeightedObservedPoint > ( unsorted ) ;
steps = new ArrayList < FieldStepInterpolator < T > > () ;
final Set < City > unique = new HashSet < City > () ;
final List < Future < > > execOutput = new ArrayList < Future < > > () ;
certifiedValues = new HashMap < String , Double > () ;
{ return new EulerFieldIntegrator < T > ( field , field . getOne () ) ; }
FieldMatrix < T > identity = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
return new Array2DRowFieldMatrix < T > ( field , bp , false ) ;
return new ArrayFieldVector < T > ( bp , false ) ;
return new ArrayFieldVector < T > ( field , bp , false ) ;
{ return new Solver < T > ( field , lu , pivot , singular ) ; }
cachedP = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedU = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
cachedL = new Array2DRowFieldMatrix < T > ( field , m , m ) ;
List < Chromosome > popChr = new ArrayList < Chromosome > () ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
Collection < Neuron > exclude = new HashSet < Neuron > () ;
final List < BigFraction > list = new ArrayList < BigFraction > () ;
this . derivatives = new HashMap < Integer , Double > () ;
this . derivatives = new HashMap < Integer , Double > () ;
tasks = new ArrayList < Callable < Double > > ()
final FieldODEStateAndDerivative < T > stateTmp = new FieldODEStateAndDerivative < T > ( stepEnd , yTmp , yDotTmp ) ;
population = new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
new ListPopulation ( chromosomes , NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
new ListPopulation ( chromosomes , - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ;
{ new ListPopulation ( - NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } } ; }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
population = new ListPopulation ( NUMBER_CONSTANT ) { public Population nextGeneration () { return null ; } }
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
public StepInterpolator copy () { return this ; }
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p1c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
final Chromosome p2c = new Chromosome () { public double fitness () { return NUMBER_CONSTANT ; } } ;
for ( int val : this . getRepresentation () ) { if ( val != NUMBER_CONSTANT ) num ++ ; }
if ( count ++ > NUMBER_CONSTANT ) break;
if ( count ++ > NUMBER_CONSTANT ) break;
if ( counts [ i ] == - NUMBER_CONSTANT ) continue;
RandomSource . restoreState ( random , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( random ) . getState () ) ; }
RandomSource . restoreState ( delegate , state ) ;
{ out . defaultWriteObject () ; out . writeObject ( RandomSource . saveState ( delegate ) . getState () ) ; }
{ double n = upper - lower + NUMBER_CONSTANT ; return ( n * n - NUMBER_CONSTANT ) / NUMBER_CONSTANT ; }
{ return NUMBER_CONSTANT * ( lower + upper ) ; }
return ( x - lower + NUMBER_CONSTANT ) / ( upper - lower + NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT / ( upper - lower + NUMBER_CONSTANT ) ;
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) delegate . saveState () ) . getState () ) ; }
{ out . defaultWriteObject () ; out . writeObject ( ( ( RandomSource.State ) random . saveState () ) . getState () ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
if ( shuffle ) { Collections . shuffle ( points , new JDKRandomAdaptor ( rng ) ) ; }
final double delta = ( ( Vector1D ) point ) . getX () - location . getX () ;
final Vector1D location
{ final Circle otherC = ( Circle ) other ; return Vector3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Vector3D direction
final Vector3D pole
Vector3D [] points
final List < Vector3D > vertices
Arrays . asList ( Vector3D.ZERO , Vector3D.PLUS_I , Vector3D.PLUS_J , Vector3D.PLUS_K )
try { ps . checkPoint ( Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Vector2D tmp = loop [ min ] ;
final Vector2D [] bLoop
final Vector3D axis
Vector3D axis
Vector2D oneTwo = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Vector2D ( v ) ; }
{ final Vector1D p1 = ( Vector1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
Vector2D expected = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = Vector2D.NEGATIVE_INFINITY ;
Vector2D c = Vector2D.POSITIVE_INFINITY ;
Vector2D c = Vector2D.NaN ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Vector2D c = new Vector2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ return new Line ( new Vector2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Vector1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Vector3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
Vector1D v
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D v = new Vector1D ( NUMBER_CONSTANT ) ;
{ Space space = new Vector1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Vector3D p = h . toSpace ( Vector2D.ZERO ) ;
final Vector2D p = h . toSpace ( Vector1D.ZERO ) ;
final Vector2D p2 = ( Vector2D ) vector ;
Vector3D c = Vector3D.NEGATIVE_INFINITY ;
Vector3D c = Vector3D.POSITIVE_INFINITY ;
Vector3D c = Vector3D.NaN ;
Vector1D expected = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = Vector1D.NEGATIVE_INFINITY ;
Vector1D c = Vector1D.POSITIVE_INFINITY ;
Vector1D c = Vector1D.NaN ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( - NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
Vector1D c = new Vector1D ( NUMBER_CONSTANT ) ;
final double angle = Vector3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
{ return Vector3D . angle ( p1.vector , p2.vector ) ; }
final Vector3D vector
{ return ( ( Vector3D ) point ) . dotProduct ( w ) + originOffset ; }
final Vector3D p
final Vector3D translation
final double angle = Vector3D . angle ( w , plane.w ) ;
final Vector3D tmp = u ;
final Vector3D normal
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final Vector2D p
final Vector2D p
final Vector2D p
Vector2D p2 = ( Vector2D ) point ;
final Vector2D p
final Vector2D p
TranslationTransform ( final Vector3D translation ) { this . translation = translation ; }
final Vector3D translation
final Vector3D center
final Vector3D center
final Vector3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Vector3D > vertices
final List < Vector3D > vertices
Circle circle = new Circle ( Vector3D.PLUS_K , NUMBER_CONSTANT ) ;
final Vector3D u
final Vector3D u
final Vector2D [] vertices
Collection < Vector2D > points
this . summedBarycenter = Vector3D.ZERO ;
{ return Vector2D . angle ( p1.vector , p2.vector ) ; }
final Vector2D vector
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return new SphericalCoordinates ( new Vector3D ( x , y , z ) ) ; }
final Vector3D v
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final Vector3D pole
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
final double x = ( ( Vector1D ) point ) . getX () ;
final Coordinates2D tmp = loop [ min ] ;
final Coordinates2D [] bLoop
final Coordinates2D p2 = ( Coordinates2D ) vector ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Coordinates1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
Coordinates3D [] points
final List < Coordinates3D > vertices
Arrays . asList ( Coordinates3D.ZERO , Coordinates3D.PLUS_I , Coordinates3D.PLUS_J , Coordinates3D.PLUS_K )
try { ps . checkPoint ( Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
final Coordinates3D p = h . toSpace ( Coordinates2D.ZERO ) ;
final Coordinates2D p = h . toSpace ( Coordinates1D.ZERO ) ;
Coordinates2D expected = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = Coordinates2D.NEGATIVE_INFINITY ;
Coordinates2D c = Coordinates2D.POSITIVE_INFINITY ;
Coordinates2D c = Coordinates2D.NaN ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Coordinates2D c = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
final double x = ( ( Coordinates1D ) point ) . getX () ;
Coordinates3D v
{ new Coordinates3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
{ return new Line ( new Coordinates2D ( getNumber () , getNumber () ) , getNumber () , getNumber () ) ; }
{ return new OrientedPoint ( new Coordinates1D ( getNumber () ) , getBoolean () , getNumber () ) ; }
{ return new Circle ( new Coordinates3D ( getNumber () , getNumber () , getNumber () ) , getNumber () ) ; }
Circle circle = new Circle ( Coordinates3D.PLUS_K , NUMBER_CONSTANT ) ;
{ return new SphericalCoordinates ( new Coordinates3D ( x , y , z ) ) ; }
final Coordinates3D v
this . summedBarycenter = Coordinates3D.ZERO ;
{ final Coordinates1D p1 = ( Coordinates1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
{ return Coordinates2D . angle ( p1.vector , p2.vector ) ; }
final Coordinates2D vector
final Coordinates3D p
final double angle = Coordinates3D . angle ( direction , line.direction ) ;
final Coordinates3D point
Coordinates3D c = Coordinates3D.NEGATIVE_INFINITY ;
Coordinates3D c = Coordinates3D.POSITIVE_INFINITY ;
Coordinates3D c = Coordinates3D.NaN ;
Coordinates1D expected = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = Coordinates1D.NEGATIVE_INFINITY ;
Coordinates1D c = Coordinates1D.POSITIVE_INFINITY ;
Coordinates1D c = Coordinates1D.NaN ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( - NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D c = new Coordinates1D ( NUMBER_CONSTANT ) ;
final Coordinates3D axis
Coordinates3D axis
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v1
final Coordinates3D v2
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D v
final Coordinates3D u
final double angle = Coordinates3D . angle ( thisCircle . getPole () , otherCircle . getPole () ) ;
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Coordinates2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
{ return ( ( Coordinates3D ) point ) . dotProduct ( w ) + originOffset ; }
final Coordinates3D p
final Coordinates3D translation
final double angle = Coordinates3D . angle ( w , plane.w ) ;
final Coordinates3D tmp = u ;
final Coordinates3D normal
try { FieldVector3D . angle ( v1 , Coordinates3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
{ final Circle otherC = ( Circle ) other ; return Coordinates3D . dotProduct ( pole , otherC.pole ) >= NUMBER_CONSTANT ; }
final Coordinates3D direction
final Coordinates3D pole
{ return Coordinates3D . angle ( p1.vector , p2.vector ) ; }
final Coordinates3D vector
Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
final Collection < Coordinates2D > points
ConvexHull2D hull = generator . generate ( Collections . < Coordinates2D > emptyList () ) ;
final double delta = ( ( Coordinates1D ) point ) . getX () - location . getX () ;
final Coordinates1D location
final Coordinates3D u
final Coordinates3D u
final Coordinates3D pole
final Coordinates2D point
final Coordinates2D location
final Coordinates2D . . . vertices
final Coordinates2D . . . vertices
Coordinates2D oneTwo = new Coordinates2D ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ new Coordinates2D ( v ) ; }
final Coordinates2D [] vertices
TranslationTransform ( final Coordinates3D translation ) { this . translation = translation ; }
final Coordinates3D translation
final Coordinates3D center
final Coordinates3D center
final Coordinates3D point
{ setSize ( NUMBER_CONSTANT ) ; setBarycenter ( ( Point < Euclidean3D > ) new Coordinates3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
final List < Coordinates3D > vertices
final List < Coordinates3D > vertices
Coordinates1D v
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
Coordinates1D v = new Coordinates1D ( NUMBER_CONSTANT ) ;
{ Space space = new Coordinates1D ( NUMBER_CONSTANT ) . getSpace () ; Assert . assertEquals ( NUMBER_CONSTANT , space . getDimension () ) ; }
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
final Coordinates2D p
{ centered [ i ] = values [ i ] - getMeans () [ i ] ; }
private final ContinuousSampler sampler = new BoxMullerLogNormalSampler ( rng , scale , shape ) ;
private final ContinuousSampler sampler = new BoxMullerGaussianSampler ( rng , mean , standardDeviation ) ;
public Plot ( final List < Vector2D > points ) { this . points = points ; }
List < Vector2D > points = null ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D actual = vector1DFormat . parse ( source ) ;
Cartesian1D expected = new Cartesian1D ( NUMBER_CONSTANT ) ;
{ final Cartesian1D p1 = ( Cartesian1D ) vector ; return format ( toAppendTo , pos , p1 . getX () ) ; }
final Cartesian2D p2 = ( Cartesian2D ) vector ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian2D actual = vector2DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
Cartesian3D actual = vector3DFormat . parse ( source ) ;
int j = NUMBER_CONSTANT
Assert . assertFalse ( STRING_CONSTANT + level , new KolmogorovSmirnovTest ( RandomSource.JDK , NUMBER_CONSTANT ) . kolmogorovSmirnovTest ( betaDistribution , observed ) < level ) ;
Assert . assertEquals ( test . exactP ( d , sampleSize1 , sampleSize2 , strict ) , test . monteCarloP ( d , sampleSize1 , sampleSize2 , strict , KolmogorovSmirnovTest.MONTE_CARLO_ITERATIONS , rng ) , tol )
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
final double tol = KolmogorovSmirnovTestTest.TOLERANCE ;
Vector3D p
rings = new ChineseRings ( new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT )
try { FieldVector3D . angle ( v1 , Vector3D.ZERO ) ; Assert . fail ( STRING_CONSTANT ) ; } catch ( MathArithmeticException mae ) {}
final Vector2D point
final Vector2D location
final Vector2D . . . vertices
final Vector2D . . . vertices
final Vector3D p
final double angle = Vector3D . angle ( direction , line.direction ) ;
final Vector3D point
Vector3D v
{ new Vector3D ( new double [] { NUMBER_CONSTANT , NUMBER_CONSTANT } ) ; }
Space space = new Vector3D ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) . getSpace () ;
final Collection < Vector2D > points
final Collection < Vector2D > points
final Collection < Vector2D > points
ConvexHull2D hull = generator . generate ( Collections . < Vector2D > emptyList () ) ;
Assert . assertEquals ( NUMBER_CONSTANT , ( ( Vector1D ) set . getBarycenter () ) . getX () , Precision.EPSILON ) ;
final double x = ( ( Vector1D ) point ) . getX () ;
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
for ( Vector2D p : factory . generate ( numPoints ) ) { circle . addPoint ( p . getX () , p . getY () ) ; }
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v1
final Vector3D v2
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D v
final Vector3D u
final Vector2D [] vertices
if ( x <= NUMBER_CONSTANT ) { ret = NUMBER_CONSTANT ; } else { ret = Gamma . regularizedGammaP ( shape , x / scale ) ; }
Gamma . logGamma ( z + NUMBER_CONSTANT ) - ( z + NUMBER_CONSTANT ) * FastMath . log ( z ) + z - HALF_LOG_2_PI
final double expected = Gamma . logGamma ( i + NUMBER_CONSTANT ) ;
{ return Gamma . regularizedGammaP ( mu , mu * x * x / omega ) ; }
NUMBER_CONSTANT * FastMath . pow ( mu , mu ) / ( Gamma . gamma ( mu ) * FastMath . pow ( omega , mu ) )
Assert . assertEquals ( NUMBER_CONSTANT , Gamma . gamma ( t ) / s , tol ) ;
( sc * sc ) * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) )
return sc * FastMath . exp ( Gamma . logGamma ( NUMBER_CONSTANT + ( NUMBER_CONSTANT / sh ) ) ) ;
return Gamma . logGamma ( n + NUMBER_CONSTANT ) ;
{ ret = Beta . regularizedBeta ( probabilityOfSuccess , numberOfSuccesses , x + NUMBER_CONSTANT ) ; }
Beta . logBeta ( nhalf , mhalf )
{ ret = NUMBER_CONSTANT - Beta . regularizedBeta ( probabilityOfSuccess , x + NUMBER_CONSTANT , numberOfTrials - x ) ; }
if ( x >= NUMBER_CONSTANT ) { return NUMBER_CONSTANT ; } else { return Beta . regularizedBeta ( x , alpha , beta ) ; }
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return NUMBER_CONSTANT + NUMBER_CONSTANT * Erf . erf ( dev / ( shape * SQRT2 ) ) ;
final double t = Erf . erfcInv ( p ) ;
return NUMBER_CONSTANT * Erf . erf ( v0 , v1 ) ;
return mean + standardDeviation * SQRT2 * Erf . erfInv ( NUMBER_CONSTANT * p - NUMBER_CONSTANT ) ;
return NUMBER_CONSTANT * Erf . erfc ( - dev / ( standardDeviation * SQRT2 ) ) ;
{ term *= FastMath . pow ( delta [ k ] , orders [ k ] ) / CombinatoricsUtils . factorial ( orders [ k ] ) ; }
double refDer = - CombinatoricsUtils . factorial ( n - NUMBER_CONSTANT ) / FastMath . pow ( - x , n ) ;
ArithmeticUtils . pow ( - NUMBER_CONSTANT , i ) * CombinatoricsUtils . factorial ( i ) / FastMath . pow ( x , i + NUMBER_CONSTANT )
CombinatoricsUtils . binomialCoefficientDouble ( n + m , m )
double binomial = CombinatoricsUtils . binomialCoefficient ( v + i , i ) ;
final int numCombinations = ( int ) CombinatoricsUtils . binomialCoefficient ( arraySize , numberOfTrueValues ) ;
long expected = CombinatoricsUtils . binomialCoefficient ( i + j , i ) ;
{ coeff [ i ] [ j ] = ( int ) CombinatoricsUtils . binomialCoefficient ( i , j ) ; }
Assert . assertEquals ( CombinatoricsUtils . binomialCoefficient ( n , NUMBER_CONSTANT ) , CombinatoricsUtils . stirlingS2 ( n , n - NUMBER_CONSTANT ) ) ;
return MathArrays . linearCombination ( x1 , y1 , - x2 , y2 ) ;
{ final Cartesian2D v2 = ( Cartesian2D ) v ; return MathArrays . linearCombination ( x , v2.x , y , v2.y ) ; }
final double n = FastMath . abs ( MathArrays . linearCombination ( v1.x , v2.y , - v1.y , v2.x ) ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ;
out.value = MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ;
out.value = MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ;
out.value = MathArrays . linearCombination ( a , bDouble ) ;
out.value = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return FastMath . abs ( MathArrays . linearCombination ( sin , line.cos , - cos , line.sin ) ) < tolerance ; }
return MathArrays . linearCombination ( sin , otherL.sin , cos , otherL.cos ) >= NUMBER_CONSTANT ;
{ return originOffset + ( MathArrays . linearCombination ( cos , line.cos , sin , line.sin ) > NUMBER_CONSTANT ? - line.originOffset : line.originOffset ) ; }
final double accurateValue = MathArrays . linearCombination ( a , bDouble ) ;
final double accurateValue = MathArrays . linearCombination ( aDouble , bDouble ) ;
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value , a3 , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value , a3.value , b3.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1 , b1.value , a2 , b2.value ) ) ; }
{ return new Decimal64 ( MathArrays . linearCombination ( a1.value , b1.value , a2.value , b2.value ) ) ; }
return new Decimal64 ( MathArrays . linearCombination ( a , bDouble ) ) ;
return new Decimal64 ( MathArrays . linearCombination ( aDouble , bDouble ) ) ;
final double r = MathArrays . linearCombination ( coeff [ i ] , pY ) ;
packed [ i + NUMBER_CONSTANT ] = MathArrays . linearCombination ( dv , partials ) ;
final double cos = MathArrays . cosAngle ( n , sampleDirection ) ;
final double diffNorm = MathArrays . safeNorm ( diff ) ;
checkRelative ( MathArrays . linearCombination ( aD , bD ) , bF [ NUMBER_CONSTANT ] . linearCombination ( aD , bF ) ) ;
checkRelative ( MathArrays . linearCombination ( aD , bD ) , aF [ NUMBER_CONSTANT ] . linearCombination ( aF , bF ) ) ;
{ this ( MathUtils . normalizeAngle ( alpha , FastMath.PI ) , new Cartesian2D ( FastMath . cos ( alpha ) , FastMath . sin ( alpha ) ) ) ; }
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
final double arcRelativeStart = MathUtils . normalizeAngle ( arc . getInf () , edgeStart + FastMath.PI ) - edgeStart ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
Assert . assertEquals ( p , MathUtils . normalizeAngle ( fitted [ NUMBER_CONSTANT ] , p ) , NUMBER_CONSTANT ) ;
final double lB = MathUtils . normalizeAngle ( limits . get ( j ) , lA ) ;
final double syncedStart = MathUtils . normalizeAngle ( a [ NUMBER_CONSTANT ] , reference ) - arc . getInf () ;
final double normalizedLower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
{ Assert . assertEquals ( a1 . getReal () , MathUtils . normalizeAngle ( a2 , a1 . getReal () ) , NUMBER_CONSTANT ) ; }
this . angle = MathUtils . normalizeAngle ( angle , FastMath.PI ) ;
this . angle = MathUtils . normalizeAngle ( alpha , FastMath.PI ) ;
angle = MathUtils . normalizeAngle ( line.angle , FastMath.PI ) ;
final double normalizedPoint = MathUtils . normalizeAngle ( point , middle ) ;
this . lower = MathUtils . normalizeAngle ( lower , FastMath.PI ) ;
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
if ( knots.length < NUMBER_CONSTANT ) { throw new NumberIsTooSmallException ( LocalizedFormats.NOT_ENOUGH_POINTS_IN_SPLINE_PARTITION , NUMBER_CONSTANT , knots.length , false ) ; }
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator g = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
UnitSphereRandomVectorGenerator rand
this ( new InterpolatingMicrosphere ( dimension , elements , maxDarkFraction , darkThreshold , background , new UnitSphereRandomVectorGenerator ( dimension ) ) , exponent , sharedSphere , noInterpolationTolerance ) ;
UnitSphereRandomVectorGenerator sphRandom = new UnitSphereRandomVectorGenerator ( NUMBER_CONSTANT , random ) ;
{ sampler = new NormalDistribution () . createSampler ( generator ) ; }
private final ContinuousSampler sampler = new MarsagliaLogNormalSampler ( rng , scale , shape ) ;
final RealDistribution.Sampler random
{ return randomize ( new UniformRealDistribution ( min , max ) . createSampler ( rng ) , function ( new Constant ( NUMBER_CONSTANT ) , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
IntegerDistribution.Sampler sampler
final RealDistribution expectedDistribution
final NormalDistribution normalDistribution = new NormalDistribution () ;
final NormalDistribution normalDistribution = new NormalDistribution () ;
final NormalDistribution normalDistribution = new NormalDistribution () ;
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
RealDistribution distribution
RealDistribution.Sampler sampler
this . random = new NormalDistribution () . createSampler ( rng ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
final RealDistribution kernel = findKernel ( lower , upper ) ;
x = new UniformRealDistribution ( lo , hi ) . createSampler ( rng ) ;
tP = new UniformRealDistribution ( NUMBER_CONSTANT , MathUtils.TWO_PI ) . createSampler ( rng ) ;
@ Override public double getNumericalMean () { return NUMBER_CONSTANT ; }
final double offset = plane . getOffset ( ( Point < Euclidean3D > ) point ) ;
{ Assert . assertEquals ( x , v . getX () , NUMBER_CONSTANT ) ; }
Assert . assertEquals ( false , pt . isDirect () ) ;
Assert . assertEquals ( true , copy . isDirect () ) ;
Assert . assertEquals ( true , pt . isDirect () ) ;
TestUtils . assertContains ( result , expected , tolerance ) ;
assertContains ( result , expected , tolerance ) ;
y [ i ] = new Complex ( yr , yi ) ;
data [ i ] = new Complex ( re , im ) ;
for ( Complex cc : c ) { TestUtils . assertEquals ( new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , cc , NUMBER_CONSTANT ) ; }
Object expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex expected = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex expected = new Complex ( Double.NaN , Double.NaN ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex expected = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( Double.NEGATIVE_INFINITY , Double.NEGATIVE_INFINITY ) ;
Complex c = new Complex ( Double.POSITIVE_INFINITY , Double.POSITIVE_INFINITY ) ;
Complex c = new Complex ( Double.NaN , Double.NaN ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Complex c = new Complex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
for ( float d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( double d : imaginary ) { c [ index ] = new Complex ( NUMBER_CONSTANT , d ) ; index ++ ; }
for ( float d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = new Complex ( d ) ; index ++ ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( NUMBER_CONSTANT , imaginary [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
{ return new Complex ( real [ index ] ) ; }
for ( float d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
for ( double d : real ) { c [ index ] = Complex . ofCartesian ( d ) ; index ++ ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
{ return Complex . ofCartesian ( real [ index ] ) ; }
x [ i ] = Complex . ofCartesian ( f . value ( t ) ) ;
{ final int value = count ; increment () ; return value ; }
{ new SimpsonIntegrator ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; Assert . fail ( STRING_CONSTANT ) ; }
expr . setLineno ( expr . getLineno () + templateLineno - NUMBER_CONSTANT ) ;
if ( definitionNodeByDefinitionSite . containsKey ( useSite ) ) { return null ; }
FeatureSet features = ( ( JsAst ) ast ) . getFeatures ( compiler ) ;
if ( tags == FALSY_MASK ) { return builder . append ( STRING_CONSTANT ) ; } else { return builder . append ( STRING_CONSTANT + tags ) ; }
output.compiledCode = compiler . toSource () ;
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.OFF ) ;
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
resultPair = analyzeCastFwd ( expr , inEnv ) ;
public void testEs6ONoEs6 () { testSame ( STRING_CONSTANT ) ; }
options . setWarningLevel ( DiagnosticGroups.MISSING_PROVIDE , CheckLevel.WARNING ) ;
public Node getNext () { return next ; }
public Token getToken () { return token ; }
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
return JSType.UNKNOWN ;
@ Deprecated public AssertionFunctionSpec ( String functionName ) { this ( functionName , JSType.UNKNOWN , null ) ; }
STRING . isSubtypeOf ( this ) && this . commonTypes . getNumberInstance () . mayHaveProp ( pname )
if ( type == null && isConstant ) { type = JSType.UNKNOWN ; }
if ( isUnknown () ) { return UNKNOWN ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return UNKNOWN ; }
if ( this . isUnknown () ) { return TRUTHY ; }
{ globalThisType = JSType.TOP_OBJECT . withLoose () ; }
{ Preconditions . checkState ( function . getToken () == Token.FUNCTION ) ; expandedDefinitions . add ( functionSideEffectMap . get ( function ) ) ; }
n . getChildCount () == NUMBER_CONSTANT && t . inGlobalScope ()
if ( varNode . getChildCount () > NUMBER_CONSTANT && varType != null ) { warnings . add ( JSError . make ( varNode , ONE_TYPE_FOR_MANY_VARS ) ) ; }
n . getChildCount () == NUMBER_CONSTANT && parent == googScopeBlock
initializer . isVar () && initializer . getChildCount () == NUMBER_CONSTANT
if ( n . getChildCount () == NUMBER_CONSTANT && NodeUtil . isStatement ( n ) ) { processName ( n . getFirstChild () , n ) ; }
if ( currentStatement . getChildCount () == NUMBER_CONSTANT ) { return; }
typeNode != null && typeNode . getToken () == Token.STRING
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
if ( inputId == null ) { inputId = NodeUtil . getInputId ( node ) ; }
String name = node . getQualifiedName () ;
options.rewritePolyfills = flags.rewritePolyfills ;
JSType t = getMaybeTypeFromComment ( jsdoc , registry , typeParameters ) ;
builder . append ( paramType . toStringHelper ( forAnnotations ) ) . append ( STRING_CONSTANT ) ;
builder . append ( STRING_CONSTANT ) . append ( paramType . toStringHelper ( forAnnotations ) ) ;
{ b . append ( p . getJSType () . toStringHelper ( forAnnotations ) ) ; }
b . append ( call.returnType . toStringHelper ( forAnnotations ) ) ;
sb . append ( getPropertyType ( property ) . toStringHelper ( forAnnotations ) ) ;
if ( n . isFromExterns () ) { this . allPropertyNames . add ( propName ) ; }
allPropertyNames . add ( getProp . getLastChild () . getString () ) ;
if ( NodeUtil . isPropertyTest ( compiler , n ) || isPropertyAbsentTest ( n ) ) { allPropertyNames . add ( n . getLastChild () . getString () ) ; }
allPropertyNames . add ( pname ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
compiler . getOptions () . setUseTypesForOptimization ( true ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
if ( singleSiteDefinitions . size () > NUMBER_CONSTANT ) { return false ; }
NodeTraversal . traverseEs6 ( compiler , root , new FunctionVisitor ( compiler , blacklistedPropNames ) ) ;
@ Override void endCaseBody () { super . endCaseBody () ; indent -- ; endStatement () ; }
assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
JSType objectWithBadKey = findObjectWithNonStringifiableKey ( realType ) ;
Config config = findMatching ( name ) ;
if ( currentScript.defaultExportName != null ) { assignNode . getParent () . detach () ; return; }
boolean nameIsExported = name . equals ( currentScript.defaultExportName ) ;
public J2clCheckPassTest () { enableTypeCheck () ; }
JSType jsType
JSType jsType
void setMask ( int mask ) { bitmask |= mask ; checkInvariant () ; }
if ( info . isNoSideEffects () ) { sideEffectInfo . setIsPure () ; } else { sideEffectInfo . setTaintsGlobalState () ; }
features . require ( Feature.ASYNC_FUNCTIONS ) ;
features . require ( Feature.ASYNC_FUNCTIONS ) ;
config.parseTypeSyntax && peek ( TokenType.OPEN_PAREN ) || peek ( TokenType.OPEN_ANGLE )
features . require ( Feature.ASYNC_FUNCTIONS ) ;
JSDocInfo info = getJSDocInfoForFunction ( node , parent ) ;
FunctionInformation sideEffectInfo = new FunctionInformation ( inExterns ) ;
FunctionInformation representativeNode = new FunctionInformation ( false ) ;
if ( modulePath == null ) { t . makeError ( typeNode , LOAD_ERROR , moduleName ) ; return; }
if ( modulePath == null ) { compiler . report ( t . makeError ( require , LOAD_ERROR , requireName ) ) ; return; }
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String treeDiff = node . checkTreeEquals ( getSubject () ) ;
public ImmutableMap < String , Stats > getStats () { calcTotalStats () ; return summaryCopy ; }
maybeWarnForInvalidDestructuring ( t , lhs , legacyNamespace ) ;
{ options . setReportMissingOverride ( value ? CheckLevel.WARNING : CheckLevel.OFF ) ; }
this . output . print ( Joiner . on ( STRING_CONSTANT ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , new Es6RenameReferences ( renameMap ) ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Es6RenameReferences ( renameMap ) ) ;
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
return IR . exprResult ( assign ) . useSourceInfoFromForTree ( var ) ;
{ if ( Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata ) ) { return true ; } }
Matchers . functionCall ( STRING_CONSTANT ) . matches ( child . getFirstChild () , metadata )
{ eatPredefinedString ( PredefinedName.FROM ) ; moduleSpecifier = eat ( TokenType.STRING ) . asLiteral () ; }
public void testRequireUseStrict1 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT , null ) ; }
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( EXTERNS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( EXTERNS , STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( EXTERNS , STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ; }
compiler . reportCodeChange () ;
{ parent . removeChild ( node ) ; t . getCompiler () . reportCodeChange () ; }
Pattern argPattern = Pattern . compile ( STRING_CONSTANT ) ;
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
new ByteArrayInputStream ( inputString . getBytes () )
inputSourceMaps . put ( sourceMapPath , new SourceMapInput ( sourceMap ) ) ;
{ if ( child != n . getFirstChild () ) { add ( STRING_CONSTANT ) ; } add ( child ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
final Node extendsClause = className . getNext () ;
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; break; } }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
builder . setTagAsStrict ( firstOutput && options . getLanguageOut () . isStrict () ) ;
{ if ( member . isMemberFunctionDef () && member . getString () . equals ( STRING_CONSTANT ) ) { hasConstructor = true ; } }
com.google.javascript.jscomp.parsing.parser.Parser.Config es6config = new com.google.javascript.jscomp.parsing.parser.Parser.Config ( mode ( config.languageMode ) ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , ERROR ) ;
protected CodingConvention getCodingConvention () { return codingConvention ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
if ( config.languageMode != LanguageMode.ECMASCRIPT6_TYPED ) { errorReporter . warning ( STRING_CONSTANT + feature , sourceName , lineno ( node ) , charno ( node ) ) ; }
Config config = ParserRunner . createConfig ( mode , Config.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE , Config.RunMode.KEEP_GOING , null , true ) ;
builder . setTagAsStrict ( firstOutput && options . isEmitUseStrict () && options . getLanguageOut () . isStrict () ) ;
if ( options . getLanguageIn () . isStrict () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
options . setEmitUseStrict ( flags.emitUseStrict && options . getLanguageOut () . isStrict () ) ;
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
{ googRequireNode = IR . var ( IR . name ( shortName ) , googRequireNode ) ; }
return getTypeJSDoc ( oldJSDoc , expr ) ;
if ( ! hasConstructor ) { addSyntheticConstructor ( n ) ; }
! isCallTo ( value , STRING_CONSTANT ) && ! ( info != null && info . isConstructorOrInterface () )
if ( isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
var != null && var . getInitialValue () != null && ! isCallTo ( var . getInitialValue () , STRING_CONSTANT )
if ( aliasVarNodeRhs == null || ! isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
String exportedNamespace = currentScript.declareLegacyNamespace ? currentScript.legacyNamespace : currentScript . getBinaryNamespace () ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
String exportedNamespace = rewriteState . getExportedNamespace ( legacyNamespace ) ;
if ( isExportPropertyAssignment ( n ) ) { recordExportsPropertyAssignment ( n ) ; }
{ typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , JSTypeCreatorFromJSDoc.INHERITANCE_CYCLE ) ; }
IR . call ( IR . getprop ( superClass . cloneTree () , IR . string ( STRING_CONSTANT ) ) , IR . thisNode () , IR . name ( STRING_CONSTANT ) )
assertEquals ( null , LanguageMode . fromString ( STRING_CONSTANT ) ) ;
sourceMap . appendTo ( out , sourceMapOutputFile . getName () ) ;
{ if ( n . isSuper () ) { visitSuper ( n , parent ) ; } }
add ( last , Context.PRESERVE_BLOCK ) ;
assertValidOrder ( checks ) ;
assertValidOrder ( passes ) ;
CompilerPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeFoldConstants ( late , compiler . getOptions () . useTypesForLocalOptimization ) ) ;
if ( ! ( rval >= NUMBER_CONSTANT && rval < NUMBER_CONSTANT ) ) { report ( SHIFT_AMOUNT_OUT_OF_BOUNDS , n ) ; return n ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
declaresFunction ( n )
DeclaredTypeRegistry getScope () { return this . scope ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , EARLY_REFERENCE ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock ) ; }
{ super . setUp () ; codingConvention = new GoogleCodingConvention () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; }
if ( ! targetType . getGreatestSubtype ( type ) . isBottom () ) { methodPolyfills . remove ( method ) ; }
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
new PeepholeReplaceKnownMethods ( late )
public boolean isBuiltinObject () { return this . rawType . isBuiltinWithName ( STRING_CONSTANT ) ; }
boolean isClassy () { return ! isFunction () && ! isBuiltinObject () ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isInstanceofObject () , STRING_CONSTANT , this ) ; return null ; }
return isUnknown () || ( isInstanceofObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
return nt . isBuiltinObject () ? false : nt . isPropDefinedOnSubtype ( pname ) ;
Preconditions . checkArgument ( name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) || name . equals ( STRING_CONSTANT ) , STRING_CONSTANT , name ) ;
return TOP_OBJECT ;
if ( this == other || other . isBuiltinWithName ( STRING_CONSTANT ) ) { return true ; }
if ( ! isBuiltinWithName ( STRING_CONSTANT ) ) { this . subtypes . add ( subtype ) ; }
public RemoveUnusedPolyfillsTest () { super ( EXTERNS ) ; enableTypeCheck () ; }
return Long . toString ( nonnegativeHash , NUMBER_CONSTANT ) . toUpperCase () ;
{ CompilerOptions.J2clPassMode j2clPassMode = CompilerOptions.J2clPassMode . valueOf ( flags.j2clPassMode . toUpperCase () ) ; options . setJ2clPass ( j2clPassMode ) ; }
String lowerParam = param . toLowerCase () ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( compilationLevel . toUpperCase () ) ;
addParserWarning ( STRING_CONSTANT , visibility . toString () . toLowerCase () ) ;
{ result = result . toString () . toUpperCase () ; }
String canonicalizedName = value . trim () . toUpperCase () . replaceFirst ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ Node parent = n . getParent () ; return wasCast ( n ) || isAssertionCall ( parent ) ; }
return TOP_OBJECT ;
! t . isSubtypeOf ( this . commonTypes . TOP_OBJECT ) && ( ! t . hasTypeVariable () || t . hasScalar () )
JSType objLitType = commonTypes.TOP_OBJECT ;
{ globalThisType = this . commonTypes . TOP_OBJECT . withLoose () ; }
this == other || other.ns != null || ! other . getNominalType () . equals ( this . commonTypes . getObjectType () )
boolean isInhabitable () { return this != this . commonTypes . BOTTOM_OBJECT ; }
objType != null && ! objType . getNominalType () . isClassy () && ! objType . isLoose ()
if ( nameNode == null ) return;
{ throw new IllegalStateException ( STRING_CONSTANT + declaredValue . toStringTree () ) ; }
if ( name != null ) { this . definitionNodeByDefinitionSite . remove ( node ) ; this . nameDefinitionMultimap . remove ( name , node ) ; }
pattern . getParent () . replaceChild ( pattern , IR . name ( tempVarName ) ) ;
patternParam . getParent () . replaceChild ( patternParam , newParam ) ;
callNode . getParent () . replaceChild ( callNode , replacement . useSourceInfoIfMissingFrom ( callNode ) ) ;
candidateDefinition . getParent () . replaceChild ( candidateDefinition , varNode ) ;
parent . getParent () . replaceChild ( parent , replacement ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , replacement ) ;
first . getParent () . replaceChild ( first , name ) ;
n . getParent () . replaceChild ( n , placeholder ) ;
{ Node parent = n . getParent () ; parent . getParent () . replaceChild ( parent , fncBlock ) ; }
n . getParent () . replaceChild ( n , call ) ;
msgNode . getParent () . replaceChild ( msgNode , newValue ) ;
statement . getParent () . replaceChild ( statement , newStatement ) ;
assignNode . getParent () . replaceChild ( assignNode , rhs ) ;
if ( enclosing != null && enclosing . isGeneratorFunction () ) { n . getParent () . replaceChild ( n , IR . name ( GENERATOR_THIS ) ) ; }
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , elem ) ;
n . getParent () . replaceChild ( n , lengthNode ) ;
n . getParent () . replaceChild ( n , newNode ) ;
n . getParent () . replaceChild ( n , newNumber ) ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . getParent () . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
n . getParent () . replaceChild ( n , newStringNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , newNode ) ;
if ( replacementNode != null ) { n . getParent () . replaceChild ( n , replacementNode ) ; reportCodeChange () ; return replacementNode ; }
originalTypeofNode . getParent () . replaceChild ( originalTypeofNode , newNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
n . getParent () . replaceChild ( n , newNode ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
subtree . getParent () . replaceChild ( subtree , replacement ) ;
{ parent . getParent () . replaceChild ( parent , IR . empty () ) ; }
grandparent . getParent () . replaceChild ( grandparent , functionNode ) ;
n . getParent () . replaceChild ( n , var ) ;
n . getParent () . replaceChild ( n , replacement ) ;
target . getParent () . replaceChild ( target , value . cloneTree () ) ;
node . getParent () . replaceChild ( node , replacement ) ;
n . getParent () . replaceChild ( n , stringNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
callNode . getParent () . replaceChild ( callNode , objNode ) ;
{ original . getParent () . replaceChild ( original , replacement ) ; return replacement ; }
if ( replaceParent ) { parent . getParent () . replaceChild ( parent , replacement ) ; } else { parent . replaceChild ( n , replacement ) ; }
superCall . getParent () . replaceChild ( superCall , superErrorExpr ) ;
obj . getParent () . replaceChild ( obj , result ) ;
n . getParent () . replaceChild ( n , attachTypeExpr ) ;
loadModuleStatement . getParent () . replaceChild ( loadModuleStatement , moduleBlockNode ) ;
n . getParent () . replaceChild ( n , legacyQname ) ;
exprResultNode . getParent () . replaceChild ( exprResultNode , exportsObjectCreationNode ) ;
call . getParent () . replaceChild ( call , exportedNamespaceName ) ;
{ aliasReference . getParent () . replaceChild ( aliasReference , replacement ) ; }
expressionWithScopeCall . getParent () . replaceChild ( expressionWithScopeCall , scopeClosureBlock ) ;
{ newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . getParent () . replaceChild ( msgNode , newValue ) ; compiler . reportCodeChange () ; }
callNode . getParent () . replaceChild ( callNode , replacementNode . detach () ) ;
member . getParent () . replaceChild ( member , memberVariable ) ;
{ forCondition . getParent () . replaceChild ( forCondition , IR . empty () ) ; reportCodeChange () ; }
n . getParent () . replaceChild ( n , whileNode ) ;
condition . getParent () . replaceChild ( condition , replacementConditionNode ) ;
n . getParent () . replaceChild ( n , replacement ) ;
n . getParent () . replaceChild ( n , caseBlock . detach () ) ;
{ if ( result . getParent () != null ) { result . detach () ; } n . getParent () . replaceChild ( n , result ) ; }
{ subtree . getParent () . replaceChild ( subtree , right . detach () ) ; reportCodeChange () ; return right ; }
{ oldRoot . getParent () . replaceChild ( oldRoot , newRoot ) ; }
n . getParent () . replaceChild ( n , call ) ;
n . getParent () . replaceChild ( n , not ) ;
if ( newLiteralNode != null ) { n . getParent () . replaceChild ( n , newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
n . getParent () . replaceChild ( n , replacement ) ;
enclosingCall . getParent () . replaceChild ( enclosingCall , baseCall ) ;
callNode . getParent () . replaceChild ( callNode , replacement ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNgInjectSetVisibility ( ) throws Exception { compareJsDoc = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
Node scopeMethodCall = findScopeMethodCall ( t . getScope () . getRootNode () ) ;
Node n = t . getScope () . getRootNode () ;
return list ;
return list . isEmpty () ? null : list ;
abstract Node getRoot ( ) ;
String getContent ( ) throws ServiceException ;
String getName ( ) throws ServiceException ;
{ return STRING_CONSTANT ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate , CacheBuilder . newBuilder () ) ; }
{ return Strings . nullToEmpty ( sourceMapCache . get ( path ) ) ; }
String output = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return n ; }
if ( castType . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new CachingTranspiler ( delegate ) ; }
{ return STRING_CONSTANT ; }
options . setLanguageOut ( LanguageMode.ECMASCRIPT5_STRICT ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.RECORD , objKind ) ;
return new RawNominalType ( commonTypes , defSite , name , typeParameters , Kind.INTERFACE , objKind ) ;
ImmutableCollection < Node > exports
if ( isUnknownType () || implicitPrototypeChainIsUnknown () ) { return true ; }
return list ;
if ( ! hasConstructor ) { addSyntheticConstructor ( t , n ) ; }
IR . comma ( IR . comma ( IR . comma ( getTmpError , copyMessage ) , setStack ) , IR . name ( TMP_ERROR ) ) . useSourceInfoIfMissingFromForTree ( superCall )
{ compiler . report ( JSError . make ( constructor , CANNOT_CONVERT_YET , STRING_CONSTANT + superClassQName ) ) ; }
this . implementedInterfaces = new HashMap <> () ;
script . addChildToFront ( googProvide . copyInformationFromForTree ( script ) ) ;
require . copyInformationFromForTree ( importDecl ) ;
newChild . copyInformationFrom ( child ) ;
{ node . copyInformationFromForTree ( basisNode ) ; node . setOriginalName ( originalName ) ; }
newNode . copyInformationFromForTree ( sourceInfoNode ) ;
expr . copyInformationFromForTree ( parent ) ;
newChild . useSourceInfoWithoutLengthIfMissingFrom ( child ) ;
String name
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
if ( strictMismatch ) { mismatches . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordImplicitInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordImplicitInterfaceUses ( rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( caseType , switchType ) ; }
@ Override Iterable < TypeMismatch > getImplicitInterfaceUses () { return getTypeValidator () . getImplicitStructuralInterfaceUses () ; }
if ( strictMismatch ) { implicitStructuralInterfaceUses . add ( new TypeMismatch ( found , required , error ) ) ; }
if ( ! argType . isSubtypeWithoutStructuralTyping ( paramType ) ) { recordStructuralInterfaceUses ( argType , paramType ) ; }
if ( ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
if ( ! leftType . isNoType () && ! rightType . isSubtypeWithoutStructuralTyping ( leftType ) ) { recordStructuralInterfaceUses ( rightType , leftType ) ; }
{ recordStructuralInterfaceUses ( caseType , switchType ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStop ( passName , result ) ; }
if ( options.tracer . isOn () && tracker != null ) { tracker . recordPassStart ( passName , true ) ; }
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options.tracer . isOn () ) ; }
options.tracer = config.tracerMode ;
testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExport5 () { test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
for ( Reference ref : refCollection ) { processReference ( collector , ref , info ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
Map < String , DependencyInfo > parsedFiles = new HashMap <> () ;
Map < String , DependencyInfo > depsFiles = new HashMap <> () ;
Map < String , DependencyInfo > providesMap = new HashMap <> () ;
( ! NodeUtil . isPropertyTest ( compiler , n ) || objectType . isStruct () )
{ if ( canCreate ) { createName ( name ) ; } return allNames . get ( name ) ; }
if ( ! Double . isNaN ( d ) ) { cc . addNumber ( d ) ; } else { addJsString ( n ) ; }
assertThat ( result.sourceMap ) . contains ( STRING_CONSTANT ) ;
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
catch ( IOException e ) { compiler . report ( JSError . make ( REPORT_PATH_IO_ERROR , reportPath ) ) ; }
Preconditions . checkState ( current . isGetProp () ) ;
static boolean isEnhancedFor ( Node n ) { return n . isForOf () || isForIn ( n ) ; }
return newNode ( Token.FOR , initializer , transform ( loopNode.collection ) , transformBlock ( loopNode.body ) ) ;
return new Node ( Token.FOR , target , cond , body ) ;
validateNodeType ( Token.BLOCK , n ) ;
validateNodeType ( Token.BLOCK , n ) ;
String path
String path
TranspileResult transpile ( String path , String code ) ;
TranspileResult result = transpiler . transpile ( path , s ) ;
String path
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
BaseTranspiler.CompileResult result = compiler . compile ( STRING_CONSTANT , STRING_CONSTANT ) ;
String path
String path
if ( NodeUtil . isForIn ( parent ) ) { return n != parent . getFirstChild () ; } else { return NodeUtil . getConditionExpression ( parent ) != n ; }
NodeUtil . isForIn ( source )
( NodeUtil . isForIn ( parent ) )
if ( n . isForOf () || NodeUtil . isForIn ( n ) ) { return n . getSecondChild () ; }
if ( NodeUtil . isForIn ( parent ) ) { return parent ; } else { return parent . getSecondChild () . getNext () ; }
if ( NodeUtil . isVanillaFor ( cur ) ) { iter = cur . getChildAtIndex ( NUMBER_CONSTANT ) ; }
NodeUtil . isForIn ( forNode ) || forNode . isForOf ()
NodeUtil . isForIn ( c )
NodeUtil . isForIn ( parent )
! NodeUtil . isForIn ( n )
parent . isFor () && ! NodeUtil . isForIn ( parent )
if ( ! NodeUtil . isForIn ( parent ) && child == parent . getFirstChild () ) { return parent ; }
boolean lhsOfForInLoop = NodeUtil . isForIn ( gp ) && gp . getFirstFirstChild () == declNode ;
NodeUtil . isVanillaFor ( loopNode )
srcDeclaration . isConst () && ! ( NodeUtil . isForIn ( srcParent ) && srcDeclaration == srcParent . getFirstChild () )
! NodeUtil . isForIn ( n )
NodeUtil . isForIn ( nextSibling )
! NodeUtil . isForIn ( n )
if ( enclosingFunc == null || ! enclosingFunc . isGeneratorFunction () || NodeUtil . isForIn ( n ) ) { return; }
if ( NodeUtil . isForIn ( currentStatement ) ) { visitForIn () ; return false ; }
if ( NodeUtil . isForIn ( parent ) && parent . getFirstChild () == n ) { return false ; }
NodeUtil . isForIn ( n )
Preconditions . checkState ( NodeUtil . isForIn ( expr ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( expr . getParent () ) ) ;
Preconditions . checkState ( NodeUtil . isForIn ( lvalue . getParent () ) ) ;
NodeUtil . isForIn ( n )
Node expr = NodeUtil . isForIn ( n ) ? n . getFirstChild () : NodeUtil . getConditionExpression ( n ) ;
if ( NodeUtil . isForIn ( parent ) ) { return; }
if ( NodeUtil . isForIn ( n ) ) { return n ; }
if ( ! NodeUtil . isForIn ( node ) ) { tryJoinForCondition ( node ) ; tryMinimizeCondition ( NodeUtil . getConditionExpression ( node ) ) ; }
NodeUtil . isForIn ( parent )
if ( ! NodeUtil . isForIn ( parent ) ) { return ( parent . getSecondChild () == expr ) ; }
( isForIn ( parent ) && parent . getFirstChild () == n )
return NodeUtil . isForIn ( n ) ? null : n . getSecondChild () ;
( isForIn ( parent ) && parent . getFirstChild () == n )
! NodeUtil . isForIn ( n )
NodeUtil . isForIn ( control )
NodeUtil . isForIn ( n )
parent . isFor () && ! NodeUtil . isForIn ( parent ) && NodeUtil . getConditionExpression ( parent ) != n
if ( ! NodeUtil . isForIn ( n ) ) { tryRemoveAssignment ( t , NodeUtil . getConditionExpression ( n ) , state ) ; }
var . getParentNode () . isVar () && ! NodeUtil . isForIn ( var . getParentNode () . getParent () )
Preconditions . checkState ( ! parent . isFor () ) ;
currentStatement . isFor ()
n . isAssign () && ! parent . isFor ()
n . isAssign () && ( parent . isExprResult () || parent . isFor () || parent . isReturn () )
( declaration . getParent () . isVar () && ! declaration . getGrandparent () . isFor () )
nextSibling . isFor () && nextSibling . getFirstChild () . isEmpty ()
Node initializer = n . isFor () ? n . getFirstChild () : IR . empty () ;
if ( ! parent . isFor () ) { assign = NodeUtil . newExpr ( assign ) ; }
grandparent . isFor ()
{ appendField ( out , name , STRING_CONSTANT ) ; }
Preconditions . checkNotNull ( scope ) ;
boolean preserveBlock = n . isBlock () && ! n . isSyntheticBlock () ;
parent . isBlock () || NodeUtil . isAnyFor ( parent ) || parent . isScript () || parent . isModuleBody () || parent . isLabel ()
boolean scanInnerBlocks = n . isSyntheticBlock () || NodeUtil . isFunctionBlock ( n ) || n . isModuleBody () ;
TypedScope s = new TypedScopeCreator ( compiler , CodingConventions . getDefault () ) . createInitialScope ( new Node ( Token.BLOCK ) ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
testMissingRequireCall ( js , STRING_CONSTANT ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
if ( this . optimizePropertyIndex && isObjectLiteralThatCanBeSkipped ( type ) ) { type = this . sentinelObjectLiteral ; }
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
invalidationMap . get ( t )
throw Throwables . propagate ( cause ) ;
if ( exception [ NUMBER_CONSTANT ] != null ) { Throwables . propagate ( exception [ NUMBER_CONSTANT ] ) ; }
try { TextFormat . merge ( textProto , builder ) ; } catch ( Exception e ) { throw Throwables . propagate ( e ) ; }
{ try { initialize ( metadata . getCompiler () ) ; } catch ( Exception e ) { Throwables . propagate ( e ) ; } }
@ Override public void setUp ( ) throws Exception { super . setUp () ; }
{ CompilerOptions options = super . getOptions () ; if ( enableUnusedLocalAssignmentCheck ) { options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; } return options ; }
getInvalidationsErrors () . get ( t )
private String getNewName () { return paramPredix + uniqueId ++ ; }
{ this . compiler = Preconditions . checkNotNull ( compiler ) ; this . paramPredix = Preconditions . checkNotNull ( paramPrefix ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeMinimizeConditions ( late , useTypes , assumeAccurateNullUndefinedTypes ) ) ;
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeMinimizeConditions ( late , false , false )
new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization , options.assumeAccurateNullUndefinedTypes )
( new NodeTraversal ( compiler , this ) ) . traverseAtScope ( scope ) ;
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testInjects ( STRING_CONSTANT ) ; }
{ addLibrary ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; setLanguage ( ES6 , ES5 ) ; testInjects ( STRING_CONSTANT ) ; }
validateSyntheticBlock ( n . getLastChild () ) ;
{ validateNodeType ( Token.DEFAULT_CASE , n ) ; validateChildCount ( n ) ; validateSyntheticBlock ( n . getLastChild () ) ; }
{ Preconditions . checkState ( body . isBlock () ) ; body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
body . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
block . putBooleanProp ( Node.SYNTHETIC_BLOCK_PROP , true ) ;
public void testEmpty () { this . instrumentationPb = STRING_CONSTANT ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testSwitchCase () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveDo () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( src , src ) ;
public void testForIn () { inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ foldSame ( STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testDivision () { fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( js , js ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
public void testNgInjectToArrowFunctions () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testReturnType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRestParameter () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ testLocal ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testLocal ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
testWithInversion ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( fullJsCode , fullJsCode ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( ! isClinitMethod ( node ) ) { return; } trySubstituteEmptyFunction ( node , t . getCompiler () ) ; }
{ tryRemovingClinit ( t , node , parent ) ; if ( isNewControlBranch ( parent ) ) { clinitsCalledAtBranch = clinitsCalledAtBranch.parent ; } }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode ) ;
this . functionSideEffectMap = ArrayListMultimap . create () ;
PropertyType pt = getPropTypeHelper ( jsdoc , initializer , rawType ) ;
{ lint ( Paths . get ( filename ) , false ) ; }
{ testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testSameEs6 ( STRING_CONSTANT ) ; testWarningEs6 ( STRING_CONSTANT , VariableReferenceCheck.EARLY_REFERENCE ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
options.protectHiddenSideEffects = true ;
NodeTraversal outOfBandTraversal = new NodeTraversal ( compiler , this ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Node root = compiler . parseTestCode ( js ) ; assertEquals ( NUMBER_CONSTANT , compiler . getErrorCount () ) ; return root ; }
ScopeCreator scopeCreator = SyntacticScopeCreator . makeUntypedWithRedeclHandler ( compiler , new DuplicateDeclarationHandler () ) ;
if ( isConstructor ( n ) ) { processConstructor ( n ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , new RemoveCode ( compiler ) , externs , root ) ;
handleTypedefDefinition ( t , n ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
Node memberType = parseTypeExpressionList ( typeName , next () ) ;
lastIndex = replacement . getStartPosition () + replacement . getLength () ;
{ return compilerExecutor . runInCompilerThread ( callable , options != null && options . getTracerMode () . isOn () ) ; }
List < FunctionInformation > possibleSideEffects = getSideEffectsForCall ( callNode , definitionProvider , representativeNodesByName ) ;
this . functionSideEffectMap = new LinkedHashMap <> () ;
Object object
{ Preconditions . checkState ( token == Token.BLOCK ) ; putBooleanProp ( SYNTHETIC_BLOCK_PROP , val ) ; }
public void setTypeI ( TypeI type ) { this . typei = type ; }
public TypeI getTypeI () { return typei ; }
public void setJSType ( JSType jsType ) { this . typei = jsType ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
{ Preconditions . checkState ( parent != null ) ; parent . removeChild ( this ) ; return this ; }
public AncestorIterable getAncestors () { return new AncestorIterable ( this . getParent () ) ; }
public Node getParent () { return parent ; }
void setPropListHead ( PropListItem propListHead ) { this . propListHead = propListHead ; }
PropListItem getPropListHeadForTesting () { return propListHead ; }
public void setStaticSourceFile ( StaticSourceFile file ) { this . putProp ( STATIC_SOURCE_FILE , file ) ; }
PropListItem next
PropListItem next
Object value
{ Preconditions . checkState ( this . propListHead == null , STRING_CONSTANT ) ; this . propListHead = other.propListHead ; return this ; }
Preconditions . checkArgument ( target != null , STRING_CONSTANT ) ;
{ Preconditions . checkArgument ( prevChild.next != null , STRING_CONSTANT ) ; replaceChild ( prevChild.next , newChild ) ; }
{ Preconditions . checkArgument ( child.parent == null ) ; child.parent = this ; }
public Node getSecondChild () { return first.next ; }
public Node getFirstChild () { return first ; }
PropListItem next
PropListItem next
PropListItem next
PropListItem next
@ Override public abstract PropListItem chain ( PropListItem next ) ;
PropListItem next
PropListItem chain ( PropListItem next ) ;
PropListItem getNext ( ) ;
Node memberType = parseTypeExpressionList ( next () ) ;
condition . isCall () && condition . getChildCount () == NUMBER_CONSTANT
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
callName . matchesQualifiedName ( STRING_CONSTANT ) && n . getChildCount () == NUMBER_CONSTANT
boolean isDeprecatedCall = callNode . getChildCount () == NUMBER_CONSTANT && callName . isGetProp () ;
checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
Preconditions . checkState ( left . getChildCount () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( n . getChildCount () == NUMBER_CONSTANT , n ) ;
Preconditions . checkState ( node . getChildCount () == NUMBER_CONSTANT ) ;
if ( createSourceMap ) { mcp . generateSourceMap ( sourceMap ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
assertThat ( templateTypes ) . hasSize ( NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespace . substring ( namespace . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
String shortName = namespaceToRequire . substring ( namespaceToRequire . lastIndexOf ( CHAR_CONS ) + NUMBER_CONSTANT ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope , true ) ; }
setReferencedType ( new NoResolvedType ( registry , getReferenceName () ) ) ;
rightmostName . toUpperCase ()
{ Preconditions . checkState ( isAnalyzableObjectDefinePropertiesDefinition ( n ) ) ; return ImmutableList . of ( n . getLastChild () ) ; }
Preconditions . checkArgument ( parent . isVanillaFor () , STRING_CONSTANT , parent . getToken () ) ;
Preconditions . checkNotNull ( reportPath ) ;
NameInformation referring
NameInformation referring
Preconditions . checkNotNull ( ns ) ;
{ Preconditions . checkNotNull ( name ) ; scopes . put ( node , name ) ; }
Preconditions . checkState ( node . isCall () ) ;
{ super ( name , node ) ; Preconditions . checkState ( node . isCall () ) ; }
{ super ( name , parent . getFirstChild () ) ; Preconditions . checkState ( parent . isAssign () ) ; }
{ checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT6 ) ; checkLocalityOfMarkedCalls ( source , expected , LanguageMode.ECMASCRIPT5 ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , NO_PURE_CALLS ) ; }
assertPureCallsMarked ( templateSrc . replace ( STRING_CONSTANT , STRING_CONSTANT ) , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
assertPureCallsMarked ( source , NO_PURE_CALLS ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = simpleInferExprType ( argNode ) ;
{ String name = NodeUtil . getName ( n ) ; noSideEffectExterns . put ( name , null ) ; }
qname != null && noSideEffectExterns . containsKey ( qname ) && ! isDefinedInSrc
Map < ParamGroup , CompilationParam [] > compilationParamsByGroup = new HashMap <> () ;
assertTrue ( functionA . getBodyNode () . isBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isBlock () ) ;
assertTrue ( mainFunction . getBodyNode () . isBlock () ) ;
{ return n . isBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
statement . isBlock ()
Preconditions . checkState ( n . getFirstChild () . isBlock () , n ) ;
markNameProcessed ( nameNode . getQualifiedName () ) ;
Preconditions . checkState ( root . isBlock () ) ;
if ( ! originalBody . isBlock () ) { originalBody = IR . block ( IR . returnNode ( originalBody ) ) . useSourceInfoFromForTree ( originalBody ) ; }
! body . isBlock ()
Preconditions . checkState ( block . isBlock () ) ;
Preconditions . checkState ( body . getNext () == null && body . isBlock () , body ) ;
checkState ( body . isBlock () , body ) ;
if ( n . isExprResult () || n . isBlock () ) { return; }
Preconditions . checkArgument ( block . isBlock () , STRING_CONSTANT ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isBlock ()
if ( body . isBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
if ( ! n . isBlock () || ! n . hasChildren () ) { return; }
if ( newChild . isBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
if ( ! n . isScript () && ! n . isBlock () ) { return; }
parent . isScript () || ( parent . isBlock () && parent . getParent () . isFunction () )
c . isBlock ()
c . isBlock ()
Preconditions . checkState ( caseBody . isBlock () ) ;
! labeledStatement . isBlock ()
last . isBlock ()
currentStatement . isBlock ()
if ( ! favorsCommaOverSemiColon && ! block . isBlock () ) { return false ; }
Preconditions . checkArgument ( node . isBlock () ) ;
parent != null && ( parent . isBlock () || parent . isScript () )
s . isFunctionScope () && s . getRootNode () . getLastChild () . isBlock ()
for ( Node child : node . children () ) { if ( child . isBlock () ) { blocks . add ( child ) ; } }
! target . getParent () . isScript () && ! target . getParent () . isBlock ()
! n . getParent () . isScript () && ! n . getParent () . isBlock ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isBlock () && ! scopeRoot . getParent () . isFunction ()
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isBlock ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isBlock () ) { return false ; }
if ( ! n . isFunction () || ! n . getLastChild () . isBlock () ) { return; }
umdPattern.activeBranch . isBlock () && umdPattern.activeBranch . getChildCount () == NUMBER_CONSTANT
n . isBlock ()
n . isBlock ()
n . isBlock ()
n . isBlock ()
if ( n . isEmpty () || ( n . isBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isBlock ()
if ( ! body . isBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
{ Preconditions . checkArgument ( blockNode . isBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isBlock () ) { visitBlock ( n ) ; }
{ Preconditions . checkArgument ( n . isBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
Preconditions . checkState ( addingRoot . isBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
Preconditions . checkState ( block . isBlock () ) ;
node . isBlock ()
for ( ; ! currentParent . isScript () && ! currentParent . isBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
if ( ! ( parent . isScript () || grandparent != null && grandparent . isFunction () && parent . isBlock () ) ) { return; }
body . isBlock () && ! body . hasChildren ()
{ return ( n . isBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
Preconditions . checkState ( block . isBlock () ) ;
return expectedBlock . isBlock () ? expectedBlock : null ;
if ( ! subtree . isScript () && ! subtree . isBlock () ) { return subtree ; }
Preconditions . checkState ( n . isBlock () , n ) ;
if ( maybeAssign . isBlock () || maybeAssign . isScript () || NodeUtil . isStatement ( maybeAssign ) ) { return; }
n . isBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( finallyBody . isBlock () ) ;
Preconditions . checkState ( tryBody . isBlock () ) ;
{ Preconditions . checkState ( body . isBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
Preconditions . checkState ( then . isBlock () ) ;
Preconditions . checkState ( body . isBlock () ) ;
! isArrow && ! isSignature && ! bodyNode . isBlock ()
! irNode . isBlock ()
n . hasChildren () && n . getFirstChild () . isBlock ()
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isBlock () ) ;
Preconditions . checkState ( externs . isBlock () ) ;
{ assertTrue ( mainRoot . isBlock () && ! mainRoot . hasChildren () ) ; }
assertTrue ( functionA . getBodyNode () . isNormalBlock () ) ;
assertTrue ( mainFunction . getAstNode () . isRoot () ) ;
assertTrue ( mainFunction . getBodyNode () . isRoot () ) ;
return ImmutableList . of ( bang , qmark ) ;
return scopeRoot . isBlock () && scopeRoot . getParent () != null && scopeRoot . getParent () . isFunction () ;
n . isBlock ()
( parent . isScript () || ( parent . isBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
block . isBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
node . isBlock () && parent != null && parent . isTry () && NodeUtil . getCatchBlock ( parent ) == node
if ( ! n . isBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
if ( ! block . isBlock () ) { return false ; }
if ( node . isBlock () ) { node . setToken ( Token.SCRIPT ) ; }
boolean needsSemicolon = parent != null && ( parent . isExprResult () || parent . isBlock () || parent . isScript () ) ;
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isBlock () )
Preconditions . checkState ( parentNode . isBlock () , STRING_CONSTANT ) ;
endPass () ;
endPass () ;
endPass () ;
endPass () ;
! currentScope . hasThis () && NodeUtil . referencesSuper ( fn )
Renamer forChildScope ( boolean hoisted ) ;
{ renamer = nameStack . peek () . forChildScope ( ! NodeUtil . createsBlockScope ( declarationRoot ) ) ; }
if ( isInferrableConst ( jsdoc , name ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
if ( ! isInferrableConst ( jsdoc , nameNode ) ) { return; }
testSame ( STRING_CONSTANT ) ;
warnings . add ( JSError . make ( propAccessNode , ABSTRACT_METHOD_NOT_CALLABLE , funName ) ) ;
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Node argList = getFunctionArgList ( function ) ;
Node argList = getFunctionArgList ( function ) ;
throw new MalformedException ( STRING_CONSTANT + node . getToken () , fnChild ) ;
findDeclaredNames ( functionBody , null , renamer ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , null , renamer ) ; }
if ( isCallInLoop ) { fixUnitializedVarDeclarations ( newBlock , newBlock ) ; }
Preconditions . checkArgument ( declaration . isName () ) ;
void clear () { prefixNames . clear () ; seenNames . clear () ; constructorsToProcess . clear () ; }
for ( String prefix : Iterables . concat ( seenNames , prefixNames ) ) { if ( fullyQualifiedName . startsWith ( prefix ) ) { return true ; } }
if ( instrumentationData . get ( fileName ) != null ) { node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; }
{ node . addChildToFront ( newHeaderNode ( traversal , node ) ) ; instrumentBranchCoverage ( traversal , instrumentationData . get ( fileName ) ) ; }
{ return isUnionType () ? this . toMaybeUnionType () . getAlternates () : null ; }
JSType type
JSType type = getType ( typeObj ) ;
JSType type = getType ( n ) ;
this . BOTTOM_OBJECT = this . registry . getNativeType ( JSTypeNative.NO_OBJECT_TYPE ) . toObjectType () ;
JSType type
JSType type
{ objectType = FunctionType . getTopDefiningInterface ( objectType , propName ) ; }
if ( isInterface () ) { return getTopDefiningInterface ( getInstanceType () , propertyName ) ; }
if ( lvalueType . isEnumElement () ) { lvalueType = lvalueType . getEnumeratedType () ; }
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
JSType enumeratedType = requiredType . getProp ( new QualifiedName ( pname ) ) . getEnumeratedType () ;
{ NominalType tmp = NominalType . pickSuperclass ( n1 , n2 ) ; if ( tmp != null ) { return tmp . getInstanceAsJSType () ; } }
NominalType nominal = NominalType . pickSuperclass ( nt1 , nt2 ) ;
@ Override public CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler ) ; }
{ Preconditions . checkState ( n . isName () , n ) ; n . removeChild ( n . getFirstChild () ) ; }
parent . removeChild ( parent . getFirstChild () ) ;
! currentScript.declareLegacyNamespace && currentScript.defaultExportRhs == null && namedExport . hasInlinableName ()
Preconditions . checkArgument ( o instanceof JSType ) ;
this . registry = compiler . getTypeRegistry () ;
test ( externs , js , expected , null , warning , description ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES + STRING_CONSTANT + STRING_CONSTANT ;
testSets ( BaseJSTypeTestCase.ALL_NATIVE_EXTERN_TYPES , js , output , STRING_CONSTANT ) ;
{ super . setUp () ; super . enableNormalize () ; super . enableTypeCheck () ; }
public DisambiguatePropertiesTest () { parseTypeInfo = true ; }
if ( ! t . inGlobalHoistScope () ) { return false ; }
{ assertEquals ( e . getType () , type ) ; assertEquals ( e.lineNumber , lineNumber ) ; }
assertEquals ( result.errors [ NUMBER_CONSTANT ] . getType () , errorType ) ;
assertTrue ( result.success ) ;
assertTrue ( compiler . getResult () . success ) ;
checkShortGoogRequireCall ( t , callNode , parent ) ;
options . setPolymerPass ( true ) ;
polymerPass = false ;
if ( options.deadAssignmentElimination ) { passes . add ( deadAssignmentsElimination ) ; if ( ! options.polymerPass ) { passes . add ( deadPropertyAssignmentElimination ) ; } }
if ( options.polymerPass ) { checks . add ( polymerPass ) ; }
options . setPolymerPass ( true ) ;
if ( other . isGeneric () ) { other = instantiateGenericsWithUnknown ( other ) ; }
{ if ( this . equals ( other ) ) { return true ; } return instantiateGenericsWithUnknown ( this ) . isSubtypeOfHelper ( other , checkThisType , subSuperMap , boxedInfo ) ; }
if ( isGeneric () ) { return instantiateGenericsWithUnknown ( this ) . transformByApplyProperty () ; }
Preconditions . checkArgument ( rootNode != parent.rootNode , STRING_CONSTANT , rootNode , parent.rootNode ) ;
public void testDontCrashCtorAliasWithEnum () { test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
public void testGlobalObjectDeclaredToPreserveItsPreviousValue2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjLitAssignmentDepth2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
boolean isConstDeclaration () { return getParent () . isConst () ; }
boolean isVarDeclaration () { return getParent () . isVar () ; }
{ traverseClass ( n , parent ) ; }
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
String zipEntryPath = STRING_CONSTANT + absoluteZipPath + STRING_CONSTANT + entryPath ;
options . setPrettyPrint ( true ) ;
this . prettyPrint = options . isPrettyPrint () ;
public void testJqueryExpandedEachExpansionEs6ComputedProp () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ExpandJqueryAliases.JQUERY_UNABLE_TO_EXPAND_INVALID_NAME ) ; }
options.prettyPrint = true ;
this . prettyPrint = options.prettyPrint ;
{ options . setPolymerPass ( value ) ; }
fix . getReplacements () . keys ()
nameDefinitionMultimap . keys ()
nameDefinitionMultimap . keySet ()
nameDefinitionMultimap . keys ()
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = Joiner . on ( CHAR_CONS ) . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testError ( STRING_CONSTANT , VarCheck.VAR_ARGUMENTS_SHADOWED_ERROR ) ;
{ checkState ( scope . getParent () == null ) ; scanVars ( n , true , true ) ; }
{ CompilerOptions options = createCompilerOptions () ; options . setCheckTypes ( true ) ; test ( options , STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; }
public void testTypeParsingOnWithVerbose () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; test ( STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ; }
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.TYPE_PARSE_ERROR ) ;
markConstAndCopyJsDoc ( assignNode , jsdocNode , rhs ) ;
markConstAndCopyJsDoc ( target , target , value ) ;
markConstAndCopyJsDoc ( jsdocNode , jsdocNode , parent . getLastChild () ) ;
{ return list . get ( list . size () - NUMBER_CONSTANT ) ; }
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
super . setCode ( cachedCode , this . getCharset () == StandardCharsets.UTF_8 ) ;
if ( this . ns != null ) { builder . append ( this . ns . toString () ) ; }
{ if ( inheritedPropDef.methodType != null ) { propMethodTypesToProcess . put ( pname , inheritedPropDef.methodType . substituteNominalGenerics ( superType ) ) ; } }
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) . substituteGenerics ( typeMap ) ; }
this . inGeneratorContext . add ( initialGeneratorContext ) ;
Node namespaceArg = crDefineCallNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
Node pathArg = crExportPathNode . getChildAtIndex ( NUMBER_CONSTANT ) ;
String target = call . getChildAtIndex ( NUMBER_CONSTANT ) . getQualifiedName () ;
{ int result = BASE64_DECODE_MAP [ c ] ; assert ( result != - NUMBER_CONSTANT ) : STRING_CONSTANT ; return BASE64_DECODE_MAP [ c ] ; }
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
ParseTree arrowFunctionBody = parseArrowFunctionBody ( expressionIn ) ;
parseGeneratorFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
parseFunctionTail ( builder , isGenerator ) ;
recvType = recvType . removeType ( commonTypes.NULL ) ;
if ( NodeUtil . isCallTo ( destructuringLhsNode . getLastChild () , STRING_CONSTANT ) ) { return; }
if ( aliasVarNodeRhs == null || ! NodeUtil . isCallTo ( aliasVarNodeRhs , STRING_CONSTANT ) ) { t . report ( call , INVALID_GET_ALIAS ) ; return; }
return call != null && NodeUtil . isCallTo ( call , STRING_CONSTANT ) && call . getLastChild () . isFunction () ;
nameGenerator . reset ( reservedNames , STRING_CONSTANT , reservedCharacters ) ;
{ this ( compiler , generatePseudoNames , prevUsedPropertyMap , null , nameGenerator ) ; }
{ this ( compiler , generatePseudoNames , null , null , nameGenerator ) ; }
NameGenerator nameGen = new DefaultNameGenerator ( reservedNames . build () , STRING_CONSTANT , reservedCharacters ) ;
reset ( reservedNames , prefix , reservedCharacters ) ;
{ return new AmbiguateProperties ( compiler , options.anonymousFunctionNaming . getReservedCharacters () ) ; }
if ( isBottom () || isUnknown () || hasTruthyMask () ) { return this . commonTypes . UNKNOWN ; }
private boolean hasFalsyMask () { return FALSY_MASK == getMask () ; }
private boolean hasTruthyMask () { return TRUTHY_MASK == getMask () ; }
Preconditions . checkState ( this . isFinalized ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isLiteralObject () ) ;
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; TypeMismatch . recordImplicitUseOfNativeObject ( this . mismatches , n , caseType , switchType ) ; }
{ recordImplicitInterfaceUses ( n , argType , paramType ) ; recordImplicitUseOfNativeObject ( n , argType , paramType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , rightType , leftType ) ; recordImplicitUseOfNativeObject ( n , rightType , leftType ) ; }
{ recordImplicitInterfaceUses ( n , caseType , switchType ) ; recordImplicitUseOfNativeObject ( n , caseType , switchType ) ; }
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
boolean createdFromGoogProvide = ( type != null && type . isInstanceofObject () ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
for ( Var v : globalExternsScope . getAllSymbols () ) { considerVar ( v , null ) ; }
scope . getAllSymbols ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getAllSymbols () ) ; }
parseWarning ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( Var v : globalExternsScope . getVarIterable () ) { considerVar ( v , null ) ; }
scope . getVarIterable ()
for ( TypedScope s : scopes . values () ) { Iterables . addAll ( vars , s . getVarIterable () ) ; }
{ return isContinueStructure ( target ) && matchLabel ( target . getParent () , label ) ; }
{ if ( leftOfArrow.type == ParseTreeType.CALL_EXPRESSION ) { return completeAssignmentExpressionParseAtArrow ( leftOfArrow . asCallExpression () , expressionIn ) ; } else { return completeArrowFunctionParseAtArrow ( leftOfArrow , expressionIn ) ; } }
if ( ! sourceType . isSubtypeWithoutStructuralTyping ( targetType ) ) { recordImplicitInterfaceUses ( n , sourceType , targetType ) ; }
recordImplicitInterfaceUses ( n , argType , paramType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , rightType , leftType ) ;
recordImplicitInterfaceUses ( n , caseType , switchType ) ;
if ( topInterface != null && topInterface . getConstructor () != null ) { foundType = topInterface . getConstructor () . getPrototypeProperty () ; }
if ( isPrototypeObject () ) { return builder . append ( getOwnerFunction () . getInstanceTypeOfCtor () ) . append ( STRING_CONSTANT ) ; }
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnPropery ( new QualifiedName ( propertyName ) ) ; }
if ( this . equals ( proto ) ) { Preconditions . checkState ( this . isUnknownObject () , STRING_CONSTANT , this ) ; return null ; }
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
testSets ( js , output , STRING_CONSTANT + STRING_CONSTANT ) ;
n . isVar () && n . getFirstFirstChild () != null && n . getFirstFirstChild () . isFunction ()
return builder () . withCharset ( inputCharset ) . withOriginalPath ( originalZipPath + STRING_CONSTANT + entryPath ) . buildFromUrl ( zipEntryUrl ) ;
assertPasses ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
parent . isVar () || parent . isExprResult ()
println ( STRING_CONSTANT + funType ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , FindExportableNodes.EXPORT_ANNOTATION_NOT_ALLOWED ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendPlaceholderReference ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
{ registerMessage ( new JsMessage.Builder ( STRING_CONSTANT ) . appendStringPart ( STRING_CONSTANT ) . build () ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected void setUp () { style = RELAX ; compareJsDoc = false ; }
@ Override public void setUp () { enableNormalize () ; compareJsDoc = false ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
{ if ( options == null ) { initOptions ( new CompilerOptions () ) ; } return errorManager ; }
inputsById . clear () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
Preconditions . checkState ( ! areSubtypes ) ;
{ switch ( ch ) { case CHAR_CONS : case CHAR_CONS : return true ; default: return Character . isLetter ( ch ) ; } }
{ if ( options == null ) { initOptions ( newCompilerOptions () ) ; } return errorManager ; }
inputsById = new HashMap <> () ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = errorManager ; }
Preconditions . checkArgument ( callNode . isCall () ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
testSame ( STRING_CONSTANT ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ; return options ; }
Node root = compiler . getRoot () . getLastChild () ;
{ assertThat ( aggregateWarnings ) . isEmpty () ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testCodeMotionDoesntBreakFunctionHoisting ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; }
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ; test ( js , js , null , null ) ; }
public void testConst () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testLet () { testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT3 ) ; testRewriteWarning ( code , expected , warning , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewriteError ( js , error , LanguageMode.ECMASCRIPT3 ) ; testRewriteError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ testRewrite ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testRewrite ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( true ) ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT8 ;
public void testAsyncArrowFunction () { languageMode = LanguageMode.ECMASCRIPT8 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT8 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testMemberGeneratorYield1 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testNewTarget () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParametersWithRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testRestParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDefaultParameters () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testOctalNumericKey () { allowWarnings = true ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testComputedPropertiesClassMethods () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
{ assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrettyPrinter_defaultValue ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testPrettyPrinter_arrow ( ) throws Exception { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testForOf () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testDestructuringForOfLoops2 () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintDestructuringInRestParam () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintMixedDestructuring () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintNestedObjectPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
public void testPrettyPrintArrayPattern () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrettyPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
{ languageMode = LanguageMode.ECMASCRIPT6 ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
languageMode = LanguageMode.ECMASCRIPT6 ;
public void testPrintBlockScopedFunctions () { languageMode = LanguageMode.ECMASCRIPT6 ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPrint ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationAssignmentOperator () { languageMode = LanguageMode.ECMASCRIPT7 ; assertPrintSame ( STRING_CONSTANT ) ; }
languageMode = LanguageMode.ECMASCRIPT7 ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; compiler = createCompiler () ; }
public void testWhileLoopBranch ( ) throws Exception { compareWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopMultiLineBranch ( ) throws Exception { compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopMultiLineBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testDoWhileLoopBranch ( ) throws Exception { compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareDoWhileLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testForLoopBranch ( ) throws Exception { compareForLoopBranch ( LanguageMode.ECMASCRIPT5 ) ; compareForLoopBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfElseBranch ( ) throws Exception { compareIfElseBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfElseBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testIfBranch ( ) throws Exception { compareIfBranch ( LanguageMode.ECMASCRIPT5 ) ; compareIfBranch ( LanguageMode.ECMASCRIPT6 ) ; }
public void testFunction ( ) throws Exception { compareFunctionOneMode ( LanguageMode.ECMASCRIPT5 ) ; compareFunctionOneMode ( LanguageMode.ECMASCRIPT6 ) ; }
return languageOutIsAtLeast ( LanguageMode.ECMASCRIPT6 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 , CompilerOptions.LanguageMode.ECMASCRIPT5 ) ;
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; }
{ testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT6 ) ; testExternChanges ( extern , input , expectedExtern , LanguageMode.ECMASCRIPT5 ) ; }
{ testWarning ( js , expected , warning , LanguageMode.ECMASCRIPT6 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning , warningMessage ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testWarning ( js , warning ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testWarning ( js , warning ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; testError ( js , error , LanguageMode.ECMASCRIPT5 ) ; }
{ testError ( js , error , LanguageMode.ECMASCRIPT6 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , es6Error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , es5Error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testError ( js , error ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . testError ( js , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( externs , js , diag , error ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . testSame ( externs , js , warning ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , js ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , js ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ test ( js , expected , LanguageMode.ECMASCRIPT6 ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; super . test ( js , expected ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; super . test ( js , expected ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; anchorUnusedVars = false ; canRemoveExterns = false ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; allowExternsChanges ( false ) ; }
{ CompilerOptions options = super . getOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT6 ) ; return options ; }
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , VarCheck.VIOLATED_MODULE_DEP_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , VarCheck.MISSING_MODULE_DEP_ERROR ) ; }
public void testLegalConstReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testLegalLetReferenceBetweenModules () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testForLoopsEs6 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; assertUnreachable ( STRING_CONSTANT ) ; assertUnreachable ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public CheckUnusedPrivatePropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
{ compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setLanguageInAndOut ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testFunctionNonMovement1 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( createModuleStar ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
public void testInvalidVariableInScope () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_INVALID_VARIABLE ) ; }
public void testNonAliasLocal () { testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT6 ) ; }
{ testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT3 ) ; testScopedNoChanges ( aliases , code , LanguageMode.ECMASCRIPT6 ) ; }
{ testScoped ( code , expected , LanguageMode.ECMASCRIPT3 ) ; testScoped ( code , expected , LanguageMode.ECMASCRIPT6 ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testAsyncFunction () { setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; testError ( STRING_CONSTANT , CANNOT_CONVERT_YET ) ; }
public void testExponentiationAssignmentOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testExponentiationOperator () { setLanguage ( LanguageMode.ECMASCRIPT7 , LanguageMode.ECMASCRIPT5 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
setLanguage ( LanguageMode.ECMASCRIPT8 , LanguageMode.ECMASCRIPT5 ) ;
public void testValidRestParameter () { setLanguage ( LanguageMode.ECMASCRIPT6 , LanguageMode.ECMASCRIPT5 ) ; valid ( STRING_CONSTANT ) ; valid ( STRING_CONSTANT ) ; }
options . setLanguage ( LanguageMode.ECMASCRIPT8 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
return CompilerOptions.LanguageMode.ECMASCRIPT6_STRICT ;
this . languageIn = CompilerOptions.LanguageMode.ECMASCRIPT6 ;
options . setLanguage ( LanguageMode.ECMASCRIPT6_STRICT ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageOut ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
setLanguage ( LanguageMode.ECMASCRIPT6_STRICT , LanguageMode.ECMASCRIPT5_STRICT ) ;
compiler . getOptions () . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
{ testError ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( createShorthandFunctionInObjLit ( body ) ) ; }
{ testOk ( createFunction ( body ) ) ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testOk ( createShorthandFunctionInObjLit ( body ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testEs6EnhancedObjLiteralsComputedValuesNotRemoved () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; }
public void testEs6GettersWithoutTranspilation () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; languageOut = LanguageMode.ECMASCRIPT3 ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; disableTypeCheck () ; runTypeCheckAfterProcessing = true ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( createShorthandFunctionInObjLit ( returnType , body ) ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; String js = createShorthandFunctionInObjLit ( returnType , body ) ; testWarning ( js , CheckMissingReturn.MISSING_RETURN_STATEMENT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ;
public void testNoMoveDeepFunctionDeclarations () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT6_STRICT ) ;
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrowFunction4 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction3 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrowFunction2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
public void testArrowFunction1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testFailure ( STRING_CONSTANT ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; propertyRenaming = PropertyRenamingPolicy.ALL_UNQUOTED ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT8 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; runTypeCheckAfterProcessing = true ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
public void testTaggedTemplateError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
{ setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; testError ( STRING_CONSTANT , ObjectPropertyStringPreprocess.STRING_LITERAL_EXPECTED_ERROR ) ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNoRewriteIfNotInGlobalScope1 ( ) throws Exception { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT6 ) ; testSame ( STRING_CONSTANT + NoRewriteIfNotInGlobalScopeTestInput.INPUT + STRING_CONSTANT ) ; }
setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ;
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT6 ) ; runTypeCheckAfterProcessing = true ; compareJsDoc = true ; }
replaceSymbol ( n , name , t . getInput () ) ;
com.google.javascript.jscomp.newtypes.FunctionType ctorType = functionType . getFunTypeIfSingletonObj () ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
replaceSymbol ( t , n , name , t . getInput () ) ;
findDeclaredNames ( functionBody , renamer , false ) ;
if ( ! declarationRoot . isFunction () ) { findDeclaredNames ( declarationRoot , renamer , false ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTypeCheck () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
{ checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
checkState ( child.parent == this ) ;
{ Preconditions . checkState ( n . hasOneChild () , n ) ; newInitializer = n . getFirstChild () ; n . removeChild ( newInitializer ) ; }
Preconditions . checkState ( this . isFinalized , STRING_CONSTANT , this ) ;
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addUndeclaredProperty ( pname , defSite , this . commonTypes . UNKNOWN , false ) ; }
{ Preconditions . checkState ( ! this . isFinalized ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( this . isFinalized ) ;
if ( ! this . isFinalized ) { return null ; }
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
Preconditions . checkState ( ! this . isFinalized ) ;
public boolean isStruct () { Preconditions . checkState ( isFinalized () || isClass () ) ; return this . objectKind . isStruct () ; }
{ if ( isFinalized && externs . containsKey ( name ) ) { type = externs . get ( name ) ; } }
Preconditions . checkState ( isFinalized ) ;
Preconditions . checkState ( this . rawType . isFinalized () ) ;
{ Preconditions . checkState ( this . rawType . isFinalized () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFinalized () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFinalized () ) ; return this . rawType ; }
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
Preconditions . checkArgument ( nominalType . isFinalized () ) ;
if ( ! thisNode . isEquivalentToShallow ( thatNode ) ) { return false ; }
ScopedChangeHandler () { this . lastCodeChangeQuery = timestamp ; }
maybeSanityCheck ( externs , root ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp () { super . enableNormalize () ; }
@ Override protected void setUp () { nameGenerator = null ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { enableNormalize () ; }
public InlineVariablesConstantsTest () { enableNormalize () ; }
@ Override public void setUp () { enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
@ Override public void setUp () { enableNormalize () ; }
globalScope = TypedScope . createGlobalScope ( blockNode ) ;
{ fieldType = createFromTypeNodesInternal ( fieldTypeNode . getLastChild () , sourceName , scope ) ; }
setReferencedType ( registry . getNativeObjectType ( JSTypeNative.NO_RESOLVED_TYPE ) ) ;
@ Override public void setUp () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; validateAstChangeMarking ( false ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
compiler . reportCodeChange () ;
{ Node grandparent = parent . getParent () ; replaceWithEmpty ( parent , grandparent ) ; compiler . reportCodeChange () ; }
@ Override public boolean isUnresolved () { return false ; }
JSTypes getCommonTypes () { return this . commonTypes ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ newBlockNode . useSourceInfoIfMissingFromForTree ( oldBlockNode ) ; functionNode . replaceChild ( oldBlockNode , newBlockNode ) ; compiler . reportCodeChange () ; }
if ( ! origValueNode . getString () . equals ( newString ) ) { origValueNode . setString ( newString ) ; compiler . reportCodeChange () ; }
if ( newValue != msgNode ) { newValue . useSourceInfoIfMissingFromForTree ( msgNode ) ; msgNode . replaceWith ( newValue ) ; compiler . reportCodeChange () ; }
enableTypeCheck () ;
public void testCoercionSubstitution_boxedNumberVsZero () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { enableTypeCheck () ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
compiler . reportCodeChange () ;
{ Node retValue = returnedValue . cloneTree () ; parent . replaceChild ( call , retValue ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( ! p.newName . equals ( oldName ) ) { n . setString ( p.newName ) ; compiler . reportCodeChange () ; }
@ Override public void setUp () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( ! collapses . isEmpty () ) { applyCollapses () ; compiler . reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; reportCodeChange () ; return n ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; reportCodeChange () ; return null ; }
this . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ parent . removeChild ( n ) ; compiler . reportCodeChange () ; functions . put ( t . getModule () , n ) ; }
if ( codeChanged ) { reportCodeChange () ; }
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
t . getCompiler () . reportCodeChange () ;
compiler . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; reportCodeChange () ; return result ; }
reportCodeChange () ;
reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; reportCodeChange () ; return replacementNode ; }
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override protected void setUp () { allowExternsChanges ( true ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
void apply () { parent . replaceChild ( oldChild , newChild ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . setString ( newName ) ; t . getCompiler () . reportCodeChange () ; return; }
public InlineVariablesConstantsTest () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
{ n . setString ( prop + fileid ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override protected void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
if ( node != null ) { n . setDeclaredTypeExpression ( node ) ; compiler . reportCodeChange () ; }
{ attachTypeExpr = IR . rest ( n . getString () ) ; n . replaceWith ( attachTypeExpr ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; reportCodeChange () ; } }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
@ Override protected void setUp () { super . enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
for ( Node closureRequire : requiresToBeRemoved ) { closureRequire . detach () ; compiler . reportCodeChange () ; }
notifyOfRemoval ( node ) ;
{ parent . removeChild ( node ) ; notifyOfRemoval ( node ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( STRING_CONSTANT ) ; }
reportCodeChange ( STRING_CONSTANT ) ;
reportCodeChange ( STRING_CONSTANT ) ;
test ( options , code , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; NodeTraversal . traverseEs6 ( compiler , root , denormalizePass ) ; }
scope . isLocal ()
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( maybeNormalizeFunctionDeclaration ( n ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ return new TypeInformationGatherer ( compiler , new DevirtualizePrototypeMethods ( compiler ) , typeInformation ) ; }
Iterable < JSModule > getAllModules () { return modules ; }
n . isName () && n . getParent () . isVar ()
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
compiler . setScope ( root ) ;
setInputId ( null , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( scopeRoot ) , STRING_CONSTANT ) ;
setInputId ( NodeUtil . getInputId ( root ) , STRING_CONSTANT ) ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ c . setQuotedString () ; compiler . reportCodeChange () ; }
@ Override public void setUp () { super . enableLineNumberCheck ( false ) ; validateAstChangeMarking ( false ) ; }
{ Node dollarChildProp = n . getGrandparent () ; dollarChildProp . setToken ( Token.GETELEM ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ parent . replaceChild ( n , declaringNode . getFirstFirstChild () . cloneTree () ) ; compiler . reportCodeChange () ; }
{ if ( isUtilGetDefineCall ( n ) ) { substituteUtilGetDefine ( n ) ; } }
t . getCompiler () . reportCodeChange () ;
t . getCompiler () . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( isGoogLoadModuleStatement ( n ) ) { updateGoogLoadModuleLate ( n ) ; }
{ n . putBooleanProp ( Node.GOOG_MODULE , true ) ; inlineModuleIntoGlobal ( n ) ; compiler . reportCodeChange () ; checkAndSetStrictModeDirective ( t , n ) ; }
if ( newJsdoc != null ) { jsdocNode . setJSDocInfo ( newJsdoc ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ if ( NodeUtil . isDestructuringDeclaration ( n ) ) { splitDeclaration ( n , parent ) ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; compiler . reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; compiler . reportCodeChange () ; return null ; }
for ( Node childToRemove : nodesToRemove ) { node . removeChild ( childToRemove ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ visitArrowFunction ( n , checkNotNull ( thisContext ) ) ; }
if ( ! newNode . isEquivalentTo ( n ) ) { parent . replaceChild ( n , newNode ) ; compiler . reportCodeChange () ; return newNode ; }
if ( rhs . isChanged () ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( placeholder , mNode . getNode () . removeFirstChild () ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
if ( follow == null || areMatchingExits ( n , follow ) ) { n . detach () ; compiler . reportCodeChange () ; return null ; }
this . compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( tryReplaceArguments ( traversal . getScope () ) ) { traversal . getCompiler () . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; compiler . reportCodeChange () ; return newLiteralNode ; }
if ( canFoldStandardConstructors ( n ) ) { n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
visitClass ( n , parent ) ;
visitRestParam ( n , parent ) ;
compiler . reportCodeChange () ;
{ if ( NodeUtil . getPureBooleanValue ( forCondition ) == TernaryValue.TRUE ) { forCondition . replaceWith ( IR . empty () ) ; compiler . reportCodeChange () ; } }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; compiler . reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ maybeBreak . detach () ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; compiler . reportCodeChange () ; return right ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ callTarget . getLastChild () . setString ( STRING_CONSTANT ) ; firstArg . getNext () . detach () ; compiler . reportCodeChange () ; return n ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
JSTypeExpression typeExpr = getTypeFromGetterOrSetter ( member ) . clone () ;
{ if ( expr != null ) { return cloneTypeNodes ? expr . clone () : expr ; } return null ; }
if ( foundObj . isGeneric () ) { foundType = foundObj . getRawType () ; }
ImmutableMap < String , JSType > typeVars
if ( obj != null && obj . isGeneric () ) { return obj . instantiateGenericsWithUnknown () ; }
if ( foundType != null && foundType . isGeneric () ) { foundType = foundType . getRawType () ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new PropagateConstJsdoc ( compiler ) ) ; new RemoveCode ( compiler ) . process ( externs , root ) ; }
@ Override public void setUp () { enableNormalize () ; validateAstChangeMarking ( false ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
JSType type = n . getJSType () ;
JSType type = n . getJSType () ;
if ( extractionInfo . shouldExtract () ) { doExtraction ( extractionInfo ) ; compiler . reportCodeChange () ; }
compiler . reportChangeToEnclosingScope ( getKey . getParent () ) ;
{ if ( logger . isLoggable ( Level.FINE ) ) { logger . fine ( STRING_CONSTANT + callName ) ; } inlineEmptyMethod ( parent , callNode ) ; }
t . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; validateAstChangeMarking ( false ) ; }
for ( Definition def : definitionsGatherer.definitions ) { def . remove () ; compiler . reportCodeChange () ; }
if ( codeChanged ) { compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ result . useSourceInfoIfMissingFromForTree ( n ) ; n . replaceWith ( result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
{ n . detachChildren () ; parent . replaceChild ( n , result ) ; compiler . reportCodeChange () ; return result ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( replacementNode != null ) { n . replaceWith ( replacementNode ) ; compiler . reportCodeChange () ; return replacementNode ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; compiler . reportCodeChange () ; }
if ( ! precheck () ) { return; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
@ Override public int getNumRepetitions () { return NUMBER_CONSTANT ; }
if ( Keywords . isKeyword ( idToken.value ) && ! Keywords . isTypeScriptSpecificKeyword ( idToken.value ) ) { reportError ( STRING_CONSTANT + name + STRING_CONSTANT ) ; }
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
optimizer = new PhaseOptimizer ( compiler , tracker , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer optimizer = new PhaseOptimizer ( compiler , null , null ) ;
PhaseOptimizer phaseopt = new PhaseOptimizer ( compiler , null , null ) ;
if ( typeWithBannedProp . isSubtypeOf ( foundType ) ) { if ( matchesPrototype ( typeWithBannedProp , foundType ) ) { return ConformanceResult.VIOLATION ; } else if ( reportLooseTypeViolations ) { return ConformanceResult.POSSIBLE_VIOLATION_DUE_TO_LOOSE_TYPES ; } }
Iterable < JSModule > getAllModules () { return modules ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ clazz . replaceChild ( clazz . getFirstChild () , IR . empty () . useSourceInfoFrom ( clazz . getFirstChild () ) ) ; compiler . reportCodeChange () ; }
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
if ( n . getLineno () == NUMBER_CONSTANT ) { n . setCharno ( n . getCharno () - NUMBER_CONSTANT ) ; compiler . reportCodeChange () ; }
Compiler compiler
reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
compiler . reportCodeChange () ;
{ if ( isMethodOrCtorCallThatTriggersRemoval ( t , n , parent ) ) { replaceHighestNestedCallWithNull ( n , parent ) ; } }
if ( parent . getFirstChild () == n && isReferenceToRemovedVar ( t , n ) ) { replaceHighestNestedCallWithNull ( parent , parent . getParent () ) ; }
{ n . setString ( newName ) ; t . getCompiler () . reportChangeToEnclosingScope ( n ) ; return; }
maybeRewriteClassDefinition ( n ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
this . mode = TypeInferenceMode.BOTH ;
PeepholeFoldConstantsTest () { super ( DEFAULT_EXTERNS ) ; }
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( CodeReplacement . create ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
List < CodeReplacement > replacements = ImmutableList . of ( new CodeReplacement ( NUMBER_CONSTANT , NUMBER_CONSTANT , STRING_CONSTANT ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; }
Iterable < JSModule > getAllModules () { return Arrays . asList ( modules ) ; }
tightenTypeAndDontWarn ( varName , expr , declType , inferredType , requiredType )
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT ) , InliningMode.DIRECT ) ;
Iterable < JSModule > getAllModules () { return modules ; }
NodeTraversal . traverseEs6 ( currentCompiler , currentCompiler.jsRoot , s ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = currentCompiler.jsRoot ; return currentAnalysis ; }
List < TypeMismatch > actual = ImmutableList . copyOf ( compiler . getTypeMismatches () ) ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
JSTypeRegistry registry = compiler . getTypeRegistry () ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , s ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( lastCompiler , lastCompiler.jsRoot , findParameter ) ;
NodeUtil . isCompoundAssignementOp ( n ) || n . isInc () || n . isDec ()
if ( NodeUtil . isCompoundAssignementOp ( n ) ) { normalizeAssignShorthand ( n ) ; }
bundler . appendTo ( out , input , input . getSourceFile () . getCodeCharSource () ) ;
sourceMapOriginalSources . putIfAbsent ( path , originalSourcesLoader . apply ( path ) ) ;
Function < String , SourceFile > originalSourcesLoader
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
read () ;
{ ensureRequirementIsMutable () ; super . addAll ( values , requirement_ ) ; onChanged () ; }
catch ( com.google.protobuf.InvalidProtocolBufferException e ) { parsedMessage = ( com.google.javascript.jscomp.ConformanceConfig ) e . getUnfinishedMessage () ; throw e ; }
private void maybeForceBuilderInitialization () { if ( com.google.protobuf.GeneratedMessage.alwaysUseFieldBuilders ) { getRequirementFieldBuilder () ; } }
private Builder ( com.google.protobuf.GeneratedMessage.BuilderParent parent ) { super ( parent ) ; maybeForceBuilderInitialization () ; }
com.google.protobuf.GeneratedMessage.BuilderParent parent
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseDelimitedFrom ( input , extensionRegistry ) ; }
{ return PARSER . parseFrom ( input , extensionRegistry ) ; }
public void testInlineInFunction () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( n . isAsyncFunction () ) { cannotConvertYet ( n , STRING_CONSTANT ) ; }
inlineFunctionsInFile ( root , STRING_CONSTANT , ImmutableSet . of ( STRING_CONSTANT , STRING_CONSTANT ) , InliningMode.DIRECT ) ;
declaration . isVar () && declaredVarOrProp . isName ()
testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ;
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getLastChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) . getFirstFirstChild () ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
{ Node parent = parse ( STRING_CONSTANT ) ; testGetFunctionName ( parent . getFirstChild () , STRING_CONSTANT ) ; }
if ( sanityCheck != null ) { setSanityCheckState () ; }
{ sanityCheck . create ( compiler ) . process ( externs , root ) ; NodeUtil . verifyScopeChanges ( passName , mtoc , jsRoot ) ; }
if ( n . getFirstChild () . matchesQualifiedName ( Es6ToEs3Converter.INHERITS ) ) { inheritsCalls . add ( n ) ; }
parent . replaceChild ( node , Node . newNumber ( NUMBER_CONSTANT ) . useSourceInfoIfMissingFrom ( node ) ) ;
compiler . optimize () ;
n . isName () && searchIt . currentParent () . isVar () && n . getString () . equals ( STRING_CONSTANT )
( declaration . getParent () . isVar () && ! NodeUtil . isLoopStructure ( declaration . getGrandparent () ) )
public HierarchicalSet ( HierarchicalSet parent ) { this . parent = parent ; }
clinitsCalledAtBranch = new HierarchicalSet ( clinitsCalledAtBranch ) ;
JSType declType = currentScope . getDeclaredTypeOf ( name ) ;
NTIScope innerScope = currentScope . getScope ( fnName ) ;
lhs . isName () && currentScope . isConstVar ( lhs . getString () )
if ( ! currentScope . hasThis () ) { return new EnvTypePair ( inEnv , UNKNOWN ) ; }
return expr . isNew () || ( expr . isCall () && currentScope . isConstructor () && expr . getFirstChild () . isSuper () ) ;
JSType declType = currentScope . getDeclaredTypeOf ( name ) ;
JSType declRetType = currentScope . getDeclaredFunctionType () . getReturnType () ;
guardA . addGuard ( accessControlsOff ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
checkState ( val . isObjectLit () , val ) ;
checkState ( object . isObjectLit () , object ) ;
checkState ( parent . getFirstChild () == name ) ;
Preconditions . checkState ( val . isObjectLit () ) ;
Preconditions . checkState ( object . isObjectLit () ) ;
Preconditions . checkState ( parent . getFirstChild () == name ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( t . getScope () != t . getClosestHoistScope () ) { return; }
public InlineVariablesTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
@ Override void reportChangeToEnclosingScope ( Node n ) { recordChange ( getEnclosingChangeScope ( n ) ) ; notifyChangeHandlers () ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
{ return precedence ( n ) < minPrecedence ; }
{ invalidatingPropRef = ! maybeCandidateDefinition ( t , n , parent ) ; }
JSType type
public Charset getCharset () { return inputCharset ; }
{ inputCharset = c ; }
{ return new OnDisk ( file . toPath () , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return fromFile ( fileName , UTF_8 ) ; }
checkArgument ( child.parent == null ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
catch ( IllegalStateException e ) { assertTrue ( e . getMessage () . contains ( STRING_CONSTANT ) ) ; }
Preconditions . checkState ( ! maybeDecl . isInitializingDeclaration () ) ;
Preconditions . checkState ( references . get ( NUMBER_CONSTANT ) . isDeclaration () ) ;
{ deepestModule = graph . getDeepestCommonDependencyInclusive ( m , deepestModule ) ; }
{ return NodeUtil . precedence ( n . getToken () ) < minPrecedence ; }
Preconditions . checkNotNull ( js ) ;
Preconditions . checkState ( collectionRoot . isScript () || collectionRoot . isRoot () ) ;
{ Preconditions . checkNotNull ( options ) ; return warningsGuard . level ( error ) ; }
{ Preconditions . checkState ( changeScopeRoot . isScript () || changeScopeRoot . isFunction () ) ; recordChange ( changeScopeRoot ) ; notifyChangeHandlers () ; }
if ( currentChangeScope != null ) { Preconditions . checkState ( currentChangeScope . isScript () || currentChangeScope . isFunction () ) ; recordChange ( currentChangeScope ) ; }
Preconditions . checkState ( passes instanceof DefaultPassConfig , STRING_CONSTANT ) ;
Preconditions . checkState ( input . isExtern () , STRING_CONSTANT , input . getName () ) ;
Preconditions . checkState ( currentTracer != null , STRING_CONSTANT ) ;
Preconditions . checkState ( currentTracer == null ) ;
{ Preconditions . checkNotNull ( errorManager , STRING_CONSTANT ) ; this . errorManager = new ThreadSafeDelegatingErrorManager ( errorManager ) ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
if ( ! compiler . hasErrors () ) { compiler . checkAndTranspileAndOptimize () ; compiler . completeCompilation () ; }
blockStack . get ( i ) . root == containingScope . getRootNode ()
if ( clone == null ) { verifyNewNode ( n ) ; } else { verifyNodeChange ( passNameMsg , n , clone ) ; }
grandparent == null || ( ! isPrototypePropertyDeclaration ( grandparent ) && ! isClassPropertyDeclaration ( parent . getFirstChild () , currentScope ) )
ReferenceCollectingCallback.Reference aliasRef = aliasRefs.references . get ( i ) ;
ReferenceCollectingCallback.Reference ref
compiler . reportChangeToEnclosingScope ( expr ) ;
name . equals ( node . getQualifiedName () )
String newName
public InlineObjectLiteralsTest () { enableNormalize () ; }
public Charset getCharset () { return Charset . forName ( inputCharset ) ; }
{ inputCharset = c . name () ; }
{ return new OnDisk ( file , originalPath , charset ) ; }
@ GwtIncompatible ( STRING_CONSTANT ) public static SourceFile fromFile ( String fileName ) { return builder () . buildFromFile ( fileName ) ; }
{ return builder () . buildFromFile ( file ) ; }
{ parent . getParent () . removeChild ( parent ) ; }
qNameRoot != null && EXPORTS . equals ( qNameRoot . getQualifiedName () ) && NodeUtil . isLValue ( qNameRoot )
callbackBlock . getParent () . removeChild ( callbackBlock ) ;
onlyExport . getParent () . removeChild ( onlyExport ) ;
@ Override public boolean isPropertyTestFunction ( Node call ) { return STRING_CONSTANT . equals ( call . getFirstChild () . getQualifiedName () ) ; }
boolean isInClass = n . getParent () . getToken () == Token.CLASS_MEMBERS ;
{ parent . getParent () . removeChild ( parent ) ; }
{ n . getParent () . removeChild ( n ) ; }
{ if ( alreadyRemoved ( n ) ) { continue; } compiler . reportChangeToEnclosingScope ( n ) ; n . getParent () . removeChild ( n ) ; }
if ( defined ) { compiler . reportChangeToEnclosingScope ( vnode . getParent () ) ; vnode . getParent () . removeChild ( vnode ) ; }
assignmentParent . getParent () . removeChild ( assignmentParent ) ;
return parent != null && parent . getToken () == Token.ASSIGN && parent . getFirstChild () == n ;
{ parent . removeChild ( n ) ; if ( ! parent . hasChildren () ) { parent . getParent () . removeChild ( parent ) ; } }
return enclosingNode != null && enclosingNode . getToken () != Token.FUNCTION ;
if ( ! name . equals ( anc . getFirstChild () . getQualifiedName () ) ) { return Ref.Type.ALIASING_GET ; }
Node block = t . getScope () . getRootNode () ;
isASTNormalized () && Token.NAME == constructorNameNode . getToken ()
parent . getParent () . removeChild ( parent ) ;
{ if ( isNamespacePlaceholder ( parent ) ) { compiler . reportChangeToEnclosingScope ( parent ) ; parent . getParent () . removeChild ( parent ) ; } }
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
Preconditions . checkState ( ! name . equals ( ARGUMENTS ) ) ;
Preconditions . checkArgument ( ! idPrefix . isEmpty () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . setString ( newName ) ; compiler . reportChangeToEnclosingScope ( n ) ; }
if ( currentScript.isModule ) { rewriteShortObjectKey ( n ) ; }
{ testWarning ( js , warning , LanguageMode.ECMASCRIPT6 ) ; }
shouldRemove ( nameNode )
if ( isInferrableConst ( jsdoc , name , false ) ) { jsdoc = pullJsdocTypeFromAst ( compiler , jsdoc , name ) ; }
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
ReferenceCollectingCallback collector
public void testNgInjectAddsInjectToClassConstructor ( ) throws Exception { testEs6 ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
{ if ( null == str ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; } this . str = str ; }
this . quoteKeywordProperties = options.quoteKeywordProperties ;
options . assumeStrictThis () || options . getLanguageIn () == LanguageMode.ECMASCRIPT5_STRICT
if ( options . shouldAmbiguateProperties () && ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ) { passes . add ( ambiguateProperties ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
CrossModuleReferenceCollector collector = new CrossModuleReferenceCollector ( compiler , CrossModuleReferenceCollector.DO_NOTHING_BEHAVIOR , new Es6SyntacticScopeCreator ( compiler ) ) ;
@ Override public void setUp () { setLanguage ( ECMASCRIPT_NEXT , ECMASCRIPT_NEXT ) ; behavior = null ; }
public CompilerOptions setEmitUseStrict ( boolean emitUseStrict ) { this . emitUseStrict = emitUseStrict ; return this ; }
builder . setTagAsStrict ( firstOutput && shouldEmitUseStrict () ) ;
{ NodeTraversal . traverse ( compiler , root , this ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , error.description ) ;
{ NodeTraversal . traverse ( compiler , scriptRoot , this ) ; }
NodeTraversal t = new NodeTraversal ( compiler , finder ) ;
NodeTraversal t = new NodeTraversal ( compiler , null ) ;
Preconditions . checkState ( reference . isName () ) ;
if ( unusedAssignment != null && ! isRead && ! hasErrors ) { checkForUnusedLocalVar ( v , unusedAssignment ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
ObjectsBuilder newObjs = new ObjectsBuilder ( ResolveConflictsBy.MEET ) ;
public RemoveSuperMethodsPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
while ( s.parent != null ) { if ( isDefinedLocally ( varName , false ) ) { return false ; } s = s.parent ; }
catch ( MaxIterationsExceededException e ) { assertEquals ( e . getMessage () , STRING_CONSTANT + MAX_STEP + STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertEquals ( e . getMessage () , FixedPointGraphTraversal.NON_HALTING_ERROR_MSG ) ; }
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
options . assumeStrictThis () || options . isStrictModeInput ()
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , builder ) ; }
catch ( Exception e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
options . assumeStrictThis () || options . getLanguageIn () == ECMASCRIPT5_STRICT
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getLanguageMode () , key . getString () )
public CompilerOptions setStrictModeInput ( boolean isStrictModeInput ) { this . isStrictModeInput = isStrictModeInput ; return this ; }
Config.StrictMode strictMode = expectStrictModeInput () ? Config.StrictMode.STRICT : Config.StrictMode.SLOPPY ;
if ( expectStrictModeInput () ) { options . setWarningLevel ( DiagnosticGroups.ES5_STRICT , CheckLevel.ERROR ) ; }
return new InlineFunctions ( compiler , compiler . getUniqueNameIdSupplier () , options.inlineFunctions , options.inlineLocalFunctions , true , options . assumeStrictThis () || options . isStrictModeInput () , options.assumeClosuresOnlyCaptureReferences , options.maxFunctionSizeAfterInlining ) ;
! NodeUtil . isValidQualifiedName ( compiler . getOptions () . getLanguageOut () , name )
Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT )
! NodeUtil . isValidQualifiedName ( compiler . getLanguageMode () , name )
key . isStringKey () && ! key . isQuotedString () && NodeUtil . isValidPropertyName ( compiler . getOptions () . getLanguageOut () , key . getString () )
String finalMessage = STRING_CONSTANT + STRING_CONSTANT + message ;
STRING_CONSTANT + number + ( unsupported ? STRING_CONSTANT : STRING_CONSTANT ) + ( es6Modules ? STRING_CONSTANT : STRING_CONSTANT ) + ( typeScript ? STRING_CONSTANT : STRING_CONSTANT ) + STRING_CONSTANT
( ( FeatureSet ) other ) . unsupported == unsupported
this . number >= other.number && ( this . unsupported || ! other.unsupported )
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ if ( mockToString ) { return STRING_CONSTANT ; } return appendTo ( new StringBuilder () ) . toString () ; }
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
{ parent . replaceChild ( assignNode , assignNode . getLastChild () . detach () ) ; }
builder . append ( CHAR_CONS ) ;
MemoizedScopeCreator scopeCreator
MemoizedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
typedScopeCreator = new MemoizedScopeCreator ( internalScopeCreator ) ;
scopeCreator = new MemoizedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedScopeCreator scopeCreator
MemoizedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
{ foundNodes . put ( name , n ) ; }
{ this . names = names ; foundNodes = new HashMap <> () ; }
Preconditions . checkState ( inputs.length > NUMBER_CONSTANT ) ;
List < SourceFile > externsInputs = ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , externs ) ) ;
test ( compiler , expected , error , warning ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.DECLARE , n ) ; validateAmbientDeclarationHelper ( n . getFirstChild () ) ; }
{ validateEs6TypedFeature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.TYPE_ALIAS , n ) ; validateChildCount ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6TypedFeature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
validateEs6Feature ( STRING_CONSTANT , n ) ;
{ validateEs6Feature ( STRING_CONSTANT , n ) ; validateNodeType ( Token.AWAIT , n ) ; validateWithinAsyncFunction ( n ) ; }
validateEs6Feature ( STRING_CONSTANT , n ) ;
languageMode = options . getLanguageIn () ;
this . languageMode = options . getLanguageIn () ;
{ Compiler compiler = new Compiler () ; compiler . setLanguageMode ( acceptedLanguage ) ; return compiler ; }
{ if ( options.skipNonTranspilationPasses ) { whitespaceOnlyPasses () ; if ( options . lowerFromEs6 () ) { transpileAndDontCheck () ; } } else { check () ; } }
compiler . getOptions () . lowerFromEs6 ()
compiler . getOptions () . lowerFromEs6 ()
Node root2 = compiler . parseSyntheticCode ( source ) ;
if ( options.dartPass && ! options . getLanguageOut () . isEs6OrHigher () ) { checks . add ( dartSuperAccessorsPass ) ; }
options.rewritePolyfills = flags.rewritePolyfills && options . getLanguageIn () . isEs6OrHigher () ;
return replaceNode ( minCond . getPlaceholder () , minCond . getMinimized ( MinimizationStyle.PREFER_UNNEGATED ) ) ;
final int precedence
expectFeatures ( Feature.DESTRUCTURING , Feature.REST_PARAMETERS ) ;
{ Preconditions . checkState ( script . isScript () ) ; if ( TranspilationPasses . isScriptEs6ImplOrHigher ( script ) ) { return true ; } }
isScriptEs6ImplOrHigher ( scriptRoot )
isScriptEs6ImplOrHigher ( singleRoot )
{ if ( isScriptEs6ImplOrHigher ( scriptRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; } } }
{ if ( isScriptEs6ImplOrHigher ( singleRoot ) ) { for ( Callback callback : callbacks ) { NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; } } }
! forTranspileOnly || ( compiler . getOptions () . getLanguageIn () . toFeatureSet () . contains ( FeatureSet.ES6 ) && TranspilationPasses . isScriptEs6ImplOrHigher ( scriptRoot ) )
{ for ( Node singleRoot : root . children () ) { if ( TranspilationPasses . isScriptEs6ImplOrHigher ( singleRoot ) ) { return true ; } } }
return isConst && ! hasAnnotatedType ( jsdoc ) && ! NodeUtil . isNamespaceDecl ( nameNode ) ;
rhs . replaceWith ( IR . cast ( IR . number ( NUMBER_CONSTANT ) , getQmarkTypeJSDoc () ) . srcrefTree ( rhs ) ) ;
new ProcessEs6Modules ( this ) . processFile ( root , forceRewrite ) ;
{ compiler . stage1Passes () ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
{ compiler . restoreState ( serializedInputStream ) ; if ( ! compiler . hasErrors () ) { compiler . stage2Passes () ; } compiler . completeCompilation () ; }
completeCompilation () ;
completeCompilation () ;
{ if ( ! compiler . getFeatureSet () . contains ( feature ) ) { violation ( STRING_CONSTANT + feature , n ) ; } }
features = features . require ( factory . getFeatures () ) ;
for ( LanguageMode mode : LanguageMode . values () ) { if ( mode.featureSet . contains ( feature ) ) { return mode ; } }
{ features = features . require ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.ARRAY_PATTERN_REST ) ;
features = features . require ( Feature.DESTRUCTURING ) ;
features = features . require ( Feature.NEW_TARGET ) ;
features = features . require ( Feature.EXPONENT_OP ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ARROW_FUNCTIONS ) ;
if ( TokenType.STAR_STAR_EQUAL . equals ( operator.type ) ) { features = features . require ( Feature.EXPONENT_OP ) ; }
{ features = features . require ( Feature.TRAILING_COMMA ) ; if ( config.warnTrailingCommas ) { errorReporter . reportWarning ( commaToken.location.start , STRING_CONSTANT ) ; } }
features = features . require ( Feature.REST_PARAMETERS ) ;
features = features . require ( Feature.DEFAULT_PARAMETERS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
features = features . require ( Feature.ASYNC_FUNCTIONS ) ;
if ( Keywords . isKeyword ( name.value ) ) { features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
if ( expectedFeatures != null ) { assertThat ( result.features ) . isEqualTo ( expectedFeatures ) ; }
expectFeatures ( Feature.DESTRUCTURING , Feature.LET_DECLARATIONS ) ;
expectFeatures ( Feature.CLASSES , Feature.CONST_DECLARATIONS ) ;
m.featureSet . contains ( Feature.ASYNC_FUNCTIONS )
expectFeatures ( Feature.DESTRUCTURING ) ;
expectFeatures ( Feature.EXTENDED_OBJECT_LITERALS ) ;
STRING_CONSTANT + featureSet . toLanguageModeString ()
features = features . require ( Feature.STRING_CONTINUATION ) ;
features = features . require ( feature ) ;
features = features . require ( feature ) ;
features = features . require ( Feature.SETTER ) ;
features = features . require ( Feature.GETTER ) ;
features = features . require ( Feature.KEYWORDS_AS_PROPERTIES ) ;
{ if ( isValidSimpleName ( name ) ) { return true ; } else { return mode . contains ( Feature.KEYWORDS_AS_PROPERTIES ) && TokenStream . isKeyword ( name ) ; } }
features . hasEs6Modules ()
setFeatureSet ( featureSet . withoutModules () ) ;
Collection < JSModule > modules
{ if ( hasConditionalAncestor ( parent . getParent () ) ) { info.allowMove = false ; } }
Node parse ( String js ) { return parse ( js , false ) ; }
Preconditions . checkArgument ( root . isRoot () ) ;
assertPrettyPrintSame ( STRING_CONSTANT ) ;
String [] parts = path . split ( Pattern . quote ( MODULE_SLASH ) ) ;
public void testConstTarget () { disableTypeCheck () ; testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , POLYMER_INVALID_DECLARATION ) ; }
testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ testEs6 ( wrapInFunction ( original ) , wrapInFunction ( expected ) ) ; }
{ fold ( STRING_CONSTANT , STRING_CONSTANT ) ; fold ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGoogScopeClassOutput () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportEs6ArrowFunction () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportConst () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testExportLet () { testEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
{ testWarningEs6 ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ; testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISPLACED_ANNOTATION ) ; }
public void testExtractableExport4 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testExtractableExport3 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testEs6Class_testMethod () { testEs6 ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
private void assertNoWarningEs6 ( String js ) { testSameEs6 ( js ) ; }
private void assertAmbiguousEs6 ( String js ) { testSameEs6 ( js ) ; }
public void testAliasInModule () { enableUnusedLocalAssignmentCheck = true ; testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSameEs6 ( STRING_CONSTANT ) ;
@ Override public void setUp () { injectNamespace = false ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
public void testDuplicate_destructuring () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
public void testDuplicate_shorthand () { testWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , DUPLICATE_REQUIRE ) ; }
testWarningEs6 ( STRING_CONSTANT , UNUSED_LABEL ) ;
testSameEs6 ( STRING_CONSTANT ) ;
testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.CONDITIONAL_ID_GENERATOR_CALL ) ;
public void testClass () { testSameEs6 ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ReplaceIdGenerators.INVALID_GENERATOR_PARAMETER ) ; }
public void testPassModule () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override public void setUp () { mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
public void testGoogModuleWithEmptyDestructuringRequire () { testErrorEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , EXTRA_REQUIRE_WARNING ) ; }
public void testRemovalMultipleAssignment3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemovalMultipleAssignment2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveRepeatedProperties () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testRemoveUnnecessaryBodies () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testEs6 ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstPropagationPrivateProperties2 () { testEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testConstructorAlias4 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorAlias3 () { testSameEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testPathologicalCaseThatsOkAnyway () { testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , NAME_DEFINED_LATE_WARNING ) ; }
public void testNullUndefined () { testSame ( STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( Collections . < TypeMismatch > emptyList () ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ;
{ testSame ( STRING_CONSTANT , TYPE_MISMATCH_WARNING ) ; assertMismatches ( ImmutableList . of ( fromNatives ( STRING_TYPE , NUMBER_TYPE ) ) ) ; }
{ testSame ( STRING_CONSTANT + params + STRING_CONSTANT + arguments + STRING_CONSTANT , type ) ; }
testSame ( fooDfn + STRING_CONSTANT , WRONG_ARGUMENT_COUNT ) ;
testSame ( declarations + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
{ testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
public void testBadObjectLiteralCast1 () { testSame ( STRING_CONSTANT + STRING_CONSTANT , ClosureCodingConvention.OBJECTLIT_EXPECTED ) ; }
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , RhinoErrorReporter.UNRECOGNIZED_TYPE_ERROR ) ;
{ return ! found ; }
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( typedefExterns , code , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT , value ( STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testCustomBanUnknownThisProp2 () { configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testCustomRestrictThrow2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
{ allowSourcelessWarnings () ; configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( EXTERNS + STRING_CONSTANT , code + STRING_CONSTANT , null ) ;
testSame ( code + STRING_CONSTANT ) ;
{ configuration = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; testConformance ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION ) ; }
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
test ( input , input , null , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
testSame ( ImmutableList . of ( SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ) ) ;
public void testViolationWhitelisted2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
public void testViolationWhitelisted1 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testSame ( STRING_CONSTANT ) ;
public void testNotViolation2 () { configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
testWarning ( STRING_CONSTANT , STRING_CONSTANT , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
NodeTraversal t
Node export = n . getFirstChild () ;
public void testObjLit () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; assertUnreachable ( STRING_CONSTANT ) ; }
if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) && ! options.skipTranspilationAndCrash ) { checks . add ( convertStaticInheritance ) ; }
catch ( IOException e ) { report ( JSError . make ( AbstractCompiler.READ_ERROR , input . getName () ) ) ; }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
defUse = new MustBeReachingVariableDef ( cfg , scope , compiler ) ;
useDef = new MaybeReachingVariableUse ( cfg , scope , compiler ) ;
liveness = new LiveVariablesAnalysis ( cfg , functionScope , compiler ) ;
LiveVariablesAnalysis liveness = new LiveVariablesAnalysis ( cfg , scope , compiler ) ;
public void testObjectDestructuringDefaultValsDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignNewVarNamesDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringAssignWithoutDeclarationDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testObjectDestructuringBasicAssignDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringVarAssignDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
public void testArrayDestructuringSwapDoesntCrash () { testSame ( STRING_CONSTANT ) ; }
{ new GraphReachability <> ( controlFlowGraph , new ReachablePredicate () ) . compute ( controlFlowGraph . getEntry () . getValue () ) ; }
inheritsCall . useSourceInfoIfMissingFromForTree ( classNode ) ;
Node lp = scope . getRootNode () . getSecondChild () ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
assertEquals ( expected , cssNames ) ;
catch ( IOException e ) { compiler . report ( JSError . make ( COULD_NOT_DESERIALIZE_AST , filename ) ) ; }
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; disableMultistageCompilation () ; }
public void testArguments () { testConsts ( STRING_CONSTANT , STRING_CONSTANT ) ; }
peepholePass . setRetraverseOnChange ( false ) ;
public void testIssue () { super . allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public RemoveUnusedClassPropertiesTest () { super ( EXTERNS ) ; enableGatherExternProperties () ; }
allowExternsChanges ( true ) ;
public void testProvideInExterns () { allowExternsChanges ( true ) ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
runTypeCheckAfterProcessing = true ;
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; test ( STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , null , null ) ; }
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
allowExternsChanges ( true ) ;
if ( transpileEnabled && transpileExpected && ! compiler . hasErrors () ) { transpileToEs5 ( compiler , externsRoot , mainRoot ) ; }
public String getFilename () { return filename ; }
public J2clCheckPassTest () { super ( DEFAULT_EXTERNS ) ; enableTypeCheck () ; }
enableCheckAccessControls ( true ) ;
enableCheckAccessControls ( true ) ;
public GatherRawExportsTest () { super ( EXTERNS ) ; super . enableNormalize () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; runTypeCheckAfterProcessing = true ; }
compareJsDoc = false ;
@ Override protected void setUp ( ) throws Exception { useGoogleCodingConvention = true ; }
public RemoveUnusedVarsTest () { super ( STRING_CONSTANT ) ; enableNormalize () ; }
public void testEs6ONoEs6 () { allowExternsChanges ( true ) ; testSame ( STRING_CONSTANT ) ; }
public Es6ExternsCheckTest () { super ( EXTERNS_BASE ) ; allowSourcelessWarnings () ; }
{ enableTypeCheck () ; allowExternsChanges ( true ) ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , POSSIBLE_INEXISTENT_PROPERTY ) ; }
{ declarationCheck = ! sanityCheck ; this . enableCompareAsTree ( false ) ; testExternChanges ( extern , input , expectedExtern ) ; }
super . allowExternsChanges ( true ) ;
public ProcessDefinesTest () { super ( DEFAULT_EXTERNS + STRING_CONSTANT ) ; allowSourcelessWarnings () ; }
runSmartNameRemoval = true ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
allowExternsChanges ( true ) ;
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ allowExternsChanges ( true ) ; String code = STRING_CONSTANT ; testSame ( code ) ; testExternChanges ( code , STRING_CONSTANT ) ; }
{ this . enableCompareAsTree ( false ) ; super . testExternChanges ( input , expectedExtern ) ; }
validateAstChangeMarking ( false ) ;
public RuntimeTypeCheckTest () { super ( STRING_CONSTANT ) ; enableTypeCheck () ; }
{ value = key . getFirstChild () . detachFromParent () ; }
Node assign = IR . assign ( windowPropAccess , nameNode . getFirstChild () . detachFromParent () ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , currentScript.legacyNamespace ) ;
exportedNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
binaryNamespaceName . putProp ( Node.ORIGINALNAME_PROP , legacyNamespace ) ;
Node initializer = n . getFirstChild () . detach () ;
Node extern = externs . getFirstChild () . detach () ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ testModules ( this , input , STRING_CONSTANT + expected ) ; }
if ( n . isArrayPattern () ) { validateArrayPattern ( Token.CATCH , caught ) ; } else { validateObjectPattern ( Token.CATCH , caught ) ; }
test ( options , source , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ;
public void testNotStringLiteralConstantArgument3 () { testError ( CLOSURE_DEFS + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument2 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotStringLiteralConstantArgument1 () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
public void testNotConstantArgument () { testError ( CLOSURE_DEFS + STRING_CONSTANT + STRING_CONSTANT , ConstParamCheck.CONST_NOT_ASSIGNED_STRING_LITERAL_ERROR ) ; }
shadowedVar != null && shadowedVar . isLocal ()
shadowedVar != null && ! shadowedVar . getScope () . isModuleScope ()
this . redeclarationHandler = new DefaultRedeclarationHandler () ;
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , SyntacticScopeCreator.DEFAULT_REDECLARATION_HANDLER , scope ) ; }
public Es6SyntacticScopeCreator ( AbstractCompiler compiler , ScopeFactory scopeFactory ) { this ( compiler , SyntacticScopeCreator.DEFAULT_REDECLARATION_HANDLER , scopeFactory ) ; }
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
int count = RandomNameGenerator.FIRST_CHAR.length * ( RandomNameGenerator.NONFIRST_CHAR.length + NUMBER_CONSTANT ) ;
{ this . random = random ; reset ( new HashSet < String > () , STRING_CONSTANT , null ) ; }
var . getParentNode () . isVar () && ! var . getParentNode () . getParent () . isForIn ()
Scope scope = new Es6SyntacticScopeCreator ( compiler ) . createScope ( root , null ) ;
NodeTraversal . traverseEs6 ( compiler , root , new RemoveNonDeclarations () ) ;
for ( Assign assign : assignsByVar . get ( var ) ) { compiler . reportChangeToEnclosingScope ( assign.assignNode ) ; assign . remove () ; }
this . changeProxy = new AstChangeProxy () ;
map . clear () ;
if ( externsRoot != null && n == externsRoot ) { externsScope = t . getScope () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options.chromePass = flags.chromePass ;
if ( options.chromePass ) { checks . add ( chromePass ) ; }
protected FeatureSet featureSet () { return FeatureSet.ES5 ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2016 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
{ if ( n . isFunction () ) { NormalizeStatements . maybeNormalizeFunctionDeclaration ( n , compiler ) ; } }
if ( maybeNormalizeFunctionDeclaration ( n , compiler ) ) { reportCodeChange ( n , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT , null , Es6TypedToEs6Converter.CANNOT_CONVERT_BOUNDED_GENERICS ) ;
test ( modules , expected , null , warning ) ;
{ test ( js , js ) ; }
{ test ( modules , expected , null ) ; }
{ assertNotNull ( warning ) ; test ( js , null , null , warning , description ) ; }
{ test ( js , expected , null , null ) ; }
test ( externs , js , ( String ) null , null , ConstCheck.CONST_REASSIGNED_VALUE_ERROR ) ;
test ( externs , js , js , null , null ) ;
{ testSame ( kExterns + extraExterns , source , null ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
public void testExternFunction () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT + STRING_CONSTANT , null ) ; }
public void testObjectLitExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT , null ) ; }
public void testJSDocDescInExterns () { testWarning ( STRING_CONSTANT , MISPLACED_MSG_ANNOTATION ) ; testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testEnum () { testSame ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , null ) ; }
testErrorExterns ( jsdoc + STRING_CONSTANT , null ) ;
public void testProvideInExterns () { allowExternsChanges () ; test ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
{ test ( createModuleStar ( moduleInputs ) , expected , null ) ; }
{ test ( js , null , null , null ) ; assertEquals ( fieldTypes , mapToString ( lastPass . getRenamedTypesForTesting () ) ) ; }
test ( DEFAULT_EXTERNS + externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testSkipNativeFunctionMethod () { String js = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testSame ( js , null ) ; }
testSame ( externs , js , null ) ;
{ test ( code , addLibraries ( code , libraries ) , null , warning ) ; }
public void testGlobalAliasWithProperties5 () { testSame ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ; }
test . test ( inputs , null , error ) ;
{ currentLocationAbstractionIdentifier = locationAbstractionIdentifier ; testSame ( SHARED_EXTERNS , js , null ) ; currentJsRoot = getLastCompiler () . jsRoot ; return currentAnalysis ; }
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
test ( js , null , VarCheck.VAR_MULTIPLY_DECLARED_ERROR , null , message ) ;
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
{ String externs = STRING_CONSTANT ; String code = STRING_CONSTANT ; testSame ( externs , code , null ) ; }
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
{ testSame ( externs , STRING_CONSTANT , null ) ; assertEquals ( ImmutableSet . copyOf ( properties ) , getLastCompiler () . getExternProperties () ) ; }
testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( externs , STRING_CONSTANT , null ) ;
testSame ( externs , js , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
test ( externs , js , js , null , null , null ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT , null ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT , null ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( OBJECT_EXTERNS , STRING_CONSTANT + STRING_CONSTANT , null ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
test ( STRING_CONSTANT , STRING_CONSTANT , null , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
{ testSame ( externs , source , null ) ; assertEquals ( expected , found ) ; found . clear () ; }
{ setAcceptedLanguage ( lang ) ; test ( code , expected , null , warning ) ; }
test ( googModule , null , MISSING_MODULE_OR_PROVIDE , null , warning ) ;
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( js , js , null , MISSING_PROVIDE_WARNING , warning ) ;
test ( externs , input , expected , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ;
public void testRenameWithExterns2 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testRenameWithExterns1 () { String externs = STRING_CONSTANT ; test ( externs , STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
{ overrides . put ( STRING_CONSTANT , new Node ( Token.TRUE ) ) ; test ( STRING_CONSTANT , STRING_CONSTANT , null , ProcessDefines.UNKNOWN_DEFINE_WARNING ) ; }
public void testNamespaceResetInLocalScope2 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInLocalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
public void testNamespaceResetInGlobalScope1 () { test ( STRING_CONSTANT , STRING_CONSTANT , null , NAMESPACE_REDEFINED_WARNING ) ; testSame ( STRING_CONSTANT + STRING_CONSTANT , NAMESPACE_REDEFINED_WARNING ) ; }
{ testSame ( CompilerTestCase.ACTIVE_X_OBJECT_DEF , STRING_CONSTANT , null ) ; assertEquals ( STRING_CONSTANT , findNameType ( STRING_CONSTANT , globalScope ) . toString () ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , null ) ;
test ( externs , code , code , null , null ) ;
if ( Es6RewriteModules . isEs6ModuleRoot ( root ) ) { moduleRewriter . processFile ( root , forceRewrite ) ; }
Preconditions . checkState ( exportsNameNode . getString () . equals ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null ) ;
Preconditions . checkArgument ( n . isStringKey () ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
Preconditions . checkState ( c . isScript () ) ;
public void testES6AliasClassDeclarationWithoutNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testES6AliasClassDeclarationWithNew () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
protected FeatureSet featureSet () { return FeatureSet . latest () ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; enableRunTypeCheckAfterProcessing () ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_NEXT ) ;
if ( parent . isForIn () ) { return; }
public void testSimpleConstAliasInCode01 () { testSame ( STRING_CONSTANT ) ; }
{ Preconditions . checkState ( error.node . getParent () . isStringKey () ) ; fix . delete ( error.node . getParent () ) ; }
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( regexMatcher . matches () , STRING_CONSTANT , error.description ) ;
Preconditions . checkState ( fullNameMatcher . matches () , error.description ) ;
Preconditions . checkState ( name . isName () , name ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
mayWarnAboutGlobalThis ( expr , currentScope ) ;
Object o
public HierarchicalSet ( HierarchicalSet < T > parent ) { this . parent = parent ; }
if ( n . isObjectLit () && n . getParent () . isArrowFunction () ) { return true ; } else { return precedence ( n ) < minPrecedence ; }
{ for ( Var var : computeLiveness ( src ) . getEscapedLocals () ) { assertFalse ( var.name . equals ( name ) ) ; } }
public void visitCallSite ( NodeTraversal t , Node callNode , FunctionState fs ) ;
{ throw new IllegalStateException ( STRING_CONSTANT + child ) ; }
throw new IllegalStateException ( STRING_CONSTANT + parent . getFirstChild () ) ;
Map < String , Node > map = new HashMap <> () ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
ScopeCreator creator = new MemoizedScopeCreator ( SyntacticScopeCreator . makeUntyped ( compiler ) ) ;
{ test ( createModuleStar ( moduleInputs ) , expected ( expected ) , null ) ; }
{ Preconditions . checkState ( expected == null ) ; expected = expected ( ( ( Sources ) part ) . sources ) ; }
protected Sources srcs ( List < SourceFile > files ) { return new Sources ( files ) ; }
protected Sources srcs ( String [] srcTexts ) { return new Sources ( createSources ( STRING_CONSTANT , srcTexts ) ) ; }
protected Sources srcs ( String srcText ) { return new Sources ( maybeCreateSources ( filename , srcText ) ) ; }
{ testSame ( modules , null ) ; }
{ test ( modules , expected ( expected ) , null ) ; }
builder . setTypeRegistry ( this . typeRegistry ) ;
validateChildCount ( n , NUMBER_CONSTANT ) ;
public Es6RewriteModules ( Compiler compiler ) { this . compiler = compiler ; }
testModules ( STRING_CONSTANT , Es6RewriteModules.NAMESPACE_IMPORT_CANNOT_USE_STAR ) ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
@ Override protected FeatureSet featureSet () { return ES7 ; }
@ Override protected FeatureSet featureSet () { return ES6 ; }
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
if ( forAnnotations ) { return sb . append ( this . primitiveType ) ; }
{ return STRING_CONSTANT + type . toMaybeObjectType () . getElementsType () . toNonNullAnnotationString () + STRING_CONSTANT ; }
TypeI getElementsType ( ) ;
@ Override public TypeI getElementsType () { return null ; }
Preconditions . checkState ( sum > NUMBER_CONSTANT ) ;
Preconditions . checkState ( s instanceof TypedScope , STRING_CONSTANT ) ;
Preconditions . checkState ( curNode != null ) ;
Preconditions . checkNotNull ( parent ) ;
Preconditions . checkState ( s . isGlobal () || s . isModuleScope () ) ;
type = Name.Type.CLASS ;
{ super . setUp () ; compilerOptions . setLanguageIn ( LanguageMode.ECMASCRIPT6_TYPED ) ; compilerOptions . setLanguageOut ( LanguageMode.ECMASCRIPT3 ) ; }
if ( ! functionScope . isDeclared ( name , false ) ) { return; }
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclared ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclared ( name , false ) ) { return; }
{ this . warningsGuard = new ComposeWarningsGuard ( new SuppressDocWarningsGuard ( getDiagnosticGroups () . getRegisteredGroups () ) , warningsGuard ) ; }
Es6SyntacticScopeCreator createInternalScopeCreator ( AbstractCompiler compiler ) { return new Es6SyntacticScopeCreator ( compiler , new PersistentScopeFactory () ) ; }
ScopeScanner ( AbstractCompiler compiler , Scope scope ) { this ( compiler , DEFAULT_REDECLARATION_HANDLER , scope ) ; }
new ScopeScanner ( compiler , redeclarationHandler , scope ) . populate () ;
vars . remove ( var.name ) ;
NodeUtil . isEnhancedFor ( n )
{ logger . warning ( STRING_CONSTANT + scopeRoot ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkArgument ( functionNode . isFunction () ) ;
Preconditions . checkArgument ( nameNode . isQualifiedName () ) ;
Preconditions . checkState ( NodeUtil . isStatement ( statement ) , statement ) ;
Preconditions . checkState ( functionBody . isNormalBlock () ) ;
Preconditions . checkArgument ( paramList . isParamList () ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) { processRequire ( expr ) ; } else { Preconditions . checkState ( callee . matchesQualifiedName ( STRING_CONSTANT ) ) ; }
void markConstructorToProcess ( Node ctorNode ) { Preconditions . checkArgument ( ctorNode . isFunction () ) ; constructorsToProcess . add ( ctorNode ) ; }
int getMaxArguments ( ) ;
int getMinArguments ( ) ;
index < funType . getMaxArguments ()
{ if ( currentType . getMaxArguments () <= expectedType . getMaxArguments () ) { return expectedType ; } }
{ this ( res , new Number ( op1 ) , o , op2 ) ; }
{ this ( res , op1 , o , new Number ( op2 ) ) ; }
Preconditions . checkArgument ( ! members . isEmpty () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( nt . isGeneric () , nt ) ;
Preconditions . checkArgument ( nameNode . getParent () . isVar () ) ;
Preconditions . checkArgument ( funNode . isFunction () ) ;
Preconditions . checkState ( n . isOr () || n . isAnd () ) ;
Preconditions . checkState ( n . isGetElem () ) ;
return Preconditions . checkNotNull ( funType ) . toFunctionType () ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkState ( declNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkNotNull ( lendsName ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkState ( qnameNode . isName () || qnameNode . isGetProp () ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( ! fnName . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
Preconditions . checkState ( qnameNode . isQualifiedName () ) ;
{ if ( maybeAssign . isAssign () ) { maybeAssign . putBooleanProp ( Node.ANALYZED_DURING_GTI , true ) ; } else { Preconditions . checkState ( maybeAssign . isExprResult () ) ; } }
Preconditions . checkState ( ! currentScope . isNamespace ( qname ) ) ;
{ PropertyDef propdef = Preconditions . checkNotNull ( getPropDefFromClass ( superType , pname ) ) ; inheritedPropDefs = ImmutableSet . of ( propdef ) ; }
{ JSType t = castTypes . get ( n ) ; Preconditions . checkNotNull ( t ) ; return t ; }
{ Preconditions . checkNotNull ( part , STRING_CONSTANT ) ; parts . add ( part ) ; return this ; }
Preconditions . checkNotNull ( name , STRING_CONSTANT ) ;
Preconditions . checkState ( n . isScript () ) ;
Preconditions . checkState ( passName . equals ( logStats.pass ) ) ;
Preconditions . checkArgument ( mode != TracerMode.OFF , STRING_CONSTANT ) ;
Preconditions . checkNotNull ( qualifiedName ) ;
Preconditions . checkArgument ( lastLink.nextLink == null ) ;
Preconditions . checkState ( token == JsDocToken.PIPE ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkArgument ( token == JsDocToken.LEFT_CURLY ) ;
Preconditions . checkState ( annotation == Annotation.IMPLEMENTS ) ;
Preconditions . checkState ( other instanceof NominalType ) ;
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . getSubtypesWithProperty ( pname . getLeftmostName () ) ; }
{ Preconditions . checkArgument ( pname . isIdentifier () ) ; return this . rawType . isPropDefinedOnSubtype ( pname . getLeftmostName () ) ; }
Preconditions . checkState ( nt1.rawType . equals ( nt2.rawType ) ) ;
Preconditions . checkState ( this . rawType . equals ( other.rawType ) ) ;
Preconditions . checkState ( this . inheritsFromIObjectReflexive () && other . inheritsFromIObjectReflexive () ) ;
Preconditions . checkArgument ( other . isStructuralInterface () ) ;
Preconditions . checkState ( typeMap . size () == NUMBER_CONSTANT ) ;
Preconditions . checkState ( this . rawType . isFrozen () ) ;
{ Preconditions . checkState ( this . rawType . isFrozen () ) ; return this . rawType . getCtorPropDeclaredType ( STRING_CONSTANT ) ; }
Preconditions . checkState ( this . rawType . isFrozen () ) ;
Preconditions . checkState ( isUninstantiatedGenericType () ) ;
Preconditions . checkState ( types . size () == typeParams . size () ) ;
public RawNominalType getRawNominalType () { Preconditions . checkState ( ! this . rawType . isFrozen () ) ; return this . rawType ; }
{ Preconditions . checkArgument ( value . isInterface () ) ; return new SubtypeCache ( this . m . with ( key , value ) ) ; }
Preconditions . checkState ( node . isSuper () ) ;
{ Preconditions . checkArgument ( ! ( scope instanceof TypedScope ) ) ; return new Arguments ( scope ) ; }
{ Preconditions . checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ super ( registry , null , null , isNativeType , constructor . getTemplateTypeMap () ) ; Preconditions . checkNotNull ( constructor ) ; this . constructor = constructor ; }
{ Preconditions . checkState ( m == null ) ; }
Preconditions . checkState ( line < nextLine || col <= nextCol ) ;
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkState ( variableNode != null ) ;
Preconditions . checkArgument ( n . getChildCount () > NUMBER_CONSTANT ) ;
{ Preconditions . checkNotNull ( isDisposalStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isDisposalStack . peek () ; } return null ; }
{ Preconditions . checkNotNull ( isConstructorStack ) ; if ( ! isDisposalStack . isEmpty () ) { return isConstructorStack . peek () ; } return null ; }
Preconditions . checkArgument ( checkingPolicy != DisposalCheckingPolicy.OFF ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( NodeUtil . isStatementBlock ( parent ) ) ;
Preconditions . checkArgument ( ret . isReturn () ) ;
Preconditions . checkArgument ( node . isNormalBlock () ) ;
{ Preconditions . checkArgument ( classByAlias . containsKey ( original ) ) ; classByAlias . put ( alias , classByAlias . get ( original ) ) ; }
Preconditions . checkState ( subclassMember . isAssign () , subclassMember ) ;
Preconditions . checkState ( staticGetProp . isGetProp () ) ;
{ Preconditions . checkState ( n . isName () , n ) ; n . removeFirstChild () ; }
{ Preconditions . checkState ( root . isRoot () ) ; if ( root . getChangeTime () != NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } }
Preconditions . checkArgument ( n . isCast () ) ;
Preconditions . checkState ( first . getParent () == last . getParent () ) ;
{ Preconditions . checkState ( n . getParent () . isGetProp () , n ) ; nodeToRename = n ; }
Preconditions . checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
Preconditions . checkState ( node . isName () ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Preconditions . checkArgument ( mode != TypeInferenceMode.BOTH ) ;
Preconditions . checkState ( subns.namespaceType != null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkState ( ! prop . isOptional () ) ;
this . defSite = Preconditions . checkNotNull ( defSite ) ;
Preconditions . checkNotNull ( clinitName ) ;
Preconditions . checkNotNull ( name ) ;
Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ;
{ super ( symbolName , value ) ; this . exportPath = Preconditions . checkNotNull ( exportPath ) ; }
Preconditions . checkArgument ( fn . isFunction () ) ;
{ Preconditions . checkState ( pathDefinition . isVar () ) ; pathDefinition . setJSDocInfo ( jsdoc ) ; }
{ Preconditions . checkState ( valueToExport . isObjectLit () ) ; initializer = createExternObjectLit ( valueToExport ) ; }
Preconditions . checkArgument ( before . isExprResult () , STRING_CONSTANT ) ;
Preconditions . checkArgument ( keyValPairs.length % NUMBER_CONSTANT == NUMBER_CONSTANT ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
Preconditions . checkState ( isNamespacePlaceholder ( decl ) ) ;
{ Preconditions . checkState ( newModule == minimumModule , STRING_CONSTANT ) ; }
Preconditions . checkArgument ( explicitNode != node ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkNotNull ( providedModule , n ) ;
Preconditions . checkState ( parent . isExprResult () ) ;
Preconditions . checkState ( isRegistered () ) ;
boolean isCorrectRegisterFunction ( TweakFunction registerFunction ) { Preconditions . checkNotNull ( registerFunction ) ; return this . registerFunction == registerFunction ; }
Preconditions . checkArgument ( scriptNodeCount == NUMBER_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( moduleNode . isModuleBody () ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
Preconditions . checkArgument ( parent . isModuleBody () , parent ) ;
{ Preconditions . checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
Preconditions . checkArgument ( subtree . isCall () ) ;
{ Preconditions . checkState ( script . isScript () ) ; visit ( script ) ; }
Preconditions . checkState ( ! member . isStaticMember () ) ;
Preconditions . checkNotNull ( constructor ) ;
Preconditions . checkArgument ( object != null , STRING_CONSTANT ) ;
Preconditions . checkState ( ! frozen ) ;
Preconditions . checkState ( fnNode . isFunction () || type . isFunctionType () ) ;
Preconditions . checkNotNull ( registry ) ;
Preconditions . checkState ( NodeUtil . isNameDeclaration ( n ) ) ;
Preconditions . checkArgument ( ! envs . isEmpty () ) ;
{ Preconditions . checkArgument ( ! n . contains ( STRING_CONSTANT ) ) ; return typeMap . get ( n ) ; }
Preconditions . checkState ( typeMap . size () >= SIZE_THRESHOLD ) ;
Preconditions . checkState ( meaning != null ) ;
Preconditions . checkArgument ( n . isCall () || n . isNew () ) ;
Preconditions . checkState ( n . isNew () ) ;
Preconditions . checkState ( n . isCall () ) ;
Preconditions . checkState ( n . isCall () , n ) ;
Preconditions . checkArgument ( NodeUtil . isAssociative ( n . getToken () ) ) ;
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkNotNull ( compiler ) ;
{ Preconditions . checkArgument ( groupIndex >= NUMBER_CONSTANT && groupIndex <= NUMBER_CONSTANT ) ; this . groupIndex = groupIndex ; }
Preconditions . checkState ( n . isGetProp () , n ) ;
Preconditions . checkNotNull ( typei ) ;
Preconditions . checkArgument ( callSite . isCall () || callSite . isNew () ) ;
Preconditions . checkArgument ( callType == Token.CALL || callType == Token.NEW ) ;
Preconditions . checkArgument ( NodeUtil . isNameDeclaration ( node . getParent () ) ) ;
{ Preconditions . checkNotNull ( sideEffectInfo ) ; updateSideEffectsForNode ( sideEffectInfo , traversal , node , enclosingFunction ) ; }
Preconditions . checkNotNull ( functionInfo ) ;
Preconditions . checkNotNull ( cacheCall ) ;
this . compiler = Preconditions . checkNotNull ( compiler ) ;
Preconditions . checkState ( initialization . getGrandparent () . isExprResult () ) ;
Preconditions . checkState ( value != null ) ;
Preconditions . checkState ( NodeUtil . isNameDeclaration ( varNode ) , varNode ) ;
Preconditions . checkState ( scriptRoot . isScript () ) ;
Time ( String name ) { Preconditions . checkNotNull ( name ) ; this . name = name ; }
Event ( T value ) { Preconditions . checkNotNull ( value ) ; this . value = value ; }
Preconditions . checkState ( exportDefinition . hasInlinableName ( currentScript.exportsToInline . keySet () ) ) ;
Preconditions . checkState ( n . isScript () , n ) ;
Preconditions . checkState ( currentScript.willCreateExportsObject || currentScript.hasCreatedExportObject ) ;
Preconditions . checkArgument ( importNode . getFirstChild () . isDestructuringLhs () , importNode ) ;
Preconditions . checkState ( currentScript.defaultExportRhs == null , currentScript.defaultExportRhs ) ;
Preconditions . checkArgument ( n . isStringKey () , n ) ;
Preconditions . checkState ( scriptRoot . isScript () , scriptRoot ) ;
Preconditions . checkState ( c . isScript () , c ) ;
Preconditions . checkState ( returnNode . isReturn () , returnNode ) ;
{ Preconditions . checkArgument ( containsModule ( legacyNamespace ) ) ; return scriptDescriptionsByGoogModuleNamespace . get ( legacyNamespace ) . declareLegacyNamespace ; }
{ Preconditions . checkState ( isInterface () ) ; isStructuralInterface = flag ; }
Preconditions . checkArgument ( isConstructor () || isInterface () ) ;
Preconditions . checkNotNull ( that ) ;
Preconditions . checkArgument ( interfaceType . isInterface () ) ;
Preconditions . checkState ( msgBuilder != null ) ;
Preconditions . checkState ( ! STRING_CONSTANT . equals ( projectId ) ) ;
{ Preconditions . checkArgument ( classNode . isClass () ) ; return classNode . getFirstChild () . isName () && parent . isName () ; }
Preconditions . checkNotNull ( name ) ;
Preconditions . checkArgument ( n . isFunction () ) ;
Preconditions . checkState ( rootNode . isFunction () ) ;
Preconditions . checkState ( ! typeMap . isEmpty () ) ;
public JSType getRestFormalsType () { Preconditions . checkState ( restFormals != null ) ; return restFormals ; }
Preconditions . checkArgument ( propertyName . isString () ) ;
Preconditions . checkArgument ( superSet . isAssign () ) ;
Preconditions . checkArgument ( objectLit . isObjectLit () ) ;
Preconditions . checkState ( parent . isCall () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
Preconditions . checkNotNull ( t ) ;
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( state != State.RESOLVED ) ;
public JSType getType () { Preconditions . checkState ( state == State.RESOLVED ) ; return type ; }
Preconditions . checkNotNull ( typeExpr ) ;
{ Preconditions . checkState ( renameStrategy == RenameStrategy.MAPPED ) ; return new MappedNameSupplier ( mappings ) ; }
{ Preconditions . checkState ( grandparent . isLabel () ) ; throw new IllegalStateException ( STRING_CONSTANT ) ; }
Preconditions . checkState ( functionBody . getParent () . isFunction () ) ;
Preconditions . checkArgument ( n . isLabel () ) ;
Preconditions . checkState ( n . isFunction () , n ) ;
Preconditions . checkArgument ( ! Iterables . isEmpty ( options ) , STRING_CONSTANT ) ;
Preconditions . checkState ( oldName . equals ( p.oldName ) ) ;
Map < String , String > getRenamingMap () { Preconditions . checkNotNull ( renamingMap ) ; return renamingMap ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( refNode ) ;
Preconditions . checkNotNull ( value ) ;
if ( invalidatingPropRef ) { Preconditions . checkNotNull ( propName ) ; invalidateProperty ( propName ) ; }
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkNotNull ( inputId ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( token , expr ) ; }
Preconditions . checkState ( function . isFunction () ) ;
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.SPREAD , expr ) ; }
Preconditions . checkState ( mayBeExpression ( value ) ) ;
{ Preconditions . checkState ( expr . isString () ) ; return new Node ( Token.REGEXP , expr ) ; }
for ( Node expr : exprs ) { Preconditions . checkState ( mayBeExpressionOrEmpty ( expr ) ) ; arraylit . addChildToBack ( expr ) ; }
Preconditions . checkState ( mayBeExpression ( target ) ) ;
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) ) ; newcall . addChildToBack ( arg ) ; }
for ( Node arg : args ) { Preconditions . checkState ( mayBeExpression ( arg ) , arg ) ; call . addChildToBack ( arg ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.CONTINUE , name ) ; }
{ Preconditions . checkState ( name . isLabelName () ) ; return new Node ( Token.BREAK , name ) ; }
Preconditions . checkState ( finallyBody . isNormalBlock () ) ;
{ Preconditions . checkState ( ! name . isEmpty () ) ; return Node . newString ( Token.LABEL_NAME , name ) ; }
{ Preconditions . checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) , expr ) ; return new Node ( Token.EXPR_RESULT , expr ) ; }
{ Preconditions . checkState ( mayBeExpression ( expr ) ) ; return new Node ( Token.RETURN , expr ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatementNoReturn ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; paramList . addChildToBack ( stmt ) ; }
for ( Node stmt : stmts ) { Preconditions . checkState ( mayBeStatement ( stmt ) ) ; block . addChildToBack ( stmt ) ; }
{ Preconditions . checkState ( mayBeStatement ( stmt ) ) ; Node block = new Node ( Token.BLOCK , stmt ) ; return block ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; paramList . addChildToBack ( param ) ; }
{ Preconditions . checkState ( param . isName () || param . isRest () ) ; return new Node ( Token.PARAM_LIST , param ) ; }
Preconditions . checkArgument ( node . isGetProp () ) ;
Preconditions . checkArgument ( NodeUtil . isVarDeclaration ( node ) ) ;
{ super ( IR . getprop ( IR . objectlit () , name . cloneNode () ) , true ) ; Preconditions . checkArgument ( name . isString () ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( node , inExterns ) ; Preconditions . checkArgument ( NodeUtil . isFunctionExpression ( node ) ) ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isFunction () ) ; function = node ; }
Preconditions . checkNotNull ( lValue ) ;
{ Preconditions . checkState ( fileName . equals ( file . getName () ) ) ; sourceFile = file ; }
Preconditions . checkArgument ( parent . isExprResult () ) ;
Preconditions . checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
Preconditions . checkState ( expressionRoot != null ) ;
Preconditions . checkState ( notAlreadyOutstanding ) ;
Preconditions . checkState ( Thread . currentThread () == startThread ) ;
Preconditions . checkState ( noCycles ) ;
{ Preconditions . checkState ( parentClass . isInterface () ) ; warnings . add ( JSError . make ( funNode , CONFLICTING_EXTENDED_TYPE , STRING_CONSTANT , functionName ) ) ; }
Preconditions . checkState ( thisRoot . getToken () == Token.BANG ) ;
Preconditions . checkArgument ( params != null || jsdoc != null ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( n . getFirstChild () . isNormalBlock () , n ) ;
Preconditions . checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkState ( td != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Preconditions . checkNotNull ( n ) ;
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkState ( options.sourceMapDetailLevel != null ) ;
Preconditions . checkState ( n . isNormalBlock () , n ) ;
Preconditions . checkState ( line >= NUMBER_CONSTANT ) ;
Preconditions . checkState ( sourceMapDetailLevel != null ) ;
Preconditions . checkArgument ( getCfg () . hasNode ( useNode ) ) ;
{ Preconditions . checkState ( ownerFunction == null || type == null ) ; ownerFunction = type ; }
Preconditions . checkNotNull ( templateType , STRING_CONSTANT ) ;
Preconditions . checkState ( index >= NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( ! values . isEmpty () ) ;
Preconditions . checkState ( scope . isFunctionScope () , scope ) ;
Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkArgument ( o instanceof ObjectType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
Preconditions . checkArgument ( qname . isIdentifier () ) ;
{ Preconditions . checkArgument ( qname . isIdentifier () ) ; Property p = getLeftmostProp ( qname ) ; return p != null ; }
{ Preconditions . checkState ( p != null ) ; return p . getType () . getProp ( qname . getAllButLeftmost () ) ; }
Preconditions . checkNotNull ( this . ns ) ;
Preconditions . checkState ( isLoose || other.isLoose ) ;
Preconditions . checkNotNull ( pname ) ;
Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ;
Preconditions . checkNotNull ( resultNominalType ) ;
Preconditions . checkNotNull ( nominalType ) ;
{ return new ObjectType ( commonTypes , commonTypes . getObjectType () , Preconditions . checkNotNull ( commonTypes.BOTTOM_PROPERTY_MAP ) , null , null , false , ObjectKind.UNRESTRICTED ) ; }
Preconditions . checkNotNull ( reference ) ;
Preconditions . checkState ( node . isName () , node ) ;
public boolean isLive ( Var v ) { Preconditions . checkNotNull ( v ) ; return liveSet . get ( v.index ) ; }
Preconditions . checkNotNull ( other ) ;
{ Preconditions . checkNotNull ( other ) ; this . liveSet = ( BitSet ) other.liveSet . clone () ; }
Preconditions . checkState ( first . isString () ) ;
Preconditions . checkArgument ( ctorType . isConstructor () ) ;
{ Preconditions . checkState ( parent . isFunction () ) ; parent . setJSType ( varType ) ; }
Preconditions . checkState ( n . isGetElem () , n ) ;
Preconditions . checkNotNull ( data ) ;
Preconditions . checkNotNull ( preservedNamespaces , STRING_CONSTANT ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! isDefined ( qnameNode ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkState ( s != null ) ;
{ Preconditions . checkArgument ( ! fnName . contains ( STRING_CONSTANT ) ) ; return getScopeHelper ( new QualifiedName ( fnName ) ) != null ; }
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) ) ;
Preconditions . checkArgument ( qnameNode . isQualifiedName () ) ;
{ Preconditions . checkState ( this . isTopLevel () ) ; this . unknownTypeNames = ImmutableSet . copyOf ( names ) ; }
boolean isPrototypeMethod () { Preconditions . checkArgument ( root != null ) ; return NodeUtil . isPrototypeMethod ( root ) ; }
Preconditions . checkNotNull ( declaredType ) ;
Node getBody () { Preconditions . checkArgument ( root . isFunction () ) ; return NodeUtil . getFunctionBody ( root ) ; }
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkArgument ( NodeUtil . isGet ( n ) ) ;
Preconditions . checkState ( left . isString () ) ;
Preconditions . checkArgument ( n . isGetElem () ) ;
Preconditions . checkArgument ( n . isNew () ) ;
Preconditions . checkArgument ( n . isCall () ) ;
{ Preconditions . checkArgument ( n . isNew () ) ; if ( inForcedStringContext ( n ) ) { return tryFoldInForcedStringContext ( n ) ; } return n ; }
Preconditions . checkArgument ( node . isAdd () ) ;
Preconditions . checkArgument ( n . isAssign () ) ;
Preconditions . checkArgument ( n . isInstanceOf () ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
Preconditions . checkArgument ( originalTypeofNode . isTypeOf () ) ;
Preconditions . checkNotNull ( n ) ;
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
public ConstParamCheck ( AbstractCompiler compiler ) { this . compiler = Preconditions . checkNotNull ( compiler ) ; }
Preconditions . checkState ( options.propertyRenaming == PropertyRenamingPolicy.ALL_UNQUOTED ) ;
{ Preconditions . checkArgument ( ! callbacks . isEmpty () ) ; return new CombinedCompilerPass ( compiler , callbacks ) ; }
if ( checks . contains ( closureGoogScopeAliases ) ) { Preconditions . checkState ( checks . contains ( checkVariableReferences ) , STRING_CONSTANT ) ; }
if ( pass1Index != - NUMBER_CONSTANT && pass2Index != - NUMBER_CONSTANT ) { Preconditions . checkState ( pass1Index < pass2Index , msg ) ; }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( ! pass . isOneTimePass () ) ; } }
{ for ( PassFactory pass : passes ) { Preconditions . checkState ( pass . isOneTimePass () ) ; } }
Preconditions . checkState ( this . namespaceType == null ) ;
{ Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
Preconditions . checkState ( ! compiler . hasErrors () ) ;
Preconditions . checkState ( parametersList . isParamList () ) ;
Preconditions . checkNotNull ( traversal ) ;
Preconditions . checkNotNull ( traversal ) ;
{ Preconditions . checkArgument ( usingNameNode . isName () ) ; return referencesByNameNode . get ( usingNameNode ) ; }
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
Preconditions . checkArgument ( otherLocation instanceof VisibilityBasedEffectLocation ) ;
{ Preconditions . checkArgument ( isStorageNode ( node ) ) ; return NodeUtil . isLValue ( node ) ; }
Preconditions . checkArgument ( isStorageNode ( node ) ) ;
Preconditions . checkArgument ( variableReference . isName () ) ;
Preconditions . checkState ( n . isGetProp () , n ) ;
Preconditions . checkState ( caseBody . isNormalBlock () ) ;
Preconditions . checkState ( first . getString () . isEmpty () ) ;
Preconditions . checkArgument ( token.type == TokenType.STRING ) ;
{ Preconditions . checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
Preconditions . checkArgument ( scriptNode . isScript () ) ;
Preconditions . checkState ( ret . isString () ) ;
Preconditions . checkState ( work . isEmpty () ) ;
Preconditions . checkArgument ( isZipEntry ( zipURL ) ) ;
Preconditions . checkArgument ( arrowFunction . isArrowFunction () ) ;
{ Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ; this . templateJs = refasterJsTemplate ; }
Preconditions . checkState ( templateJs == null , STRING_CONSTANT ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
{ JSModule module = input . getModule () ; Preconditions . checkNotNull ( module ) ; entryPointInputsPerModule . put ( module , input ) ; }
Preconditions . checkState ( n . isCall () , n ) ;
{ Preconditions . checkState ( child . getParent () == n ) ; normalizeNodeTypes ( child ) ; }
Preconditions . checkNotNull ( thisType ) ;
Preconditions . checkState ( moduleSpecifier . isString () ) ;
Preconditions . checkNotNull ( ref . getTwin () ) ;
Preconditions . checkState ( isObjKey || isQName ) ;
Preconditions . checkState ( ref.node . getParent () . isExprResult () ) ;
Preconditions . checkState ( child . hasOneChild () ) ;
Preconditions . checkState ( cycleCount != maxIterations , NON_HALTING_ERROR_MSG ) ;
public int getArgIndex () { Preconditions . checkState ( this . argIndex >= NUMBER_CONSTANT ) ; return this . argIndex ; }
public JSType getExpectedType () { return Preconditions . checkNotNull ( this . expected ) ; }
public JSType getFoundType () { return Preconditions . checkNotNull ( this . found ) ; }
public String getPropName () { return Preconditions . checkNotNull ( this . propName ) ; }
Preconditions . checkState ( firstScript . isScript () ) ;
Preconditions . checkState ( namespace . hasExternsRoot () ) ;
{ Preconditions . checkArgument ( namespace . hasExternsRoot () ) ; this . namespace = namespace ; return this ; }
Preconditions . checkNotNull ( prevUsedRenameMap . getNewNameToOriginalNameMap () ) ;
{ Preconditions . checkState ( this . newName == null ) ; this . newName = newName ; }
Preconditions . checkState ( nameNode . isName () ) ;
Preconditions . checkArgument ( n . isAnd () || n . isOr () ) ;
Preconditions . checkNotNull ( replacementFnType ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkNotNull ( resultType ) ;
Preconditions . checkNotNull ( var ) ;
Preconditions . checkArgument ( objectType . isUnknownType () ) ;
Preconditions . checkNotNull ( errorRoot ) ;
{ Preconditions . checkState ( this . knownConstants . isEmpty () ) ; this . knownConstants = knownConstants ; }
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; }
Preconditions . checkArgument ( callSiteType != CallSiteType.UNSUPPORTED ) ;
if ( type == DecompositionType.DECOMPOSABLE ) { return CallSiteType.DECOMPOSABLE_EXPRESSION ; } else { Preconditions . checkState ( type == DecompositionType.UNDECOMPOSABLE ) ; }
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( this != callSiteType ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkState ( fnRecursionName != null ) ;
Preconditions . checkArgument ( n . isDo () ) ;
Preconditions . checkArgument ( n . isVanillaFor () ) ;
Preconditions . checkArgument ( n . isWhile () ) ;
{ Preconditions . checkState ( isExprConditional ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isSimpleAssignment ( n ) ) ; return n . getFirstChild () . getLastChild () ; }
Preconditions . checkState ( isSimpleAssignment ( n ) ) ;
Preconditions . checkState ( n . isSwitch () , n ) ;
Preconditions . checkState ( subtree . isAssign () ) ;
Preconditions . checkState ( n . isTry () , n ) ;
Preconditions . checkState ( this . namespaceType == null ) ;
{ NominalType builtinObj = Preconditions . checkNotNull ( this . commonTypes . getObjectType () , STRING_CONSTANT ) ; protoNT = builtinObj ; }
Preconditions . checkState ( ! this . isFrozen ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; super . addProperty ( pname , defSite , type , isConstant ) ; }
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
if ( isClass () ) { Preconditions . checkState ( this . name . equals ( STRING_CONSTANT ) ) ; return getAllPropsOfClass () ; }
Preconditions . checkState ( isInterface () ) ;
Preconditions . checkState ( isClass () ) ;
Preconditions . checkState ( ancestor . isInterface () ) ;
Preconditions . checkState ( ! this . isFrozen ) ;
Preconditions . checkState ( ancestor . isClass () ) ;
{ Preconditions . checkState ( ! this . isFrozen ) ; this . ctorFn = ctorFn ; }
public boolean isStruct () { Preconditions . checkState ( isFrozen () || isClass () ) ; return this . objectKind . isStruct () ; }
JSType getPrototypeObject () { Preconditions . checkState ( this . isFrozen ) ; return this . protoObject ; }
Preconditions . checkNotNull ( objectKind ) ;
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
{ super ( commonTypes ) ; this . objs = Preconditions . checkNotNull ( objs ) ; }
@ Override protected ImmutableSet < EnumType > getEnums () { return Preconditions . checkNotNull ( enums ) ; }
@ Override protected ImmutableSet < ObjectType > getObjs () { return Preconditions . checkNotNull ( objs ) ; }
@ Override public final Iterable < TypeI > getParameterTypes () { return Preconditions . checkNotNull ( getFunType () ) . getParameterTypes () ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getNominalTypeIfSingletonObj () . isClassy () ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getPropertyDefSite ( propertyName ) ; }
{ Preconditions . checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getReturnType () ; }
{ Preconditions . checkState ( this . isFunctionType () ) ; return this . getFunTypeIfSingletonObj () . getMinArity () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getThisType () ; }
Preconditions . checkState ( this . isFunctionType () ) ;
{ Preconditions . checkState ( this . isFunctionType () ) ; return getFunTypeIfSingletonObj () . getInstanceTypeOfCtor () != null ; }
Preconditions . checkState ( this . isFunctionType () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
Preconditions . checkArgument ( type != null ) ;
Preconditions . checkNotNull ( arrayType ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
if ( getObjs () . isEmpty () ) { Preconditions . checkState ( ! getEnums () . isEmpty () ) ; return this ; }
Preconditions . checkState ( ! areSubtypes ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkState ( this . isSingletonObj () ) ;
Preconditions . checkState ( ! getObjs () . isEmpty () ) ;
private JSType ( JSTypes commonTypes ) { Preconditions . checkNotNull ( commonTypes ) ; this . commonTypes = commonTypes ; }
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkState ( newExpr . isNew () ) ;
Preconditions . checkArgument ( NodeUtil . isCallOrNew ( call ) , STRING_CONSTANT ) ;
Preconditions . checkArgument ( function . isFunction () , STRING_CONSTANT ) ;
Preconditions . checkState ( value . getParent () == null ) ;
Preconditions . checkState ( DefinitionUseSiteFinder . isCallOrNewSite ( site ) ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
Preconditions . checkArgument ( ! isIdentifier () ) ;
{ Preconditions . checkArgument ( ! isIdentifier () ) ; return new QualifiedName ( parts . subList ( NUMBER_CONSTANT , parts . size () ) ) ; }
Preconditions . checkArgument ( fnNode . isFunction () ) ;
Preconditions . checkArgument ( unsafe != null ) ;
{ Preconditions . checkState ( ! NodeUtil . isFunctionObjectApply ( callNode ) ) ; argMap . put ( THIS_MARKER , NodeUtil . newUndefinedNode ( callNode ) ) ; }
Preconditions . checkArgument ( n . isScript () ) ;
Preconditions . checkNotNull ( lValue ) ;
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
Preconditions . checkState ( outBefore . size () == state.out . size () ) ;
void setOut ( L out ) { Preconditions . checkNotNull ( out ) ; this . out = out ; }
void setIn ( L in ) { Preconditions . checkNotNull ( in ) ; this . in = in ; }
{ Preconditions . checkNotNull ( dep ) ; Preconditions . checkState ( dep != this , STRING_CONSTANT , this ) ; deps . add ( dep ) ; }
Preconditions . checkState ( inputs . contains ( other ) ) ;
Preconditions . checkState ( n . isSwitch () ) ;
Preconditions . checkState ( allCatchNodes . hasOneChild () ) ;
Preconditions . checkArgument ( type instanceof TypeDeclarationNode ) ;
Preconditions . checkNotNull ( reader ) ;
{ Preconditions . checkNotNull ( whitelist ) ; this . whitelist = normalizeWhitelist ( whitelist ) ; }
public JSTypeExpression getTypeExprForErrorReporting () { Preconditions . checkState ( this . state == State.DURING_RESOLUTION ) ; return typeExpr ; }
Preconditions . checkState ( this . state != State.RESOLVED ) ;
public JSType getPropType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return enumPropType ; }
public JSType getEnumeratedType () { Preconditions . checkState ( this . state == State.RESOLVED ) ; return declaredType ; }
Preconditions . checkNotNull ( typeExpr ) ;
{ Preconditions . checkState ( isVarBlock ( n ) ) ; return n . getFirstChild () ; }
{ Preconditions . checkState ( isReturnExpressBlock ( n ) ) ; return n . getFirstFirstChild () ; }
{ Preconditions . checkState ( isFoldableExpressBlock ( n ) ) ; return n . getFirstChild () ; }
Preconditions . checkArgument ( n . isNot () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( objLit . isObjectLit () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkArgument ( declaration . isName () || declaration . isStringKey () ) ;
{ Preconditions . checkState ( isCallOrNew ( call ) ) ; return getNthSibling ( call . getSecondChild () , index ) ; }
{ Preconditions . checkState ( function . isFunction () ) ; return getNthSibling ( function . getSecondChild () . getFirstChild () , index ) ; }
{ Preconditions . checkArgument ( fnNode . isFunction () ) ; return fnNode . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getSecondChild () ; }
{ Preconditions . checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
Preconditions . checkArgument ( NodeUtil . isObjectDefinePropertiesDefinition ( definePropertiesCall ) ) ;
{ Preconditions . checkState ( isLValue ( n ) ) ; lhsNodes . add ( n ) ; }
{ Preconditions . checkArgument ( function . isFunction () ) ; return isNameReferenced ( function . getLastChild () , STRING_CONSTANT , MATCH_NOT_THIS_BINDING ) ; }
{ Preconditions . checkArgument ( fn . isFunction () , fn ) ; return fn . getLastChild () ; }
Preconditions . checkState ( block . isNormalBlock () ) ;
Preconditions . checkState ( tryNode . isTry () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( objlit . isObjectLit () ) ;
Preconditions . checkState ( n . isObjectLit () || n . isClassMembers () ) ;
{ Preconditions . checkState ( n . isNew () , n ) ; return n . isOnlyModifiesThisCall () ; }
{ Preconditions . checkState ( n . isCall () , n ) ; return ( n . getSideEffectFlags () & Node.FLAG_LOCAL_RESULTS ) > NUMBER_CONSTANT ; }
Preconditions . checkState ( node . hasTwoChildren () , node ) ;
{ Preconditions . checkArgument ( n . isClass () ) ; return n . getLastChild () ; }
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkState ( n . isFunction () || n . isClass () ) ;
Preconditions . checkState ( descriptor . isObjectLit () ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Preconditions . checkNotNull ( var ) ;
Preconditions . checkState ( function . isFunction () ) ;
Preconditions . checkState ( function . isFunction () ) ;
if ( modifyCallSites ) { Preconditions . checkNotNull ( defFinder ) ; callSiteOptimizer = new CallSiteOptimizer ( compiler , defFinder ) ; }
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
{ Preconditions . checkState ( this . fn == null ) ; this . fn = fn ; }
Preconditions . checkArgument ( changed != null ) ;
Preconditions . checkState ( functionState . hasExistingFunctionDefinition () ) ;
Preconditions . checkState ( n . isName () , n ) ;
Preconditions . checkState ( name . isName () ) ;
Preconditions . checkState ( NodeUtil . isGet ( child ) ) ;
Preconditions . checkArgument ( fn . isFunction () ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () . isNormalized () ) ;
Preconditions . checkNotNull ( data ) ;
{ Preconditions . checkState ( hasProcessBeenRun , STRING_CONSTANT ) ; return definitionNodeByDefinitionSite . values () ; }
Preconditions . checkNotNull ( site ) ;
Preconditions . checkState ( ! hasProcessBeenRun , STRING_CONSTANT ) ;
Preconditions . checkNotNull ( colorToNodeMap , STRING_CONSTANT ) ;
int exitCodeValue = Preconditions . checkNotNull ( exitCode ) ;
{ Preconditions . checkNotNull ( entryPoints ) ; this . entryPoints = entryPoints ; return this ; }
{ Preconditions . checkState ( NUMBER_CONSTANT == Iterables . size ( inputs ) ) ; return; }
Preconditions . checkState ( compiler . getOptions () . outputJs == OutputJs.NORMAL ) ;
Preconditions . checkState ( specs != null ) ;
Preconditions . checkState ( zipEntryName . contains ( filename ) ) ;
Preconditions . checkNotNull ( input ) ;
{ this . exitCodeReceiver = Preconditions . checkNotNull ( newExitCodeReceiver ) ; }
Preconditions . checkArgument ( inputsSupplier == null ^ modulesSupplier == null ) ;
Preconditions . checkState ( currentInfo != null ) ;
{ this . compilerOptions = Preconditions . checkNotNull ( compilerOptions ) ; return this ; }
{ Preconditions . checkState ( c . isScript () ) ; hotSwapScript ( c , null ) ; }
Preconditions . checkNotNull ( sourceString ) ;
Preconditions . checkArgument ( js.length == NUMBER_CONSTANT , STRING_CONSTANT ) ;
Preconditions . checkState ( block . isNormalBlock () ) ;
{ Preconditions . checkState ( nameNode . isQualifiedName () ) ; return nameNode . getLastChild () . getString () . startsWith ( STRING_CONSTANT ) ; }
Preconditions . checkState ( TokenStream . isJSIdentifier ( tempVarName ) ) ;
Preconditions . checkArgument ( newSourceInd < sources . size () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( result != null ) ;
Preconditions . checkState ( n . isNew () || n . isCall () ) ;
Preconditions . checkState ( compiler . getLifeCycleStage () == LifeCycleStage.NORMALIZED ) ;
Preconditions . checkState ( null == m . put ( type , top ) ) ;
{ Integer priority = priorities . get ( n ) ; Preconditions . checkNotNull ( priority ) ; return priority ; }
Preconditions . checkState ( handler . isTry () ) ;
Preconditions . checkState ( cur . getParent () != null , STRING_CONSTANT ) ;
{ Preconditions . checkState ( next . isCase () ) ; createEdge ( node , Branch.ON_FALSE , next ) ; }
{ Preconditions . checkState ( exceptionHandler . peek () == parent ) ; exceptionHandler . pop () ; }
String aliasExpanded = Preconditions . checkNotNull ( aliasDefinition . getQualifiedName () ) ;
{ Preconditions . checkState ( ! aliasReference . hasChildren () ) ; aliasReference . addChildToFront ( replacement ) ; }
Preconditions . checkState ( matches . size () == NUMBER_CONSTANT , matches ) ;
Preconditions . checkState ( currentStatement . isDo () ) ;
Preconditions . checkNotNull ( compiler ) ;
{ Preconditions . checkState ( parent == scope . getParent () ) ; }
Preconditions . checkArgument ( nameNode . isName () ) ;
Preconditions . checkArgument ( ancestors.length > NUMBER_CONSTANT ) ;
private int getMaskForBitIndex ( int bitIndex ) { Preconditions . checkArgument ( bitIndex >= NUMBER_CONSTANT , STRING_CONSTANT ) ; return NUMBER_CONSTANT < < bitIndex ; }
Preconditions . checkState ( t . getScope () . isFunctionBlockScope () ) ;
{ Preconditions . checkNotNull ( edgeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( edgeAnnotationStack ) ; }
{ Preconditions . checkNotNull ( nodeAnnotationStack , STRING_CONSTANT ) ; popAnnotations ( nodeAnnotationStack ) ; }
{ Preconditions . checkState ( call . isCall () ) ; call . putBooleanProp ( Node.FREE_CALL , true ) ; return call ; }
{ Preconditions . checkState ( parent . isCall () ) ; compiler . report ( JSError . make ( parent , GOOG_CLASS_DESCRIPTOR_NOT_VALID ) ) ; }
Preconditions . checkArgument ( call . isCall () ) ;
{ Preconditions . checkState ( parent . isVar () ) ; parent . removeChild ( nameNode ) ; }
{ Preconditions . checkState ( NodeUtil . createsBlockScope ( root ) , scope ) ; symbolStack . push ( new NameContext ( anonymousNode , scope ) ) ; }
Preconditions . checkState ( isGeneric () ) ;
{ Preconditions . checkState ( isGeneric () ) ; return substituteParametricGenerics ( typeMap ) ; }
{ for ( String typeParam : this . typeParameters ) { Preconditions . checkState ( ! typeMap . containsKey ( typeParam ) ) ; } }
Preconditions . checkState ( this . isLoose () || f2 . isLoose () ) ;
{ Preconditions . checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
Preconditions . checkArgument ( f1 . isLoose () || f2 . isLoose () ) ;
Preconditions . checkArgument ( ! isTopFunction () ) ;
{ Preconditions . checkState ( ! isTopFunction () ) ; return requiredFormals . size () ; }
{ Preconditions . checkState ( ! isTopFunction () ) ; return outerVarPreconditions . get ( name ) ; }
Preconditions . checkState ( ! isTopFunction () ) ;
public JSType getRestFormalsType () { Preconditions . checkNotNull ( restFormals ) ; return restFormals ; }
Preconditions . checkState ( isUniqueConstructor () ) ;
Preconditions . checkNotNull ( commonTypes ) ;
Preconditions . checkArgument ( o instanceof DeferredCheck ) ;
Preconditions . checkArgument ( pname . isIdentifier () ) ;
Preconditions . checkState ( insideQualifiedName ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( pname == null || pname . isIdentifier () ) ;
Preconditions . checkNotNull ( type ) ;
{ Preconditions . checkArgument ( ! varName . contains ( STRING_CONSTANT ) ) ; return env . putType ( varName , type ) ; }
{ Preconditions . checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
Preconditions . checkArgument ( expr . isNew () || expr . isCall () ) ;
Preconditions . checkArgument ( callNode . isCall () || callNode . isNew () ) ;
Preconditions . checkNotNull ( type ) ;
Preconditions . checkArgument ( thisExpr . isThis () ) ;
Preconditions . checkState ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkArgument ( getProp . isGetProp () ) ;
Preconditions . checkArgument ( propAccessNode . isGetProp () || propAccessNode . isGetElem () ) ;
Preconditions . checkNotNull ( funType ) ;
Preconditions . checkState ( receiver == null || isFwd ) ;
Preconditions . checkState ( ! formalType . isBottom () ) ;
Preconditions . checkArgument ( call . isCall () ) ;
Preconditions . checkState ( logicalOp == Token.AND ) ;
Preconditions . checkState ( n != null , STRING_CONSTANT ) ;
TypeEnv outEnv = Preconditions . checkNotNull ( getOutEnv ( dn ) ) ;
if ( fnType . getFunType () == null ) { Preconditions . checkState ( fnType . isUnknown () ) ; return this . commonTypes . qmarkFunction () ; }
Preconditions . checkState ( qnameRoot . isName () ) ;
{ Preconditions . checkNotNull ( original ) ; return original != this . node || this . isChanged () ; }
{ Preconditions . checkState ( this . isNot () ) ; return ( normalizeChildren ( node , children ) [ NUMBER_CONSTANT ] ) . change () ; }
Preconditions . checkNotNull ( n . getParent () ) ;
Preconditions . checkState ( n . getParent () != null ) ;
Preconditions . checkNotNull ( dNode ) ;
Preconditions . checkNotNull ( dNode ) ;
if ( doSanityChecks && sourceFile != null ) { Preconditions . checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
{ Preconditions . checkState ( this . declaration == null ) ; this . declaration = ref ; }
if ( otherScopeParent == null ) { Preconditions . checkState ( globalScope == null , STRING_CONSTANT ) ; }
Preconditions . checkNotNull ( declNode ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkState ( fn . isConstructor () || fn . isInterface () ) ;
Preconditions . checkArgument ( destructuringLhs . isDestructuringLhs () ) ;
{ Preconditions . checkState ( lhs . isName () ) ; checkShortName ( t , lhs , callNode . getLastChild () . getString () ) ; }
Preconditions . checkState ( callNode . isCall () ) ;
Preconditions . checkState ( currentModule == null ) ;
{ Preconditions . checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ Preconditions . checkState ( languageIn != LanguageMode.NO_TRANSPILE ) ; this . languageIn = languageIn ; }
{ Preconditions . checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
Preconditions . checkNotNull ( entryPoints ) ;
{ Preconditions . checkArgument ( funAstSize > NUMBER_CONSTANT ) ; this . maxFunctionSizeAfterInlining = funAstSize ; }
Preconditions . checkState ( value instanceof String ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
Preconditions . checkState ( script . isScript () ) ;
{ Preconditions . checkState ( hasReferenceName () ) ; return getReferenceName () . hashCode () ; }
{ Preconditions . checkState ( n . getParent () . getFirstChild () == n ) ; return n . getParent () . cloneTree () . getFirstChild () ; }
if ( n . isScript () ) { Preconditions . checkState ( this . script == null ) ; this . script = n ; }
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( root . isScript () ) ;
Preconditions . checkState ( newReachable . getAnnotation () != REACHABLE ) ;
Preconditions . checkNotNull ( compiler ) ;
{ super ( source ) ; Preconditions . checkNotNull ( source ) ; this . excerpt = excerpt ; }
Preconditions . checkNotNull ( paramType , STRING_CONSTANT ) ;
Preconditions . checkState ( n . isAssign () ) ;
protected boolean isASTNormalized () { Preconditions . checkNotNull ( compiler ) ; return compiler . getLifeCycleStage () . isNormalized () ; }
{ Preconditions . checkNotNull ( compiler ) ; return compiler . areNodesEqualForInlining ( n1 , n2 ) ; }
Preconditions . checkNotNull ( typeParameters ) ;
{ Preconditions . checkState ( this . nominalType == null ) ; this . nominalType = t ; return this ; }
{ Preconditions . checkState ( returnType == null ) ; returnType = t ; return this ; }
{ Preconditions . checkState ( restFormals == null ) ; restFormals = t ; return this ; }
Preconditions . checkArgument ( ! t . isBottom () ) ;
public FunctionTypeBuilder ( JSTypes commonTypes ) { this . commonTypes = Preconditions . checkNotNull ( commonTypes ) ; }
Preconditions . checkArgument ( qName != null && ownerName != null ) ;
Preconditions . checkArgument ( ! variableName . isEmpty () ) ;
{ Preconditions . checkNotNull ( inputId ) ; sourceName = NodeUtil . getSourceName ( n ) ; }
Preconditions . checkArgument ( o instanceof Property ) ;
Preconditions . checkArgument ( inferredType != null ) ;
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkNotNull ( inputId ) ;
{ super ( registry , templateTypeMap ) ; setReferencedType ( Preconditions . checkNotNull ( referencedType ) ) ; }
Preconditions . checkState ( DEFAULT_EXTERNS . length () != externs . length () ) ;
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkState ( behaviorObjLit . isObjectLit () ) ;
Preconditions . checkNotNull ( keys ) ;
Preconditions . checkNotNull ( namedType ) ;
{ Preconditions . checkNotNull ( name ) ; nonNullableTypeNames . add ( name ) ; }
Preconditions . checkArgument ( source == null || source . isFunction () ) ;
Preconditions . checkState ( source . isFunction () , source ) ;
{ Preconditions . checkState ( namesToTypes . containsKey ( name ) ) ; register ( t , name ) ; }
{ Preconditions . checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
public TemplateType getObjectIndexKey () { Preconditions . checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
Preconditions . checkNotNull ( inputId ) ;
Preconditions . checkState ( n . hasOneChild () , n ) ;
{ Preconditions . checkArgument ( compiler . getLifeCycleStage () . isNormalized () ) ; this . compiler = compiler ; }
{ Preconditions . checkNotNull ( realSource ) ; this . realSource = realSource ; this . reportParseErrors = reportParseErrors ; }
Preconditions . checkNotNull ( declaration ) ;
Preconditions . checkState ( parent . isClassMembers () ) ;
Preconditions . checkState ( parent . isObjectLit () ) ;
Preconditions . checkState ( obj instanceof AstChange ) ;
Preconditions . checkArgument ( functionName != null ) ;
Preconditions . checkArgument ( parameterName != null ) ;
Preconditions . checkState ( labeledVariable . isVar () ) ;
Property nameProp = Preconditions . checkNotNull ( getOrCreateProperty ( n ) ) ;
{ Preconditions . checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
Preconditions . checkArgument ( assignedAt . isQualifiedName () ) ;
{ Preconditions . checkArgument ( lhs . isQualifiedName () ) ; writes . addLast ( new PropertyWrite ( lhs ) ) ; }
Preconditions . checkArgument ( obj . isObjectLit () ) ;
{ Preconditions . checkNotNull ( internalScopeCreator ) ; internalScopeCreator . patchGlobalScope ( topScope , scriptRoot ) ; }
Preconditions . checkState ( defParent . isExprResult () ) ;
Preconditions . checkArgument ( use . isName () ) ;
Preconditions . checkState ( t . getScopeRoot () . isFunction () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( callOrNew . isCall () || callOrNew . isNew () ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkState ( parts.length == NUMBER_CONSTANT || parts.length == NUMBER_CONSTANT ) ;
Preconditions . checkArgument ( userOrderedInputs . containsAll ( rootInputs ) ) ;
Preconditions . checkState ( nameNode != null ) ;
Preconditions . checkState ( ! name . isEmpty () ) ;
Preconditions . checkState ( ! current.renameMap . containsKey ( name ) ) ;
Preconditions . checkState ( fnNode . isFunction () ) ;
Preconditions . checkState ( callNode . isCall () ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
Preconditions . checkState ( ORDER_CODE_REPLACEMENTS . isOrdered ( replacements ) ) ;
{ Preconditions . checkState ( n . isFunction () , n ) ; return true ; }
Preconditions . checkState ( this . namespaceType == null ) ;
Preconditions . checkNotNull ( interfaceType ) ;
Preconditions . checkNotNull ( node ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , this , false ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true , true ) ; }
{ return new J2clClinitPrunerPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler , compiler . getChangedScopeNodesForPass ( STRING_CONSTANT ) ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler , true ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () , true ) ; }
EnvTypePair pair = analyzeExprFwd ( prop , recvLvalue.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
builder . put ( typeParam , t . isBottom () ? UNKNOWN : t ) ;
pair = analyzeExprFwd ( index , pair.env , indexType . isBottom () ? UNKNOWN : indexType ) ;
{ builder . addRetType ( actualRetType . isBottom () ? TOP : actualRetType ) ; }
moduleResolutionMode = ModuleLoader.ResolutionMode.LEGACY ;
public void testEs6ThisWithImportModule () { testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , Es6CheckModule.ES6_MODULE_REFERENCES_THIS ) ; }
String result = STRING_CONSTANT + STRING_CONSTANT ;
String result = STRING_CONSTANT ;
if ( forAnnotations ) { return sb . append ( getReferenceName () ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new UnreachableCodeElimination ( compiler , removeNoOpStatements ) ; }
{ @ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; } }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new UnreachableCodeElimination ( compiler , true ) ; }
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
static CompilerPass getContextualRenameInverter ( AbstractCompiler compiler ) { return new ContextualRenameInverter ( compiler ) ; }
MakeDeclaredNamesUnique () { this ( new ContextualRenamer () ) ; }
{ return new J2clEqualitySameRewriterPass ( compiler ) ; }
{ return new J2clClinitPrunerPass ( compiler ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels () ) ; }
RenameLabels ( final AbstractCompiler compiler ) { this ( compiler , new DefaultNameSupplier () , true ) ; }
{ this ( config , errorReporter , source , offset , false , true ) ; }
return new ParseResult ( root , comments , features , p . getInlineSourceMap () ) ;
Node objectLit = n . getFirstChild () . getFirstChild () . getFirstChild () ;
@ Override MustDef createEntryLattice () { return new MustDef ( jsScope . getVarIterable () ) ; }
return JSType . fromObjectType ( ObjectType . fromNominalType ( tmp . instantiateGenerics ( typeMap ) ) ) ;
return nominal == null ? null : nominal . instantiateGenerics ( this . commonTypes . MAP_TO_UNKNOWN ) . getInstanceAsJSType () ;
{ if ( interf . inheritsFromIObjectReflexive () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; } }
for ( NominalType interf : this . rawType . getInterfaces () ) { result . add ( interf . instantiateGenerics ( typeMap ) ) ; }
return this . rawType . getSuperClass () . instantiateGenerics ( typeMap ) ;
{ handleConstructorAnnotation ( functionName , funNode , constructorType , parentClass , implementedIntfs , registry , builder ) ; }
! isInvalidatingType ( dest )
! props . containsKey ( propName ) && ! isInvalidatingType ( type ) && NodeUtil . isImmutableValue ( value ) && NodeUtil . isExecutedExactlyOnce ( value )
{ fn = fn == null ? null : fn . withLoose () ; props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
{ props = joinPropsLoosely ( commonTypes , obj1.props , obj2.props ) ; }
if ( doSlicing ) { pair.env = envPutType ( pair.env , name , declType != null ? declType : UNKNOWN ) ; }
preciseType = declType == null ? requiredType : declType ;
{ JSType result = ft . getSuperPrototype () ; pair.type = result != null ? result : UNDEFINED ; return pair ; }
{ JSType tmp = t . getIndexedType () ; return tmp == null ? UNKNOWN : tmp ; }
declRetType = declRetType == null ? UNKNOWN : declRetType ;
throw new IllegalStateException ( STRING_CONSTANT ) ;
{ return new InstrumentFunctions ( compiler , functionNames , options.instrumentationTemplate , options.appNameStr ) ; }
{ variableMap = runVariableRenaming ( compiler , prevVariableMap , externs , root ) ; }
propertyMap = rprop . getPropertyMap () ;
anonymousFunctionNameMap = naf . getFunctionMap () ;
{ return new CrossModuleMethodMotion ( compiler , crossModuleIdGenerator , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
stringMap = pass . getStringMap () ;
idGeneratorMap = pass . getSerializedIdMappings () ;
functionNames = pass . getFunctionNames () ;
cssNames = newCssNames ;
{ return new CrossModuleMethodMotion ( compiler , new CrossModuleMethodMotion.IdGenerator () , canMoveExterns , noStubs ) ; }
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
parse ( STRING_CONSTANT ) ;
skipStringLiteralEscapeSequence () ;
private boolean skipStringLiteralChar () { if ( peek ( CHAR_CONS ) ) { return skipStringLiteralEscapeSequence () ; } nextChar () ; return true ; }
return isUnknown () || ( isUnknownObject () && isLoose () ) || ( ft != null && ft . isTopFunction () ) ;
objType == null || types . contains ( objType ) || objType . isUnknownObject () || objType . isUnknownType () || objType . isBottom ()
return objType . isUnknownObject () || ( ft != null && ft . isConstructor () && isInvalidatingType ( ft . getInstanceType () ) ) ;
JSType type
JSType type
JSType type
boolean mustReplaceThisAndArguments () { return thisAndArgumentsContext . isAsyncContext () ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
parent . getParent () . isCall () && NodeUtil . isCallOrNewTarget ( parent )
checkArgument ( expr . isCall () ) ;
checkArgument ( n . isFunction () || ( n . isName () && NodeUtil . isCallOrNewTarget ( n ) ) ) ;
return analyzeCallNodeArgsFwdWhenError ( call , inEnv ) ;
{ checkArgument ( ! pname . contains ( STRING_CONSTANT ) ) ; return env . getType ( pname ) ; }
for ( FunctionTypeI impl : constructor . getSubTypes () ) { list . add ( impl . getInstanceType () ) ; }
if ( constructor != null ) { for ( FunctionTypeI subType : constructor . getSubTypes () ) { addRelatedInstance ( subType , related ) ; } }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
preserveClosurePrimitives = false ;
options . setWarningLevel ( DiagnosticGroups.LINT_CHECKS , CheckLevel.WARNING ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.TEMPLATE_ARGUMENT_MISMATCH , NewTypeInference.WRONG_ARGUMENT_COUNT ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
testSame ( TEST_EXTERNS + externs , STRING_CONSTANT , GlobalTypeInfo.REDECLARED_PROPERTY ) ;
typeCheck ( js , GlobalTypeInfo.CTOR_IN_DIFFERENT_SCOPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( js , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , GlobalTypeInfo.ANONYMOUS_NOMINAL_TYPE , NewTypeInference.MISTYPED_ASSIGN_RHS ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.WRONG_PARAMETER_COUNT ) ;
public void testUnknownTypeReferenceDoesntCrash () { typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.INEXISTENT_PARAM ) ;
public void testVarDecls () { typeCheck ( STRING_CONSTANT , GlobalTypeInfo.ONE_TYPE_FOR_MANY_VARS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; typeCheck ( STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS ) ; }
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
typeCheck ( STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
testSame ( DEFAULT_EXTERNS , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
this . symbolTable = ( GlobalTypeInfo ) compiler . getSymbolTable () ;
passes . add ( makePassFactory ( STRING_CONSTANT , compiler . getSymbolTable () ) ) ;
test ( options , STRING_CONSTANT , GlobalTypeInfo.UNRECOGNIZED_TYPE_NAME ) ;
@ Override protected CompilerPass create ( final AbstractCompiler compiler ) { return compiler . getSymbolTable () ; }
symbolTable = compilerState.symbolTable ;
this . symbolTable = compiler.symbolTable ;
return getSymbolTable () . getImplicitInterfaceUses () ;
return getSymbolTable () . getMismatches () ;
symbolTable = null ;
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , GlobalTypeInfo.INVALID_PROP_OVERRIDE ) ;
ignoreWarnings ( GlobalTypeInfo.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( STRING_CONSTANT , TRAILING_COMMA_MESSAGE ) ;
parseWarning ( js , warning , warning ) ;
Node ast
features = features . union ( factory . getFeatures () ) ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . union ( FeatureSet.TYPESCRIPT ) ; return nextToken () . type ; }
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEs6Message ( Feature.DESTRUCTURING ) , getRequiresEs6Message ( Feature.ARRAY_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( STRING_CONSTANT , requiresLanguageModeMessage ( LanguageMode.ECMASCRIPT5 , Feature.TRAILING_COMMA ) ) ;
parseWarning ( js , warning ) ;
@ Nullable Node ast
features = factory . getFeatures () ;
ImmutableMap . < Pattern , DiagnosticType > builder () . put ( Pattern . compile ( STRING_CONSTANT + STRING_CONSTANT ) , TRAILING_COMMA )
{ features = features . with ( Feature.ACCESSIBILITY_MODIFIER ) ; return nextToken () . type ; }
new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.SINGLE_FILE )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.SINGLE_FILE ) ; }
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckRequiresForConstructors ( compiler , CheckRequiresForConstructors.Mode.FULL_COMPILE ) ; }
public void testFailGoogArray () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testFailConstant () { mode = CheckRequiresForConstructors.Mode.SINGLE_FILE ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; testMissingRequireStrict ( STRING_CONSTANT , STRING_CONSTANT ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CheckRequiresForConstructors ( compiler , mode ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; mode = CheckRequiresForConstructors.Mode.FULL_COMPILE ; }
n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ( ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) || ! childDeclared )
{ return n . isName () && n . getString () . equals ( ARGUMENT_ARRAY_ALIAS ) && ! jsScope . isDeclaredSloppy ( ARGUMENT_ARRAY_ALIAS , false ) ; }
if ( ! jsScope . isDeclaredSloppy ( name , false ) ) { return; }
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
assertTrue ( fBlockScope . isDeclaredSloppy ( STRING_CONSTANT , false ) ) ;
if ( ! functionBlockScope . isDeclaredSloppy ( name , false ) ) { return; }
if ( current . isDeclaredSloppy ( oldName , false ) ) { return; } else { current = current . getParent () ; }
String expectedCode = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveGoogProvidesAndRequires || this . shouldGenerateTypedExterns () ; }
preserveGoogProvidesAndRequires = false ;
public static Matcher googModuleOrProvide () { return anyOf ( functionCall ( STRING_CONSTANT ) , functionCall ( STRING_CONSTANT ) ) ; }
maybeProcessAccessibilityModifier ( member , tree.access ) ;
maybeProcessAccessibilityModifier ( n , tree.access ) ;
maybeProcessAccessibilityModifier ( member , functionTree.access ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_NEXT ) ; }
{ env = analyzeExprBwd ( prop . getFirstChild () , env , enumeratedType ) . env ; }
EnvTypePair pair = analyzeExprBwd ( prop . getFirstChild () , env , reqPtype ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , enumeratedType ) ;
EnvTypePair pair = analyzeExprFwd ( prop . getFirstChild () , env , reqPtype , specPtype ) ;
PropertyDef propdef = checkNotNull ( getPropDefFromClass ( superType , pname ) ) ;
return state . getIn () . reachingDef . get ( jsScope . getVar ( name ) ) ;
Var dep = jsScope . getVar ( n . getString () ) ;
@ Override MustDef createEntryLattice () { return new MustDef ( returnAllVars () ) ; }
Iterable < ? extends Var > vars
return state . getOut () . mayUseMap . get ( jsScope . getVar ( name ) ) ;
{ Pattern pattern = new Pattern () ; pattern.regExp = RegExp . compile ( string ) ; return pattern ; }
node = new Node <> ( e ) ;
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = new HashMap <> () ;
E e
@ Override public void add ( E e ) { union ( e , e ) ; }
{ for ( E elem : other . elements () ) { union ( elem , other . find ( elem ) ) ; } }
public void testUnusedLocalConst_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalConst () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
public void testUnusedLocalLet_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUnusedEs6 ( STRING_CONSTANT ) ; }
{ enableUnusedLocalAssignmentCheck = true ; assertUnused ( STRING_CONSTANT ) ; assertUnusedEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUnusedEs6 ( STRING_CONSTANT ) ;
public void testDefaultParam_withES6Modules () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testES6Module_destructuring () { enableUnusedLocalAssignmentCheck = true ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testUnusedCompoundAssign_withES6Modules () { assertNoWarningEs6 ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testUsedInShorthandObjLit_withES6Modules () { enableUnusedLocalAssignmentCheck = true ; assertUndeclaredEs6 ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
assertUndeclaredEs6 ( STRING_CONSTANT ) ;
public void testForOf () { assertEarlyReferenceError ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
public void testRedeclare_withES6Modules () { assertRedeclare ( STRING_CONSTANT ) ; assertNoWarningEs6 ( STRING_CONSTANT ) ; }
assertNoWarningEs6 ( STRING_CONSTANT ) ;
parent . isVar ()
Pattern includeFilePattern
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null ) . collectDefines ( root ) . keySet () ;
{ overrideDefines ( collectDefines ( root ) ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
EnumSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! EnumSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
recordPropertyName ( getProp . getLastChild () . getString () , getProp ) ;
recordPropertyName ( pname , qnameNode ) ;
Function < String , Void > recordPropertyName
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.ES3 ; }
new ProcessDefines ( compiler , overrides , false ) . injectNamespace ( namespace ) . process ( externs , js ) ;
new ProcessDefines ( compiler , ImmutableMap . copyOf ( replacements ) , options.checksOnly ) . injectNamespace ( namespaceForChecks ) . process ( externs , jsRoot ) ;
Set < String > defines = new ProcessDefines ( compiler , null , false ) . collectDefines ( externs , root ) . keySet () ;
( n . isName () ) && isDeclaration ( n )
public boolean isAsyncFunction () { return getBooleanProp ( ASYNC_FN ) ; }
public boolean isArrowFunction () { return getBooleanProp ( ARROW_FN ) ; }
if ( key . isEmpty () ) { continue; }
isInvalidatingType ( recvType ) || isStructuralInterfacePrototype ( recv )
{ if ( isInvalidatingType ( type ) ) { invalidate () ; return false ; } rootTypesByNode . put ( node , type ) ; }
if ( isInvalidatingType ( top ) ) { invalidate () ; return; }
PolymerPassStaticUtils . extractProperties ( behaviorValue , compiler )
List < MemberDefinition > properties = PolymerPassStaticUtils . extractProperties ( behaviorValue , compiler ) ;
new PolymerPass ( compiler ) . process ( externs , root ) ;
new PolymerPass ( compiler ) . process ( externsRoot , mainRoot ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDef ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
Property p = getProp ( pname ) ;
Property p = getPropFromClass ( pname ) ;
rhs . matchesQualifiedName ( ABSTRACT_METHOD_NAME ) || ( GlobalTypeInfo . isCtorDefinedByCall ( lhs ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
( GlobalTypeInfo . isCtorDefinedByCall ( nameNode ) && ! isFunctionBind ( rhs . getFirstChild () , inEnv , true ) )
if ( maybeWin != null ) { return maybeWin . getProp ( pname ) ; }
return this . nominalType . getProp ( pname ) ;
if ( nom != null ) { return nom . getProp ( pname ) ; }
Property p = this . rawType . getProp ( pname ) ;
Property p = this . rawType . getOwnProp ( pname ) ;
( ns . hasProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType ) )
GlobalTypeInfo . isCtorDefinedByCall ( getProp )
classType . hasCtorProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , propDeclType , previousPropType )
GlobalTypeInfo . isCtorDefinedByCall ( nameNode )
final CompilerPass simplifier = new PeepholeOptimizationsPass ( compiler , new PeepholeSimplifyRegExp () ) ;
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ;
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new ReorderConstantExpression () ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeCollectPropertyAssignments () ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new PeepholeSubstituteAlternateSyntax ( late ) ) ;
{ PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , new StatementFusion ( favorsCommas ) ) ; return peepholePass ; }
{ return new PeepholeOptimizationsPass ( compiler , new ExploitAssigns () ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return createPeepholeOptimizationsPass ( compiler ) ; }
{ return new PeepholeOptimizationsPass ( compiler , new PeepholeRemoveDeadCode () ) ; }
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope . getParent () , jsScope , escaped , compiler , scopeCreator ) ;
computeEscaped ( jsScope , jsScopeChild , escaped , compiler , scopeCreator ) ;
if ( isObjLit ) { declareVarsForObjLitValues ( n , alias , rvalue , varNode , varNode . getPrevious () , varParent ) ; }
super ( inExterns ) ;
super ( isExtern ) ;
{ super ( inExterns ) ; checkArgument ( node . isAssign () ) ; assignment = node ; }
{ super ( inExterns ) ; Preconditions . checkArgument ( node . isClass () ) ; c = node ; }
{ super ( inExterns ) ; checkArgument ( node . isFunction () ) ; function = node ; }
super ( inExterns ) ;
Property p = this . rawType . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ;
superType . isInterface () && current . isClass () && ! isCtorDefinedByCall ( current ) && ! current . mayHaveProp ( pname )
superClass . isAbstractClass () && superClass . hasAbstractMethod ( pname ) && ! rawType . isAbstractClass () && ! rawType . mayHaveOwnProp ( pname )
if ( maybeWin != null ) { return maybeWin . getProp ( pname , PropAccess.INCLUDE_STRAY_PROPS ) ; }
@ Override public boolean apply ( Node n ) { return isFunctionDeclaration ( n ) || n . isVar () ; }
parent . isVar ()
n . getParent () . isVar ()
! NodeUtil . isVarOrSimpleAssignLhs ( callNode , parent )
! NodeUtil . isVarOrSimpleAssignLhs ( name , name . getParent () )
{ if ( NodeUtil . isVarOrSimpleAssignLhs ( parent , grandparent ) ) { validProperties . add ( propName ) ; } else { return false ; } }
NodeUtil . isVarOrSimpleAssignLhs ( n , parent )
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { if ( referring != null ) { recordReference ( referringName , name , RefType.REGULAR ) ; } return; }
if ( NodeUtil . isVarOrSimpleAssignLhs ( n , parent ) ) { return; }
{ if ( nextParent == null || ! NodeUtil . isVarOrSimpleAssignLhs ( nextNode , nextParent ) ) { readsState = true ; } }
NodeUtil . isVarOrSimpleAssignLhs ( n , n . getParent () )
dest . isString () && NodeUtil . isExprAssign ( grandParent ) && NodeUtil . isVarOrSimpleAssignLhs ( n , parent )
public void testEs6EnhancedObjLiteralsPropertyShorthand () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
public void testES6ClassComputedProperty () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( STRING_CONSTANT ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT5 ) ; }
final int prop
int propType
int propType
int propType
public void putBooleanProp ( int propType , boolean value ) { putIntProp ( propType , value ? NUMBER_CONSTANT : NUMBER_CONSTANT ) ; }
int propType
int propType
int propType
public boolean getBooleanProp ( int propType ) { return getIntProp ( propType ) != NUMBER_CONSTANT ; }
int propType
int propType
int propType
int propType
int propType
int propType
@ Override public int getType () { return propType ; }
int propType
int propType
Set < Var > escaped
Set < N > entrySet = new HashSet <> () ;
Set < N > nodes = new HashSet <> () ;
String lValueName = NodeUtil . getBestLValueName ( NodeUtil . getBestLValue ( rValue ) ) ;
isStatementBlock ( parent ) || isSwitchCase ( node )
assertThat ( computeEscapedLocals ( STRING_CONSTANT ) ) . isEmpty () ;
validateChildCount ( n ) ;
{ validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
private void validateUnaryOp ( Node n ) { validateChildCount ( n ) ; validateExpression ( n . getFirstChild () ) ; }
new ReorderConstantExpression ()
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
List < Scope > allScopes = liveness . getScopeStack () ;
assertThat ( statements . get ( NUMBER_CONSTANT ) . isMovableDeclaration () ) . isTrue () ;
{ if ( parent . isParamList () ) { return true ; } else if ( NodeUtil . isNameDeclaration ( parent ) ) { return n . hasChildren () ; } }
thisProps = ! thisNt . isBuiltinObject () && thisNt . isStructuralInterface () ? thisNt . getAllPropsOfInterface () : this . props . keySet ()
{ otherPropNames = otherNt . getAllPropsOfInterface () ; if ( otherPropNames == null ) { return false ; } }
QualifiedName setterPname = new QualifiedName ( JSType . createSetterPropName ( pname . getLeftmostName () ) ) ;
QualifiedName getterPname = new QualifiedName ( JSType . createGetterPropName ( pname ) ) ;
scopeRoots . push ( node ) ;
{ validateChildCount ( n ) ; validateAssignmentTarget ( n . getFirstChild () ) ; validateExpression ( n . getLastChild () ) ; }
{ validateAssignmentTarget ( n ) ; }
public void testInvalidAnnotation5 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
public void testInvalidAnnotation4 ( ) throws Exception { testWarning ( STRING_CONSTANT + STRING_CONSTANT , INVALID_NO_SIDE_EFFECT_ANNOTATION ) ; }
if ( ! t . getScope () . isHoistScope () ) { return; }
{ if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; } }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
if ( t . getScope () . isHoistScope () ) { pop ( blockStack ) ; }
if ( t . getScope () . isHoistScope () ) { blockStack . add ( new BasicBlock ( parent , n ) ) ; }
Node hoistRoot = t . getClosestHoistScope () . getRootNode () ;
{ if ( n . isVar () && t . getScope () != t . getClosestHoistScope () ) { hoistVarIfNeeded ( t , n , parent ) ; } }
if ( scopeType == ScopeType.EXEC_CONTEXT ) { return t . getClosestHoistScope () . getRootNode () == currentScript.rootNode ; } else { return n . getParent () == currentScript.rootNode ; }
Node scopeRoot = t . getClosestHoistScope () . getRootNode () ;
if ( ! n . hasChildren () ) { rewriteEs6ObjectLiteralShorthandPropertySyntax ( n , compiler ) ; reportCodeChange ( n , STRING_CONSTANT ) ; }
yield . setYieldFor ( tree.isYieldFor ) ;
if ( n . isYieldFor () ) { checkNotNull ( first ) ; add ( STRING_CONSTANT ) ; }
if ( isGlobal () || isModuleScope () ) { throw new IllegalStateException ( STRING_CONSTANT + this ) ; }
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new ClosureOptimizePrimitives ( compiler , propertyRenamingEnabled ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ enableTypeCheck () ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
DiagnosticType warning
{ super . setUp () ; disableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testWarning ( STRING_CONSTANT , RhinoErrorReporter.TOO_MANY_TEMPLATE_PARAMS ) ; }
{ if ( parent . isParamList () ) { return true ; } else if ( parent . isVar () ) { return n . hasChildren () ; } }
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( options , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
checkState ( ! compiler . getLifeCycleStage () . isNormalized () ) ;
if ( hasParamWithNumberObjectLit ( fnNode ) ) { functionState . setInline ( false ) ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild ) ; }
NodeUtil . tryMergeBlock ( scopeClosureBlock ) ;
NodeUtil . tryMergeBlock ( callbackBlock ) ;
if ( NodeUtil . tryMergeBlock ( n ) ) { reportCodeChange () ; return null ; }
NodeUtil . tryMergeBlock ( moduleBody ) ;
Exception cause
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
catch ( Exception unexpectedException ) { throwUnexpectedException ( unexpectedException ) ; }
Exception unexpectedException
abstract void throwInternalError ( String msg , Exception cause ) ;
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalTypeAfterTypeChecking () . getInstanceAsJSType () : null ; }
if ( ! init . isEmpty () && ! init . isVar () ) { init = trySimplifyUnusedResult ( init , false ) ; }
if ( n . isVar () && n . hasOneChild () && n . getFirstFirstChild () != null ) { return true ; }
return globalScope . getType ( typeName ) ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
JSType declRetType = this . currentScope . getDeclaredFunctionType () . getReturnType () ;
DeclaredFunctionType dft = this . currentScope . getDeclaredFunctionType () ;
return this . registry . evaluateTypeExpression ( expr , typeEnv ) ;
TypeI type = typeEnv . getType ( name ) ;
Node mapFunctionBody = getFunctionBody ( mapFunction ) ;
this . registry = compiler . getTypeRegistry () ;
ImmutableList < String > names
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isGeneric () ? nt . getRawNominalType () . getInstanceAsJSType () : null ; }
{ TemplatizedType t = toMaybeTemplatizedType () ; return t == null ? null : t . getReferencedType () ; }
if ( STRING_CONSTANT . equals ( name ) ) { if ( ! hasThis () ) { return null ; } return getDeclaredFunctionType () . getThisType () ; }
ImmutableSet . of ( TokenType.IDENTIFIER , TokenType.TYPE , TokenType.DECLARE , TokenType.MODULE , TokenType.NAMESPACE ) . contains ( type )
! peekId () && ! ImmutableSet . of ( TokenType.VOID , TokenType.OPEN_PAREN , TokenType.OPEN_CURLY , TokenType.TYPEOF ) . contains ( peekType () )
compiler = multistageSerializeAndDeserialize ( compiler , inputs , recentChange ) ;
{ functionBody . removeChild ( current ) ; insertAfter = addToFront ( functionBody , current , insertAfter ) ; reportCodeChange ( functionBody , STRING_CONSTANT ) ; }
reportCodeChange ( n , STRING_CONSTANT ) ;
reportCodeChange ( n , STRING_CONSTANT ) ;
boolean hasUnfilledTemplateKeys () { return numUnfilledTemplateKeys () > NUMBER_CONSTANT ; }
compiler . getOptions () . setStrictModeInput ( false ) ;
Object getObjectValue ( ) ;
compiler . addToDebugLog ( STRING_CONSTANT + defineName ) ;
compiler . addToDebugLog ( STRING_CONSTANT + var.name ) ;
compiler . addToDebugLog ( STRING_CONSTANT + name + STRING_CONSTANT + newName ) ;
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
t . getCompiler () . addToDebugLog ( STRING_CONSTANT + fn . getName () ) ;
{ return new IntPropListItem ( getType () , intValue , next ) ; }
{ return new ObjectPropListItem ( getType () , objectValue , next ) ; }
public void testRestParam () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
var . setStaticSourceFile ( input . getSourceFile () ) ;
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
assertPassOrder ( checks , chromePass , checkJsDoc , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
ImmutableList < String > typeParameters
public List < String > getTypeParameters () { return typeParameters ; }
builder . addTypeParameters ( nt . getTypeParameters () ) ;
this . typeParameters = ImmutableList . of () ;
ImmutableList < String > typeParameters
ImmutableList < String > typeParameters
public boolean isDeleted () { return getBooleanProp ( DELETED ) ; }
@ Nullable PropListItem getPropListHeadForTesting () { return propListHead ; }
public int getSourcePosition () { return sourcePosition ; }
public int getCharno () { return extractCharno ( sourcePosition ) ; }
public int getLineno () { return extractLineno ( sourcePosition ) ; }
public int getLength () { return this . length ; }
public boolean hasProps () { return propListHead != null ; }
public boolean hasChildren () { return first != null ; }
{ validateExpression ( n . getLastChild () ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; super . enableNormalize () ; }
parent . isVar ()
public void toStringIsEqualTo ( String typeString ) { assertEquals ( actual () . toString () , typeString ) ; }
if ( n . isParamList () ) { requiresTypes = true ; return; }
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
checks . add ( createEmptyPass ( PassNames.AFTER_STANDARD_CHECKS ) ) ;
passName . equals ( PassNames.PARSE_INPUTS )
n . getParent () . isVar () && n . isName ()
checkState ( e != null , STRING_CONSTANT + STRING_CONSTANT ) ;
Typedef td = Typedef . make ( jsdoc . getTypedefType () ) ;
TypeI type = typeEnv . getNamespaceType ( name ) ;
options . setPackageJsonEntryNames ( ImmutableList . of ( STRING_CONSTANT , CompilerOptions.PACKAGE_JSON_MAIN ) ) ;
packageJsonEntryNames = ImmutableList . of ( CompilerOptions.PACKAGE_JSON_MAIN ) ;
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
passName . equals ( Compiler.PARSING_PASS_NAME )
{ Node nameNode = n . getFirstChild () ; renamer . addDeclaredName ( nameNode . getString () , true ) ; }
if ( this . classProps . containsKey ( pname ) || this . protoProps . containsKey ( pname ) ) { return; }
this . allProps = builder . addAll ( classProps . keySet () ) . addAll ( protoProps . keySet () ) . build () ;
Property p = getOwnProp ( pname , propAccess ) ;
Property p = getOwnProp ( pname , propAccess ) ;
{ ObjectType obj = getObjTypeIfSingletonObj () ; return obj != null && obj . hasOwnProperty ( new QualifiedName ( propertyName ) ) ; }
{ checkState ( this . isSingletonObj () ) ; return this . getObjTypeIfSingletonObj () . getOwnPropertyDefSite ( propertyName ) ; }
classType . mayHaveOwnProp ( pname ) && previousPropType != null && ! suppressDupPropWarning ( jsdoc , typeInJsdoc , previousPropType )
this . externs = makeCompilerInput ( externs , true ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
{ for ( Var var : scriptToVarMap . get ( script ) ) { super . undeclareInteral ( var ) ; } }
visitForOf ( n , parent ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
CompilerInput newInput = ( CompilerInput ) deserialize ( serialize ( input ) ) ;
@ Override public FeatureSet featureSet () { return ES8 ; }
madeChange = true ;
preloadEs6RuntimeFunction ( compiler , function ) ;
visitForOf ( t , n , parent ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Util.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
return this . globalScope . getInstanceType ( typeName ) ;
JSType t = getInstanceType ( typeName ) ;
public void testTypeTransformationNoneType () { inFunction ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; verify ( STRING_CONSTANT , JSTypeNative.NO_TYPE ) ; }
{ tmpEnv = collectTypesForFreeVarsFwd ( callee , tmpEnv ) ; }
TypeEnv outEnv = collectTypesForFreeVarsFwd ( expr , inEnv ) ;
TypeEnv exitEnv = getInEnv ( this . cfg . getImplicitReturn () ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es6ToEs3Converter ( compiler ) ; }
{ compiler . report ( JSError . make ( export , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
{ compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT , STRING_CONSTANT ) ) ; }
if ( controlCanExit ( n . getFirstChild () ) ) { compiler . report ( JSError . make ( n , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return false ; }
if ( currentStatement . hasChildren () ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; }
if ( loop == null ) { compiler . report ( JSError . make ( currentStatement , Es6ToEs3Converter.CANNOT_CONVERT_YET , STRING_CONSTANT ) ) ; return; }
handleGet ( module , scope , n , parent , prefix , Ref.Type.PROTOTYPE_GET ) ;
handleGet ( module , scope , n , parent , name , type ) ;
{ if ( n . isEmpty () && parent . isClassMembers () ) { compiler . reportChangeToEnclosingScope ( n ) ; n . detach () ; } }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveEmptyClassMembers ( compiler ) ) ;
compiler . ensureLibraryInjected ( STRING_CONSTANT + function . toLowerCase ( Locale.US ) , false ) ;
visitForOf ( n , parent ) ;
{ builder . addRetType ( firstNonBottom ( actualRetType , TOP ) ) ; }
for ( ObjectTypeI interfaceType : funType . getAncestorInterfaces () ) { interfaces . add ( interfaceType . toAnnotationString () ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT , record . toAnnotationString () ) ;
assertEquals ( STRING_CONSTANT , record . toAnnotationString () ) ;
if ( ! runOptimizeCalls ) { passes . add ( getRemoveUnusedVars ( STRING_CONSTANT , false ) ) ; }
checks . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
t . reportCodeChange () ;
if ( n . getChildCount () != NUMBER_CONSTANT ) { return false ; }
Node statementNode = rhsNode . getParent () . getParent () ;
if ( call . getChildCount () != NUMBER_CONSTANT || ! legacyNamespaceNode . isString () ) { t . report ( legacyNamespaceNode , INVALID_GET_NAMESPACE ) ; return; }
if ( call . getChildCount () != NUMBER_CONSTANT || ! namespaceNode . isString () ) { t . report ( namespaceNode , INVALID_FORWARD_DECLARE_NAMESPACE ) ; return; }
grandparent . isStringKey () && NodeUtil . isObjectDefinePropertiesDefinition ( grandparent . getParent () . getParent () )
NodeTraversal . traverseEs6 ( compiler , fnName . getParent () . getParent () , uniquifier ) ;
if ( entry . isObjectLit () ) { checkState ( entryName == STRING_CONSTANT ) ; processBrowserFieldAdvancedUsage ( dirName , entry ) ; }
{ checkState ( this . setUpRan , STRING_CONSTANT ) ; ignoredWarnings . addAll ( Arrays . asList ( warnings ) ) ; }
{ @ Override public boolean apply ( Node n ) { return name . equals ( n . getQualifiedName () ) ; } }
catch ( IllegalArgumentException expected ) { assertTrue ( expected . getMessage () . contains ( STRING_CONSTANT + STRING_CONSTANT ) ) ; }
Node classNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
Node fNode = root . getFirstChild () . getFirstChild () . getFirstChild () ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
js = renameFunctionDefinition + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
catch ( IllegalStateException e ) { assertEquals ( FixedPointGraphTraversal.NON_HALTING_ERROR_MSG , e . getMessage () ) ; }
{ testSame ( kExterns + extraExterns , source ) ; assertEquals ( expected , noSideEffectCalls ) ; noSideEffectCalls . clear () ; }
Node fNode = root . getFirstChild () . getFirstChild () ;
assertEquals ( null , noInline ) ;
if ( parent . isVar () ) { parent . getParent () . removeChild ( parent ) ; reportCodeChange () ; return null ; }
{ node . getParent () . removeChild ( node ) ; reportCodeChange () ; return null ; }
if ( line . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT ) { return line . indexOf ( STRING_CONSTANT ) ; }
public void testImportedNameCollision () { testSame ( STRING_CONSTANT ) ; checkSynthesizedExtern ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkState ( n . isName () || n . isStringKey () , STRING_CONSTANT , n ) ;
@ Override public FeatureSet featureSet () { return ES8_MODULES ; }
{ checkArgument ( n . isTry () ) ; return n . getChildCount () == NUMBER_CONSTANT ; }
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
Node root = typeInfoCheckAndGetRoot ( STRING_CONSTANT ) ;
{ iterableType = iterable . getTypeI () . toMaybeObjectType () ; typeParam = iterableType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; }
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; }
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
tryRemovingClinit ( node , parent ) ;
newEmptyClinitMethod = true ;
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () ) { addOldTypeCheckerPasses ( checks , options ) ; }
Renamer renamer = nameStack . peek () ;
{ if ( NodeUtil . isFunctionBlock ( t . getScopeRoot () ) ) { return; } if ( ! t . inGlobalScope () ) { nameStack . pop () ; } }
new PureFunctionIdentifier.Driver ( compiler , null ) . process ( externs , root ) ;
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
if ( returnType != null ) { builder . append ( CHAR_CONS ) ; returnType . appendTo ( builder , ctx ) ; }
if ( options . getNewTypeInference () && options . getRunOTIafterNTI () && ! options.checksOnly ) { addOldTypeCheckerPasses ( checks , options ) ; }
lit . setJSType ( exportedObjectLit . getJSType () ) ;
disableTypeCheck () ;
disableTypeCheck () ;
{ super . setUp () ; enableNormalize () ; enableTypeCheck () ; }
{ super . setUp () ; allowExternsChanges () ; enableTypeCheck () ; enableRunTypeCheckAfterProcessing () ; enableParseTypeInfo () ; }
disableTypeCheck () ;
{ disableTypeCheck () ; assertExternProperties ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
disableTypeCheck () ;
public void tagAsStrict () { add ( STRING_CONSTANT ) ; }
enableTypeCheck () ;
enableTypeCheck () ;
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties4 () { enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
enableTypeCheck () ;
{ enableTypeCheck () ; test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ enableTypeCheck () ; testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty2 () { enableTypeCheck () ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testConstructorProperty1 () { enableTypeCheck () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
enableTypeCheck () ;
v != null || isShadowingDisallowed ( name , s )
if ( options.j2clPassMode . shouldAddJ2clPasses () ) { passes . add ( j2clConstantHoisterPass ) ; passes . add ( j2clOptBundlePass ) ; }
boolean shouldPrintExterns () { return this . printExterns ; }
return new TypeSubject ( THROW_ASSERTION_ERROR , actualPropType ) ;
t . inGlobalScope () && isDeclaration ( n ) && ! n . getBooleanProp ( Node.IS_NAMESPACE ) && ! isWhitelisted ( n )
assertFalse ( NodeUtil . isFunctionDeclaration ( getFunctionNode ( STRING_CONSTANT ) ) ) ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
warning ( TYPE_MISMATCH_WARNING )
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
disableTypeCheck () ;
enableTypeCheck () ;
checkState ( curNode != null ) ;
boolean isFunctionExpression = ( parent != null ) && NodeUtil . isFunctionExpression ( n ) ;
checkState ( s . isGlobal () || s . isModuleScope () ) ;
checkArgument ( child.parent == null , STRING_CONSTANT , child , parent , this ) ;
passes . add ( createEmptyPass ( STRING_CONSTANT ) ) ;
public void testJSDocCopiedForClasses () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralMethods () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectLiteralShorthand () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testDefaultParameter () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition3 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition2 () { testScoped ( STRING_CONSTANT + STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testClassDefinition1 () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testArrowFunction () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testNonTopLevelDestructuring () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testObjectDescructuringError2 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testObjectDescructuringError1 () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testDestructuringError () { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testScopedError ( STRING_CONSTANT , ScopedAliases.GOOG_SCOPE_NON_ALIAS_LOCAL ) ; }
public void testYieldExpression () { testScoped ( STRING_CONSTANT , SCOPE_NAMESPACE + STRING_CONSTANT , LanguageMode.ECMASCRIPT_2015 ) ; }
public void testInlineEmptyFunction6 () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , Lists . newArrayList ( fooFunction , barFunction , bazFunction ) , callback , callback , false ) ;
testSame ( STRING_CONSTANT + STRING_CONSTANT ) ;
public void testMakeLocalNamesUniqueWithContext10 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testMakeLocalNamesUniqueWithContext9 () { this . useDefaultRenamer = true ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
if ( NodeUtil . isBleedingFunctionName ( n ) ) { renameBleedingFunctionName ( n ) ; }
{ newNode = IR . assign ( getprop , rhs . cloneNode () ) ; }
{ FunctionType getterType = typeRegistry . createFunctionType ( objectType ) ; codingConvention . applySingletonGetterOld ( functionType , getterType , objectType ) ; }
if ( superCtor != null && subCtor != null ) { codingConvention . applySubclassRelationship ( superCtor , subCtor , relationship.type ) ; }
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , false , STRING_CONSTANT ) ) ;
when ( mockCompiler . compile ( FOO_JS , STRING_CONSTANT ) ) . thenReturn ( new BaseTranspiler.CompileResult ( STRING_CONSTANT , NO_ERRORS , true , STRING_CONSTANT ) ) ;
inFunction ( STRING_CONSTANT , STRING_CONSTANT ) ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ replacement = replacement . useSourceInfoIfMissingFrom ( node ) ; node . replaceWith ( replacement ) ; reportCodeChange () ; }
{ Node replacement = measuredNodeReplacement . applyTo ( original ) ; reportCodeChange () ; return replacement ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
this . reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . removeChild ( right ) ; parent . replaceChild ( n , right ) ; reportCodeChange () ; return right ; }
{ NodeUtil . redeclareVarsInsideBranch ( caseNode ) ; switchNode . removeChild ( caseNode ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
{ maybeBreak . detach () ; reportCodeChange () ; }
reportCodeChange () ;
{ subtree . replaceWith ( right . detach () ) ; reportCodeChange () ; return right ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
{ n . replaceChild ( child , IR . number ( NUMBER_CONSTANT ) ) ; reportCodeChange () ; }
reportCodeChange () ;
if ( codeChanged ) { reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
if ( newLiteralNode != null ) { n . replaceWith ( newLiteralNode ) ; reportCodeChange () ; return newLiteralNode ; }
{ n . setToken ( Token.CALL ) ; n . putBooleanProp ( Node.FREE_CALL , true ) ; reportCodeChange () ; }
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
reportCodeChange () ;
compileFilesError ( SourceFile.DUPLICATE_ZIP_CONTENTS , zipFile1 , zipFile2 ) ;
if ( options.j2clPassMode . equals ( CompilerOptions.J2clPassMode.AUTO ) ) { checks . add ( j2clSourceFileChecker ) ; }
j2clPassMode = J2clPassMode.OFF ;
checkState ( child.parent == this , STRING_CONSTANT , child , parent ) ;
checkState ( child.parent == this ) ;
assertThat ( result.transpiled ) . isFalse () ;
assertThat ( result.transpiled ) . isTrue () ;
{ MockitoAnnotations . initMocks ( this ) ; transpiler = new Transpiler ( mockCompiler , STRING_CONSTANT ) ; compiler = new Transpiler.CompilerSupplier () ; }
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
Files . asCharSink ( jsFile , Charsets.UTF_8 ) . write ( code ) ;
{ this . def = def ; this . use = use ; }
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false ) ) ; }
inFunction ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ;
AnalyzePrototypeProperties analyzer = new AnalyzePrototypeProperties ( compiler , null , canModifyExterns , anchorUnusedVars ) ;
this . analyzer = new AnalyzePrototypeProperties ( compiler , moduleGraph , canModifyExterns , false ) ;
compilationLevelParsed = COMPILATION_LEVEL_MAP . get ( Ascii . toUpperCase ( compilationLevel ) ) ;
if ( cacheEntry.input == null ) { cacheEntry.input = new CompilerInput ( source ) ; }
boolean transformed = ! result.transpiledFiles . isEmpty () ;
@ Override public FeatureSet featureSet () { return ES8 ; }
public void testInlineIntoNestedNonHoistedNamedFunctions () { setAcceptedLanguage ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
jsDoc != null && jsDoc . isConstant () && jsDoc . getType () == null
newNode . useSourceInfoWithoutLengthIfMissingFromForTree ( sourceInfoNode ) ;
expr . useSourceInfoWithoutLengthIfMissingFromForTree ( parent ) ;
checkState ( n . isFunction () || n . isClass () ) ;
boolean shouldAmbiguateProperties () { return this . ambiguateProperties ; }
boolean shouldDisambiguateProperties () { return this . disambiguateProperties ; }
boolean shouldInlineProperties () { return inlineProperties ; }
{ return new Es6RewriteClass ( compiler ) ; }
decl . maybeRemoveRhs ( compiler ) ;
public void testFor () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
n . isForIn ()
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
typeCheck ( CLOSURE_DEFS + STRING_CONSTANT ) ;
typeCheck ( CLOSURE_BASE + STRING_CONSTANT ) ;
List < Node > replacements
@ Override public String toString () { return appendTo ( new StringBuilder () ) . toString () ; }
if ( hasReferenceName () ) { return sb . append ( getReferenceName () ) ; }
if ( ! isPrettyPrint () || this == registry . getNativeType ( JSTypeNative.FUNCTION_INSTANCE_TYPE ) ) { return sb . append ( STRING_CONSTANT ) ; }
{ checkArgument ( qnameNode . isQualifiedName () ) ; declarations . add ( PotentialDeclaration . from ( qnameNode , scope ) ) ; }
boolean isImport = rhs != null && isImportRhs ( rhs ) ;
this . mode = TypeInferenceMode.OTI_ONLY ;
public void testInherits6 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testInherits4 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits3 () { testSame ( STRING_CONSTANT ) ; }
public void testInherits2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLoggerOnObject3b () { this . mode = TypeInferenceMode.OTI_ONLY ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
! callClassType . isBottom () && ! callClassType . isUnknownType ()
if ( doSanityChecks && sourceFile != null ) { checkState ( sourceFile . equals ( n . getSourceFileName () ) ) ; }
if ( devMode ) { runSanityCheck () ; if ( hasErrors () ) { return null ; } }
maybeSanityCheck () ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new SanityCheck ( compiler ) ; }
if ( options.devMode == DevMode.EVERY_PASS ) { phaseOptimizer . setSanityCheck ( sanityCheck ) ; }
if ( options.devMode == DevMode.START_AND_END ) { runSanityCheck () ; }
! sanityCheck
{ declarationCheck = ! sanityCheck ; disableCompareAsTree () ; testExternChanges ( extern , input , expectedExtern ) ; }
sanityCheck = true ;
public void testViolatedModuleDependencyNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrictNotPromoted () { sanityCheck = true ; strictModuleDepErrorLevel = CheckLevel.ERROR ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
public void testViolatedModuleDependencySkipNonStrict () { sanityCheck = true ; testDependentModules ( STRING_CONSTANT , STRING_CONSTANT , null ) ; }
public void testMissingModuleDependencySkipNonStrict () { sanityCheck = true ; testIndependentModules ( STRING_CONSTANT , STRING_CONSTANT , null , null ) ; }
sanityCheck = false ;
@ Override public ObjectBuilder prototype () { return prototype ; }
@ Override public ObjectBuilder instance () { return instance ; }
@ Override public ObjectBuilder constructor () { return constructor ; }
convention . applySingletonGetter ( new NominalTypeBuilderNti ( lateProps , rawType ) , getInstanceType ) ;
new FunctionTypeBuilder ( getCommonTypes () ) . addReqFormal ( getCommonTypes () . getNativeType ( U2U_CONSTRUCTOR_TYPE ) )
testSame ( STRING_CONSTANT ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ reportBadGoogBaseUse ( t , n , STRING_CONSTANT ) ; }
{ compiler . report ( JSError . make ( node , INVALID_SUPER_CALL ) ) ; }
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
return bindComponents.thisValue == null ? null : simpleInferExprType ( bindComponents.thisValue ) ;
currentScope . isConstructor ()
JSType rhsType = simpleInferExprType ( rhs ) ;
JSType newPropType = rhs == null ? null : simpleInferExprType ( rhs ) ;
JSType recvType = simpleInferExprType ( recv ) ;
JSType t = initializer == null ? null : simpleInferExprType ( initializer ) ;
if ( initializer != null ) { inferredType = simpleInferExprType ( initializer ) ; }
JSType t = simpleInferExprType ( prop . getFirstChild () ) ;
checkState ( n . isName () , n ) ;
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this ) ; cjs . process ( null , root ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = ProcessCommonJSModules . getCommonJsImportPath ( require ) ;
{ this . compiler = compiler ; }
if ( STRING_CONSTANT . equals ( type . getDisplayName () ) ) { return true ; }
case REMOVE_RHS :
void markProvided ( String providedName ) { providedNamespaces . add ( providedName ) ; }
void markNameProcessed ( String fullyQualifiedName ) { seenNames . add ( fullyQualifiedName ) ; }
{ return new ObjectLiteralPropertyDefinition ( parent , n , n . getFirstChild () , isExtern ) ; }
List < Var > orderedVars = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT3 ) ; }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } , new String [] { STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( new String [] { STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT , } , new String [] { STRING_CONSTANT , STRING_CONSTANT } )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testModules ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( options.processCommonJSModules ) { ProcessCommonJSModules cjs = new ProcessCommonJSModules ( this , true ) ; cjs . process ( null , root ) ; }
testModules ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
String requireName = require . getSecondChild () . getString () ;
{ this ( compiler , true ) ; }
public void testDontPreserveUnknownTypeDeclarations () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
testWarning ( STRING_CONSTANT + STRING_CONSTANT , CheckConformance.CONFORMANCE_VIOLATION , STRING_CONSTANT ) ;
typeCheck ( LINE_JOINER . join ( FORWARD_DECLARATION_DEFINITIONS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( isUnknown () ) { return this ; }
checkArgument ( nameNode . isQualifiedName () ) ;
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . needsTranspilationOf ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
options . needsTranspilationFrom ( FeatureSet.ES6_MODULES ) || options.transformAMDToCJSModules || options.processCommonJSModules
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
PeepholeOptimizationsPass peepholePass = new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeMinimizeConditions ( late , useTypes ) ) ;
TernaryValue result = evaluateComparison ( n . getToken () , left , right , shouldUseTypes ) ;
Double rightValObj = NodeUtil . getNumberValue ( right , shouldUseTypes ) ;
Double result = NodeUtil . getNumberValue ( n , shouldUseTypes ) ;
new PeepholeMinimizeConditions ( late , false )
new PeepholeMinimizeConditions ( late , false )
caseMatches = PeepholeFoldConstants . evaluateComparison ( Token.SHEQ , cond , caseLabel , false ) ;
new PeepholeOptimizationsPass ( compiler , getName () , new PeepholeRemoveDeadCode () , new PeepholeMinimizeConditions ( true , false ) , new PeepholeFoldConstants ( true , false ) )
new PeepholeMinimizeConditions ( late , useTypesForOptimization )
optimizations . add ( new PeepholeMinimizeConditions ( late , useTypesForOptimization ) ) ;
Node n = parseError ( STRING_CONSTANT , STRING_CONSTANT ) ;
replacement . setJSType ( call . getJSType () ) ;
{ checkArgument ( boxedInfo.length == NUMBER_CONSTANT ) ; f1 . isSubtypeOfHelper ( f2 , true , subSuperMap , boxedInfo ) ; }
{ return isSubtypeOfHelper ( other , true , subSuperMap , null ) ; }
{ return isSubtypeOfHelper ( other , false , SubtypeCache . create () , null ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; disableCompareAsTree () ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
void process ( Node externs , Node root , ReferenceMap references ) ;
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testCallOrApply ( ) throws Exception { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
options . setEmitUseStrict ( emitUseStrict ) ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addDeadCodeElimination () ; addInlineVariables () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
passes = new LinkedList <> () ;
{ passes = new LinkedList <> () ; addInlineVariables () ; addPeephole () ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ messages = new LinkedList <> () ; mode = JsMessage.Style.LEGACY ; compilerOptions = null ; renameMessages = false ; }
return getTopObject () . getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
return superClass == null ? null : superClass . getPrototypePropertyOfCtor () ;
JSType proto = getNominalTypeIfSingletonObj () . getPrototypePropertyOfCtor () ;
checkState ( n . isCall () , n ) ;
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalStateException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( RuntimeException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( IllegalArgumentException e ) { assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
ref.scope . isGlobal ()
ref.scope . getClosestHoistScope () . isGlobal ()
try { compiler . compile ( EXTERNS , inputs , options ) ; } catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
Result result = compiler . compile ( EXTERNS , inputs , options ) ;
if ( type . contains ( STRING_CONSTANT ) ) { type = type . substring ( NUMBER_CONSTANT , type . lastIndexOf ( STRING_CONSTANT ) ) ; } else { return; }
String shortName = parent . getQualifiedName () . substring ( parent . getQualifiedName () . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
suffixes . add ( polyfillName . substring ( polyfillName . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replaceAll ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
Map < Node < E > , ImmutableSet.Builder < E > > groupsTmp = Maps . newLinkedHashMap () ;
Map < String , Integer > map = Maps . newHashMap () ;
NodeUtil . getLhsNodesOfDeclaration ( n )
NodeUtil . getLhsNodesOfDeclaration ( n )
NodeUtil . getLhsNodesOfDeclaration ( decl )
Iterable < Node > allVars = NodeUtil . getLhsNodesOfDeclaration ( n ) ;
names = NodeUtil . getLhsNodesOfDeclaration ( c ) ;
NodeUtil . getLhsNodesOfDeclaration ( paramList )
Preconditions . checkNotNull ( sideEffectInfo , STRING_CONSTANT , function ) ;
NodeUtil . getLhsNodesOfDeclaration ( varNode )
{ for ( Node lhs : NodeUtil . getLhsNodesOfDeclaration ( n ) ) { declareVar ( s , lhs ) ; } }
NodeUtil . getLhsNodesOfDeclaration ( declaration )
if ( NodeUtil . getLhsNodesOfDeclaration ( nameDecl ) . size () > NUMBER_CONSTANT ) { continue; }
ref.scope . isGlobal ()
public void failing_testLocalAliasWithLet3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void failing_testLocalAliasWithLet2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT3 ;
List < Var > orderedVars = new LinkedList <> () ;
List < Node > arrayFoldedChildren = new LinkedList <> () ;
Deque < ScriptDescription > scriptDescriptions = new LinkedList <> () ;
List < Node > newVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
List < Var > orderedVars = new LinkedList <> () ;
this . orderedVars = new LinkedList <> () ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
public void testCallOrApply ( ) throws Exception { testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testNoRewriteArrLit ( ) throws Exception { String source = newlineJoin ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( source ) ; }
public void testFunctionArgRemoval_defaultValue3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false , false ) ; }
void process ( Node externs , Node root , DefinitionUseSiteFinder definitions ) ;
languageIn = LanguageMode.ECMASCRIPT3 ;
public void testConst () { inFunction ( STRING_CONSTANT ) ; }
languageIn = LanguageMode.ECMASCRIPT_2017 ;
varify () ;
varify () ;
Node varName
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
checkLocalityOfMarkedCalls ( source , ImmutableList . < String > of () ) ;
assertFalse ( NodeUtil . evaluatesToLocalValue ( n ) ) ;
languageIn = LanguageMode.ECMASCRIPT3 ;
languageIn = LanguageMode.ECMASCRIPT_2017 ;
return STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + sourceName ;
String fullExportedName = currentScript . getBinaryNamespace () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () ) ;
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
if ( ! currentScript.isModule ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) ;
checkState ( currentScript.isModule , currentScript ) ;
if ( ! currentScript.isModule || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
languageIn = LanguageMode.ECMASCRIPT3 ;
if ( et != null && et . enumLiteralHasKey ( pname ) ) { return et . getEnumeratedType () ; }
{ type = locals . get ( name ) ; }
{ locals . put ( name , newDeclType ) ; }
String fullExportedName = currentScript . getBinaryNamespace () . get () + exportDefinition . getExportPostfix () ;
Node binaryNamespaceName = IR . name ( currentScript . getBinaryNamespace () . get () ) ;
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
if ( ! currentScript . isModule () ) { return; }
String exportedNamespace = rewriteState . getExportedNamespaceOrScript ( legacyNamespace ) . get () ;
checkState ( currentScript . isModule () , currentScript ) ;
if ( ! currentScript . isModule () || ! n . getString () . equals ( STRING_CONSTANT ) || ! isAssignTarget ( n ) ) { return; }
checkState ( n . isName () , n ) ;
finder . visitTree ( getAstRoot ( compiler ) ) ;
{ return STRING_CONSTANT + cls.target . getQualifiedName () . replace ( STRING_CONSTANT , STRING_CONSTANT ) + STRING_CONSTANT ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
statementNode . isVar ()
checkState ( declNode . isGetProp () ) ;
{ getGlobalScope () . addNamespaceLit ( qnameNode ) ; return true ; }
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
compilerOptions . setPreserveGoogProvidesAndRequires ( true ) ;
keyNode . isStringKey () || keyNode . isMemberFunctionDef ()
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
Node externsRoot = parse ( compiler , STRING_CONSTANT + STRING_CONSTANT ) ;
{ helperExposeExpression ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; helperExposeExpression ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
JSType jsdocType = symbolTable . getPropDeclaredType ( prop ) ;
pair.type = symbolTable . getCastType ( expr ) ;
JSType jsdocType = symbolTable . getPropDeclaredType ( prop ) ;
JSType toType = symbolTable . getCastType ( expr ) ;
visitNamespacePropertyDeclaration ( getProp , recv , pname ) ;
JSType propDeclType = getDeclaredObjLitProps () . get ( prop ) ;
return this . gti . getCastTypes () . get ( n ) ;
{ super . getOptions ( options ) ; options . setWarningLevel ( DiagnosticGroups.ANALYZER_CHECKS , CheckLevel.WARNING ) ; return options ; }
js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , js ) ;
String fileoverview = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT } ) ; }
{ testFunctionNamesAndIds ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , } ) ; }
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSets ( STRING_CONSTANT , js , output , STRING_CONSTANT , NewTypeInference.MISTYPED_ASSIGN_RHS , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEarlyReferenceError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; assertThat ( getLastCompiler () . injected ) . isEmpty () ; }
Node script = compiler . parseSyntheticCode ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT , STRING_CONSTANT , } ) ;
test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
{ test ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
test ( createModuleChain ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT } )
test ( createModuleStar ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) , new String [] { STRING_CONSTANT , STRING_CONSTANT } ) ;
test ( modules , new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testError ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , VarCheck.UNDEFINED_VAR_ERROR ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
{ String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ; assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ; }
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String source = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String externs = LINE_JOINER . join ( DEFAULT_EXTERNS , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = config ( rule ( STRING_CONSTANT ) , STRING_CONSTANT ) ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ configuration = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; testNoWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
new String [] { STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
testWarning ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , MISSING_RETURN_JSDOC ) ;
String localVar = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
fold ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
PolymerClassDefinition def = parseAndExtractClassDefFromCall ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
foldSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ;
String body = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testReference ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , false ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String googModule = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String legacyScript = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
testSame ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
t . inGlobalHoistScope () && ! NodeUtil . isFunctionExpression ( n )
Preconditions . checkState ( isFunctionExpression ( n ) ) ;
return checkForNewObjects || ! isFunctionExpression ( n ) ;
if ( isEs6ModuleRoot ( root ) ) { return true ; }
if ( FindModuleDependencies . isEs6ModuleRoot ( root ) ) { moduleType = ModuleType.ES6 ; }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) )
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
if ( NodeUtil . isFunctionExpression ( parent ) ) { break; }
{ FindStaticMembers findStaticMembers = new FindStaticMembers () ; TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ; processInherits ( findStaticMembers.inheritsCalls ) ; }
processInherits ( findStaticMembers.inheritsCalls ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
{ String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ; assertChangesRecorded ( code , new NameChangingCallback () ) ; }
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String code = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String src = LINE_JOINER . join ( lines ) ;
String src = LINE_JOINER . join ( lines ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
String js = LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
if ( ! fn . isFromExterns () ) { getScopes () . add ( fnScope ) ; }
typeCheck ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , NewTypeInference.NULLABLE_DEREFERENCE ) ;
node . useSourceInfoWithoutLengthIfMissingFromForTree ( basisNode ) ;
{ return new JSErrorSubject ( THROW_ASSERTION_ERROR , error ) ; }
{ return new NodeSubject ( THROW_ASSERTION_ERROR , node ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
TranspilationPasses . processTranspile ( compiler , scriptRoot , findStaticMembers ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
TranspilationPasses . processTranspile ( compiler , externs , this ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this , new SelfReferenceRewriter () ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapCheck ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processCheck ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , this ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , this ) ; }
{ if ( maybeExternMethod ( first ) ) { return DecompositionType.UNDECOMPOSABLE ; } else { return DecompositionType.DECOMPOSABLE ; } }
checkState ( allowObjectCallDecomposing () , STRING_CONSTANT ) ;
Node name = NodeUtil . newQName ( compiler , prototypeAlias + STRING_CONSTANT + declar.memberName , declar.node , declar.memberName ) ;
Node var = NodeUtil . newVarNode ( prototypeAlias , null ) . useSourceInfoIfMissingFromForTree ( injectionPoint ) ;
declNode . isAssign ()
{ NominalType nt = getNominalTypeIfSingletonObj () ; return nt . isLiteralObject () || nt . isBuiltinObject () ; }
boolean isPropertyRemovable ( String propertyName ) { return isEntirelyRemovable || unreferencedPropertiesMayBeRemoved && ! referencedPropertyNames . contains ( propertyName ) ; }
resultPair = analyzeCastFwd ( expr , inEnv , specializedType ) ;
Name superclassNameObj = getOrCreateName ( superclassName , false ) ;
abstract void verify ( Compiler compiler ) ;
currentArgumentsAccess = new LinkedList <> () ;
List < MemberDefinition > allProperties = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < SourceFile > files = new LinkedList <> () ;
List < String > entryPoints = new LinkedList <> () ;
cur = instance.declarations . getLast () . node ;
PrototypeMemberDeclaration first = instance.declarations . getFirst () ;
if ( lValue . isRest () ) { lValue = lValue . getFirstChild () ; }
VarInfo varInfo = getVarInfo ( classScope . getVar ( classNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( c , c ) ) ; }
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( var ) ;
VarInfo varInfo = getVarInfo ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = getVarInfo ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = getVarInfo ( scope . getVar ( exceptionNameNode . getString () ) ) ;
{ VarInfo varInfo = getVarInfo ( var ) ; varInfo . addRemovable ( new RemovableBuilder () . buildDestructuringAssign ( restNode , target ) ) ; }
VarInfo classVarInfo = getVarInfo ( classVar ) ;
Preconditions . checkState ( isCallOrNew ( invocation ) ) ;
Scope scope
Preconditions . checkState ( current . isGetProp () , STRING_CONSTANT , current ) ;
Preconditions . checkState ( current . isLabel () ) ;
Preconditions . checkState ( isControlStructure ( parent ) ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkState ( n . isClassMembers () || n . isObjectLit () ) ;
Preconditions . checkArgument ( callNode . isNew () , STRING_CONSTANT , callNode . getToken () ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
throw new IllegalStateException ( STRING_CONSTANT ) ;
checkState ( ! NodeUtil . isObjectLitKey ( n ) ) ;
boolean isMarkedConst = n . isConst () || ( jsdoc != null && jsdoc . isConstant () ) ;
Queue < Property > propertyQueue = new LinkedList <> ( propertiesSet ) ;
{ if ( n . isFunction () ) { break; } this . ancestors . add ( NUMBER_CONSTANT , n ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
assertPureCallsMarked ( source , ImmutableList . of ( STRING_CONSTANT ) ) ;
Var v
Node definitionRValue
isStaticCtorProp ( getProp , currentScope )
JSModule module
JSModule module
DefinitionProvider definitionProvider
if ( defs == null ) { return; }
@ VisibleForTesting Multimap < String , UseSite > getUseSitesByName () { return LinkedHashMultimap . create ( useSitesByName ) ; }
{ if ( inExterns ) { visitExterns ( traversal , node , parent ) ; } else { visitCode ( traversal , node ) ; } }
public void testAnnotationInExterns_new5 ( ) throws Exception { assertPureCallsMarked ( STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RemoveUnusedVars ( compiler , false , false ) ; }
new RemoveUnusedVars ( compiler , true , false ) . process ( externs , root ) ;
{ new RemoveUnusedVars ( compiler , removeGlobal , preserveFunctionExpressionNames ) . process ( externs , root ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames ) ;
{ visitScript ( t , n , parent ) ; }
assertThat ( packageJsonMainEntries ) . containsEntry ( STRING_CONSTANT , NodeModuleResolver.JSC_BROWSER_BLACKLISTED_MARKER ) ;
checkArgument ( fnNode . isFunction () ) ;
LinkedHashMap < String , Node > actualMap = FunctionArgumentInjector . getFunctionCallParameterMap ( fn , call , getNameSupplier () ) ;
public void testFindModifiedParameters12 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters2 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters1 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
public void testFindModifiedParameters0 () { assertThat ( FunctionArgumentInjector . findModifiedParameters ( parseFunction ( STRING_CONSTANT ) ) ) . isEmpty () ; }
Boolean replaceParent = true ;
tracer = new Tracer ( STRING_CONSTANT ) ;
{ if ( edgeAnnotationStack == null ) { edgeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( edgeAnnotationStack , getEdges () ) ; }
{ if ( nodeAnnotationStack == null ) { nodeAnnotationStack = new LinkedList <> () ; } pushAnnotations ( nodeAnnotationStack , getNodes () ) ; }
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < blockScope . getVarCount () + functionScope . getVarCount () ) { return; }
if ( LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysis.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; varInfo.unreferencedPropertiesMayBeRemoved = false ; }
exceptionVarInfo . setCannotRemoveAnything () ;
canonicalTotallyUnremovableVarInfo . setCannotRemoveAnything () ;
Set < String > namesToAlias
Set < String > needAliases
LinkedHashMap < String , Node > argMap
return LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE > orderedVars . size () ;
if ( LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE < t . getScope () . getVarCount () ) { return; }
i < LiveVariablesAnalysisEs6.MAX_VARIABLES_TO_ANALYZE + NUMBER_CONSTANT
if ( ! n . isVar () ) { return; }
parent . isVar () && nameNode . hasOneChild ()
parent . isVar ()
removeUnusedProperties && r . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( r . getPropertyName () )
removeUnusedProperties && removable . isNamedPropertyAssignment () && ! referencedPropertyNames . contains ( removable . getPropertyName () )
! n . isString () && ! isConstantNameNode ( n , knownConstants )
if ( rValue == null || ! rValue . isFunction () || NodeUtil . isVarArgsFunction ( rValue ) ) { return false ; }
if ( NodeUtil . isVarArgsFunction ( fnc ) ) { return false ; }
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope , escaped , compiler , scopeCreator ) ;
computeEscapedEs6 ( jsScope . getParent () , escaped , compiler , scopeCreator ) ;
isConstructorCall ( expr )
private Scope newScope () { return Scope . createGlobalScope ( new Node ( Token.SCRIPT ) ) ; }
@ Override public void setUp () { allowMethodCallDecomposing = false ; }
{ test ( createCompilerOptions () , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
testModules ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
public void testES6Modules () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testB3473189 () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
BlackHoleErrorManager . silence ( compiler ) ;
String classAndItsMethodAliasedAsExtern = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String getPropertyName () { checkState ( isNamedPropertyAssignment () ) ; return checkNotNull ( propertyName ) ; }
if ( toRemove . isParamList () ) {} else { throw new IllegalStateException ( STRING_CONSTANT ) ; }
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
assertTrue ( options.collapseProperties ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options.collapseProperties ; }
@ Override public FeatureSet featureSet () { return ES5 ; }
return ! n . getFirstChild () . isVar () ;
public void testNoGlobalSchopeChanges () { testSame ( STRING_CONSTANT ) ; }
return new RemoveUnusedVars ( compiler , ! removeOnlyLocals , preserveAnonymousFunctionNames , false ) ;
( getTypeDeprecationInfo ( t . getTypedScope () . getTypeOfThis () ) != null )
TypedVar var
TypedVar var
@ Override boolean isMethodDeclaration () { return true ; }
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isMethodDeclaration () ; }
boolean isMethodDeclaration () { return false ; }
isGlobal && ! removeGlobals && ! removeUnusedProperties
removeUnusedProperties && removable . isNamedProperty ()
if ( removeUnusedProperties ) { removeUnreferencedProperties () ; }
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedVars () ) ; }
{ passes . add ( flowSensitiveInlineVariables ) ; if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( lastRemoveUnusedVars () ) ; } }
new RemoveUnusedVars.Builder ( compiler ) . removeGlobals ( true ) . build () . process ( externs , root ) ;
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( getRemoveUnusedCode () ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new RewriteGlobalFunctionStatementsToVarAssignmentsCallback () ) ;
new SimpleDependencyInfo.Builder ( closureRelativePath , filePath ) . setProvides ( provides ) . setRequires ( requires ) . setWeakRequires ( weakRequires ) . setLoadFlags ( loadFlags ) . build ()
if ( options.removeUnusedVars || options.removeUnusedLocalVars ) { passes . add ( removeUnusedCode ) ; }
atLeast8 = mode == Mode.ES8_OR_GREATER ;
ImmutableCollection < String > getWeakRequires ( ) ;
Collection < String > getRequires ( ) ;
Collection < String > getProvides ( ) ;
public void testDefaultParam_argIsUnknown () { testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testDefaultParam_argIsUndefined () { test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void disabled_testArrayPatternParam () { testSame ( STRING_CONSTANT ) ; }
visitParamList ( t , n , parent ) ;
Annotation annotation = annotationNames . get ( annotationName ) ;
config.languageMode != LanguageMode.TYPESCRIPT
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( SETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . error ( GETTER_ERROR_MESSAGE , sourceName , lineno ( node ) , NUMBER_CONSTANT ) ; return true ; }
if ( config.languageMode == LanguageMode.ECMASCRIPT3 ) { errorReporter . warning ( INVALID_ES3_PROP_NAME , sourceName , node . getLineno () , node . getCharno () ) ; }
{ checkState ( config.keepGoing == Config.RunMode.KEEP_GOING ) ; bodyNode = IR . block () ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
CollapseProperties collapseProperties = new CollapseProperties ( compiler ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new CollapseProperties ( compiler ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
options . setCollapseProperties ( true ) ;
@ Override public void apply ( CompilerOptions options , boolean value ) { options . setCollapseProperties ( value ) ; }
if ( p != null && ! p . canCollapse () ) { continue; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
if ( ! canCollapseChildNames || ! n . canCollapse () ) { return; }
isObjLit && n . canEliminate ()
isObjLit && n . canEliminate ()
if ( n . canCollapse () ) { updateGlobalNameDeclaration ( n , alias , canCollapseChildNames ) ; }
new CollapseProperties ( compiler ) . process ( externs , js ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new CollapseProperties ( compiler ) ; }
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
options . setCollapseProperties ( true ) ;
collapseProperties = false ;
if ( shouldRunRemoveUnusedCode () ) { passes . add ( removeUnusedCode ) ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . removeLocalVars ( true ) . build () ; }
if ( parent . isVar () || parent . isFunction () ) { return true ; }
{ return new RemoveUnusedCode.Builder ( compiler ) . build () ; }
if ( options.removeUnusedPrototypeProperties ) { passes . add ( removeUnusedPrototypeProperties ) ; }
{ options . setCollapsePropertiesLevel ( PropertyCollapseLevel.ALL ) ; }
for ( String filename : files ) { if ( fix ) { fix ( filename ) ; } else { lint ( filename ) ; } }
passes . add ( extraSmartNamePass ) ;
String qualifiedName = aliasVar . getInitialValue () . getQualifiedName () ;
String aliasExpanded = checkNotNull ( aliasDefinition . getQualifiedName () ) ;
allowGlobalFunctionInlining = false ;
public void testLocalFunctionInliningOnly4 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly3 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testLocalFunctionInliningOnly2 () { this . allowGlobalFunctionInlining = false ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
allowGlobalFunctionInlining = true ;
{ options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_NEXT ) ; options . setLanguageOut ( value ? CompilerOptions.LanguageMode.ECMASCRIPT5 : CompilerOptions.LanguageMode.NO_TRANSPILE ) ; }
boolean includesGlobals () { return this == ALL ; }
addToDebugLog ( STRING_CONSTANT + file . getName () ) ;
checkState ( NodeUtil . isAssignmentOp ( assignNode ) ) ;
Node superClassNameNode = NodeUtil . newQName ( compiler , superClassString ) . useSourceInfoIfMissingFrom ( metadata.superClassNameNode ) ;
VarInfo varInfo = traverseVar ( classScope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( classNameNode . getString () ) ) ;
VarInfo varInfo = traverseVar ( checkNotNull ( scope . getVar ( nameNode . getString () ) ) ) ;
VarInfo varInfo = traverseVar ( scope . getVar ( nameNode . getString () ) ) ;
VarInfo exceptionVarInfo = traverseVar ( scope . getVar ( exceptionNameNode . getString () ) ) ;
testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
public void testIssue618_2 () { this . removeGlobal = false ; testSame ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
rhs == null || isTypedRhs ( rhs ) || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) || isImportRhs ( rhs )
getAllSymbolsSorted ()
public Iterable < Symbol > getAllSymbols () { return Collections . unmodifiableCollection ( symbols . values () ) ; }
foldSame ( STRING_CONSTANT ) ;
getAllSymbolsSorted ()
getAllSymbolsSorted ()
if ( ! key . hasChildren () ) { maybeWarn = true ; }
if ( node . isStringKey () && ! node . hasChildren () ) { t . report ( node , SHORTHAND_ASSIGNMENT_IN_ENUM ) ; }
if ( parent . isObjectPattern () ) { return ! ( n . isStringKey () && n . hasChildren () ) ; }
{ validateObjectLitStringKey ( c ) ; }
passes . add ( removeUnusedCodeOnce ) ;
options . setInlineFunctions ( false ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
options . setInlineFunctions ( true ) ;
{ this . inlineFunctions = inlineFunctions ; }
Iterables . addAll ( allSymbols , table . getAllSymbols () ) ;
boolean isIndependentlyRemovableNamedProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
if ( isClassMemberFunction ( functionNode ) ) { return STRING_CONSTANT . equals ( functionNode . getParent () . getString () ) ; }
isClassMemberFunction ( functionNode )
{ if ( isImport ) { currentFile . recordImport ( name . getString () ) ; } else { currentFile . recordDeclaration ( name , t . getScope () ) ; } }
String name = ConvertToTypedInterface . getPrototypeNameOfMethod ( functionNode ) ;
if ( isConstructor ( n ) && n . getLastChild () . hasChildren () ) { currentFile . markConstructorToProcess ( n ) ; }
newJsdoc == null && isThisProp ( nameNode )
if ( isClassMethod ( n ) ) { currentFile . recordMethod ( n , t . getScope () ) ; }
! isConstructor ( n )
{ if ( isTypeCompatible ( receiverType , method.type ) ) { unusedMethodPolyfills . remove ( method ) ; } }
checkArgument ( functionNode . isFunction () ) ;
private boolean isAssignmentToPrototype ( Node n ) { return n . isAssign () && isPrototypeGetProp ( n . getFirstChild () ) ; }
long nodeCount = graph . getNodes () . size () ;
checkState ( n . isName () || n . isStringKey () || n . isImportStar () , STRING_CONSTANT , n ) ;
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
if ( NodeUtil . isAssignmentTarget ( n ) ) { return n ; }
boolean isPrototypeProperty () { return isPrototypeObjectNamedPropertyAssignment () || isClassOrPrototypeNamedProperty () ; }
removeUnusedThisProperties && removable . isThisNamedPropertyAssignment ()
RemovableBuilder builder = new RemovableBuilder () . setIsThisNamedPropertyAssignment ( true ) ;
{ fsCalled . setRemove ( false ) ; if ( ! minimizeCost ( fsCalled ) ) { fsCalled . setInline ( false ) ; } }
{ Node rootNode = scopeRoots . get ( i - NUMBER_CONSTANT ) ; if ( Scope . isHoistScopeRootNode ( rootNode ) ) { return rootNode ; } }
public boolean isHoistScope () { return Scope . isHoistScopeRootNode ( getScopeRoot () ) ; }
checkState ( ( NodeUtil . isNameDeclaration ( parent ) && var.scope . isGlobal () ) || NodeUtil . isFunctionDeclaration ( parent ) ) ;
if ( aliasVar != null ) { return aliasVar.scope . isGlobal () ; }
Node name = importSpec . getFirstChild () ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
validateChildCountIn ( n , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Builder removeUnusedConstructorProperties ( boolean value ) { this . removeUnusedConstructorProperties = value ; return this ; }
this . removeUnusedConstructorProperties = builder.removeUnusedConstructorProperties ;
test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) )
Scope s = getScope () ;
refinedScope != null && getScope () != refinedScope
checkState ( name != null && ! name . isEmpty () ) ;
String name = ClassUtil . getPrototypeNameOfMethod ( functionNode ) ;
NodeUtil . deleteNode ( getStatement () , compiler ) ;
Node oldStatement = getStatement () ;
Node getStatement () { return NodeUtil . getEnclosingStatement ( lhs ) ; }
@ Override public boolean hasReferenceName () { return referencedObjType == null ? null : referencedObjType . hasReferenceName () ; }
passes . add ( extraSmartNamePass ) ;
testModules ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
new String [] { CompilerTestCase.LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT }
new String [] { LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( incOrDecNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( incOrDecNode ) ; }
if ( NodeUtil . mayHaveSideEffects ( objExpression ) ) { replaceExpressionWith ( referenceNode , objExpression . detach () ) ; } else { removeExpressionCompletely ( referenceNode ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Arguments ( Scope scope ) { super ( STRING_CONSTANT , null , scope , - NUMBER_CONSTANT , null ) ; }
@ Override public TypedScope getScope ( TypedVar var ) { return var.scope ; }
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator creator = new Es6SyntacticScopeCreator ( compiler ) ;
{ scope . declare ( name , n , input ) ; }
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Scope s
private void pushScope ( Scope s ) { pushScope ( s , false ) ; }
Scope refinedScope
Scope scope
Scope s
Scope hoistedScope = t . getClosestHoistScope () ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
ScopeCreator scopeCreator = new Es6SyntacticScopeCreator ( compiler ) ;
Var var = new Var ( name , nameNode , this , vars . size () , input ) ;
Scope parent
ScopeCreator scopeCreator = createScopeCreator () ;
Scope parent
test ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ return new FeatureSet ( Sets . union ( features , other.features ) ) ; }
public FeatureSet withoutTypes () { return new FeatureSet ( Sets . difference ( features , LangVersion.TYPESCRIPT . features () ) ) ; }
private FeatureSet ( Set < Feature > features ) { this . features = ImmutableSet . copyOf ( features ) ; }
{ test ( STRING_CONSTANT , STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
test ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
! scope . isDeclared ( name , false ) && ! ( scope . isLocal () && name . equals ( ARGUMENTS ) )
if ( STRING_CONSTANT . equals ( name ) && NodeUtil . isVanillaFunction ( scope . getRootNode () ) ) { return scope . getArgumentsVar () ; }
public S getScope () { return scope ; }
if ( ! isFunctionScope () || rootNode . isArrowFunction () ) { return parent . getArgumentsVar () ; }
@ Override public TypedScope getScope ( TypedVar var ) { return ( TypedScope ) var.scope ; }
optimizations . add ( new MinimizeExitPoints ( compiler ) ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , null , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
assertChanges ( externs , originalCode , expectedCode , template ) ;
assertChanges ( STRING_CONSTANT , originalCode , expectedCode , template ) ;
public void clearTemplates () { templates = null ; matchedTemplate = null ; }
checkNotNull ( funType ) ;
if ( ProcessCommonJSModules . isCommonJsImport ( n ) ) { visitRequireCall ( t , n , parent ) ; }
this . moduleLoader = new ModuleLoader ( null , options.moduleRoots , inputs , ModuleLoader.PathResolver.RELATIVE , options.moduleResolutionMode , null ) ;
options . setModuleResolutionMode ( ModuleLoader.ResolutionMode.NODE ) ;
public JsonFileSpec ( String src , String path ) { this ( src , path , null ) ; }
if ( var . getParentNode () . isParamList () ) { varInfo.propertyAssignmentsWillPreventRemoval = true ; }
catch ( RuntimeException e ) { fail ( STRING_CONSTANT ) ; }
@ Override public boolean preventsRemovalOfVariableWithNonLocalOrNonLiteralValueOrPrototype () { return true ; }
fold ( STRING_CONSTANT , STRING_CONSTANT ) ;
public void testNewOperatior3 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior2 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testNewOperatior1 () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
return getLeastSupertype ( this , that ) ;
checkState ( n . hasOneChild () ) ;
Node newDeclaration = IR . declaration ( lhsToSplit . detach () , rhs , n . getToken () ) . srcref ( n ) ;
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2017 ) ;
Map < String , TypeI > props = new HashMap <> () ;
checkState ( mayBeStatement ( stmt ) ) ;
NameDeclarationStatement removable = builder . setAssignedValue ( valueNode ) . buildNameDeclarationStatement ( declarationStatement ) ;
( parent . isForIn () )
if ( grandparent != null && grandparent . isVar () ) { return false ; }
public void testLoggerMethodCallByVariableType () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
ParseTree right = parseUnaryExpression () ;
return findModifiedParameters ( fnNode . getLastChild () , null , names , unsafeNames , false ) ;
public void testDirectPrototypeAssignment2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testPropertyInference6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getErrorManager () . report ( CheckLevel.ERROR , JSError . make ( AbstractCompiler.READ_ERROR , getName () ) ) ; return SimpleDependencyInfo.EMPTY ; }
catch ( IOException e ) { compiler . report ( JSError . make ( AbstractCompiler.READ_ERROR , sourceFile . getName () ) ) ; }
boolean allowDupe = VarCheck . hasDuplicateDeclarationSuppression ( referenceNode , v ) ;
{ testClosureTypesMultipleWarnings ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , ImmutableList . of ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ) ; }
public void testMissingProperty30 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , TypeMatchingStrategy.LOOSE ) ;
return fnThisType . isUnknownType () ? null : fnThisType . toObjectType () ;
IR . string ( modulePath . toString () )
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new CheckMissingSuper ( compiler ) ; }
checks . add ( checkMissingSuper ) ;
passes . add ( checkMissingSuper ) ;
{ visitInterfaceGetprop ( t , assign , object , pname , lvalue , rvalue ) ; }
visitGetProp ( t , n , parent ) ;
checkArgument ( scriptNode . isScript () ) ;
{ Node enclosingNode = NodeUtil . getEnclosingNode ( n , loopPredicate ) ; return enclosingNode != null && ! enclosingNode . isFunction () ; }
{ return new Es6RewriteClass ( compiler , ! compiler . getOptions () . inIncrementalCheckMode () ) ; }
assertTypeEquals ( typeRegistry . getNativeType ( JSTypeNative.BOOLEAN_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
suppressors . put ( STRING_CONSTANT , new DiagnosticGroupWarningsGuard ( new DiagnosticGroup ( DiagnosticGroups.CHECK_TYPES , DiagnosticGroups.STRICT_MISSING_PROPERTIES ) , CheckLevel.OFF ) ) ;
if ( ! rewriteState . containsModule ( legacyNamespace ) ) { unrecognizedRequires . add ( new UnrecognizedRequire ( call , legacyNamespace , false , false ) ) ; }
public boolean inIncrementalCheckMode () { return incrementalCheckMode != IncrementalCheckMode.OFF ; }
Node originalFunction = functionContext.function . get () ;
{ for ( PotentialDeclaration decl : currentFile . getDeclarations () . get ( name ) ) { processDeclaration ( decl ) ; } }
if ( getRhs () == null ) { return; }
if ( ! isConstToBeInferred ( originalJsdoc , nameNode ) ) { return; }
boolean isImport = isImportRhs ( rhs ) ;
lhsToSplit . isDestructuringLhs () && ! isImportRhs ( lhsToSplit . getLastChild () )
isConstToBeInferred ( jsdoc , nameNode ) && ! nameNode . isFromExterns () && ! JsdocUtil . isPrivate ( jsdoc )
jsdoc == null || ! jsdoc . containsDeclaration () || ConvertToTypedInterface . isConstToBeInferred ( jsdoc , jsdocNode )
checkState ( caseBody . isNormalBlock () ) ;
checkState ( first . getString () . isEmpty () ) ;
public void testIssue2508576_1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testClassExtern () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern2 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
public void testObjectLitExtern1 () { String externs = STRING_CONSTANT ; testSame ( externs , STRING_CONSTANT ) ; }
testSame ( CompilerTypeTestCase.DEFAULT_EXTERNS , STRING_CONSTANT ) ;
testSame ( SHARED_EXTERNS , js ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( externs , js ) ;
testSame ( METHOD_DEFS , STRING_CONSTANT ) ;
testSame ( externs , code ) ;
testSame ( externs , code ) ;
{ testSame ( externs , source ) ; assertEquals ( expected , found ) ; found . clear () ; }
tester . testSame ( STRING_CONSTANT , STRING_CONSTANT ) ;
testSame ( ALL_NATIVE_EXTERN_TYPES , STRING_CONSTANT ) ;
testSame ( externs , STRING_CONSTANT ) ;
testSame ( externs , js ) ;
testSame ( externs , code ) ;
testSame ( EXTERNS , STRING_CONSTANT ) ;
private void testSameEs6Strict ( String js ) { setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; testSame ( js , js ) ; }
testTypes ( LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
String externs = DEFAULT_EXTERNS . replace ( STRING_CONSTANT , LINE_JOINER . join ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
Map < String , StaticTypedSlot < JSType > > slots = new LinkedHashMap <> () ;
parent . isVar ()
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil : : isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil : : isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil : : isNameDeclaration ) ;
add ( first . getNext () ) ;
public void testFindExpressionRoot5 () { assertThat ( findExpressionRoot ( STRING_CONSTANT , STRING_CONSTANT ) ) . isNull () ; }
{ return null ; }
{ return ! isStringifiable ( templatizedType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; } else { return FALSE ; }
{ registerMismatchAndReport ( n , INVALID_OPERAND_TYPE , msg , type , getNativeType ( NUMBER_TYPE ) , null , null ) ; }
this . allValueTypes = typeRegistry . createUnionType ( STRING_TYPE , NUMBER_TYPE , BOOLEAN_TYPE , NULL_TYPE , VOID_TYPE ) ;
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
{ input . addOrderedRequire ( require ) ; }
public abstract Builder setRequires ( Collection < String > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
rootInput . getRequires ()
userOrderedInput . getRequires ()
input . getRequires ()
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
public void testGithubIssue2818 () { noInline ( STRING_CONSTANT ) ; noInline ( STRING_CONSTANT ) ; inline ( STRING_CONSTANT , STRING_CONSTANT ) ; }
testError ( srcs ( js ) , error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT ) ) ;
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
error ( BAD_PRIVATE_PROPERTY_ACCESS , STRING_CONSTANT )
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_FOR_GOOG_SCOPE , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_WARNING , warningText ) ) ; }
{ testSame ( srcs ( js ) , warning ( MISSING_REQUIRE_STRICT_WARNING , warningText ) ) ; }
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
testError ( srcs ( js ) , error ( VarCheck.VAR_MULTIPLY_DECLARED_ERROR , message ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , expected ( expected ) , warning ( warning , description ) ) ;
test ( externs ( externs ) , srcs ( STRING_CONSTANT ) , expected ( STRING_CONSTANT ) , warning ( e , STRING_CONSTANT + STRING_CONSTANT ) ) ;
{ assertNotNull ( warning ) ; test ( externs ( externs ) , srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( inputs ) , warning ( warning , description ) ) ; }
{ assertNotNull ( warning ) ; test ( srcs ( js ) , warning ( warning , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( inputs ) , error ( error , description ) ) ; }
{ assertNotNull ( error ) ; test ( srcs ( js ) , error ( error , description ) ) ; }
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
testWarning ( srcs ( js ) , warning ( MISSING_PROVIDE_WARNING , warning ) ) ;
public abstract Builder setRequires ( Collection < Require > requires ) ;
public void addRequire ( Require require ) { extraRequires . add ( require ) ; }
Require require
allDeps . addAll ( input . getRequiredSymbols () ) ;
input . getKnownRequiredSymbols ()
rootInput . getRequiredSymbols ()
requires . addAll ( deps . getRequiredSymbols () ) ;
for ( String require : dependency . getRequiredSymbols () ) { addDependency ( require , seen , list ) ; }
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) ) )
ImmutableList . of ( googRequireSymbol ( STRING_CONSTANT ) , googRequireSymbol ( STRING_CONSTANT ) )
writeJsArray ( out , Require . asSymbolList ( info . getRequires () ) ) ;
ImmutableList < Require > getRequires ( ) ;
userOrderedInput . getRequiredSymbols ()
input . getRequiredSymbols ()
{ input . addOrderedRequire ( Require . compilerModule ( require ) ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( checks ) ; }
if ( options . getLanguageIn () . toFeatureSet () . has ( FeatureSet.Feature.MODULES ) ) { TranspilationPasses . addEs6ModulePass ( passes ) ; }
n . putBooleanProp ( Node.GOOG_MODULE_ALIAS , true ) ;
TranspilationPasses . addEs6ModulePass ( factories ) ;
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler ) ; }
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
inline ( STRING_CONSTANT , STRING_CONSTANT ) ;
for ( TemplateType ignore : obj . getTemplateTypeMap () . getTemplateKeys () ) { unknowns . add ( getNativeType ( UNKNOWN_TYPE ) ) ; }
public void testIssue70b () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
public void testIssue70a () { args . add ( STRING_CONSTANT ) ; test ( STRING_CONSTANT , RhinoErrorReporter.ES6_FEATURE ) ; }
options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ;
rewriteGeneratorBody ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( node . hasChildren () && node . getLastChild () . isString () ) { info.importedModules . add ( node . getLastChild () . getString () ) ; }
MemoizedTypedScopeCreator typedScopeCreator = getTypedScopeCreator () ;
scopeCreator = new MemoizedTypedScopeCreator ( new TypedScopeCreator ( compiler ) ) ;
MemoizedTypedScopeCreator scopeCreator
MemoizedTypedScopeCreator getTypedScopeCreator () { return typedScopeCreator ; }
MemoizedTypedScopeCreator scopeCreator
public abstract Builder setRequires ( Collection < String > requires ) ;
SimpleDependencyInfo . builder ( CLOSURE_PATH , SRC_PATH ) . setProvides ( ImmutableList . of ( STRING_CONSTANT ) ) . setRequires ( ImmutableList . of ( STRING_CONSTANT ) )
ImmutableList . of ( STRING_CONSTANT , STRING_CONSTANT )
userOrderedInput . getRequires ()
input . getRequires ()
rootInput . getRequires ()
requires . addAll ( deps . getRequires () ) ;
for ( String require : dependency . getRequires () ) { addDependency ( require , seen , list ) ; }
writeJsArray ( out , info . getRequires () ) ;
ImmutableList < String > getRequires ( ) ;
public void addRequire ( String require ) { extraRequires . add ( require ) ; }
String require
{ input . addOrderedRequire ( require ) ; }
allDeps . addAll ( input . getRequires () ) ;
input . getKnownRequires ()
public boolean shouldPreservesGoogProvidesAndRequires () { return this . preserveClosurePrimitives || this . shouldGenerateTypedExterns () ; }
inline ( lines ( STRING_CONSTANT ) , lines ( STRING_CONSTANT ) ) ;
public void testNoInlineGetEle () { noInline ( STRING_CONSTANT ) ; }
public void testNoInlineGetProp () { noInline ( STRING_CONSTANT ) ; }
@ Override public StaticTypedScope < JSType > getParentScope () { return getFunctionScope () . getParentScope () ; }
Scope usageScope
List < String > provides = Lists . newArrayList ( depInfo . getProvides () ) ;
this . nullOrUndefined = typeRegistry . createUnionType ( NULL_TYPE , VOID_TYPE ) ;
{ return testForEquality ( that ) . equals ( UNKNOWN ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ; testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.OFF ) ;
rewriteGeneratorBodyWithVars ( STRING_CONSTANT , STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
context . writeGeneratedNode ( IR . ifNode ( condition , context . createJumpToBlock ( startCase , n ) ) . useSourceInfoFrom ( n ) ) ;
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
IR . ifNode ( IR . not ( condition ) . useSourceInfoFrom ( condition ) , context . createJumpToBlock ( endCase , n ) ) . useSourceInfoFrom ( n )
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( passes ) ; passes . add ( setFeatureSet ( ES8 ) ) ; }
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
parseWarning ( STRING_CONSTANT , getRequiresEsNextMessage ( Feature.OBJECT_PATTERN_REST ) ) ;
if ( options . needsTranspilationFrom ( ES_NEXT ) ) { TranspilationPasses . addEs2018Passes ( checks ) ; checks . add ( setFeatureSet ( ES8 ) ) ; }
return rhs . isQualifiedName () || NodeUtil . isCallTo ( rhs , STRING_CONSTANT ) ;
if ( replacements . isEmpty () ) { return STRING_CONSTANT ; }
allJsDocParams = ( info == null ) ? new HashSet < String > () : new HashSet <> ( info . getParameterNames () )
JSType type = typeRegistry . getType ( dottedName ) ;
JSType type = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ return metadata . getCompiler () . getTypeRegistry () . getType ( type ) ; }
TypeI mathType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ return registry . getType ( typeName ) ; }
domHelperType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getType ( STRING_CONSTANT ) ; }
TypeI methodClassType = registry . getType ( r.type ) ;
TypeI typeWithBannedProp = registry . getType ( prop.type ) ;
{ TypeI type = registry . getType ( typeName ) ; if ( type != null ) { types . add ( type ) ; } }
TypeI methodClassType = registry . getType ( className ) ;
Scope scope = t . getScope () ;
TranspilationPasses . addEs6Passes ( passes ) ;
Predicates . < Node > alwaysTrue ()
ImmutableList.Builder < Callback > callbacks = ImmutableList . < Callback > builder () ;
parent . isAssign () && parent . getFirstChild () == getProp && parent . getFirstChild () . getLastChild () . getString () . equals ( STRING_CONSTANT )
parent . isAssign () && parent . getFirstChild () == getProp && getProp . getLastChild () . getString () . equals ( STRING_CONSTANT )
{ Node declNode = NodeUtil . getEnclosingNode ( coalescedName . getParentNode () , NodeUtil.isNameDeclaration ) ; declNode . setToken ( Token.VAR ) ; }
Node var = NodeUtil . getEnclosingNode ( name , NodeUtil.isNameDeclaration ) ;
Node nameDecl = NodeUtil . getEnclosingNode ( v . getNode () , NodeUtil.isNameDeclaration ) ;
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( choices - > choices . getAlternatives () . get ( choiceIndex ) )
StreamSupport . stream ( fixChoices . spliterator () , false ) . map ( f - > f . getAlternatives () . size () )
newVar = scopeToDeclareIn . declare ( variableName , n , type , input , inferred ) ;
if ( Keywords . isKeyword ( importedName.value ) ) { reportError ( importedName , STRING_CONSTANT , importedName.value ) ; }
if ( Keywords . isKeyword ( importedName.value ) ) { reportExpectedError ( null , PredefinedName.AS ) ; }
this . scanner = new Scanner ( errorReporter , commentRecorder , source , offset ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ parse ( STRING_CONSTANT ) ; expectErrors ( STRING_CONSTANT ) ; parse ( STRING_CONSTANT ) ; testNotEs6Typed ( STRING_CONSTANT , STRING_CONSTANT ) ; }
checkState ( nameNode . isName () ) ;
for ( Case currentCase : allCases ) { switchNode . addChildToBack ( currentCase.caseNode ) ; }
{ currentCase.embedInto . replaceWith ( currentCase.caseBlock . detach () ) ; it . remove () ; continue; }
this . context = new TranspilationContext ( originalGeneratorBody ) ;
ImmutableSortedSet . copyOf ( ENTRY_COMPARATOR , map . entrySet () )
this . modulePaths = resolvePaths ( Iterables . transform ( Iterables . transform ( inputs , UNWRAP_DEPENDENCY_INFO ) , pathResolver ) , moduleRootPaths ) ;
{ this . cache = builder . build ( CacheLoader . from ( source - > delegate . transform ( source ) ) ) ; }
{ return x - > transform ( x ) ; }
{ return x - > function . apply ( x ) ; }
Predicates . < DiGraphEdge < Node , ControlFlowGraph.Branch > > alwaysTrue ()
return NodeUtil . has ( node , pred , Predicates . < Node > alwaysTrue () ) ;
{ this ( compiler , behavior , creator , Predicates . < Var > alwaysTrue () ) ; }
return NodeUtil . has ( callNode , hasSpreadCallArgumentPredicate , Predicates . < Node > alwaysTrue () ) ;
return ! referencesArguments && ! NodeUtil . has ( block , p , Predicates . < Node > alwaysTrue () ) ;
return result == null ? ImmutableList . < Symbol > of () : ImmutableList . of ( result ) ;
if ( customPasses == null ) { customPasses = LinkedHashMultimap . < CustomPassExecutionTime , CompilerPass > create () ; }
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , fixJsdocTypeNodes , Predicates . < Node > alwaysTrue () ) ; }
{ maybeAddUsage ( t , n , typeNode , false , Predicates . < Node > alwaysTrue () ) ; }
Predicates . < Node > alwaysTrue ()
{ return eval ( ttlAst , typeVars , ImmutableMap . < String , String > of () ) ; }
List < Ref > getRefs () { return refs == null ? ImmutableList . < Ref > of () : refs ; }
{ return chars == null ? ImmutableSet . < Character > of () : ImmutableSet . copyOf ( Chars . asList ( chars ) ) ; }
reserved = previousMap != null ? previousMap . getNewNameToOriginalNameMap () . keySet () : Collections . < String > emptySet ()
return invocation . hasOneChild () ? ImmutableList . < Node > of () : invocation . getSecondChild () . siblings () ;
{ return getCount ( node , new MatchNameNode ( name ) , Predicates . < Node > alwaysTrue () ) ; }
Predicates . < Node > alwaysTrue ()
Arrays . sort ( arr , Ordering . < String > natural () ) ;
for ( Node typeNode : info . getTypeNodes () ) { NodeUtil . visitPreOrder ( typeNode , replaceJsDocRefs , Predicates . < Node > alwaysTrue () ) ; }
ImmutableSet . < String > of ()
invalidations = FluentIterable . from ( invalidationMap . get ( t ) ) . transform ( Suppliers . < JSError > supplierFunction () ) . limit ( MAX_INVALIDATION_WARNINGS_PER_PROPERTY )
this . invalidationMap = propertiesToErrorFor . isEmpty () ? null : LinkedHashMultimap . < TypeI , Supplier < JSError > > create () ;
return new JSTypeExpression ( typeNode , PolymerPass.VIRTUAL_FILE ) ;
JSType type = compiler . getTypeRegistry () . getType ( STRING_CONSTANT ) ;
TypeI type = registry . getType ( target . getFirstFirstChild () . getQualifiedName () ) ;
{ final JSType voidType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
{ return isTheObjectType () || isStringObjectType () || isDateType () || isRegexpType () || isArrayType () || isNumberObjectType () || isBooleanObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
@ Override public boolean matchesNumberContext () { return isNumberObjectType () || isDateType () || isBooleanObjectType () || isStringObjectType () || hasOverridenNativeProperty ( STRING_CONSTANT ) ; }
TypeI type = compiler . getTypeIRegistry () . getType ( typeName ) ;
public void testMissingProperty33 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty22 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty21 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty18 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty15 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty12 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty11 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty10 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testMissingProperty9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
JSTypeExpression expr = new JSTypeExpression ( getCallArgument ( ttlAst , NUMBER_CONSTANT ) , STRING_CONSTANT ) ;
compiler . getOptions () . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 )
if ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
{ CompilerOptions options = super . getDefaultOptions () ; options . setLanguageIn ( LanguageMode.ECMASCRIPT_2015 ) ; options . setLanguageOut ( LanguageMode.ECMASCRIPT5 ) ; return options ; }
return ( nameNode . getFirstChild () != null || isLhsOfEnhancedForExpression ( nameNode ) ) ;
{ if ( pos >= js . length () ) { return null ; } else { return js . substring ( pos , js . length () ) ; } }
if ( node . isQuotedString () || node . getFirstChild () == null ) { return; }
Collections . sort ( declList , DECLARATIONS_FIRST ) ;
{ JSType newType = objType . getTemplateTypes () . get ( NUMBER_CONSTANT ) ; redeclareSimpleVar ( informed , item , newType ) ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
abstract JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) ;
ErrorReporter t
@ Override JSType resolveInternal ( ErrorReporter t , StaticTypedScope < JSType > scope ) { return this ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModulesToCommonJsModules ( compiler ) ; }
private String transpileEs6Module ( String s ) { return transpile ( transpile ( s , es6ModuleTranspiler ) ) ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
if ( t . isUnknownType () || t . isNoResolvedType () || ! t . isSubtype ( type ) ) { restricted . addAlternate ( t ) ; }
if ( ! alternate . isUnknownType () && that . isSubtype ( alternate ) ) { return this ; }
if ( isStructural && ! thisUnresolved && ! thatUnresolved ) { return rightType . isSubtype ( leftType ) ; } else { return rightType . isSubtypeWithoutStructuralTyping ( leftType ) ; }
{ return type . isSubtype ( getNativeType ( ARRAY_TYPE ) ) ? null : type ; }
{ JSType arrayType = getNativeType ( ARRAY_TYPE ) ; return arrayType . isSubtype ( type ) ? arrayType : null ; }
if ( resultEqualsValue ) { return ctorType . getGreatestSubtype ( type ) ; } else { return type . isSubtype ( ctorType ) ? null : type ; }
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( x . isSubtype ( windowCtor . getInstanceType () ) ) ;
assertTrue ( y . isSubtype ( getNativeType ( STRING_TYPE ) ) ) ;
{ if ( this . isSubtype ( rawThat ) ) { return this ; } else if ( rawThat . isSubtype ( this ) ) { return filterNoResolvedType ( rawThat ) ; } }
assertTrue ( unknown . isSubtype ( STRING_TYPE ) ) ;
assertTrue ( NULL_TYPE . isSubtype ( nullOrUnknown ) ) ;
! argType . isSubtype ( paramType )
! rightType . isSubtype ( leftType )
! leftType . isNoType () && ! rightType . isSubtype ( leftType )
! switchType . canTestForShallowEqualityWith ( caseType ) && ( caseType . autoboxesTo () == null || ! caseType . autoboxesTo () . isSubtype ( switchType ) )
! type . isNoType () && ! type . isUnknownType () && type . isSubtype ( nullOrUndefined ) && ! containsForwardDeclaredUnresolvedName ( type )
! type . isSubtype ( getNativeType ( NUMBER_STRING_SYMBOL ) )
! type . isSubtype ( getNativeType ( NUMBER_STRING ) )
! type . matchesNumberContext () && ! type . isSubtype ( allBitwisableValueTypes )
! type . isSubtype ( getNativeType ( NUMBER_TYPE ) )
if ( ! anyObjectType . isSubtype ( type ) && ! type . isEmptyType () ) { mismatch ( t , n , msg , type , anyObjectType ) ; }
if ( funcTarget . hasInstanceType () ) { if ( type . isSubtype ( funcTarget . getInstanceType () ) ) { return null ; } return type ; }
if ( ! objType . isNoType () && ! objType . isUnknownType () && objType . isSubtype ( getNativeType ( NULL_VOID ) ) ) { return; }
if ( castType . restrictByNotNullOrUndefined () . isSubtype ( exprType ) || expr . isObjectLit () ) { expr . setJSType ( castType ) ; }
if ( isEmptyType () || that . isEmptyType () ) { return isSubtype ( that ) || that . isSubtype ( this ) ; }
{ JSType alternate = alternatesList . get ( i ) ; if ( alternate . isSubtype ( arrayType ) ) { return true ; } }
public final boolean isSymbol () { return isSubtype ( getNativeType ( JSTypeNative.SYMBOL_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isNumber () { return isSubtype ( getNativeType ( JSTypeNative.NUMBER_VALUE_OR_OBJECT_TYPE ) ) ; }
public final boolean isString () { return isSubtype ( getNativeType ( JSTypeNative.STRING_VALUE_OR_OBJECT_TYPE ) ) ; }
if ( that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN_SYMBOL ) ) ) { return UNKNOWN ; }
! type . isSubtype ( typeRegistry . getNativeType ( OBJECT_TYPE ) )
assertTrue ( STRING_CONSTANT + varType + STRING_CONSTANT + name + STRING_CONSTANT + type + STRING_CONSTANT , varType . isSubtype ( type ) ) ;
return new BooleanOutcomePair ( jsType . getPossibleToBooleanOutcomes () , registry . getNativeType ( BOOLEAN_TYPE ) . isSubtype ( jsType ) ? BooleanLiteralSet.BOTH : BooleanLiteralSet.EMPTY , flowScope , flowScope ) ;
outcome.booleanValues == BooleanLiteralSet.EMPTY && getNativeType ( BOOLEAN_TYPE ) . isSubtype ( type )
argObjectType . isSubtype ( referencedParamType )
! jsType . isUnknownType () && ! jsType . isAllType () && jsType . isSubtype ( providedJsType )
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.OBJECT_NUMBER_STRING_BOOLEAN ) ) ) { return UNKNOWN ; }
{ final JSType voidType = compiler . getTypeRegistry () . getNativeType ( JSTypeNative.VOID_TYPE ) ; return voidType . isSubtype ( returnType ) ; }
if ( that . isUnknownType () || that . isSubtype ( getNativeType ( JSTypeNative.NUMBER_STRING_BOOLEAN ) ) || that . isObject () ) { return UNKNOWN ; }
assertFalse ( arrayOfString . isSubtype ( createUnionType ( arrayOfNumber , NULL_VOID ) ) ) ;
@ Override public boolean isSubtype ( JSType that ) { return isSubtype ( that , ImplCache . create () , SubtypingMode.NORMAL ) ; }
return thisType . isSubtype ( thatType ) || thatType . isSubtype ( thisType ) ;
{ if ( thisType . isFunctionType () ) { return true ; } else { return thisType . isSubtype ( functionType ) || functionType . isSubtype ( thisType ) ; } }
options . setLanguageIn ( CompilerOptions.LanguageMode.ECMASCRIPT_2015 ) ;
boolean isConstToBeInferred () { return isConstToBeInferred ( getJsDoc () , getLhs () ) ; }
maybeWarnForConstWithoutExplicitType ( compiler , jsdoc , nameNode ) ;
@ Override protected CompilerPass getProcessor ( final Compiler compiler ) { return new J2clPass ( compiler ) ; }
if ( astValidationEnabled ) { ( new AstValidator ( compiler ) ) . validateRoot ( root ) ; }
new PureFunctionIdentifier.DriverInJ2cl ( compiler , null ) . process ( externs , root ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( name , name ) ;
exportedNameToLocalQName . put ( STRING_CONSTANT , name ) ;
Map.Entry < String , String > entry
functionNames = compilerState.functioNames ;
this . functioNames = compiler.functionNames ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( moduleScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( blockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( forOfScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionScope . isDeclared ( STRING_CONSTANT , false ) ) ;
assertTrue ( functionBlockScope . isDeclared ( STRING_CONSTANT , false ) ) ;
catch ( FlagUsageException e ) { assertThat ( e ) . hasMessage ( STRING_CONSTANT ) ; }
return s != null ? s : createScope ( n , createScope ( NodeUtil . getEnclosingScopeRoot ( n . getParent () ) ) ) ;
TypeInference dfa = new TypeInference ( compiler , cfg , rai , assumedScope , ASSERTION_FUNCTION_MAP ) ;
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () == syntacticScope ;
if ( isUnflowable ( syntacticScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != syntacticScope . getSlot ( qualifiedName ) ) ;
ttlObj = new TypeTransformation ( compiler , syntacticScope ) ;
TypedVar var = syntacticScope . getVar ( qKeyName ) ;
TypedVar var = syntacticScope . getVar ( qName ) ;
TypedVar var = syntacticScope . getVar ( varName ) ;
{ type = info . getType () . evaluate ( syntacticScope , registry ) ; }
if ( info != null && info . hasType () ) { n . setJSType ( info . getType () . evaluate ( syntacticScope , registry ) ) ; }
if ( rename ) { NodeTraversal . traverseEs6 ( compiler , js , new Renamer ( compiler ) ) ; }
registry . createNullableType ( registry . getType ( STRING_CONSTANT ) )
{ super ( registry , reference , sourceName , lineno , charno ) ; }
resolvedNamedTypes . putAll ( scope , unresolvedNamedTypes . removeAll ( scope ) ) ;
public void clearNamedTypes () { resolvedNamedTypes . clear () ; unresolvedNamedTypes . clear () ; }
{ checkArgument ( ! name . contains ( STRING_CONSTANT ) , STRING_CONSTANT ) ; namesToTypes . put ( name , type ) ; }
assertTrue ( findNameType ( STRING_CONSTANT , lastLocalScope ) . isEquivalentTo ( registry . getType ( STRING_CONSTANT ) ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , jsdoc . getImplementedInterfaces () . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , types . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , NUMBER_CONSTANT , NUMBER_CONSTANT ) , jsdoc . getBaseType () ) ;
{ assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , parse ( STRING_CONSTANT ) . getBaseType () ) ; }
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , interfaces . get ( NUMBER_CONSTANT ) ) ;
assertTypeEquals ( createNullableType ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
assertTypeEquals ( registry . createNamedType ( STRING_CONSTANT , null , - NUMBER_CONSTANT , - NUMBER_CONSTANT ) , info . getType () ) ;
! newType . isEquivalentTo ( varType )
{ assertEquals ( expected , resolve ( actual ) ) ; }
{ return ! checkEquivalenceHelper ( that , EquivalenceMethod.DATA_FLOW ) ; }
{ if ( constructorI . checkEquivalenceHelper ( constructorJ , EquivalenceMethod.IDENTITY ) ) { shouldCheck = false ; } }
{ this ( Functions . < String > identity () , errorManager ) ; }
Node ast = parseSyntheticCode ( STRING_CONSTANT + resourceName + STRING_CONSTANT , originalCode ) ;
if ( ! scope . isDeclared ( NodeUtil.JSC_PROPERTY_NAME_FN , true ) ) { scope . declare ( NodeUtil.JSC_PROPERTY_NAME_FN , null , null ) ; }
if ( scope . isDeclared ( qName , false ) ) { continue; }
! scope . isDeclared ( qName , false ) && n . isUnscopedQualifiedName ()
if ( ! name . isEmpty () && ! usageScope . isDeclared ( name , true ) ) { return true ; }
if ( t . getScope () . isDeclared ( alias , true ) ) { compiler . report ( JSError . make ( n , TYPE_ALIAS_ALREADY_DECLARED , alias ) ) ; }
n . isName () && ! t . getScope () . isDeclared ( n . getString () , true )
if ( current . isDeclared ( oldName , false ) ) { return; } else { current = current . getParent () ; }
assertTrue ( fooScope . isDeclared ( STRING_CONSTANT , false ) ) ;
if ( ! getRootNode () . isFunction () ) { return getClosestNonBlockScope () . getTypeOfThis () ; }
return v != null && v . isLocal () && v . isMarkedEscaped () && v . getScope () . getClosestNonBlockScope () == cfgRootScope ;
this . cfgRootScope = syntacticScope ;
while ( t . getScope () . isDeclared ( pseudoName , true ) ) { pseudoName += STRING_CONSTANT ; }
varsInFunctionBody . contains ( refName ) && ! scope . isDeclared ( refName , true )
curScope . isDeclared ( assignment.oldName , true )
AbstractVar < , > var = getSubject () . getVar ( name ) ;
AbstractVar < , > var = getSubject () . getVar ( name ) ;
if ( isUnflowable ( currentScope . getVar ( varName ) ) ) { return; }
isLocallyInferred = ( var != currentScope . getSlot ( qualifiedName ) ) ;
backwardsInferenceFromCallSite ( n , ct ) ;
backwardsInferenceFromCallSite ( n , fnType ) ;
TypedVar var = currentScope . getVar ( qKeyName ) ;
boolean unflowable = isInferred && isUnflowable ( currentScope . getVar ( varName ) ) ;
{ type = info . getType () . evaluate ( currentScope , registry ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null , false , ResolutionMode.BROWSER ) ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , MODULE_USES_GOOG_MODULE_GET ) ; }
return getBinaryModuleNamespace ( legacyNamespace ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
test ( externs ( DEFAULT_EXTERNS + externs ) , srcs ( js ) , error ( DisambiguateProperties.Warnings.INVALIDATION_ON_TYPE ) . withMessageContaining ( STRING_CONSTANT ) ) ;
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
{ test ( srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , error ( DisambiguateProperties.Warnings.INVALIDATION ) . withMessageContaining ( STRING_CONSTANT ) ) ; }
TypedVar fnVar = scope . getVar ( fnName ) ;
Node rootNode = scope . getRootNode () ;
private GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
if ( scope . hasOwnSlot ( qName ) ) { continue; }
TypedVar ownerVar = scope . getVar ( slotName ) ;
TypedVar slot = scope . getVar ( name ) ;
{ return rValueInfo . getType () . evaluate ( scope , typeRegistry ) ; }
{ return createEnumTypeFromNodes ( rValue , lValue . getQualifiedName () , info ) ; }
return scope . isGlobal () || ! type . isReturnTypeInferred () ;
parent == null || ! parent . isFunction () || n == parent . getFirstChild () || parent == scope . getRootNode ()
if ( this . getFunctionScope () != that . getFunctionScope () ) { return false ; }
return slot != null ? slot : getFunctionScope () . getSlot ( var . getName () ) ;
{ return getSlot ( getVarFromFunctionScope ( name ) ) ; }
ScopedName var = getVarFromFunctionScope ( symbol ) ;
{ return new LinkedFlowScope ( new FlatFlowScopeCache ( scope ) ) ; }
{ if ( type != null ) { type = type . resolve ( errorReporter , scope ) ; } }
public TemplateType getObjectIndexKey () { checkNotNull ( iObjectIndexTemplateKey ) ; return this . iObjectIndexTemplateKey ; }
public TemplateType getObjectElementKey () { return this . iObjectElementTemplateKey ; }
new InvalidatingTypes.Builder ( registry ) . recordInvalidations ( this . invalidationMap ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () )
Node root = NodeUtil . getEnclosingNode ( n , TypeInference : : createsContainerScope ) ;
AbstractScope ( Node rootNode ) { this . rootNode = rootNode ; }
if ( callee . matchesQualifiedName ( STRING_CONSTANT ) && t . inModuleHoistScope () ) { t . report ( n , GOOG_MODULE_USES_GOOG_MODULE_GET ) ; }
@ Override protected CompilerPass getProcessor ( Compiler compiler ) { return new Es6RewriteModules ( compiler , null ) ; }
return MODULE_EXPORTS_PREFIX + this . legacyNamespace . replace ( CHAR_CONS , CHAR_CONS ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
if ( Keywords . isKeyword ( name.value ) ) { features = features . with ( Feature.KEYWORDS_AS_PROPERTIES ) ; }
{ if ( moduleType == ModuleType.GOOG_MODULE ) { moduleType = ModuleType.LEGACY_GOOG_MODULE ; } else { compiler . report ( JSError . make ( declaresLegacyNamespace , DECLARE_LEGACY_NAMESPACE_OUTSIDE_GOOG_MODULE ) ) ; } }
n . isVar ()
if ( n . isVar () ) { return n . getFirstChild () ; } else if ( NodeUtil . isExprAssign ( n ) ) { return n . getFirstFirstChild () ; }
if ( ! child . isVar () && ! NodeUtil . isExprAssign ( child ) ) { continue; }
parent != null && parent . isVar ()
Node node = withType ( IR . number ( id ) . useSourceInfoFrom ( sourceNode ) , numberType ) ;
sourceNode . replaceWith ( IR . breakNode () ) ;
IR . block ( callContextMethodResult ( sourceNode , STRING_CONSTANT , section . getNumber ( sourceNode ) ) , IR . breakNode () . useSourceInfoFrom ( sourceNode ) ) . useSourceInfoFrom ( sourceNode )
{ writeGeneratedNode ( n ) ; writeGeneratedNode ( IR . breakNode () . useSourceInfoFrom ( n ) ) ; currentCase.mayFallThrough = false ; }
var != null && var . getScope () == getSubject ()
{ checkState ( scope != getSubject () , STRING_CONSTANT ) ; expectScope ( STRING_CONSTANT , scope , scope ) ; }
private DeclarationSubject ( AbstractVar < , > var ) { this . var = var ; }
ImmutableList < AbstractVar < , > > declared = ImmutableList . copyOf ( getSubject () . getAllAccessibleVariables () ) ;
if ( replace . isVar () ) { replace . replaceWith ( NodeUtil . newExpr ( replacement ) ) ; } else { replace . replaceWith ( replacement ) ; }
ref . getParent () . isVar ()
parent . isVar ()
if ( parent . isFunction () || parent . isVar () || parent . isNew () ) { return; }
{ return ( n . isVar () || n . isFunction () ) && isWhitelistedName ( n . getFirstChild () . getString () ) ; }
checkArgument ( returnNode . isReturn () ) ;
{ return ! isValidIndex ( index + offset ) ? CHAR_CONS : source.contents . charAt ( index + offset ) ; }
private char nextChar () { if ( isAtEnd () ) { return CHAR_CONS ; } return source.contents . charAt ( index ++ ) ; }
String value = this . source . contents . substring ( startOffset , index ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new ProcessLabels ( markChanges ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , collector ) ;
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , extractionInfo ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; addWindowProperties () ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , body , updater ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ symbolMap = getCssRenamingMap () ; NodeTraversal . traverseEs6 ( compiler , root , new Traversal () ) ; }
NodeTraversal . traverseEs6 ( compiler , scriptRoot , traverser ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseRootsEs6 ( compiler , renamer , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , checkNotNull ( root ) , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
for ( Callback callback : callbacks ) { scriptRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
for ( Callback callback : callbacks ) { singleRoot . putBooleanProp ( Node.TRANSPILED , true ) ; NodeTraversal . traverseEs6 ( compiler , singleRoot , callback ) ; }
do { codeChanged = false ; NodeTraversal . traverseEs6 ( compiler , root , new EliminationPass ( cfg ) ) ; } while ( codeChanged ) ;
{ checkNotNull ( root ) ; checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ if ( Es6RewriteModules . isEs6ModuleRoot ( script ) ) { NodeTraversal . traverseEs6 ( compiler , script , new Rewriter ( compiler , script ) ) ; } }
NodeTraversal . traverseEs6 ( compiler , root , finder ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , finder ) ;
NodeTraversal . traverseEs6 ( compiler , block , new UnmarkedNodeTranspiler () ) ;
{ YieldFinder yieldFinder = new YieldFinder () ; NodeTraversal . traverseEs6 ( compiler , n , yieldFinder ) ; return yieldFinder . getYieldNode () ; }
NodeTraversal . traverseEs6 ( compiler , wrapper , context . new UnmarkedNodeTranspiler () ) ;
NodeTraversal . traverseEs6 ( compiler , originalGeneratorBody , new YieldNodeMarker () ) ;
NodeTraversal . traverseEs6 ( compiler , root , new LabelFinder () ) ;
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
NodeTraversal . traverseRootsEs6 ( compiler , pass , externs , root ) ;
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ; }
{ NodeTraversal . traverseEs6 ( compiler , js , this ) ; }
if ( renameMessages ) { RenameMessagesVisitor renameMessagesVisitor = new RenameMessagesVisitor () ; NodeTraversal . traverseEs6 ( compiler , root , renameMessagesVisitor ) ; }
NodeTraversal . traverseEs6 ( compiler , root , namingCallback ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , originalRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , function . getLastChild () , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getLoopCodeBlock ( loopNode ) , continueStatementUpdater ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , superSet . getLastChild () , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , normalizePass ) ; denormalizePass . process ( externs , root ) ; }
{ CheckProvidesCallback callback = new CheckProvidesCallback ( codingConvention ) ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , callback ) ; }
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , n , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , cfgNode , gatherCb ) ;
NodeTraversal . traverseEs6 ( compiler , t . getScopeRoot () , new GatherCandidates () ) ;
NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ new InferConsts ( compiler ) . process ( externs , root ) ; NodeTraversal . traverseEs6 ( compiler , root , constFinder ) ; }
NodeTraversal . traverseEs6 ( this , n , sia ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , NodeUtil . getFunctionBody ( constructor ) , finder ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , externs , this ) ; compiler . setExternProperties ( ImmutableSet . copyOf ( externProperties ) ) ; }
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
NodeTraversal . traverseEs6 ( compiler , tree , test ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , root , new Callback () ) ;
NodeTraversal . traverseEs6 ( compiler , root , traversal ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , externsCallback ) ;
NodeTraversal . traverseEs6 ( compiler , originalRoot , cb ) ;
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new GatherCollapses () ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ checkState ( compiler . getLifeCycleStage () . isNormalized () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopes , new EmptyClinitPruner () , false ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
NodeTraversal . traverseEs6 ( compiler , script , test ) ;
{ checkArgument ( isEs6ModuleRoot ( root ) , root ) ; clearState () ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
if ( isEs6ModuleRoot ( scriptNode ) ) { processFile ( scriptNode ) ; } else { NodeTraversal . traverseEs6 ( compiler , scriptNode , new RewriteRequiresForEs6Modules () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , callbacks . get ( NUMBER_CONSTANT ) ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new Strip () ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findFunction ) ;
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , findParameter ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new ExportTestFunctionsNodes () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , externs , findExternsCallback ) ;
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , callback , new RenameCallback ( aliasName , renamed ) ) ; aliasName = renamed ; break; }
NodeTraversal . traverseEs6 ( compiler , callbackBlock , new DefineCallbackReturnCallback () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new TransformAMDModulesCallback () ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , script , this ) ;
NodeTraversal . traverseEs6 ( compiler , googRoot , this ) ;
{ checkArgument ( scriptNode . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , scriptNode , this ) ; }
{ if ( ! rules . isEmpty () ) { NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; } }
NodeTraversal . traverseEs6 ( compiler , tree , cb ) ;
{ checkState ( root . isScript () ) ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ;
NodeTraversal . traverseEs6 ( compiler , js , new Normalize.NormalizeStatements ( compiler , false ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ProcessVars () ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , new UseSiteGatheringCallback () , false ) ;
{ super . process ( externs , source ) ; NodeTraversal . traverseEs6 ( compiler , source , new UseSiteGatheringCallback () ) ; }
NodeTraversal . traverseEs6 ( getLastCompiler () , getLastCompiler () . jsRoot , s ) ;
{ requiresLineNumbers = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , constructorBody , replaceThisWithSuperThis ) ;
NodeTraversal . traverseEs6 ( compiler , functionBody , checkForDefinedReturnValue ) ;
NodeTraversal . traverseEs6 ( compiler , enclosingFunction , checkAssigns ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , findExportableNodes ) ;
NodeTraversal . traverseEs6 ( compiler , parsed.ast , new Traverser ( info ) ) ;
{ FindPrimitives pass = new FindPrimitives () ; NodeTraversal . traverseEs6 ( compiler , root , pass ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , pass ) ;
NodeTraversal . traverseEs6 ( compiler , body , traversal ) ;
NodeTraversal . traverseEs6 ( compiler , root , getterSetterCollector ) ;
NodeTraversal . traverseEs6 ( compiler , body , this ) ;
NodeTraversal . traverseEs6ScopeRoots ( compiler , null , changedScopeRoots , cb , cb , false ) ;
{ requiresTypes = false ; NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , this ) ;
{ if ( ! J2clSourceFileChecker . shouldRunJ2clPasses ( compiler ) ) { return; } NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ mode = Mode.SINGLE_FILE ; reset () ; NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ reset () ; NodeTraversal . traverseRootsEs6 ( compiler , this , externs , root ) ; }
NodeTraversal . traverseEs6 ( compiler , root , definitionsGatherer ) ;
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6ScopeRoots ( compiler , root , changedScopeNodes , new PeepCallback () , false ) ; if ( ! retraverseOnChange ) { break; } }
NodeTraversal . traverseEs6 ( compiler , root , new ReductionGatherer ( reducers , reductionMap ) ) ;
{ NodeTraversal . traverseEs6 ( compiler , js , new DeadAssignmentsElimination ( compiler ) ) ; }
{ NodeTraversal . traverseEs6 ( compiler , root , this ) ; }
{ NodeTraversal . traverseEs6 ( compiler , scriptRoot , this ) ; }
NodeTraversal . traverseEs6 ( compiler , root , new ProcessProperties () ) ;
{ NodeTraversal . traverseEs6 ( compiler , root , new SourceInformationAnnotator ( STRING_CONSTANT , false ) ) ; }
{ PolymerPassSuppressBehaviors suppressBehaviorsCallback = new PolymerPassSuppressBehaviors ( compiler ) ; NodeTraversal . traverseEs6 ( compiler , root , suppressBehaviorsCallback ) ; }
return new IdentifierToken ( getTokenRange ( beginToken ) , value . intern () ) ;
NodeTraversal . traverseEs6 ( compiler , script , cb ) ;
NodeTraversal . traverseEs6 ( compiler , rootNode , callback ) ;
NodeTraversal . traverseEs6 ( metadata . getCompiler () , script , callback ) ;
assertEquals ( STRING_CONSTANT , x . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , bar . getType () . toString () ) ;
assertEquals ( STRING_CONSTANT , f . getPropertyType ( STRING_CONSTANT ) . toString () ) ;
if ( item . isVar () ) { item = item . getFirstChild () ; }
{ checkArgument ( parent . isFunction () || parent . isVar () || parent . isParamList () || parent . isCatch () ) ; }
NodeTraversal . traverseTyped ( compiler , root , new DiscoverEnumsAndTypedefs ( typeRegistry ) ) ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
NodeTraversal . traverseEs6 ( compiler , root , new IdentifyGlobalEnumsAndTypedefsAsNonNullable ( typeRegistry ) ) ;
ReferenceCollectingCallback refCollector = new ReferenceCollectingCallback ( this , ReferenceCollectingCallback.DO_NOTHING_BEHAVIOR , SyntacticScopeCreator . makeUntyped ( this ) ) ;
private TypeCheckResult parseAndTypeCheckWithScope ( String js ) { return parseAndTypeCheckWithScope ( DEFAULT_EXTERNS , js ) ; }
private Node parseAndTypeCheck ( String js ) { return parseAndTypeCheck ( DEFAULT_EXTERNS , js ) ; }
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , diag , false ) ; }
{ testTypes ( externs , js , ( String ) null , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testCovariantIThenable3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testSymbol2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testSymbol1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeStructuralMatch1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testIArrayLikeCovariant1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; testAddingMethodsUsingPrototypeIdiomComplexNamespace ( p ) ; }
Node js1Node = parseAndTypeCheck ( STRING_CONSTANT + STRING_CONSTANT ) ;
public void testFunctionBind5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind4 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionBind1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall8 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall7 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall6 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall5 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall2 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testFunctionCall1 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testAbstractMethodCall13 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall12 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall10 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall7 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testAbstractMethodCall3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testAbstractMethodCall1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , STRING_CONSTANT ) ; }
public void testIssue1201b () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testThis14 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess9 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess8 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess7 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess6 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess4 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess3 () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess2 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testArrayAccess1 () { testTypes ( STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForGettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testGetelemStruct_noErrorForSettingWellKnownSymbol () { testTypes ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testForOf8 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf6 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf4 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ Node number = createUntypedNumber ( n ) ; number . setJSType ( NUMBER_TYPE ) ; return number ; }
{ Node n = new Node ( Token.NULL ) ; n . setJSType ( NULL_TYPE ) ; return n ; }
child . inferSlotType ( STRING_CONSTANT , NUMBER_TYPE ) ;
public void testTransformationWithUnionInMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidMaprecord () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithInvalidNestedMapunion () { testTTL ( UNKNOWN_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testTransformationWithNestedMapunionInMapFunctionBody () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanSecondParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
public void testTransformationWithNestedExpressionInBooleanFirstParam () { testTTL ( STRING_TYPE , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
assertTypeEquals ( type , OBJECT_TYPE ) ;
{ Node n = parseAndTypeCheck ( STRING_CONSTANT ) ; assertTypeEquals ( ERROR_TYPE , n . getFirstFirstChild () . getJSType () ) ; }
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( NUMBER_TYPE , type ) ;
assertTypeEquals ( STRING_CONSTANT , NUMBER_TYPE , googFooGetprop2ObjectType . getPropertyType ( STRING_CONSTANT ) ) ;
public void testName5 () { assertTypeEquals ( REGEXP_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName4 () { assertTypeEquals ( DATE_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName3 () { assertTypeEquals ( ARRAY_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName2 () { assertTypeEquals ( OBJECT_FUNCTION_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
public void testName1 () { assertTypeEquals ( VOID_TYPE , testNameNode ( STRING_CONSTANT ) ) ; }
assertTypeEquals ( ARRAY_TYPE , a . getType () ) ;
assertTypeEquals ( VOID_TYPE , n . getJSType () ) ;
{ Node falseNode = typeCheck ( new Node ( Token.FALSE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , falseNode . getJSType () ) ; }
{ Node trueNode = typeCheck ( new Node ( Token.TRUE ) ) ; assertTypeEquals ( BOOLEAN_TYPE , trueNode . getJSType () ) ; }
{ Node n = typeCheck ( Node . newString ( STRING_CONSTANT ) ) ; assertTypeEquals ( STRING_TYPE , n . getJSType () ) ; }
{ Node n = typeCheck ( Node . newNumber ( NUMBER_CONSTANT ) ) ; assertTypeEquals ( NUMBER_TYPE , n . getJSType () ) ; }
{ TypeCheckResult p = parseAndTypeCheckWithScope ( STRING_CONSTANT ) ; assertTypeEquals ( NUMBER_TYPE , p.scope . getVar ( STRING_CONSTANT ) . getType () ) ; }
JSDocInfo jsDoc = node . getParent () . isVar () ? node . getParent () . getJSDocInfo () : node . getJSDocInfo () ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
shouldAddTypes ? this . contextType . getPropertyType ( fieldName ) : null
String embedded = transpiled + STRING_CONSTANT + URLEncoder . encode ( sourceMap ) + STRING_CONSTANT ;
var . getParentNode () != null && var . getType () == null && var . getParentNode () . isVar ()
options . setPreserveGoogProvidesAndRequires ( true ) ;
ObjectType regType = ObjectType . cast ( registry . getType ( qualifiedName ) ) ;
JSType windowType = getType ( STRING_CONSTANT ) ;
private void registerGlobalType ( JSType type ) { registerGlobalType ( type , type . toString () ) ; }
{ typesIndexedByProperty . clear () ; eachRefTypeIndexedByProperty . clear () ; initializeBuiltInTypes () ; namesToTypes . clear () ; initializeRegistry () ; }
assertTypeEquals ( typeRegistry . getNativeType ( GENERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERATOR_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
assertTypeEquals ( typeRegistry . getNativeType ( ITERABLE_TYPE ) , typeRegistry . getType ( STRING_CONSTANT ) ) ;
{ warnImplicitlyNullable ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; noWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
JSType type = registry . getType ( reference ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( factories , compiler . getOptions () ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes , compiler . getOptions () ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks , options ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes , options ) ;
NodeUtil . isLoopStructure ( s . getRootNode () )
actualYieldType = actualYieldType . dereference () . getTemplateTypeMap () . getResolvedTemplateType ( typeRegistry . getIterableTemplate () ) ;
var . getParentNode () != null && var . getType () == null && NodeUtil . isNameDeclaration ( var . getParentNode () )
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NTI_ONLY ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = false ; useTypes = true ; numRepetitions = NUMBER_CONSTANT ; mode = TypeInferenceMode.NEITHER ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
warningOtiNti ( TYPE_MISMATCH_WARNING , MISTYPED_ASSIGN_RHS )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
Node parse ( String js ) { return parse ( js , TypeInferenceMode.NEITHER ) ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.OTI_ONLY ) )
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
{ this . mode = TypeInferenceMode.NEITHER ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.OTI_ONLY ;
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.NEITHER ; unused ( STRING_CONSTANT ) ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.NEITHER ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.NEITHER ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
public void testArguments6 () { this . mode = TypeInferenceMode.NEITHER ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.NEITHER ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.NEITHER ; }
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.NEITHER ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.BOTH ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.NEITHER ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.BOTH ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.BOTH ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; late = true ; this . mode = TypeInferenceMode.NEITHER ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
this . mode = TypeInferenceMode.OTI_ONLY ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; this . mode = TypeInferenceMode.BOTH ; }
testSame ( externs ( lines ( MINIMAL_EXTERNS , STRING_CONSTANT , STRING_CONSTANT ) ) , srcs ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) , warningOtiNti ( TypeValidator.TYPE_MISMATCH_WARNING , NewTypeInference.INVALID_ARGUMENT_TYPE ) )
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.NEITHER ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ;
{ testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; test ( srcs ( STRING_CONSTANT ) , warningOtiNti ( TOO_MANY_TEMPLATE_PARAMS , INVALID_GENERICS_INSTANTIATION ) ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
this . mode = TypeInferenceMode.BOTH ;
{ this . mode = TypeInferenceMode.BOTH ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.NEITHER ; enableRunTypeCheckAfterProcessing () ; }
for ( NamedType type : unresolvedNamedTypes . get ( scope ) ) { type . resolve ( reporter , scope ) ; }
activeXObject . resolve ( null , scope ) ;
namedA . resolve ( null , scope ) ;
{ if ( type != null ) { this . type = type . resolve ( errorReporter , scope ) ; } }
a . resolve ( null , EMPTY_SCOPE ) ;
for ( DeferredSetType deferred : deferredSetTypes ) { deferred . resolve ( currentScope ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( factories ) ;
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
if ( options . needsTranspilationFrom ( ES6 ) ) { checks . add ( es6ExternsCheck ) ; TranspilationPasses . addEs6PreTypecheckPasses ( checks ) ; }
TranspilationPasses . addEs6PreTypecheckPasses ( passes ) ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testAbstractClass () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT , warning ( INSTANTIATE_ABSTRACT_CLASS ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.DISABLED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
Node parse ( String js ) { return parse ( js , TypeInferenceMode.DISABLED ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefinePropertiesQuotesPreventRemoval () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties6 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testObjectDefineProperties5 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; test ( lines ( STRING_CONSTANT , STRING_CONSTANT ) , lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testObjectDefineProperties1 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testES6StaticProperty2 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testES6StaticProperty () { this . mode = TypeInferenceMode.DISABLED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testConstructorProperty2 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testConstructorProperty1 () { this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; enableNormalize () ; enableGatherExternProperties () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2017 ) ; this . mode = TypeInferenceMode.DISABLED ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( DiagnosticGroups.NEW_CHECK_TYPES_EXTRA_CHECKS ) ; }
@ Override protected void setUp ( ) throws Exception { super . setUp () ; }
@ Override public void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
public void testClassWithEmptyMembers () { this . mode = TypeInferenceMode.DISABLED ; testError ( STRING_CONSTANT , StrictModeCheck.DUPLICATE_CLASS_METHODS ) ; }
public void testStaticAndNonstaticSetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticGetterWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testStaticAndNonstaticMethodWithSameName () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testComputedPropInClass () { this . mode = TypeInferenceMode.DISABLED ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
public void testArguments6 () { this . mode = TypeInferenceMode.DISABLED ; testSame ( STRING_CONSTANT ) ; }
public void testUnknownVariable4 () { this . mode = TypeInferenceMode.DISABLED ; testSameEs6Strict ( STRING_CONSTANT ) ; testSameEs6Strict ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; foldStringTypes ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; late = true ; useTypes = true ; this . mode = TypeInferenceMode.DISABLED ; }
public void disable_testClassMethodUnused2 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassMethodUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; used ( STRING_CONSTANT ) ; }
public void testClassPropUnused1 () { this . mode = TypeInferenceMode.DISABLED ; unused ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ super . setUp () ; setAcceptedLanguage ( LanguageMode.ECMASCRIPT_2015 ) ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableNormalize () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = STRING_CONSTANT ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . mode = TypeInferenceMode.DISABLED ; String source = lines ( STRING_CONSTANT , STRING_CONSTANT ) ; assertNoPureCalls ( source ) ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; ignoreWarnings ( NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
{ this . mode = TypeInferenceMode.CHECKED ; testRewrite ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
{ super . setUp () ; this . mode = TypeInferenceMode.DISABLED ; enableRunTypeCheckAfterProcessing () ; }
new CodePrinter.Builder ( parse ( js , TypeInferenceMode.CHECKED ) )
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_boxedNumberVsZero () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_allType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_unknownType () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
public void testCoercionSubstitution_while () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
{ this . mode = TypeInferenceMode.CHECKED ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_expression () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
this . mode = TypeInferenceMode.CHECKED ;
public void testCoercionSubstitution_booleanResult0 () { this . mode = TypeInferenceMode.CHECKED ; testSame ( STRING_CONSTANT ) ; }
this . mode = TypeInferenceMode.CHECKED ;
@ Override protected void setUp ( ) throws Exception { super . setUp () ; enableTranspile () ; }
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
this . mode = TypeInferenceMode.DISABLED ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
public boolean isTypecheckingEnabled () { return this . checkTypes || this . useNewTypeInference ; }
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
return options . getNewTypeInference () ? getGlobalTypeInfo () : getTypeRegistry () ;
this . addTypes = MostRecentTypechecker.NTI . equals ( compiler . getMostRecentTypechecker () ) ;
ignoreWarnings ( GlobalTypeInfoCollector.INTERFACE_METHOD_NOT_IMPLEMENTED , TypeValidator.INTERFACE_METHOD_NOT_IMPLEMENTED ) ;
public void testTypeMismatch () { ignoreWarnings ( NewTypeInference.MISTYPED_ASSIGN_RHS , TypeValidator.TYPE_MISMATCH_WARNING ) ; testSame ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
DiagnosticGroup ignored = new DiagnosticGroup ( TypeCheck.INEXISTENT_PROPERTY , NewTypeInference.GLOBAL_THIS , NewTypeInference.INEXISTENT_PROPERTY , NewTypeInference.INVALID_ARGUMENT_TYPE , TypeValidator.TYPE_MISMATCH_WARNING ) ;
validator . expectCanAssignTo ( t , loopVarNode , declaredType , actualType , STRING_CONSTANT ) ;
checkArgument ( setKey . isSetterDef () , setKey ) ;
newGeneratorBody . addChildBefore ( varStatement , newGeneratorBody . getLastChild () ) ;
newGeneratorBody . addChildBefore ( n , newGeneratorBody . getLastChild () ) ;
if ( NodeUtil . isStringLiteralValue ( ast ) ) { paramNodeMatches . set ( paramIndex , ast ) ; return true ; }
{ return NodeUtil . isStringLiteralValue ( ast ) ; }
{ if ( ! isCompileTimeConstant ( traversal . getScope () , argument ) ) { compiler . report ( traversal . makeError ( argument , CONST_NOT_STRING_LITERAL_ERROR ) ) ; } }
if ( prop != null ) { if ( NodeUtil . isStringLiteralValue ( prop ) ) { continue; } return violation ; }
NodeUtil . isLhsOfAssign ( propAccess ) && ( NodeUtil . isLiteralValue ( propAccess . getNext () , false ) || NodeUtil . isStringLiteralValue ( propAccess . getNext () ) )
String lastPart = typeString . substring ( typeString . lastIndexOf ( STRING_CONSTANT ) + NUMBER_CONSTANT ) ;
int index = name . indexOf ( STRING_CONSTANT ) ;
checkArgument ( setKey == null || setKey . isSetterDef () , setKey ) ;
Path path
Path path
Path path
Path path
Path path
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
List < LocationMapping > sourceMapLocationMappings
Path path
Path path
{ switch ( n . getToken () ) { case FOR_OF : visitForOf ( t , n , parent ) ; break; default: break; } }
this . registry = compiler . getTypeIRegistry () ;
actual = new CodePrinter.Builder ( script ) . setCompilerOptions ( options ) . setTypeRegistry ( compiler . getTypeIRegistry () ) . build () . trim ()
TypeI type = fnNode . getTypeI () ;
TypeI type = n . getTypeI () ;
@ Override public boolean isPrototypeObject () { return isFunctionPrototypeType () ; }
TypeI type = srcObj . getTypeI () ;
TypeI attrsType = attrs . getTypeI () ;
TypeI type = srcObj . getTypeI () ;
ObjectTypeI targetType = target . getTypeI () . toMaybeObjectType () ;
String typeName = n . getFirstChild () . getTypeI () . toString () ;
TypeI type = n . getTypeI () ;
TypeI type = n . getTypeI () ;
{ return n . getTypeI () != null && isKnown ( n ) && invalidDeref ( n ) && ! isWhitelistedType ( n ) ; }
TypeI thrown = n . getFirstChild () . getTypeI () ;
{ super ( compiler , requirement ) ; errorObjType = compiler . getTypeIRegistry () . getGlobalType ( STRING_CONSTANT ) ; }
TemplateAstMatcher astMatcher = new TemplateAstMatcher ( compiler . getTypeIRegistry () , templateRoot , typeMatchingStrategy ) ;
FunctionTypeI restrictedCallType
FunctionTypeI restrictedCallType
FunctionTypeI functionType
TypeI type = n . getTypeI () ;
{ return isAssertionCall ( n . getParent () ) || n . getTypeIBeforeCast () != null ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isSomeUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return ( type == null || type . isUnknownType () ) ; }
{ TypeI type = n . getTypeI () ; return type != null && type . isTop () ; }
nativeObjectType = compiler . getTypeIRegistry () . getNativeType ( JSTypeNative.OBJECT_TYPE ) ;
n . setTypeI ( type ) ;
FunctionTypeI getterType
TypeIRegistry typeRegistry
public TypeSubject ( FailureMetadata failureMetadata , TypeI type ) { super ( failureMetadata , type ) ; }
TypeI type
FunctionTypeI getterType
builder . setTypeRegistry ( getTypeIRegistry () ) ;
StaticTypedScope < ? extends TypeI > scope
private String formatTypeVar ( TypeI var ) { return var . toAnnotationString ( Nullability.IMPLICIT ) ; }
TypeIRegistry registry
TypeI typeI = getPropLhs . getTypeI () ;
if ( n . getTypeI () == null ) { throw new IllegalStateException ( STRING_CONSTANT + n + STRING_CONSTANT + STRING_CONSTANT ) ; }
Builder ( TypeIRegistry registry ) { this . registry = registry ; }
ObjectTypeI objectType
@ Nullable ObjectTypeI referenceType
TypeI type = name . getTypeI () ;
TypeIRegistry typeRegistry
TypeI type
@ Override public JSType getReturnType () { return call.returnType ; }
TypeI type
TypeI type
TypeI type
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . addAllTypeMismatches ( compiler . getImplicitInterfaceUses () ) . build ()
TypeIRegistry registry
public void applySingletonGetter ( NominalTypeBuilder classType , FunctionTypeI getterType ) ;
Node assign = withType ( IR . assign ( copiedVarName , varName . removeFirstChild () ) , varName . getTypeI () ) . useSourceInfoFrom ( varName ) ;
Node newThis = withType ( context . getScopedName ( GENERATOR_THIS ) , n . getTypeI () ) ;
IR . returnNode ( withType ( IR . call ( createGenerator , withType ( genFuncName . cloneNode () , generatorFunction . getTypeI () ) , program ) , originalGenReturnType ) )
TypeIRegistry typeRegistry
TypeI type = n . getTypeI () ;
TypeIRegistry registry
TypeIRegistry registry
FunctionTypeI getterType
Node stringKey = withType ( IR . stringKey ( name , n . getFirstChild () . detach () ) , n . getTypeI () ) ;
this . registry = compiler . getTypeIRegistry () ;
ImmutableMap < String , TypeI > typeVars
TypeIRegistry registry
{ TypeI type = n . getTypeI () ; return ( type != null && type . isFunctionType () ) ; }
TypeI jsType
TypeI jsType
CodePrinter.Builder builder = new CodePrinter.Builder ( externsRoot ) . setPrettyPrint ( true ) . setOutputTypes ( true ) . setTypeRegistry ( compiler . getTypeIRegistry () ) ;
lit . setTypeI ( exportedObjectLit . getTypeI () ) ;
TemplateAstMatcher matcher = new TemplateAstMatcher ( lastCompiler . getTypeIRegistry () , templateRoot . getFirstChild () , typeMatchingStrategy ) ;
replacement . setTypeI ( call . getTypeI () ) ;
TypeI type = expr . getTypeI () ;
mathDotPowCall = withType ( IR . call ( mathPow . get () . cloneTree () , left , right ) , n . getTypeI () ) . useSourceInfoIfMissingFromForTree ( n )
TypeI type = n . getTypeI () ;
lastCompiler . getTypeIRegistry ()
lastCompiler . getTypeIRegistry ()
TypeI type
new InvalidatingTypes.Builder ( compiler . getTypeIRegistry () ) . disallowGlobalThis () . addTypesInvalidForPropertyRenaming () . addAllTypeMismatches ( compiler . getTypeMismatches () ) . build ()
TypeI type
TypeI receiverType = determineReceiverType ( n ) ;
this . registry = compiler . getTypeIRegistry () ;
TypeI type = n . getTypeI () ;
replacement . setTypeI ( getNativeStringType () ) ;
newName . setTypeI ( child . getTypeI () ) ;
@ Override public TypeI getType () { return null ; }
public Builder setTypeRegistry ( TypeIRegistry registry ) { this . registry = registry ; return this ; }
ObjectTypeI prototypeOrInstance ( ) ;
void declarePrototypeProperty ( String name , TypeI type , Node defSite ) ;
void declareInstanceProperty ( String name , TypeI type , Node defSite ) ;
void declareConstructorProperty ( String name , TypeI type , Node defSite ) ;
TypeI type
TypeI type = getType ( typeObj ) ;
TypeI type = getType ( obj ) ;
TypeI objlitType = getType ( n ) ;
TypeI type = getType ( n . getFirstChild () ) ;
return n . isGetProp () && n . getLastChild () . getString () . equals ( STRING_CONSTANT ) && n . getFirstChild () . getTypeI () . isStructuralInterface () ;
TypeI recvType = getType ( recv ) ;
TypeI type
TypeI type
ObjectTypeI objectType
ObjectTypeI objectType
TypeI type = n . getTypeI () ;
this . typeRegistry = compiler . getTypeIRegistry () ;
for ( Node n : nodeList ) { n.typei = ( TypeI ) in . readObject () ; }
for ( Node n : nodeList ) { out . writeObject ( n.typei ) ; }
dst . setTypeI ( this . typei ) ;
@ Nullable public final JSType getJSTypeBeforeCast () { return ( JSType ) getTypeIBeforeCast () ; }
@ Override public FunctionType getOwnerFunction () { return null ; }
TypeI type = firstArg . getTypeI () ;
@ Nullable TypeI typeI
n . getTypeI () == null
URI path
URI path
URI path
URI path
URI path
List < ? extends LocationMapping > sourceMapLocationMappings
{ locationMappings . add ( new SourceMap.PrefixLocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
URI path
URI path
public void setSourceMapLocationMappings ( List < ? extends SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
abstract MostRecentTypechecker getMostRecentTypechecker ( ) ;
this . compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
mostRecentTypechecker = compilerState.mostRecentTypeChecker ;
this . mostRecentTypeChecker = compiler.mostRecentTypechecker ;
compiler . setMostRecentTypechecker ( MostRecentTypechecker.OTI ) ;
{ this . compiler = compiler ; this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ; }
this . addTypes = MostRecentTypechecker.OTI . equals ( compiler . getMostRecentTypechecker () ) ;
if ( c . getString () . equals ( WINDOW_NAME ) ) { windowInExterns = true ; continue; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT , STRING_CONSTANT ) ;
{ super . setUp () ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.MISSING_OVERRIDE , CheckLevel.WARNING ) ; compiler . getOptions () . setWarningLevel ( DiagnosticGroups.STRICT_MISSING_PROPERTIES , CheckLevel.WARNING ) ; }
if ( prevUsedRenameMap != null ) { reusePreviouslyUsedVariableMap () ; }
if ( ! validator . expectIterable ( t , n , actualYieldType , STRING_CONSTANT ) ) { return; }
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
SymbolTable table = createSymbolTable ( STRING_CONSTANT ) ;
if ( c . getString () . equals ( STRING_CONSTANT ) ) { windowInExterns = true ; continue; }
public ModuleLoader.ResolutionMode getModuleResolutionMode () { return this . moduleResolutionMode ; }
ObjectType objectType
ObjectType objectType
if ( iterableType != null ) { typeParam = iterableType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ; }
JSType newType = objType . getTemplateTypeMap () . getResolvedTemplateType ( registry . getIterableTemplate () ) ;
defineSlot ( astParameter , functionNode , paramType , inferred ) ;
{ defineSlot ( fnNameNode , fnNode , fnNode . getJSType () , false ) ; }
if ( candidate . isGetProp () ) { defineSlot ( candidate , candidate . getParent () , getNativeType ( NO_TYPE ) , false ) ; }
defineSlot ( n , parent , valueType , inferred ) ;
if ( NodeUtil . isFunctionDeclaration ( n ) ) { defineSlot ( n . getFirstChild () , n , functionType ) ; }
{ boolean inferred = keyType == null ; defineSlot ( keyNode , objLit , qualifiedName , keyType , inferred ) ; }
! type . matchesNumberContext () && ! type . matchesStringContext () && ! type . matchesStringContext ()
FunctionType makeIteratorType = registry . createFunctionType ( ( JSType ) iteratorType , paramBuilder . build () ) ;
{ return isSubtype ( ( JSType ) that , ImplCache . createWithoutStructuralTyping () , SubtypingMode.NORMAL ) ; }
Path path
Path path
List < LocationMapping > sourceMapLocationMappings
public void setSourceMapLocationMappings ( List < SourceMap.LocationMapping > sourceMapLocationMappings ) { this . sourceMapLocationMappings = sourceMapLocationMappings ; }
Path path
Path path
Path path
{ locationMappings . add ( new SourceMap.LocationMapping ( mapping . getKey () , mapping . getValue () ) ) ; }
Path path
Path path
visitImport ( n ) ;
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
return dereferencePointer ( n . getFirstChild () , scope ) ;
return tightenTypeAfterDereference ( n . getFirstChild () , scope ) ;
{ testTypes ( DEFAULT_EXTERNS + STRING_CONSTANT + externs , js , description , false ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , diagnosticType , isError ) ; }
{ testTypes ( DEFAULT_EXTERNS , js , description , isError ) ; }
public void testGenerator_yieldAll_string () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_yieldAll1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_return2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_noDeclaredReturnType3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterator2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator_returnsIterable2 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testGenerator3 () { testTypes ( STRING_CONSTANT , lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject2 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_StringObject1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_string1 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_array3 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType6a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType5 () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testForOf_wrongLoopVarType4a () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
public void testArrayLitSpread () { testTypes ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
T getTypeOfThis ( ) ;
StaticTypedScope < JSType > scope
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . isTypeInferred () ; } return true ; }
{ if ( s instanceof StaticTypedScope ) { return ( ( StaticTypedScope < JSType > ) s ) . getTypeOfThis () ; } return null ; }
{ if ( sym instanceof StaticTypedSlot ) { return ( ( StaticTypedSlot < JSType > ) sym ) . getType () ; } return null ; }
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > typeEnv
StaticTypedScope < JSType > getDeclarationScope ( ) ;
FlowScope createChildFlowScope ( StaticTypedScope < JSType > scope ) ;
@ Override public T getTypeOfThis () { return null ; }
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedScope < JSType > scope
StaticTypedSlot < JSType > slot
StaticTypedScope < JSType > scope
@ Override StaticTypedScope < T > getScope ( ) ;
if ( n . isAssignAdd () ) { updateScopeForTypeChange ( scope , left , leftType , type ) ; }
visitParameterList ( t , n , functionType ) ;
visitParameterList ( t , n , fnType ) ;
lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT )
while ( current.parent != null && current.lastSlot == current.parent.lastSlot ) { current = current.parent ; }
n . isCall () || n . isYield ()
return dereferencePointer ( n . getFirstChild () , scope ) ;
updateTypeOfParameters ( n , fnType ) ;
updateTypeOfArguments ( n , fnType ) ;
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new EarlyEs6ToEs3Converter ( compiler ) ; }
updateTypeOfParameters ( n , fnType ) ;
if ( ! options.checksOnly ) { passes . add ( es6ForOf ) ; }
if ( isAliasDefinition ( decl ) ) { return; }
testWarning ( lines ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , ConvertToTypedInterface.CONSTANT_WITHOUT_EXPLICIT_TYPE ) ;
if ( n . isAssignAdd () ) { updateScopeForAssignment ( scope , left , leftType , type ) ; }
flowScope . inferSlotType ( STRING_CONSTANT , type ) ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
FlowScope blind = newScope () ;
child . inferSlotType ( STRING_CONSTANT , getNativeNumberType () ) ;
if ( this . optimizesToSameScope ( that ) ) { return true ; }
FlowScope output = input . createChildFlowScope ( scopeCreator . createScope ( root ) ) ;
FlowScope informed = blindScope . createChildFlowScope () ;
assign . useSourceInfoIfMissingFromForTree ( member ) ;
{ scope = traverse ( name . getFirstChild () , scope ) ; }
parentModuleCanSeeSymbolsDeclaredInChildren = false ;
List < String > moduleNameRegexList = options.modulesToPrintAfterEachPassRegexList ;
{ return new CrossModuleMethodMotion ( compiler , compiler . getCrossModuleIdGenerator () , options.removeUnusedPrototypePropertiesInExterns , options.crossModuleCodeMotionNoStubMethods ) ; }
{ return new CrossModuleCodeMotion ( compiler , compiler . getModuleGraph () , options.parentModuleCanSeeSymbolsDeclaredInChildren ) ; }
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new RescopeGlobalSymbols ( compiler , options.renamePrefixNamespace , options.renamePrefixNamespaceAssumeCrossModuleNames ) ; }
assertTrue ( REGEXP_TYPE . canBeCalled () ) ;
obj != null && obj . isPrototypeObject ()
return subtype . isBottom () ;
@ Override public boolean isVoidable () { return true ; }
@ Override public boolean isNullable () { return true ; }
@ Override public boolean isNoObjectType () { return false ; }
type . isEnumElement ()
type . isPrototypeObject ()
! callClassType . isBottom () && ! callClassType . isSomeUnknownType ()
type == null || type . isUnknownType () || type . isUnresolved () || type . isTop ()
return ! type . isTop () && ( type . isNullable () || type . isVoidable () ) ;
targetType . isUnknownType () || targetType . isUnresolved () || targetType . isTop () || targetType . isEquivalentTo ( registry . getNativeType ( JSTypeNative.OBJECT_TYPE ) )
{ JSType type = n . getJSType () . restrictByNotNullOrUndefined () ; return type . isBottom () ; }
{ JSType type = n . getJSType () ; return type != null && type . isTop () ; }
if ( ft != null ) { functionNode . setJSType ( ft . convertMethodToFunction () ) ; }
if ( body . isBottom () || body . isEquivalentTo ( getObjectType () ) ) { continue; }
return result . isBottom () ? getUnknownType () : result ;
if ( type . isEnumElement () ) { return type . getEnumeratedTypeOfEnumElement () ; }
return type != null && type . containsArray () ;
if ( objType . isPrototypeObject () ) { constructor = objType . getOwnerFunction () ; } else { constructor = objType . getConstructor () ; }
type . isEnumElement ()
{ return type . isEnumObject () || type . isBoxableScalar () ; }
if ( type . isEnumElement () ) { return getTypesToSkipForType ( type . getEnumeratedTypeOfEnumElement () ) ; }
if ( ! t . isObjectType () || t . isTop () ) { return; }
type . isTop () || type . isUnknownType ()
type . isTop () || type . isUnknownType ()
public boolean isAbstract () { return isAbstract ; }
return treatThisTypesAsCovariant ( other , implicitImplCache ) && this . call . isSubtype ( other.call , implicitImplCache , subtypingMode ) ;
public ObjectType getPrototypeProperty () { return getPrototype () ; }
public boolean isReturnTypeInferred () { return call.returnTypeInferred ; }
public JSType getReturnType () { return call.returnType ; }
@ Override public boolean canBeCalled () { return true ; }
public void setDict () { propAccess = PropAccess.DICT ; }
public void setStruct () { propAccess = PropAccess.STRUCT ; }
return restricted . isBottom () ? type : restricted ;
retType != null && ! retType . isBottom () && ! funType . isInterface ()
ObjectType getReferencedObjTypeInternal () { return referencedObjType ; }
JSType getReferencedTypeInternal () { return referencedType ; }
if ( ! receiverType . meetWith ( type ) . isBottom () ) { return true ; }
@ Override public boolean matchesSymbolContext () { return true ; }
@ Override public boolean matchesStringContext () { return true ; }
@ Override public boolean matchesObjectContext () { return true ; }
@ Override public boolean matchesNumberContext () { return true ; }
@ Override public boolean isConstructor () { return false ; }
if ( type == null || type . isUnknownType () || type . isTop () ) { return allowLooseMatches ? MatchResult.LOOSE_MATCH : MatchResult.NO_MATCH ; }
{ return type == null ? null : type . autoboxAndGetObject () ; }
propdef . setJSType ( null ) ;
visitImport ( t . getInput () . getPath () , n ) ;
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleMethodMotion ; }
@ Override public boolean isApplied ( CompilerOptions options ) { return options.crossModuleCodeMotion ; }
ensureTyped ( t , n ) ;
{ ensureTyped ( t , name , valueType ) ; }
ensureTyped ( t , n ) ;
ensureTyped ( t , n ) ;
ensureTyped ( t , n , type ) ;
ensureTyped ( t , iterableNode ) ;
if ( ! options.checksOnly ) { passes . add ( lateConvertEs6ToEs3 ) ; }
if ( recordUnresolvedTypes ) { unresolvedNamedTypes . put ( scope , namedType ) ; }
if ( topScope == null ) { regenerateGlobalTypedScope ( compiler , root . getParent () ) ; } else { compiler . getTypeRegistry () . resolveTypesInScope ( topScope ) ; }
{ whitespaceOnlyPasses () ; if ( options . needsTranspilationFrom ( FeatureSet.ES6 ) ) { transpileAndDontCheck () ; } }
FeatureSet features = ( FeatureSet ) script . getProp ( Node.FEATURE_SET ) ;
body . isNormalBlock () && ! body . hasChildren ()
{ return ( n . isNormalBlock () && n . isSyntheticBlock () ) || n . isScript () ; }
checkState ( block . isNormalBlock () ) ;
if ( ! block . isNormalBlock () ) { return null ; }
stmt . isEmpty () || ( stmt . isNormalBlock () && ! stmt . hasChildren () )
{ checkState ( expr . isName () ) ; checkState ( body . isNormalBlock () ) ; return new Node ( Token.CATCH , expr , body ) ; }
checkState ( finallyBody . isNormalBlock () ) ;
checkState ( tryBody . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; body . setIsAddedBlock ( true ) ; return new Node ( Token.DEFAULT_CASE , body ) ; }
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
checkState ( body . isNormalBlock () ) ;
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.WHILE , cond , body ) ; }
{ checkState ( body . isNormalBlock () ) ; checkState ( mayBeExpression ( cond ) ) ; return new Node ( Token.DO , body , cond ) ; }
{ checkState ( mayBeExpression ( cond ) ) ; checkState ( then . isNormalBlock () ) ; return new Node ( Token.IF , cond , then ) ; }
checkState ( body . isNormalBlock () || mayBeExpression ( body ) ) ;
checkState ( body . isNormalBlock () ) ;
if ( n . isExprResult () || n . isNormalBlock () ) { return; }
if ( ! favorsCommaOverSemiColon && ! block . isNormalBlock () ) { return false ; }
! n . isNormalBlock ()
{ checkArgument ( blockNode . isNormalBlock () ) ; if ( blockNode . hasChildren () ) { markAllPropsRead () ; } }
if ( n . isNormalBlock () ) { visitBlock ( n ) ; }
n . isNormalBlock ()
! target . getParent () . isScript () && ! target . getParent () . isNormalBlock () && ! target . getParent () . isModuleBody ()
boolean isVar = NodeUtil . isNameDeclaration ( parent ) && parent . getParent () . isNormalBlock () ;
isGoogScopeFunctionBody ( enclosingFunctionBody ) && scopeRoot . isNormalBlock () && ! scopeRoot . getParent () . isFunction ()
if ( ! n . isNormalBlock () || ! n . hasChildren () || ! isGoogModuleCall ( n . getFirstChild () ) ) { return false ; }
{ checkArgument ( n . isNormalBlock () ) ; return n . hasChildren () && n . getFirstChild () . isCatch () ; }
n . isNormalBlock ()
checkState ( addingRoot . isNormalBlock () || addingRoot . isModuleBody () || addingRoot . isScript () ) ;
{ return n . isNormalBlock () && n . getParent () != null && n . getParent () . isFunction () ; }
checkState ( block . isNormalBlock () ) ;
node . isNormalBlock ()
{ return n . isRoot () || n . isScript () || n . isNormalBlock () || n . isModuleBody () ; }
if ( ! block . isNormalBlock () ) { return false ; }
NodeUtil . isControlStructureCodeBlock ( n , c ) && ! c . isNormalBlock ()
checkState ( body . getNext () == null && body . isNormalBlock () , body ) ;
if ( ! n . isFunction () || ! n . getLastChild () . isNormalBlock () ) { return; }
if ( ! subtree . isScript () && ! subtree . isNormalBlock () ) { return subtree ; }
checkState ( n . isNormalBlock () , n ) ;
statement . isNormalBlock ()
if ( ! n . isNormalBlock () || ! n . hasChildren () ) { return; }
block . isNormalBlock () && block . getParent () . isTry () && block . getParent () . getFirstChild () == block
if ( parent . getParent () != null && parent . getParent () . isArrowFunction () && ! parent . isNormalBlock () ) { return false ; }
{ return getRootNode () . isNormalBlock () && getRootNode () . hasOneChild () && getRootNode () . getFirstChild () . isCatch () ; }
checkState ( block . isNormalBlock () ) ;
for ( Node child : node . children () ) { if ( child . isNormalBlock () ) { blocks . add ( child ) ; } }
n . isNormalBlock () && ! loneBlocks . isEmpty () && loneBlocks . peek () == n
( parent . isScript () || ( parent . isNormalBlock () && ! parent . isSyntheticBlock () && ! parent . isAddedBlock () ) )
scopeRoot . isNormalBlock () && scopeRoot . getParent () . isFunction ()
! setFunction . hasChildren () || ! setFunction . getLastChild () . isNormalBlock () || ! setFunction . getSecondChild () . isParamList ()
if ( ! getFunction . hasChildren () || ! getFunction . getLastChild () . isNormalBlock () ) { return false ; }
for ( ; ! currentParent . isScript () && ! currentParent . isNormalBlock () ; current = currentParent , currentParent = currentParent . getParent () ) {}
n . isFunction () && parent != null && parent . isNormalBlock () && ! parent . getParent () . isFunction ()
! n . getParent () . isScript () && ! n . getParent () . isNormalBlock ()
if ( body . isNormalBlock () ) { validateBlock ( body ) ; } else { validateExpression ( body ) ; }
{ return n . isNormalBlock () && n . hasChildren () && isReturnTypeNullable ( n . getParent () ) && ! hasSingleThrow ( n ) ; }
if ( n . isEmpty () || ( n . isNormalBlock () && ! n . hasChildren () ) ) { return; }
next != null && next . isNormalBlock ()
checkArgument ( node . isNormalBlock () ) ;
node . isFunction () && ! NodeUtil . getFunctionBody ( node ) . isNormalBlock ()
! originalBody . isNormalBlock ()
block . isNormalBlock ()
checkState ( body . isNormalBlock () , body ) ;
checkState ( block . isNormalBlock () ) ;
checkState ( jumpBlock . isNormalBlock () ) ;
checkState ( block . isNormalBlock () ) ;
checkState ( catchBody . isNormalBlock () ) ;
context . transpileUnmarkedBlock ( n . isNormalBlock () || n . isAddedBlock () ? n : IR . block ( n ) ) ;
checkState ( newGeneratorHoistBlock . isNormalBlock () , newGeneratorHoistBlock ) ;
{ return node . getParent () . isExprResult () && node . getGrandparent () . isNormalBlock () && isClinitMethod ( node . getGrandparent () . getParent () ) ; }
! ( parent . isScript () || ( grandparent != null && grandparent . isFunction () && parent . isNormalBlock () ) )
! body . isNormalBlock () || body . hasChildren ()
if ( ! body . isNormalBlock () || ! body . hasOneChild () || ! body . getFirstChild () . isReturn () ) { return; }
! isArrow && ! isSignature && ! bodyNode . isNormalBlock ()
! irNode . isNormalBlock ()
n . isFunction () && n . getParent () . isNormalBlock () && ! n . getGrandparent () . isFunction ()
checkState ( ifBlock . isNormalBlock () , ifBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( innerBlock . isNormalBlock () , innerBlock ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
checkState ( block . isNormalBlock () , block ) ;
{ Node functionBody = NodeUtil . getFunctionBody ( n ) ; if ( ! functionBody . isNormalBlock () ) { return; } }
if ( node . isNormalBlock () ) { node . setToken ( Token.SCRIPT ) ; }
deleteWhitespaceBefore && parent != null && ( parent . isScript () || parent . isNormalBlock () )
checkState ( parentNode . isNormalBlock () , STRING_CONSTANT ) ;
parent != null && ( parent . isNormalBlock () || parent . isScript () )
if ( ! n . isScript () && ! n . isNormalBlock () ) { return; }
! body . isNormalBlock ()
! body . isNormalBlock ()
s . isFunctionScope () && s . getRootNode () . getLastChild () . isNormalBlock ()
n . isFunction () && ! NodeUtil . getFunctionBody ( n ) . isNormalBlock ()
c . isNormalBlock ()
c . isNormalBlock ()
checkState ( caseBody . isNormalBlock () , caseBody ) ;
! labeledStatement . isNormalBlock ()
last . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
n . isNormalBlock ()
if ( newChild . isNormalBlock () ) { NodeUtil . tryMergeBlock ( newChild , false ) ; }
JSType calleeTypeI = checkNotNull ( callee . getJSType () , callNode ) ;
assertFalse ( numbers . isSubtype ( EVAL_ERROR_TYPE ) ) ;
if ( ! languageOutIsAtLeast ( polyfill.polyfillVersion ) ) { traversal . report ( node , INSUFFICIENT_OUTPUT_VERSION_ERROR , name , compiler . getOptions () . getLanguageOut () . toString () ) ; }
if ( options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { passes . add ( optimizeToEs6 ) ; }
if ( options.dartPass && ! options . getLanguageOut () . toFeatureSet () . contains ( ES6 ) ) { checks . add ( dartSuperAccessorsPass ) ; }
checkState ( options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES5 ) , STRING_CONSTANT ) ;
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
FeatureSet languageOutFeatures = compiler . getOptions () . getLanguageOut () . toFeatureSet () ;
if ( ! options . getLanguageOut () . toFeatureSet () . contains ( FeatureSet.ES5 ) ) { throw new InvalidOptionsException ( STRING_CONSTANT ) ; }
{ if ( incrementalCheckMode == IncrementalCheckMode.GENERATE_IJS ) { return false ; } return this . quoteKeywordProperties || languageOut == LanguageMode.ECMASCRIPT3 ; }
{ return getLanguageIn () . toFeatureSet () . has ( feature ) && ! getLanguageOut () . toFeatureSet () . has ( feature ) ; }
{ return getLanguageIn () . toFeatureSet () . contains ( languageLevel ) && ! getLanguageOut () . toFeatureSet () . contains ( languageLevel ) ; }
{ checkState ( language != LanguageMode.NO_TRANSPILE ) ; this . languageIn = language ; this . languageOut = language ; }
{ if ( outputTypes ) { return Format.TYPED ; } if ( prettyPrint || options . getLanguageOut () == LanguageMode.ECMASCRIPT6_TYPED ) { return Format.PRETTY ; } return Format.COMPACT ; }
public void testArrowception () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testArrowFunctionInObject () { test ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ this . compiler = compiler ; this . thisContextStack = new ArrayDeque <> () ; }
private LocalScopeBuilder ( TypedScope scope ) { super ( scope ) ; thisTypeForProperties = getThisTypeForCollectingProperties () ; }
assertThat ( compiler . hasErrors () ) . isFalse () ;
{ if ( inTypeSummary ( error ) ) { return CheckLevel.WARNING ; } return null ; }
{ this . outputFeatureSet = featureSet ; }
@ JsOverlay public final List < T > asList () { return new JsArrayList < T > ( this ) ; }
{ objectSet ( this , key , value ) ; return this ; }
@ Override protected HotSwapCompilerPass create ( final AbstractCompiler compiler ) { return new Es7ToEs6Converter ( compiler ) ; }
GlobalScopeBuilder ( TypedScope scope ) { super ( scope ) ; }
GlobalScopeBuilder scopeBuilder = new GlobalScopeBuilder ( globalScope ) ;
{ return new ModulePath ( normalize ( ModuleNames . escapePath ( pathResolver . apply ( path ) ) , moduleRootPaths ) ) ; }
visitImport ( n ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
String path = ModuleNames . escapePath ( moduleAddress ) ;
private void skipOctalDigits () { while ( isOctalDigit ( peekChar () ) ) { nextChar () ; } }
if ( ! currentInfo . isConstant () ) { currentInfo . setConstant ( true ) ; populated = true ; return true ; } else { return false ; }
assertThat ( jsdoc . isConstant () ) . isFalse () ;
isConst = nameNode . getParent () . isConst () || isExportLhs ( nameNode ) || ( jsdoc != null && jsdoc . hasConstAnnotation () )
final Token type
final String name
final String name
return parent == null || ! NodeUtil . createsScope ( n ) ;
JSType ownerType
{ currentModule . setModuleType ( ModuleType.COMMON_JS , t , n ) ; return; }
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . isEmpty () ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
assertThat ( m . getGoogNamespaces () ) . containsExactly ( STRING_CONSTANT ) ;
@ Nullable JSType ownerType
return shouldDescend ( n , parent ) ;
Token type
String name
String name
assertTypeEquals ( registry . createOptionalType ( STRING_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ;
{ JSDocInfo info = parse ( STRING_CONSTANT ) ; assertTypeEquals ( registry . createOptionalType ( NUMBER_TYPE ) , info . getParameterType ( STRING_CONSTANT ) ) ; }
{ expandObjectLitAssignment ( t , root , export.scope ) ; return; }
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ validator . expectStringOrNumber ( t , n , leftType , STRING_CONSTANT ) ; }
return parent == null || ! NodeUtil . createsScope ( n ) ;
final Token type
final String name
final String name
JSType ownerType
@ JsMethod ( namespace = STRING_CONSTANT )
@ JsMethod ( name = STRING_CONSTANT , namespace = STRING_CONSTANT )
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , es6ModuleTranspiler , newMode , sourceUrl , path , sourceMapCache ) ; }
{ EvalMode newMode = useEval ? EvalMode.EVAL : EvalMode.NORMAL ; return new ClosureBundler ( transpiler , newMode , sourceUrl , path , sourceMapCache ) ; }
Node restRhs = newName ( this . rhsResultName ) ;
{ int baseHash = super . hashCode () ; if ( templateTypes . isEmpty () ) { return baseHash ; } return Objects . hash ( templateTypes , baseHash ) ; }
{ NodeTraversal . traverse ( compiler , rootNode , new CoverageInstrumentationCallback ( compiler , instrumentationData , reach ) ) ; }
abstract ImmutableSet.Builder < String > es6ImportSpecifiersBuilder ( ) ;
abstract ImmutableSet.Builder < String > requiredTypesBuilder ( ) ;
abstract ImmutableSet.Builder < String > googNamespacesBuilder ( ) ;
public void testSettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden4 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden3 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
public void testGettersForbidden2 () { parseError ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ super . setUp () ; mode = LanguageMode.ECMASCRIPT3 ; strictMode = SLOPPY ; isIdeMode = false ; expectedFeatures = FeatureSet.BARE_MINIMUM ; }
testWarning ( STRING_CONSTANT , MISPLACED_ANNOTATION ) ;
validateDefaultValue ( n , info ) ;
options . setTranspileEs6ModulesToCjsModules ( true ) ;
@ Override public boolean isVarArgsParameter ( Node parameter ) { return parameter . isVarArgs () ; }
{ if ( ! isParsed () ) { parse ( compiler ) ; root . setInputId ( inputId ) ; } return root ; }
this . root = root ;
Node originalRoot = input . getAstRoot ( this ) ;
return input . getAstRoot ( this ) ;
findDeps . process ( input . getAstRoot ( this ) ) ;
Node root = input . getAstRoot ( this ) ;
return root ;
if ( ! options.checksOnly ) { passes . add ( es6RewriteRestAndSpread ) ; }
{ matchedNodeInfo = MatchedNodeInfo . create ( node , isInClosurizedFile ( node , new NodeMetadata ( compiler ) ) ) ; return this ; }
validateRest ( type , c ) ;
validateRest ( type , c ) ;
{ validateRest ( Token.PARAM_LIST , c ) ; }
public void disabled_testForOf4 () { testTypes ( STRING_CONSTANT ) ; }
AbstractCommandLineRunner () { this ( System.in , System.out , System.err ) ; }
boolean shouldDeclareOnGlobalThis = isGlobalVar && ( NodeUtil . isNameDeclaration ( parent ) || parent . isFunction () ) ;
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
JSType maybeThisType = info . getThisType () . evaluate ( templateScope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( templateScope , typeRegistry ) ; returnTypeInferred = false ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . processTranspile ( compiler , root , transpiledFeatures , new GeneratorFunctionsTranspiler () ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
{ TranspilationPasses . hotSwapTranspile ( compiler , scriptRoot , transpiledFeatures , this ) ; TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ; }
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , transpiledFeatures ) ;
if ( ! compiler . hasHaltingErrors () ) { TranspilationPasses . markFeaturesAsTranspiledAway ( compiler , features ) ; }
checkState ( source . isFunction () , source ) ;
JSType returnType = explicitReturnExpected ( n ) ;
@ Override protected CompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteImportPaths ( compiler ) ; }
case RESOLVE_IMPORT_PATHS :
SourceFile expectedEs6 = SourceFile . fromCode ( STRING_CONSTANT , STRING_CONSTANT ) ;
@ Override protected HotSwapCompilerPass create ( AbstractCompiler compiler ) { return new Es6RewriteClass ( compiler , true ) ; }
public void testSpreadLibInjection () { testSame ( STRING_CONSTANT ) ; assertThat ( getLastCompiler () . injected ) . containsExactly ( STRING_CONSTANT ) ; }
{ JSType referencedType = getReferencedType () ; if ( referencedType == this ) { handleTypeCycle ( reporter ) ; } }
if ( this == that ) { return true ; }
public final boolean isGlobalThisType () { return this == registry . getNativeType ( JSTypeNative.GLOBAL_THIS ) ; }
public final boolean isUnresolvedOrResolvedUnknown () { return isNoResolvedType () || isNamedType () && isUnknownType () ; }
assertTrue ( objectType . getImplicitPrototype () == OBJECT_TYPE ) ;
defineVar ( n ) ;
defineVars ( n ) ;
if ( context . isAsyncContext () ) { convertAsyncFunction ( context ) ; }
JSType maybeThisType = info . getThisType () . evaluate ( scope , typeRegistry ) . restrictByNotNullOrUndefined () ;
if ( returnTypeExpr != null ) { returnType = returnTypeExpr . evaluate ( scope , typeRegistry ) ; returnTypeInferred = false ; }
VerifyingRecorderTest . class
stub ( mock . simpleMethod () ) . andThrows ( new RuntimeException () ) ;
state . verifyingStarted ( VerifyingMode . atLeastOnce () ) ;
VerifyingMode mode
{ return verify ( mock , VerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
{ stub ( mock . simpleMethod () ) . andThrows ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrows ( new Exception () ) ; }
VerifyingModeTest . class
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrows ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( error ) ;
stub ( reader . read () ) . andThrows ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrows ( expected ) ;
assertNull ( Mockito.mockitoState . pullControlToBeStubbed () ) ;
< T > T verify ( T mock , VerifyingMode verifyingMode ) ;
assertNull ( Mockito.mockitoState . pullStubable () ) ;
MockitoStateImpl state = new MockitoStateImpl () ;
MockitoStateImplTest . class
{ mockitoState . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
public void addReturnValue ( Object value ) { mockitoState . stubbingCompleted () ; addResult ( Result . createReturnResult ( value ) ) ; }
state = new MockitoStateImpl () ;
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockitoState . stubbingStarted () ; return control ; }
mockitoState . validateState () ;
mockitoState . validateState () ;
{ MockUtil . validateMock ( mock ) ; mockitoState . verifyingStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockitoState , new MatchersBinder () ) ;
verifyingRecorder . recordInvocation ( invocationMatcher ) ;
verifyingRecorder = new VerifyingRecorder < T > ( new AllInvocationsFinder () ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder () ) ; }
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionIsExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
void verify ( RegisteredInvocations registeredInvocations , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
@ Test ( expected = VerificationError . class )
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . oneArg ( true ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
try { strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( NumberOfInvocationsError e ) {}
@ Test ( expected = NumberOfInvocationsError . class )
@ Test ( expected = NumberOfInvocationsError . class )
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
List < Invocation > chunk = chunker . getFirstUnverifiedInvocationChunk () ;
verifyingRecorder = new VerifyingRecorder < T > () ;
InvocationsCalculator calculator = new InvocationsCalculatorImpl ( invocations ) ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
Invocation differentMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
simpleMethod = new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ;
OngoingVerifyingModeTest . class
< T > T verify ( T mock , OngoingVerifyingMode ongoingVerifyingMode ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ) ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode = OngoingVerifyingMode . atLeastOnce () ;
OngoingVerifyingMode mode
OngoingVerifyingMode mode
public void reset () { stubbingInProgress = false ; ongoingVerifyingMode = null ; invocationSequenceNumber = NUMBER_CONSTANT ; }
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , OngoingVerifyingMode mode ) ;
OngoingVerifyingMode mode
{ return verify ( mock , OngoingVerifyingMode . times ( wantedNumberOfInvocations ) ) ; }
OngoingVerifyingMode mode
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
{ calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = calculator . getFirstUndesiredInvocationStackTrace ( new InvocationMatcher ( simpleMethodInvocation ) , OngoingVerifyingMode . times ( NUMBER_CONSTANT ) ) ;
{ if ( mode . orderOfInvocationsMatters () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
public boolean orderOfInvocationsMatters () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
if ( i . isVerifiedInOrder () ) { continue; }
for ( Object mock : mocks ) { MockUtil . validateMock ( mock ) ; strictOrderVerifier . addMockToBeVerifiedInOrder ( mock ) ; }
List < Verifier > verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier () ) ;
if ( unverified != null ) { Exceptions . zeroInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( unverified != null ) { Exceptions . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
if ( ! mocksToBeVerifiedSrictly . contains ( mock ) ) { Exceptions . strictlyRequiresFamiliarMock () ; }
if ( mocks.length == NUMBER_CONSTANT ) { Exceptions . mocksHaveToBePassedWhenCreatingStrictly () ; }
if ( stubable == null ) { Exceptions . missingMethodInvocation () ; }
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( wanted ) ) { return s . getResult () . answer () ; } }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable ) ) ; }
InvocationsCalculator calculator1 = new InvocationsCalculator ( getInvocationsForEvaluation ( VerificationMode . times ( NUMBER_CONSTANT ) ) ) ;
Result result
assertThat ( chunk , collectionHasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
VerificationMode mode = VerificationMode . strict ( NUMBER_CONSTANT , Arrays . < Object > asList ( STRING_CONSTANT ) ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
{ strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockTwo , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
{ strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; }
strictly . verify ( two , NUMBER_CONSTANT ) . simpleMethod ( NUMBER_CONSTANT ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
strictly . verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
verify ( mockOne , NUMBER_CONSTANT ) . varargsObject ( NUMBER_CONSTANT , textOne , textOne ) ;
verify ( mockOne , NUMBER_CONSTANT ) . simpleMethod ( textOne ) ;
Mockito . verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
{ Mockito . verify ( mock , NUMBER_CONSTANT ) . clear () ; fail () ; }
verify ( list , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
verify ( mock , NUMBER_CONSTANT ) . add ( STRING_CONSTANT ) ;
verify ( map , NUMBER_CONSTANT ) . put ( anyObject () , anyObject () ) ;
verify ( mock , NUMBER_CONSTANT ) . oneArg ( two ) ;
{ return new VerificationMode ( wantedNumberOfInvocations , mocksToBeVerifiedStrictly ) ; }
assertNotNull ( STRING_CONSTANT , verifier.calculator ) ;
assertNotNull ( STRING_CONSTANT , verifierStub.calculator ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.calculator . getInvocations () , collectionHasExactlyInOrder ( simpleMethod ) ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
verifier . verify ( calculatorStub , wanted , mode ) ;
void verify ( InvocationsCalculator calculator , InvocationMatcher wanted , VerificationMode mode ) ;
verifiers = Arrays . asList ( new MissingInvocationVerifier () , new NumberOfInvocationsVerifier ( new Reporter () ) , new NoMoreInvocationsVerifier () )
{ this . invocations = invocations ; return returnedByCalculator ; }
{ returnedByCalculator = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
{ VerificationMode . times ( - NUMBER_CONSTANT ) ; fail () ; }
if ( mode . numberOfInvocationsMode () ) { return; }
if ( mode . isStrict () ) { markVerifiedStrictly ( invocations ) ; } else { markVerified ( wanted , invocations ) ; }
{ if ( mode . isStrict () ) { return chunker . getFirstUnverifiedInvocationChunk ( mode . getAllMocksToBeVerifiedInSequence () ) ; } else { return registeredInvocations ; } }
if ( mode . isExplicit () ) { marker . markInvocationsAsVerified ( invocations , wanted , mode ) ; }
if ( mode . isExplicit () ) { return; }
public boolean exactNumberOfInvocationsMode () { return ! atLeastOnceMode () && isExplicit () ; }
public boolean missingMethodMode () { return isExplicit () && ( atLeastOnceMode () || wantedInvocationCount == NUMBER_CONSTANT ) ; }
public boolean isExplicit () { return verification == Verification.EXPLICIT ; }
public boolean isStrict () { return ! mocksToBeVerifiedInSequence . isEmpty () ; }
public boolean atLeastOnceMode () { return wantedInvocationCount == null ; }
assertNull ( Mockito.mockingProgress . pullStubable () ) ;
if ( mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedWhenCreatingStrictly () ; }
{ MockControl < T > control = MockUtil . getControl ( mock ) ; mockingProgress . stubbingStarted () ; return control ; }
{ MockUtil . validateMock ( mock ) ; mockingProgress . verificationStarted ( mode ) ; return mock ; }
MockControl < T > mockControl = new MockControl < T > ( mockingProgress , new MatchersBinder () ) ;
public void say ( String message ) ;
public void say ( Object message ) ;
public boolean withBooleanVarargs ( int value , boolean . . . b ) ;
public String throwsError ( int count ) throws Error ;
public String throwsIOException ( int count ) throws IOException ;
public String throwsNothing ( boolean value ) ;
{ throw new IllegalStateException ( STRING_CONSTANT ) ; }
MockControlTest . class
@ Test ( expected = MockitoException . class ) public void shouldScreamWhenNullPassed () { getControl ( null ) ; }
@ Test ( expected = NotAMockException . class ) public void shouldScreamWhenNotAMockPassed () { getControl ( STRING_CONSTANT ) ; }
try { getControl ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List < Invocation > invocationsOfSingleMock = MockUtil . getControl ( mock ) . getRegisteredInvocations () ; allInvocations . addAll ( invocationsOfSingleMock ) ; }
for ( Object mock : mocks ) { MockUtil . getControl ( mock ) . verifyNoMoreInteractions () ; }
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( VerificationError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
VerificationError e
VerificationError e
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError e ) {}
{ UndesiredInvocation cause = buildUndesiredInvocationCause ( actualInvocationStackTrace , STRING_CONSTANT , undesired ) ; throw new VerificationError ( join ( STRING_CONSTANT ) , cause ) ; }
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( VerificationError expected ) {}
Invocation actual = calculator . findActualInvocation ( invocations , wanted ) ;
int actualCount = calculator . countActual ( invocations , wanted ) ;
public MissingInvocationVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
Invocation unverified = calculator . getFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsCalculator () , new Reporter () ) ; }
{ verifier . verify ( invocations , wanted , times ( NUMBER_CONSTANT ) ) ; assertSame ( wanted , calculatorStub.wanted ) ; }
@ Test public void shouldPassBecauseActualInvocationFound () { calculatorStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
{ calculator.invocationToReturn = null ; verifier . verify ( null , null , VerificationMode . noMoreInteractions () ) ; }
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsCalculator () ) ; }
return actualbyName != null ? actualbyName : getFirstUnverified ( invocations ) ;
Invocation unverified = analyzer . getFirstUnverified ( invocations ) ;
{ verify ( sub ) . say ( CrazyMatchers . contains ( STRING_CONSTANT ) ) ; fail () ; }
mockingProgress . reportStubable ( this ) ;
OngoingStubbing pullStubable ( ) ;
void reportStubable ( OngoingStubbing ongoingStubbing ) ;
VerificationModeTest . class
VerificationMode mode
state . verificationStarted ( VerificationMode . atLeastOnce () ) ;
VerificationMode verificationMode = mockingProgress . pullVerificationMode () ;
VerificationMode mode
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode
public void verify ( VerificationMode mode ) { verify ( null , mode ) ; }
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationMode mode ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationMode . atLeastOnce () ) ;
verifier . verify ( invocations , null , VerificationMode . noMoreInteractions () ) ;
{ return VerificationMode . times ( wantedNumberOfInvocations ) ; }
{ return VerificationMode . atLeastOnce () ; }
VerificationMode mode = VerificationMode . times ( NUMBER_CONSTANT ) ;
VerificationMode mode
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
{ analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ; }
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
HasStackTrace firstUndesired = analyzer . findFirstUndesiredInvocationTrace ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , VerificationMode . times ( NUMBER_CONSTANT ) ) ;
VerificationMode mode
VerificationMode mode
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
{ VerificationMode mode = VerificationMode . noMoreInteractions () ; recorder . verify ( mode ) ; assertNull ( markerStub.mode ) ; }
VerificationMode mode = new VerificationModeBuilder () . strict () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode = VerificationMode . atLeastOnce () ;
VerificationMode mode
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ setStackTrace ( STRING_CONSTANT ) ; setCauseStackTrace ( STRING_CONSTANT ) ; remove () ; assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder () ) ; }
three . simpleMethod () ;
public VerificationModeImpl strict () { return VerificationModeImpl . strict ( null , Arrays . asList ( new Object () ) ) ; }
assertEquals ( verifierStub.mode , mode ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () ) ; }
{ analyzerStub.actualCountToReturn = NUMBER_CONSTANT ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
catch ( TooLittleActualInvocationsError e ) {}
StackTrackeFilteringTest . class
{ Mockito . verify ( mock , times ( NUMBER_CONSTANT ) ) . clear () ; fail () ; }
@ Before public void setup () { mock = Mockito . mock ( LinkedList . class ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
VerificationError e
TooManyActualInvocationsError e
TooLittleActualInvocationsError e
try { verify ( mock ) . oneArg ( same ( three ) ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
VerificationError e
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verifyNoMoreInteractions ( mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWantedError e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mockTwo ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
@ Test ( expected = VerificationError . class )
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mockOne , mockTwo , mockThree ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerificationError . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooManyActualInvocationsError e ) {}
catch ( TooLittleActualInvocationsError e ) {}
@ Test ( expected = TooLittleActualInvocationsError . class )
@ Test ( expected = TooManyActualInvocationsError . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError error
try { verifyZeroInteractions ( map ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
{ mock . clear () ; try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
{ mock . clear () ; try { verifyZeroInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {} }
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooLittleActualInvocationsError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
throw new NoInteractionsWantedError ( join ( STRING_CONSTANT ) , cause ) ;
public void wantedButNotInvoked ( String wanted ) { throw new VerificationError ( join ( STRING_CONSTANT , wanted ) ) ; }
throw new VerificationError ( join ( STRING_CONSTANT , STRING_CONSTANT , wanted ) , cause ) ;
wantedInvocation . matchesMockArgsAndMethodNameButMethodNotEqual ( actualInvocation )
try { verify ( mock ) . clear () ; fail () ; } catch ( TooManyActualInvocationsError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError expected ) {}
@ Test ( expected = VerificationError . class ) public void shouldFailVerification ( ) throws Exception { verify ( mock ) . clear () ; }
catch ( VerificationError e ) {}
try { verifyNoMoreInteractions ( mock ) ; fail () ; } catch ( NoInteractionsWantedError e ) {}
catch ( VerificationError e ) {}
catch ( VerificationError e ) {}
try { strictly . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerificationError e ) {}
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
@ Test ( expected = VerificationError . class )
try { verify ( mockTwo , atLeastOnce () ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerificationError e ) {}
TooLittleActualInvocationsError e
TooManyActualInvocationsError e
TooManyActualInvocationsError e
VerificationError e
VerificationError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
NoInteractionsWantedError e
NoInteractionsWantedError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
VerificationError e
catch ( VerificationError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( TooManyActualInvocations e ) {}
try { strictly . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
chunked = chunker . chunk ( Collections . < Integer > emptyList () , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
List < ObjectsChunk < Integer > > chunked = chunker . chunk ( asList ( NUMBER_CONSTANT ) , new EqualitySeer () ) ;
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
chunked = chunker . chunk ( asList ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new EqualitySeer () )
catch ( InvocationDiffersFromActual e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
try { strictly . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { strictly . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = InvocationDiffersFromActual . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
catch ( TooLittleActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) {}
catch ( TooLittleActualInvocations e ) {}
@ Test ( expected = TooLittleActualInvocations . class )
@ Test ( expected = TooManyActualInvocations . class )
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { strictly . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual e ) {}
strictly . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ;
public NumberOfInvocationsVerifier () { this ( new Reporter () , new InvocationsAnalyzer () , new ActualInvocationsFinder () ) ; }
public boolean strictMode () { return ! mocksToBeVerifiedStrictly . isEmpty () ; }
Invocation unverified = analyzer . findFirstUnverified ( invocations ) ;
public NoMoreInvocationsVerifier () { this ( new InvocationsAnalyzer () , new Reporter () ) ; }
{ Invocation similar = analyzer . findSimilarInvocation ( invocations , wanted , mode ) ; reportMissingInvocationError ( wanted , similar ) ; }
public MissingInvocationVerifier () { this ( new InvocationsAnalyzer () , new ActualInvocationsFinder () , new Reporter () ) ; }
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
List < Invocation > chunk = finder . findFirstStrictlyUnverified ( invocations , wanted ) ;
{ analyzer.invocationToReturn = null ; verifier . verify ( null , null , VerificationModeImpl . noMoreInteractions () ) ; }
analyzerStub.similarToReturn = actualInvocation ;
analyzerStub.similarToReturn = null ;
{ verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ; assertSame ( invocations , analyzerStub.invocations ) ; }
finderStub = new ActualInvocationsFinderStub () ;
ActualInvocationsFinder finder
public MissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public StrictlyNumberOfInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public StrictlyMissingInvocationVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
if ( mode . strictMode () ) { invocations = invocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedStrictly () ) ; } else { invocations = registeredInvocations ; }
ActualInvocationsFinder finder
public NoMoreInvocationsVerifier () { this ( new ActualInvocationsFinder () , new Reporter () ) ; }
ActualInvocationsFinder finder
public NumberOfInvocationsVerifier () { this ( new Reporter () , new ActualInvocationsFinder () ) ; }
finderStub = new ActualInvocationsFinderStub () ;
finder = new ActualInvocationsFinderStub () ;
List < Object > mocksToBeVerifiedStrictly
List < Object > mocksToBeVerifiedStrictly
HasStackTrace lastInvocation = getLastSafely ( chunk ) ;
HasStackTrace lastInvocation = getLastSafely ( actualInvocations ) ;
stub ( mock . oneArg ( anyString () ) ) . andReturn ( STRING_CONSTANT ) ;
mockingProgress . reportStubbable ( this ) ;
{ stub ( mock . simpleMethod () ) . andThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . andThrow ( new Exception () ) ; }
stub ( mock . booleanReturningMethod ( NUMBER_CONSTANT ) ) . andReturn ( true ) ;
OngoingStubbing pullStubbable ( ) ;
void reportStubbable ( OngoingStubbing ongoingStubbing ) ;
return handler ;
stub ( mock . simpleMethod () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andReturn ( Boolean.FALSE ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . andThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( error ) ;
stub ( reader . read () ) . andThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . andThrow ( expected ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( null ) ; fail () ; }
{ createStrictOrderVerifier () ; fail () ; }
Strictly strictly = createStrictOrderVerifier ( mock ) ;
{ Strictly strictly = createStrictOrderVerifier ( mock ) ; strictly . verify ( mockTwo ) . simpleMethod () ; }
@ Test ( expected = MockitoException . class ) public void shouldNotCreateStrictlyWithoutMocks () { createStrictOrderVerifier () ; }
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockDatabase ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
strictly = createStrictOrderVerifier ( mock , mockTwo ) ;
strictly = createStrictOrderVerifier ( one , two , three ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne ) ;
strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mockOne , mockTwo , mockThree ) ;
Strictly strictly = createStrictOrderVerifier ( mock ) ;
Object argument
Object actual
{ for ( IArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
public Not ( IArgumentMatcher first ) { this . first = first ; }
{ for ( IArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < IArgumentMatcher > matchers ) { this . matchers = matchers ; }
List < IArgumentMatcher > matchers
public void reportMatcher ( IArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; }
List < IArgumentMatcher > matchers
List < IArgumentMatcher > matchers
return findFirstUnverified ( invocations , wanted . getInvocation () . getMock () ) ;
{ return LastArguments . instance () . reportMatcher ( matcher ) . < T > nullValue () ; }
{ return LastArguments . instance () . reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
public static String anyString () { isA ( String . class ) ; return null ; }
{ return reportMatcher ( matcher ) . < T > nullValue () ; }
public static double doubleThat ( CustomMatcher < Double > matcher ) { return reportMatcher ( matcher ) . doubleValue () ; }
public static float floatThat ( CustomMatcher < Float > matcher ) { return reportMatcher ( matcher ) . floatValue () ; }
public static long longThat ( CustomMatcher < Long > matcher ) { return reportMatcher ( matcher ) . longValue () ; }
public static int intThat ( CustomMatcher < Integer > matcher ) { return reportMatcher ( matcher ) . intValue () ; }
public static short shortThat ( CustomMatcher < Short > matcher ) { return reportMatcher ( matcher ) . shortValue () ; }
public static byte byteThat ( CustomMatcher < Byte > matcher ) { return reportMatcher ( matcher ) . byteValue () ; }
public static boolean booleanThat ( CustomMatcher < Boolean > matcher ) { return reportMatcher ( matcher ) . booleanValue () ; }
public static char charThat ( CustomMatcher < Character > matcher ) { return reportMatcher ( matcher ) . charValue () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > nullValue () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > nullValue () ; }
public static Object notNull () { return reportMatcher ( NotNull.NOT_NULL ) . nullValue () ; }
public static Object isNull () { return reportMatcher ( Null.NULL ) . nullValue () ; }
{ return reportMatcher ( new Same ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . nullValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . shortValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . longValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . intValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . floatValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . doubleValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . charValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . byteValue () ; }
{ return reportMatcher ( new Equals ( value ) ) . booleanValue () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . nullValue () ; }
public static Object anyObject () { return reportMatcher ( Any.ANY ) . nullValue () ; }
public static short anyShort () { return reportMatcher ( Any.ANY ) . shortValue () ; }
public static double anyDouble () { return reportMatcher ( Any.ANY ) . doubleValue () ; }
public static float anyFloat () { return reportMatcher ( Any.ANY ) . floatValue () ; }
public static long anyLong () { return reportMatcher ( Any.ANY ) . longValue () ; }
public static int anyInt () { return reportMatcher ( Any.ANY ) . intValue () ; }
public static char anyChar () { return reportMatcher ( Any.ANY ) . charValue () ; }
public static byte anyByte () { return reportMatcher ( Any.ANY ) . byteValue () ; }
public static boolean anyBoolean () { return reportMatcher ( Any.ANY ) . booleanValue () ; }
public boolean booleanValue () { return false ; }
public < T > T nullValue () { return null ; }
public short shortValue () { return NUMBER_CONSTANT ; }
public byte byteValue () { return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return false ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return first ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportNot () ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return first ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) ; return false ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return null ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return NUMBER_CONSTANT ; }
{ LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) ; return false ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportOr ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnNull () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnChar () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnZero () ; }
{ return LastArguments . instance () . reportAnd ( NUMBER_CONSTANT ) . returnFalse () ; }
{ return reportMatcher ( new Same ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new InstanceOf ( clazz ) ) . returnNull () ; }
{ return LastArguments . instance () . reportNot () . returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
detects ( new OnStrictVerify () , UnfinishedVerificationException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
detects ( new OnStrictVerify () , UnfinishedStubbingException . class ) ;
assertFalse ( strict ( NUMBER_CONSTANT , asList ( new Object () ) ) . exactNumberOfInvocationsMode () ) ;
strictly = strictly ( mock , mockTwo ) ;
List < Invocation > unverified = ListUtil . filter ( invocations , new RemoveVerifiedStrictly () ) ;
strictly = strictly ( mock , mockTwo ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockTwo , atLeastOnce () ) . simpleMethod ( NUMBER_CONSTANT ) ;
inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ;
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( WantedButNotInvoked e ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
@ Override public void wantedButNotInvoked ( String wanted ) { this . wanted = wanted ; }
finderStub.firstUnverifiedChunkToReturn . add ( invocation ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . addAll ( asList ( first , second ) ) ;
finderStub.firstUnverifiedChunkToReturn . add ( differentMethod ) ;
assertTrue ( finderStub.firstUnverifiedChunkToReturn . isEmpty () ) ;
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentMethodWanted () { inOrder . verify ( mockOne ) . oneArg ( true ) ; }
@ Test ( expected = VerifcationInOrderFailed . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
@ Test ( expected = VerifcationInOrderFailed . class )
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
{ reporter . wantedButNotInvoked ( wanted . toString () ) ; }
@ Override public void wantedButNotInvoked ( Object wanted ) { this . wanted = wanted ; }
Object wanted
List < Invocation > chunk = finder . findValidMatchingChunk ( invocations , wanted , mode ) ;
Object wanted
public void wantedButNotInvoked ( Object wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
Object previous
String undesired
assertEquals ( firstUnverified . toString () , reporterStub.undesired ) ;
if ( unverified != null ) { reporter . noMoreInteractionsWanted ( unverified . toString () , unverified . getStackTrace () ) ; }
String wanted
String wanted
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
assertEquals ( wanted . toString () , reporterStub.wanted ) ;
Object previous
Invocation previousInOrder = finder . findPreviousInOrder ( invocations , wanted ) ;
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
catch ( VerifcationInOrderFailed e ) {}
@ Test ( expected = VerifcationInOrderFailed . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailed e ) {}
public String printActual () { return actual ; }
public String printWanted () { return wanted ; }
stub ( mockCalculator . countArticlesInPolish ( STRING_CONSTANT ) ) . toReturn ( NUMBER_CONSTANT ) ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedAsArguments () ; } }
CustomMatcher < T > matcher
List < ArgumentMatcher > matchers
public Not ( ArgumentMatcher first ) { this . first = first ; }
List < ArgumentMatcher > matchers
{ for ( ArgumentMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
T actual
List < ArgumentMatcher > matchers
{ for ( ArgumentMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < ArgumentMatcher > matchers ) { this . matchers = matchers ; }
private static ReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return LastArguments . instance () . reportMatcher ( matcher ) ; }
CustomMatcher < Double > matcher
CustomMatcher < Float > matcher
CustomMatcher < Long > matcher
CustomMatcher < Integer > matcher
CustomMatcher < Short > matcher
CustomMatcher < Byte > matcher
CustomMatcher < Boolean > matcher
CustomMatcher < Character > matcher
public ReturnValues reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( matcher ) ; return new ReturnValues () ; }
catch ( TooManyActualInvocations e ) {}
catch ( TooManyActualInvocations e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
if ( mode . wantedCountIsZero () && noMatchFound ) { return; }
InvocationDiffersFromActual e
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( InvocationDiffersFromActual expected ) {}
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
@ Test ( expected = InvocationDiffersFromActual . class )
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) {}
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( InvocationDiffersFromActual e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
IncorectBindingPuzzleFixedTest . class
Printable undesired
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable wanted
Printable wanted
Printable wanted
@ Override public void wantedButNotInvoked ( Printable wanted ) { this . wanted = wanted ; }
Printable undesired
Printable wanted
Printable wanted
Printable wanted
Printable wanted
Printable wanted
public void wantedButNotInvoked ( Printable wanted ) { throw new WantedButNotInvoked ( join ( STRING_CONSTANT , wanted . toString () ) ) ; }
if ( matchers == null ) { this . matchers = buildMatchers ( invocation ) ; } else { this . matchers = matchers ; }
mock . simpleMethod ( null , null ) ;
argumentsMatch ( actual . getArguments () )
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferentException expected ) {}
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
@ Test ( expected = ArgumentsAreDifferentException . class )
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) {}
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
catch ( ArgumentsAreDifferentException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
ArgumentsAreDifferentException e
assertTrue ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( invocation . isSimilarTo ( overloadedInvocation ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( onDifferentMock ) ) ;
assertFalse ( simpleMethod . isSimilarTo ( verified ) ) ;
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , cause . getMessage () . contains ( text ) ) ;
invocation . getMock () . equals ( actual . getMock () ) && invocation . getMethod () . equals ( actual . getMethod () ) && argumentsMatch ( actual )
assertTrue ( STRING_CONSTANT + value . getMessage () + STRING_CONSTANT + text , ( ( Throwable ) value ) . getMessage () . contains ( text ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , equalTo ( STRING_CONSTANT ) ) ;
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return EmptyReturnValues . emptyValueFor ( method . getReturnType () ) ; }
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = registeredInvocations ; }
EmptyReturnValuesTest . class
if ( verificationMode != null ) { verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . emptyValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . emptyValues () . valueFor ( invocation ) ;
MockitoSampleTest . class
@ After public void resetDefaultReturnValues () { MockitoConfiguration . resetCustomReturnValues () ; myDefaultReturnValues . clearSmartStubs () ; }
return MockitoConfiguration . defaultReturnValues () . valueFor ( invocation ) ;
@ Before public void configureDefaultReturnValues () { MockitoConfiguration . setCustomReturnValues ( new MyDefaultReturnValues () ) ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . defaultReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
@ Before public void configureDefaultReturnValues () { myDefaultReturnValues = new MyDefaultReturnValues () ; MockitoConfiguration . setCustomReturnValues ( myDefaultReturnValues ) ; }
invocation . isToString ()
Invocation invocation
Invocation invocation
Invocation invocation
Invocation invocation
return emptyValueFor ( returnType ) ;
assertEquals ( CHAR_CONS , mock . charReturningMethod ( NUMBER_CONSTANT ) ) ;
{ FakeReturnValues fakeReturnValues = getFakeReturnValues () ; fakeReturnValues . configure ( mocks ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertContains ( STRING_CONSTANT , mock . toString () ) ;
String mockDescription = STRING_CONSTANT + MockNamer . nameForMock ( mock ) + STRING_CONSTANT + mock . hashCode () ;
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS ) ; }
assertThat ( m . getMatchers () , collectionHasExactlyInOrder ( new Equals ( STRING_CONSTANT ) ) ) ;
assertThat ( STRING_CONSTANT , e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod , differentMethod . getInvocation () ) ) ;
assertThat ( verifierStub.invocations , collectionHasExactlyInOrder ( simpleMethod ) ) ;
MockHandler handler = new MockHandler ( state , new ExceptionThrowingBinder () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
assertEquals ( STRING_CONSTANT , invocation . toString () ) ;
{ f . set ( testClass , Mockito . mock ( f . getType () ) ) ; }
assertThat ( filtered , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
stub ( mock . oneArg ( not ( contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . oneArg ( and ( contains ( STRING_CONSTANT ) , contains ( STRING_CONSTANT ) ) ) ) . toReturn ( STRING_CONSTANT ) ;
try { getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( getMockHandler ( mock ) ) ; }
assertContains ( STRING_CONSTANT , mock . toString () ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( methodsOnTraceAfterRemoving , collectionHasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
if ( mode . inOrderMode () ) { invocations = globalInvocationsFinder . getAllInvocations ( mode . getMocksToBeVerifiedInOrder () ) ; } else { invocations = getRegisteredInvocations () ; }
{ return Modifier . isFinal ( clazz . getModifiers () ) ; }
{ if ( mocksReturningFakes . contains ( invocation . getMock () ) ) { return returnFake ( invocation ) ; } else { return defaultValueFor ( invocation ) ; } }
{ super . run ( notifier ) ; MockitoConfiguration . instance () . resetReturnValues () ; }
{ Object test = super . createTest () ; MockitoConfiguration . instance () . setReturnValues ( new FriendlyReturnValues () ) ; return test ; }
{ verifyingRecorder . verify ( invocationMatcher , verificationMode ) ; return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocationMatcher . getInvocation () ) ; }
return MockitoConfiguration . instance () . getReturnValues () . valueFor ( invocation ) ;
MockitoConfiguration config = MockitoConfiguration . instance () ;
{ super ( invocation . getInvocation () , invocation . getMatchers () ) ; this . result = result ; }
private Result ( IAnswer value ) { this . value = value ; }
public void addConsecutiveReturnValue ( Object value ) { stubbed . getFirst () . addResult ( Result . createReturnResult ( value ) ) ; }
ResultTest . class
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Result result
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( Result . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
Answer result = AnswerFactory . createThrowResult ( new RuntimeException () , filterStub ) ;
{ AnswerFactory . createThrowResult ( new RuntimeException () , new StackTraceFilter () ) . answer () ; }
{ Answer result = AnswerFactory . createReturnResult ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ validateThrowable ( throwable ) ; stubbed . getFirst () . addAnswer ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
{ mockingProgress . stubbingCompleted () ; validateThrowable ( throwable ) ; addResult ( AnswerFactory . createThrowResult ( throwable , new StackTraceFilter () ) ) ; }
assertEquals ( null , mock . oneArg ( null ) ) ;
assertEquals ( null , mock . oneArg ( null ) ) ;
public String toString () { return toString ( argumentsToMatchers () ) ; }
{ Answer result = AnswerFactory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
{ return isA ( String . class ) ; }
Answer answer = AnswerFactory . createReturningAnswer ( value ) ;
for ( StubbedInvocationMatcher s : stubbed ) { if ( s . matches ( invocation ) ) { return s . answer () ; } }
{ result . answer () ; fail () ; }
{ factory . createThrowingAnswer ( new RuntimeException () , null ) . answer () ; }
{ Answer result = factory . createReturningAnswer ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , result . answer () ) ; }
stub ( mock . threeArgumentMethod ( eq ( NUMBER_CONSTANT ) , not ( notNull () ) , eq ( STRING_CONSTANT ) ) ) . toReturn ( STRING_CONSTANT ) ;
Answer < T > answer
Answer < T > answer
Answer < T > answer
{ stubber . addConsecutiveThrowable ( throwable ) ; return this ; }
{ stubber . addConsecutiveReturnValue ( value ) ; return this ; }
Answer < T > answer
{ verifyingRecorder . eraseLastInvocation () ; stubber . addThrowable ( throwable ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addReturnValue ( value ) ; return new ConsecutiveStubbing () ; }
{ stubber . addThrowableForVoidMethod ( throwable ) ; return this ; }
{ try { stubber . addThrowable ( null ) ; fail () ; } catch ( MockitoException e ) {} }
stubber . addReturnValue ( STRING_CONSTANT ) ;
{ state . stubbingStarted () ; stubber . addReturnValue ( STRING_CONSTANT ) ; state . validateState () ; }
{ stubber . addThrowable ( new Exception () ) ; fail () ; }
public void setMock ( Object mock ) {}
ClassWithDodgyConstructor mock = factory . createMock ( ClassWithDodgyConstructor . class , new MockAwareStub () ) ;
ClassWithoutConstructor proxy = factory . createMock ( ClassWithoutConstructor . class , new MockAwareStub () ) ;
SomeInterface proxy = factory . createMock ( SomeInterface . class , new MockAwareStub () ) ;
{ return MockUtil . createMock ( classToMock , null , MOCKING_PROGRESS ) ; }
return delegate . intercept ( proxy , method , args , null ) ;
try { stubber . resultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
stubber = new Stubber ( mockingProgress ) ;
void setMock ( T mock ) ;
@ Before public void setUp () { StateResetter . reset () ; mock = Mockito . mock ( IMethods . class ) ; }
{ StateResetter . reset () ; mock = mock ( IMethods . class ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( null ) ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return new MethodSelectorImpl ( toBeReturned ) ; }
{ doReturn ( STRING_CONSTANT ) . when ( null ) . toString () ; fail () ; }
{ stubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new ThrowsException ( throwable ) ) ; return this ; }
{ stubber . addConsecutiveAnswer ( new Returns ( value ) ) ; return this ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new ThrowsException ( throwable ) ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; stubber . addAnswer ( new Returns ( value ) ) ; return new ConsecutiveStubbing () ; }
{ stubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { stubber . addAnswerForVoidMethod ( new Returns () ) ; return this ; }
{ stubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
this . stubber = new Stubber ( mockingProgress ) ;
return handler . voidMethodStubbable () ;
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . addAnswersForVoidMethod ( answers ) ; }
try { mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ; fail () ; } catch ( MockitoException e ) {}
mockitoStubber . addVoidMethodForStubbing ( new InvocationMatcher ( simpleMethod ) ) ;
{ return MockUtil . createMock ( classToMock , name , MOCKING_PROGRESS , null ) ; }
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ validator . validate ( new ReturnsVoid () , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; }
ReturnsVoid answer
doReturn () . doReturn () . doThrow ( new RuntimeException () ) . when ( mock ) . voidMethod () ;
Stubber doReturn ( ) ;
if ( answer instanceof DoesNothing ) { validateVoidReturn ( ( DoesNothing ) answer , invocation ) ; }
detects ( new OnDoReturn () , UnfinishedVerificationException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
detects ( new OnDoReturn () , UnfinishedStubbingException . class ) ;
enhancer . setClassLoader ( MockFactory . class . getClassLoader () ) ;
AtLeastOnceVerificationTest . class
try { mockitoStubber . getResultFor ( simpleMethod ) ; fail () ; } catch ( MyException e ) {}
Invocation invocation
mockingProgress . reportOngoingStubbing ( new OngoingStubbingImpl () ) ;
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
mode . atLeastOnceMode () || ! mode . matchesActualCount ( firstChunk . size () )
public boolean neverWanted () { return ! atLeastOnceMode () && wantedInvocationCount == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastOnceMode () && wantedInvocationCount > actualCount ; }
public boolean missingMethodMode () { return explicitMode () && ( atLeastOnceMode () || wantedInvocationCount > NUMBER_CONSTANT ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
stub ( mock . size () ) . toThrow ( new RuntimeException () ) ;
{ stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( null ) ; }
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( error ) ;
stub ( reader . read () ) . toThrow ( ioException ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toThrow ( expected ) ;
stub ( mockTwo . toString () ) . toReturn ( STRING_CONSTANT ) ;
stub ( mock . booleanReturningMethod () ) . toReturn ( true ) ;
stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( Boolean.FALSE ) ;
{ stub ( mock . simpleMethod () ) . toThrow ( null ) ; }
{ stub ( mock . simpleMethod () ) . toThrow ( new Exception () ) ; }
Mockito . stub ( mock . add ( STRING_CONSTANT ) ) . toReturn ( true ) ;
stub ( mock . simpleMethod () ) . toThrow ( new RuntimeException () ) ;
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new DeprecatedConsecutiveStubbing () ; }
mockingProgress . reportOngoingStubbing ( new DeprecatedOngoingStubbingImpl () ) ;
stub ( mock . oneArg ( anyString () ) ) . toReturn ( STRING_CONSTANT ) ;
ArgumentsAreDifferent e
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
try { verify ( mock ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( ArgumentsAreDifferent expected ) {}
{ HasStackTrace lastInvocation = finder . getLastStackTrace ( actualInvocations ) ; reporter . tooLittleActualInvocationsInAtLeastMode ( mode . minimumCount () , actualCount , wanted , lastInvocation ) ; }
if ( mode . explicitMode () ) { return; }
boolean atLeast = atLeastMode () && actualCount >= minInvocationCount ;
public boolean exactNumberOfInvocationsMode () { return ! inOrderMode () && explicitMode () ; }
public static VerificationModeImpl noMoreInteractions () { return new VerificationModeImpl ( null , null , Collections . emptyList () , Verification.NO_MORE_WANTED ) ; }
MockFactoryTest . class
@ Test public void shouldNeverVerifyWhenVerificationIsInAtLeastMode ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . atLeastOnce () ) ; }
@ Test public void shouldNeverVerifyWhenVerificationIsExplicit ( ) throws Exception { verifier . verify ( null , null , VerificationModeImpl . times ( NUMBER_CONSTANT ) ) ; }
mode . atLeastMode ()
mode . inOrderMode ()
VerificationModeImpl mode
public void verify ( VerificationModeImpl mode ) { verify ( null , mode ) ; }
VerificationModeImpl verificationMode = mockingProgress . pullVerificationMode () ;
VerificationModeImpl atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode = atLeastOnce () ;
public VerificationModeDecoder ( VerificationModeImpl mode ) { this . mode = mode ; }
VerificationModeImpl mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
VerificationModeImpl mode
VerificationModeImpl mode
void verify ( List < Invocation > invocations , InvocationMatcher wanted , VerificationModeImpl mode ) ;
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . missingMethodInOrderMode () ; }
VerificationModeImpl mode
VerificationModeImpl inOrderMode = new VerificationModeBuilder () . inOrder () ;
VerificationModeImpl mode = VerificationModeImpl . atLeastOnce () ;
VerificationModeImpl mode = atLeastOnce () ;
private VerificationModeDecoder decode ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . inOrderMode () ; }
VerificationModeImpl mode
public boolean appliesTo ( VerificationModeImpl mode ) { return new VerificationModeDecoder ( mode ) . exactNumberOfInvocationsMode () ; }
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
VerificationModeImpl mode
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( minNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.AT_LEAST ) ; }
{ assert ! mocksToBeVerifiedInOrder . isEmpty () ; return new VerificationModeImpl ( wantedNumberOfInvocations , mocksToBeVerifiedInOrder , Verification.EXPLICIT ) ; }
verifyingRecorder = createRecorder () ;
state . verificationStarted ( VerificationModeImpl . atLeastOnce () ) ;
VerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) , atLeastOnce () ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) , atLeastOnce () ) ;
VerificationMode mode
VerificationMode mode
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeImpl . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , atLeastOnce () ) ; }
VerificationMode mode = atLeastOnce () ;
VerificationMode mode = VerificationModeImpl . times ( NUMBER_CONSTANT ) ;
public VerificationModeDecoder ( VerificationMode mode ) { this . mode = mode ; }
verifier . verify ( invocations , wanted , atLeastOnce () ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode = times ( NUMBER_CONSTANT ) ;
VerificationMode mode
VerificationMode mode
VerificationModeImplTest . class
{ return VerificationModeImpl . atLeast ( minNumberOfInvocations ) ; }
{ return VerificationModeImpl . atLeastOnce () ; }
{ return VerificationModeImpl . times ( wantedNumberOfInvocations ) ; }
private VerificationModeDecoder decode ( VerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
{ mode . verify ( getRegisteredInvocations () , wanted ) ; }
@ Override public InvocationMatcher getWanted () { return wanted ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Matches ( regex ) ) . < String > returnNull () ; }
{ return reportMatcher ( new Contains ( substring ) ) . < String > returnNull () ; }
{ return ( Collection ) anyObject () ; }
{ return ( Map ) anyObject () ; }
{ return ( List ) anyObject () ; }
{ return ( String ) anyObject () ; }
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted , VerificationModeFactory . atLeastOnce () ) ; }
{ missingInvocation . verify ( data . getAllInvocations () , data . getWanted () , this ) ; }
@ Override public String toString () { return STRING_CONSTANT + wantedCount () + STRING_CONSTANT + mocksToBeVerifiedInOrder ; }
AtLeastXVerificationTest . class
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
{ verifyingRecorder . eraseLastInvocation () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing () ; }
verifyingRecorder = new VerifyingRecorder () ;
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( registeredInvocations . getVerifiableInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
VerifyingRecorderTest . class
if ( ! ( mode instanceof VerificationInOrderMode ) ) { throw new MockitoException ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) {}
catch ( MockitoAssertionError e ) {}
catch ( MockitoException e ) {}
public boolean neverWanted () { return ! atLeastMode () && mode . wantedCount () == NUMBER_CONSTANT ; }
public boolean tooManyActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () < actualCount ; }
public boolean tooLittleActualInvocations ( int actualCount ) { return ! atLeastMode () && mode . wantedCount () > actualCount ; }
public static MockitoVerificationMode times ( int wantedNumberOfInvocations ) { return new MockitoVerificationMode ( wantedNumberOfInvocations , Verification.EXPLICIT ) ; }
MockitoVerificationMode mode
MockitoVerificationMode mode
public VerificationModeDecoder ( MockitoVerificationMode mode ) { this . mode = mode ; }
MockitoVerificationModeTest . class
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode = VerificationModeFactory . times ( NUMBER_CONSTANT ) ;
MockitoVerificationMode mode
private VerificationModeDecoder decode ( MockitoVerificationMode mode ) { return new VerificationModeDecoder ( mode ) ; }
MockitoVerificationMode atLeastOnceInOrder = new VerificationModeBuilder () . inOrder () ;
MockitoVerificationMode mode
return Mockito . verify ( mock , new InOrderVerificationModeWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
Times mode
List < Invocation > chunk = finder . findMatchingChunk ( invocations , wanted , mode ) ;
{ if ( wantedNumberOfInvocations < NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedInvocationCount = wantedNumberOfInvocations ; }
numberOfCalls . verify ( allInvocations , wanted , this ) ;
wantedCount () > NUMBER_CONSTANT
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . verify ( invocations , wanted ) ; }
verifier . verify ( invocations , wanted ) ;
verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . verify ( invocations , wanted , NUMBER_CONSTANT ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( allInvocations , wanted , this ) ; }
if ( wantedCount == NUMBER_CONSTANT ) { missingInvocation . verify ( data . getAllInvocations () , data . getWanted () ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
verifier = new NumberOfInvocationsInOrderChecker ( finderStub , reporter ) ;
verifier . check ( invocations , wanted ) ;
verifier . check ( invocations , wanted ) ;
{ finderStub.actualToReturn . add ( new InvocationBuilder () . toInvocation () ) ; verifier . check ( invocations , wanted ) ; }
verifier . check ( invocations , wanted ) ;
verifier = new MissingInvocationChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier . check ( invocations , wanted , new VerificationModeBuilder () . inOrder () ) ;
verifier = new MissingInvocationInOrderChecker ( finderStub , reporterStub ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier . check ( invocations , wanted , NUMBER_CONSTANT ) ;
verifier = new NumberOfInvocationsChecker ( reporterStub , finderStub ) ;
numberOfCalls . verify ( allInvocations , wanted , wantedCount ) ;
numberOfInvocations . verify ( data . getAllInvocations () , data . getWanted () , wantedCount ) ;
if ( stubbing == null ) { REPORTER . missingMethodInvocation () ; }
T value
public DeprecatedOngoingStubbing < T > toReturn ( Object value ) { return toAnswer ( new Returns ( value ) ) ; }
public NewOngoingStubbing < T > thenReturn ( Object value ) { return thenAnswer ( new Returns ( value ) ) ; }
Object value
MockHandler handler = new MockHandler ( null , state , new ExceptionThrowingBinder () ) ;
{ return Configuration . instance () . getReturnValues () . valueFor ( invocation ) ; }
{ return MockUtil . createMock ( classToMock , MOCKING_PROGRESS , name , null ) ; }
{ return mock ( classToMock , null ) ; }
if ( mockedType . getSigners () != null ) { enhancer . setNamingPolicy ( NAMING_POLICY_THAT_ALLOWS_IMPOSTERISATION_OF_CLASSES_IN_SIGNED_PACKAGES ) ; } else { enhancer . setNamingPolicy ( MOCKITO_NAMING_POLICY ) ; }
MockingProgressImpl state = new MockingProgressImpl () ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; LastArguments . instance () . reset () ; }
LastArguments . instance () . validateState () ;
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnFalse () ; }
{ return LastArguments . instance () . reportNot () . returnChar () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . returnZero () ; }
{ return LastArguments . instance () . reportNot () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnChar () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . returnZero () ; }
{ return LastArguments . instance () . reportOr () . < T > returnNull () ; }
{ return LastArguments . instance () . reportOr () . returnFalse () ; }
{ return LastArguments . instance () . reportAnd () . < T > returnNull () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnChar () ; }
{ return LastArguments . instance () . reportAnd () . returnZero () ; }
{ return LastArguments . instance () . reportAnd () . returnFalse () ; }
LastArguments lastArguments
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportOr () . returnFalse () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnChar () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnZero () ; }
{ return mockingProgress . getLastArguments () . reportAnd () . returnFalse () ; }
public void reset () { stubbingInProgress = false ; verificationMode = null ; getLastArguments () . reset () ; }
getLastArguments () . validateState () ;
public void stubbingCompleted ( Invocation invocation ) { stubbedInvocations . add ( invocation ) ; stubbingInProgress = false ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; }
private boolean shouldPrint () { return ! unusedStubs . isEmpty () ; }
public byte [] naughtyMethodUnderTestWhichDoesNotFailBecauseItReturnsAValue ( String filename ) { return this . reader . readFromFile ( STRING_CONSTANT ) ; }
public void addUnstubbedInvocation ( Invocation invocation ) { unstubbedInvocations . add ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addUnstubbedInvocation ( invocation ) ; }
if ( ! invocation . isVoid () && answer == null ) { mockingProgress . getDebuggingHelper () . addPotentiallyUnstubbed ( invocationMatcher ) ; }
void print ( Object what ) ;
public void stubbingCompleted ( Invocation invocation ) { debuggingHelper . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
public void print () { System.out . println () ; }
public ExperimentalMockitoJUnitRunner ( Class < > klass ) throws InitializationError { super ( klass ) ; logger = new MockitoLoggerImpl () ; }
void println ( Object what ) ;
{ if ( hasData () ) { WarningsPrinter warningsPrinter = new WarningsPrinter ( stubbedInvocations , potentiallyUnstubbedInvocations ) ; warningsPrinter . print ( logger ) ; } }
public void addPotentiallyUnstubbed ( InvocationMatcher invocationMatcher ) { if ( ! collectingData ) { return; } potentiallyUnstubbedInvocations . add ( invocationMatcher ) ; }
public ExperimentalMockitoJUnitRunnerPMStub ( ) throws InitializationError { super ( ExperimentalMockitoJUnitRunnerPMTest . class ) ; }
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
String loggedInfo = logger . getLoggedInfo () ;
public void log ( Object what ) { loggedInfo . append ( what ) ; }
{ return MockitoProperties.DEFAULT_RETURN_VALUES . valueFor ( invocation ) ; }
{ unusedStubbingThatQualifiesForWarning () ; notifier . fireTestFailure ( null ) ; assertTrue ( debuggingInfo . hasData () ) ; }
DefaultReturnValuesTest . class
EmptyReturnValues reportMatcher ( Matcher matcher ) ;
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
Foo mock = mock ( Foo . class , SMART_NULLS ) ;
@ Before public void setup () { mock = mock ( IMethods . class , Mockito.SMART_NULLS ) ; }
{ return mock ( classToMock , name , null , USING_GLOBAL_CONFIG ) ; }
{ return mock ( classToMock , null , null , USING_GLOBAL_CONFIG ) ; }
String mockName
catch ( NoSuchMethodException e ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
verify ( mock ) ;
{ validateState () ; resetOngoingStubbing () ; verificationMode = ( VerificationMode ) verify ; }
unfinishedVerificationHere () ;
{ unfinishedVerificationHere () ; fail () ; }
this . stackTrace = filter . filterStackTrace ( stackTrace ) ;
if ( callback instanceof MethodInterceptorFilter ) { return ( MethodInterceptorFilter ) callback ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , causeMessageContains ( STRING_CONSTANT ) ) ; }
StackTrackeChangingTest . class
STRING_CONSTANT + actualCount + STRING_CONSTANT
{ matcherStack . push ( matcher ) ; return new HandyReturnValues () ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
assertEquals ( expectedMessage , actualMessage ) ;
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e . getCause () , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
reporter . tooLittleActualInvocations ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
reporter . tooLittleActualInvocationsInOrder ( wantedCount , actualCount , wanted , lastInvocation ) ;
STRING_CONSTANT + pluralize ( wantedCount ) + STRING_CONSTANT
reporter . tooLittleActualInvocationsInOrderInAtLeastMode ( wantedCount , actualCount , wanted , lastInvocation ) ;
catch ( SmartNullPointerException e ) { assertThat ( e . getCause () , hasMethodInStackTraceAt ( NUMBER_CONSTANT , STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . oneArg ( false ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( - NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( spy ) . add ( STRING_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure f ) {}
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockTwo ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . differentMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
catch ( VerifcationInOrderFailure e ) {}
@ Test ( expected = VerifcationInOrderFailure . class )
try { inOrder . verify ( mockThree ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
VerifcationInOrderFailure e
catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne , atLeastOnce () ) . simpleMethod () ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
try { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; fail () ; } catch ( VerifcationInOrderFailure e ) {}
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerifcationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String message = createTooLittleInvocationsMessage ( discrepancy , wanted , lastActualStackTrace ) ; throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ; }
throw new VerifcationInOrderFailure ( join ( STRING_CONSTANT + message ) ) ;
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing () ; }
assertEquals ( expectedMessage , actualMessage ) ;
private void misplacedArgumentMatcher () { anyString () ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () ) ;
{ return new VoidMethodStubbableImpl ( mock ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
if ( stubbingInProgress ) { stubbingInProgress = false ; reporter . unfinishedStubbing ( debuggingInfo . getLastInvocationLocation () ) ; }
mockitoStubber . setInvocationForPotentialStubbing ( new InvocationBuilder () . toInvocationMatcher () , null ) ;
public void reset () { stubbingInProgress = false ; verificationMode = null ; getArgumentMatcherStorage () . reset () ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = false ; }
{ Throwable filtered = throwable . fillInStackTrace () ; filter . filterStackTrace ( new HasStackTraceThrowableWrapper ( filtered ) ) ; throw filtered ; }
assertEquals ( invocation . getStackTrace () , reporterStub.stackTrace ) ;
assertSame ( third . getStackTrace () , reporterStub.stackTrace ) ;
{ assertTrue ( finderStub.actualToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; assertNull ( reporterStub.stackTrace ) ; }
assertSame ( second . getStackTrace () , reporterStub.stackTrace ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getStackTrace () ) ; }
HasStackTrace firstUndesired
HasStackTrace firstUndesired
HasStackTrace hasStackTrace
reporter . argumentsAreDifferent ( syncingPrinter . getWanted () , syncingPrinter . getActual () , similar . getStackTrace () ) ;
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getStackTrace () ) ; }
assertSame ( previous . getStackTrace () , reporterStub.previousStackTrace ) ;
assertSame ( actualInvocation . getStackTrace () , reporterStub.actualInvocationStackTrace ) ;
assertNull ( reporterStub.actualInvocationStackTrace ) ;
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate ) ;
int expectedMatchersSize = invocation . getArguments () . length ;
Location lastLocation = finder . getLastStackTrace ( chunk ) ;
Location lastLocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( actualInvocations ) ;
Location lastInvocation = finder . getLastStackTrace ( chunk ) ;
if ( previousInOrder == null ) { reporter . wantedButNotInvoked ( wanted ) ; } else { reporter . wantedButNotInvokedInOrder ( wanted , previousInOrder , previousInOrder . getLocation () ) ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWanted ( unverified , unverified . getLocation () ) ; }
@ Override public String toString () { return this . firstTraceElement . toString () ; }
if ( matcherStack . isEmpty () ) { return null ; }
assertNull ( Mockito.MOCKING_PROGRESS . pullOngoingStubbing () ) ;
ret . getClass () . isArray () ;
{ return doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return doAnswer ( new DoesNothing () ) ; }
{ return doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ verifyNoMoreInteractions ( mocks ) ; }
{ return verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
return MockitoCore . mock ( ( Class ) class1 , null , null , this ) ;
{ return MockitoCore . inOrder ( mocks ) ; }
{ return MockitoCore . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MockitoCore . doAnswer ( new DoesNothing () ) ; }
{ return MockitoCore . doAnswer ( answer ) ; }
{ return MockitoCore . doAnswer ( new ThrowsException ( toBeThrown ) ) ; }
{ return MockitoCore . stubVoid ( mock ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ MockitoCore . verifyNoMoreInteractions ( mocks ) ; }
{ return MockitoCore . verify ( mock , mode ) ; }
{ MockitoCore . reset ( mock ) ; }
{ return MockitoCore . verify ( mock , times ( NUMBER_CONSTANT ) ) ; }
{ return MockitoCore . when ( methodCall ) ; }
{ return MockitoCore . stub ( methodCall ) ; }
{ return MockitoCore . mock ( classToMock , null , ( T ) null , returnValues ) ; }
{ return MockitoCore . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MockitoCore . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , MOCKING_PROGRESS , Mockito.RETURNS_DEFAULTS ) ; }
MOCKING_PROGRESS . stubbingStarted () ;
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { REPORTER . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( NewOngoingStubbing ) stub () ; }
{ MOCKING_PROGRESS . stubbingStarted () ; return ( DeprecatedOngoingStubbing ) stub () ; }
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ;
{ mock = mock ( IMethods . class , Mockito.RETURNS_SMART_NULLS ) ; ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; }
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( true ) ; first () ; second () ; third () ; fourth () ; }
@ Before public void init () { StateMaster . validate () ; MockitoAnnotations . initMocks ( this ) ; }
StateMaster . validate () ;
{ return isA ( clazz ) ; }
filter . filterStackTrace ( t ) ;
{ unfilteredStackTrace = getStackTrace () ; StackTraceFilter filter = new StackTraceFilter () ; filter . filterStackTrace ( this ) ; }
filter . filterStackTrace ( this ) ;
filter . filterStackTrace ( this ) ;
this . firstTraceElement = filter . filterStackTrace ( stackTrace ) [ NUMBER_CONSTANT ] ;
@ Before public void cleanStackTraces () { super . makeStackTracesClean () ; }
filter . filterConditionally ( t ) ;
catch ( AssertionError e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e , messageContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ) ; }
catch ( InvalidUseOfMatchersException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( NeverWantedButInvoked e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
catch ( ArgumentsAreDifferent e ) { assertThat ( e , messageContains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mockTwo . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
catch ( Exception e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
assertThat ( mock . toString () , contains ( STRING_CONSTANT ) ) ;
catch ( MockitoException e ) { assertThat ( e . getMessage () , contains ( STRING_CONSTANT ) ) ; }
final boolean overloadedButSameArgs = ! methodEquals && argumentsMatch ( candidate . getArguments () ) ;
{ return anyObject () ; }
Invocation i = new Invocation ( mock , method , args , sequenceNumber ) ;
UnderTest mock = mock ( UnderTest . class ) ;
public Person ( int age ) { this . age = age ; }
if ( arguments . isEmpty () ) { new Reporter () . argumentValueNotYetCaptured () ; } else { return ( T ) arguments . getLast () ; }
{ anyObject () ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( InvalidUseOfMatchersException e ) {} }
try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedStubbingException e ) {}
{ verify ( mock ) ; try { MockitoTroubleshooter . validateFrameworkState () ; fail () ; } catch ( UnfinishedVerificationException e ) {} }
{ return ( List ) arguments ; }
{ Mockito . argThat ( this ) ; return null ; }
{ notifier . addListener ( new FrameworkUsageValidator ( notifier ) ) ; super . run ( notifier ) ; }
{ if ( classProvider . hasJUnit45OrHigher () ) { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } else { return classProvider . newInstance ( STRING_CONSTANT , klass ) ; } }
RunnerFactory ( ClassProvider classProvider ) { this . classProvider = classProvider ; }
{ super ( klass ) ; }
catch ( Throwable t ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , t ) ; }
this . runTest ( notifier ) ;
if ( MockUtil . isMock ( instance ) ) { return returnValues . valueFor ( invocation ) ; } else { return methodProxy . invoke ( instance , args ) ; }
{ try { new ShallowCopyTool () . copy ( optionalInstance , mock ) ; } catch ( UnableToCopyFieldValue e ) {} }
@ Test public void shouldCallRealMethdsEvenDelegatedToOtherSelfMethod () { String name = mock . getName () ; assertEquals ( STRING_CONSTANT , name ) ; }
protected String guessName () { return defaultName ; }
public String getName () { return guessName () ; }
{ return new VoidMethodStubbableImpl ( mock ) ; }
{ return MOCKITO_CORE . mock ( classToMock , name , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . mock ( classToMock , null , null , null , RETURNS_DEFAULTS ) ; }
assertTrue ( MockUtil . isMock ( classMock ) ) ;
assertTrue ( MockUtil . isMock ( interfaceMock ) ) ;
if ( MockUtil . isMock ( throwable ) ) { throw throwable ; }
MockUtil . isMock ( instance )
MockUtil . getMockHandler ( withFinal ) ;
MockName name = MockUtil . getMockName ( mock ) ;
try { MockUtil . getMockHandler ( o ) ; fail () ; } catch ( NotAMockException e ) {}
{ List mock = Mockito . mock ( List . class ) ; assertNotNull ( MockUtil . getMockHandler ( mock ) ) ; }
List < Invocation > fromSingleMock = MockUtil . getMockHandler ( mock ) . getRegisteredInvocations () ;
MockHandler < T > handler = MockUtil . getMockHandler ( mock ) ;
if ( mock == null ) { reporter . nullPassedWhenCreatingInOrder () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedWhenCreatingInOrder () ; }
{ if ( mock == null ) { reporter . nullPassedToVerifyNoMoreInteractions () ; } MockUtil . getMockHandler ( mock ) . verifyNoMoreInteractions () ; }
for ( T m : mocks ) { MockUtil . resetMock ( m , mockingProgress ) ; }
if ( mock == null ) { reporter . nullPassedToVerify () ; } else if ( ! MockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return MockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( Foo . class ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces () ) ; fail () ; }
{ mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , null ) ) ; fail () ; }
Foo mock = mock ( Foo . class , configureWith () . extraInterfaces ( IFoo . class , IBar . class ) ) ;
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , configureWith () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , configureWith () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( ( Class [] ) null ) ) ; }
@ Test public void shouldScreamWhenExtraIsTheSame () { mock ( IMethods . class , configureWith () . extraInterfaces ( IMethods . class ) ) ; }
@ Test public void shouldScreamWhenNonInterfacePassed () { mock ( IMethods . class , configureWith () . extraInterfaces ( LinkedList . class ) ) ; }
{ mock ( IMethods . class , configureWith () . extraInterfaces ( List . class , null ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( returnValues ) ) ; }
{ return MOCKITO_CORE . mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ MockSettingsImpl settings = ( MockSettingsImpl ) Mockito . withSettings () ; assertEquals ( Mockito.RETURNS_DEFAULTS , settings . getReturnValues () ) ; }
IMethods mock = mock ( IMethods . class , withSettings () . defaultBehavior ( RETURNS_SMART_NULLS ) . name ( STRING_CONSTANT ) ) ;
{ return mockSettings . getReturnValues () . valueFor ( invocation ) ; }
{ assertEquals ( STRING_CONSTANT , values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) ) ) ; }
ret = ( String [] ) values . valueFor ( invocationOf ( StringMethods . class , STRING_CONSTANT ) )
public static MockSettings withSettings () { return new MockSettingsImpl () . defaultBehavior ( RETURNS_DEFAULTS ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethod () ) ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultBehavior ( RETURNS_DEFAULTS ) )
{ return mock ( classToMock , withSettings () . name ( name ) . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
{ return mock ( classToMock , withSettings () . defaultBehavior ( RETURNS_DEFAULTS ) ) ; }
EmptyReturnValuesTest . class
{ ConfigurationAccess . getConfig () . overrideCleansStackTrace ( false ) ; ConfigurationAccess . getConfig () . overrideReturnValues ( null ) ; }
runner = new VerboseMockitoJUnitRunner ( DummyTest . class ) ;
public Object answer ( InvocationOnMock invocation ) throws Throwable { return invocation . invokeSuper () ; }
MOCKITO_CORE . mock ( ( Class < T > ) object . getClass () , withSettings () . spiedInstance ( object ) . defaultAnswer ( RETURNS_DEFAULTS ) )
catch ( Throwable t ) { new ConditionalStackTraceFilter () . filter ( t ) ; throw t ; }
this . firstTraceElement = filter . filter ( stackTrace ) [ NUMBER_CONSTANT ] ;
this . firstTraceElement = filter . filter ( stackTrace , NUMBER_CONSTANT ) [ NUMBER_CONSTANT ] ;
StackTraceElement [] filtered = filter . filter ( throwable . getStackTrace () , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( new StackTraceElement [ NUMBER_CONSTANT ] , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
StackTraceElement [] filtered = filter . filter ( t , NUMBER_CONSTANT ) ;
line = printer . getArgumentsLine ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , NotNull.NOT_NULL ) , PrintSettings . verboseArgs () )
printer . getArgumentsBlock ( ( List ) Arrays . asList ( new Equals ( NUMBER_CONSTANT ) , new Equals ( NUMBER_CONSTANT ) ) , PrintSettings . verboseArgs () )
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseVariant () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
public void setMatchersToBePrintedVerbosely ( Matcher [] toBePrintedVerbosely ) { this . verboseMatchers = Arrays . asList ( toBePrintedVerbosely ) ; }
Matcher . . . verboselyPrinted
Matcher . . . toBePrintedVerbosely
{ withPrintSettings . add ( ( ( CanPrintArgumentVerbosely ) matcher ) . getVerboseSelfDescribing () ) ; }
SelfDescribing getVerboseSelfDescribing ( ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . getVerboseSelfDescribing () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
CanDescribeVerbosely equals = new Equals ( NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , StringDescription . toString ( m . withExtraTypeInfo () ) ) ;
try { verify ( withFinal ) . finalMethod ( anyObject () ) ; fail () ; } catch ( UnfinishedVerificationException e ) {}
public BDDOngoingStubbingImpl ( NewOngoingStubbing < T > ongoingStubbing ) { this . mockitoOngoingStubbing = ongoingStubbing ; }
Field createInfoField = methodProxy . getClass () . getDeclaredField ( STRING_CONSTANT ) ;
{ return getInterceptor ( mock ) . getDelegate () ; }
{ Mockito . argThat ( capturingMatcher ) ; return null ; }
ArgumentCaptor < String > captor = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > person = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
{ Mockito . argThat ( capturingMatcher ) ; return new HandyReturnValues () . returnFor ( clazz ) ; }
ArgumentCaptor < String > argument = new ArgumentCaptor < String > () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () ;
newMessage += STRING_CONSTANT + debuggingInfo . getWarnings () + STRING_CONSTANT ;
private String thisStubWasNotUsed ( Invocation i ) { return join ( STRING_CONSTANT , i , i . getLocation () , STRING_CONSTANT ) ; }
{ this ( unusedStubs , unstubbedInvocations , true ) ; }
invocationMarker . markVerified ( invocations , wanted ) ;
{ if ( wantedNumberOfInvocations <= NUMBER_CONSTANT ) { throw new MockitoException ( STRING_CONSTANT ) ; } this . wantedCount = wantedNumberOfInvocations ; }
private int hashCodeForMock ( Object mock ) { return new Integer ( System . identityHashCode ( mock ) ) ; }
{ return getInterceptor ( mock ) . getMockHandler () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m , mockingProgress ) ; }
public static boolean isToString ( InvocationOnMock invocation ) { return isToString ( invocation . getMethod () ) ; }
if ( Invocation . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
equalsMethod . equals ( method )
MethodInterceptorFilter newFilter = new MethodInterceptorFilter ( Object . class , newMockHandler ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( classToMock , mockHandler ) ;
if ( hashCodeMethod . equals ( method ) ) { return hashCodeForMock ( proxy ) ; }
if ( ObjectMethodsGuru . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
public static boolean isToString ( InvocationOnMock invocation ) { return ObjectMethodsGuru . isToString ( invocation . getMethod () ) ; }
markFirstOccurence ( chunk , wantedMatcher ) ;
{ try { return argumentsMatch ( actualArgs ) ; } catch ( Throwable t ) { return false ; } }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) Arrays . asList ( new Equals ( STRING_CONSTANT ) , capturingMatcher ) ) ;
proxy . setCallbacks ( new Callback [] { interceptor , NoOp.INSTANCE } ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
public CGLIBProxyRealMethod ( MethodProxy methodProxy ) { this . methodProxy = methodProxy ; }
public FilteredCGLIBProxyRealMethod ( MethodProxy methodProxy ) { this ( new CGLIBProxyRealMethod ( methodProxy ) ) ; }
Any mock = mock ( Any . class ) ;
{ return methodProxy . getMethodProxy () . invokeSuper ( target , arguments ) ; }
public Method getMethod () { return invocation . getMethod () ; }
Method method
Method getMethod ( ) ;
Invocation i = new Invocation ( mock , new DelegatingMockitoMethod ( method ) , args , sequenceNumber , null ) ;
{ new ObjectOutputStream ( new ByteArrayOutputStream () ) . writeObject ( new MethodInterceptorFilter ( null ) ) ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHandler ) ;
assertFalse ( new SerializableMockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new SerializableMockitoMethod ( toStringMethod ) ;
Class < > getReturnType ( ) ;
MockitoMethod mockitoMethod = new SerializableMockitoMethod ( method ) ;
Invocation i = new Invocation ( mock , new SerializableMockitoMethod ( method ) , args , sequenceNumber , null ) ;
assertFalse ( new MockitoMethod ( testBaseToStringMethod ) . equals ( mockMethod ) ) ;
mockMethod = new MockitoMethod ( toStringMethod ) ;
public MockitoMethod getMethod () { return invocation . getMethod () ; }
MockitoMethod getMethod ( ) ;
MockitoMethod method
Invocation i = new Invocation ( mock , new MockitoMethod ( method ) , args , sequenceNumber , null ) ;
SerializableMethod getMethod ( ) ;
public SerializableMethod getMethod () { return invocation . getMethod () ; }
{ if ( this . getMethod () . isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; } return realMethod . invoke ( mock , rawArguments ) ; }
{ if ( invocation . getMethod () . isDeclaredOnInterface () ) { reporter . cannotCallRealMethodOnInterface () ; } }
SerializableMethod method
{ if ( isPrimitiveWrapper ( clazz ) ) { return primitiveWrapperOf ( clazz ) ; } return primitiveValueFor ( clazz ) ; }
@ Override protected MethodProxy getMethodProxy () { return methodProxy ; }
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
IMethods mock = mock ( IMethods . class , withSettings () . extraInterfaces ( Serializable . class ) . serializable () ) ;
List < Invocation > allInvocations = ongoingStubbing . getRegisteredInvocations () . getAll () ;
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
{ registeredInvocations . removeLast () ; mockitoStubber . addAnswer ( answer ) ; return new ConsecutiveStubbing < T > ( mockitoStubber ) ; }
OngoingStubbingImpl < T > ongoingStubbing = new OngoingStubbingImpl < T > ( mockitoStubber , mockitoStubber . getRegisteredInvocations () ) ;
public void addAnswer ( Answer answer ) { addAnswer ( answer , false ) ; }
public MockHandler ( MockHandler < T > oldMockHandler ) { this ( oldMockHandler.mockName , oldMockHandler.mockingProgress , oldMockHandler.matchersBinder , oldMockHandler.mockSettings ) ; }
return mockHandler . handle ( invocation ) ;
{ return ( MockHandler ) getInterceptor ( mock ) . getMockHandler () ; }
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
MethodInterceptorFilter filter = new MethodInterceptorFilter ( mockHanlder , ( MockSettingsImpl ) withSettings () ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( mockHanlder , never () ) . handle ( any ( Invocation . class ) ) ;
{ mockingProgress . validateState () ; mockingProgress . resetOngoingStubbing () ; return mockUtil . createMock ( classToMock , mockingProgress , ( MockSettingsImpl ) mockSettings ) ; }
public MockName getMockName ( Object mock ) { return getMockHandler ( mock ) . getMockName () ; }
MockHandler () { this ( new ThreadSafeMockingProgress () , new MatchersBinder () , new MockSettingsImpl () ) ; }
{ mockitoStubber . addAnswerForVoidMethod ( answer ) ; return this ; }
public VoidMethodStubbable < T > toReturn () { mockitoStubber . addAnswerForVoidMethod ( new DoesNothing () ) ; return this ; }
{ mockitoStubber . addAnswerForVoidMethod ( new ThrowsException ( throwable ) ) ; return this ; }
{ try { mockitoStubber . addAnswer ( new ThrowsException ( null ) ) ; fail () ; } catch ( MockitoException e ) {} }
{ state . stubbingStarted () ; mockitoStubber . addAnswer ( new Returns ( STRING_CONSTANT ) ) ; state . validateState () ; }
{ mockitoStubber . addAnswer ( new ThrowsException ( new Exception () ) ) ; fail () ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
{ mockitoStubber . addConsecutiveAnswer ( answer ) ; return this ; }
@ SuppressWarnings ( STRING_CONSTANT ) public void setAnswersForStubbing ( List < Answer > answers ) { mockitoStubber . setAnswersForStubbing ( answers ) ; }
{ return new VoidMethodStubbableImpl < T > ( mock , mockitoStubber ) ; }
{ VerificationDataImpl data = new VerificationDataImpl ( mockitoStubber . getInvocations () , null ) ; VerificationModeFactory . noMoreInteractions () . verify ( data ) ; }
this . mockitoStubber = new MockitoStubber ( mockingProgress ) ;
if ( i . stubInfo () != null ) { System.out . println ( STRING_CONSTANT + i . stubInfo () . stubbingLocation () ) ; }
void printInvocations ( Object . . . mocks ) ;
{ return MOCKITO_CORE . mock ( classToMock , mockSettings , true ) ; }
void varargs ( String . . . string ) ;
void varargs ( Object . . . object ) ;
List < Invocation > allInvocations = new AllInvocationsFinder () . getAllInvocations ( mocksToBeVerifiedInOrder ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . getAllInvocations ( asList ( mockOne , mockTwo ) ) ;
public void log ( Object what ) { System.out . println ( what . toString () ) ; }
public void stubbingCompleted ( Invocation invocation ) { debuggingInfo . addStubbedInvocation ( invocation ) ; stubbingInProgress = null ; }
for ( InvocationMatcher i : allInvocations ) { findingsListener . foundUstubbed ( i ) ; }
verify ( listener , only () ) . foundUstubbed ( unstubbedInvocation ) ;
void foundUstubbed ( InvocationMatcher unstubbed ) ;
{ this ( new MockitoLoggerImpl () , new RunnerFactory () . create ( klass ) ) ; }
public void cleanStackTraces () { super . makeStackTracesClean () ; }
public MockUtil ( CreationValidator creationValidator ) { this . creationValidator = creationValidator ; }
private boolean isEmpty ( String warnings ) { return warnings == null || warnings . isEmpty () ; }
SimpleTest test = new SimpleTest () ;
SimpleTest test = new SimpleTest () ;
@ Test ( expected = WantedButNotInvoked . class ) public void shouldFailOnFirstMethodBecauseDifferentArgsWanted () { inOrder . verify ( mockOne ) . simpleMethod ( NUMBER_CONSTANT ) ; }
if ( instance == null ) { throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
String log = Mockito . debug () . printInvocations ( mock , mockTwo ) ;
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock Object iAmNull = null ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Captor ArgumentCaptor captor ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Mock List mock ; } ) ; }
{ MockitoAnnotations . initMocks ( new Object () { @ InjectMock @ Spy List mock ; } ) ; }
null != field . getAnnotation ( InjectMock . class )
if ( field . isAnnotationPresent ( annotation ) ) { new Reporter () . unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , InjectMock . class . getSimpleName () ) ; }
field . isAnnotationPresent ( InjectMock . class )
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; fail () ; }
{ finderStub.validMatchingChunkToReturn . add ( wanted . getInvocation () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
{ assertTrue ( finderStub.validMatchingChunkToReturn . isEmpty () ) ; checker . check ( invocations , wanted , NUMBER_CONSTANT ) ; }
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT ) ;
return mockitoCore . verify ( mock , new InOrderWrapper ( ( VerificationInOrderMode ) mode , mocksToBeVerifiedInOrder ) ) ;
if ( invocation . isVoid () ) { reporter . cannotStubVoidMethodWithAReturnValue () ; }
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl . getInvocations () , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) { throw new MockitoException ( STRING_CONSTANT ) ; } }
try { t . verify ( data ) ; } catch ( MockitoAssertionError e ) {}
@ Override public InvocationMatcher getWanted () { return wanted ; }
@ Override public InOrderContext getOrderingContext () { return inOrder ; }
{ throw new MockitoException ( join ( STRING_CONSTANT + methodName + STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ; }
{ return ( T ) anyObject () ; }
Object instance = field . get ( testClass ) ;
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
{ throw new MockitoException ( STRING_CONSTANT + field . getName () + STRING_CONSTANT + field . getType () + STRING_CONSTANT ) ; }
NestedClassWithNoArgConstructor ( String _1arg ) {}
if ( ! mockUtil . isMock ( mock ) ) { reporter . notAMockPassedToVerify () ; }
validateState () ;
Invocation . isToString ( invocation )
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT ; }
new Reporter () . smartNullPointerException ( obj , location ) ;
if ( new ObjectMethodsGuru () . isToString ( method ) ) { return STRING_CONSTANT + formatMethodCall () + STRING_CONSTANT ; }
null != field . getAnnotation ( Mock . class )
Object testClass
int index = filter . accept ( actualMethod ) ;
notifyInvocationListener ( invocation ) ;
MockHandler handler
{ given ( handler . getMockSettings () . getDefaultAnswer () ) . willReturn ( SOME_ANSWER ) ; stubOrdinaryInvocationWithReturnValue ( handler , null ) ; }
doThrow ( new RuntimeException () ) . when ( throwingListener )
public OngoingMockInjection tryPropertyOrFieldInjection () { appendStrategy ( new PropertyAndSetterInjection () ) ; return this ; }
public OngoingMockInjection tryConstructorInjection () { appendStrategy ( new ConstructorInjection () ) ; return this ; }
{ return nextStrategy != null && nextStrategy . processInjection ( field , fieldOwner , mockCandidates ) ; }
{ assert wasAccessible != null ; try { accessibleObject . setAccessible ( wasAccessible ) ; } catch ( Throwable t ) {} }
AllInvocationsFinder finder = new AllInvocationsFinder () ;
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithException ( invocation , exception , listener ) ; } }
{ for ( InvocationListener listener : mockSettings . getInvocationListener () ) { notifyListenerOfInvocationWithReturnValue ( invocation , returnValue , listener ) ; } }
given ( handler . getMockSettings () . getInvocationListener () ) . willReturn ( Arrays . asList ( listener ) ) ;
@ Test ( expected = MockitoException . class ) public void shouldThrowCorrectExceptionForNullInvocationListener ( ) throws Exception { new Reporter () . nullInvocationListenerAdded () ; }
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener1 ) . callback ( listener2 ) ) ;
Foo foo = mock ( Foo . class , withSettings () . callback ( listener ) ) ;
{ assertFalse ( mockSettingsImpl . hasInvocationListeners () ) ; mockSettingsImpl . verboseLogging () ; assertContainsType ( mockSettingsImpl . getInvocationListeners () , LogInvocationsToStdOutListener . class ) ; }
MethodCallReport mcr
public void invocationListenersRequiresAtLeastOneListener () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
public void invocationListenerDoesNotAcceptNullParameters () { throw new MockitoException ( join ( STRING_CONSTANT ) ) ; }
{ notifier . handle ( invocation ) ; }
{ notifier . handle ( invocation ) ; }
{ mockSettingsImpl . invocationListeners ( invocationListener , null ) ; }
{ mockSettingsImpl . invocationListeners () ; }
{ mapOngoingStubbing . thenReturn ( STRING_CONSTANT ) ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } , parentClassLoader ) ; this . reloadClassPredicate = reloadClassPredicate ; }
{ super ( new URL [] { obtainClassPath ( SimplePerRealmReloadingClassLoader . class ) } ) ; this . reloadClassPredicate = reloadClassPredicate ; }
return report . fieldWasInitialized () ;
mocks . addAll ( scanMocks ( testClassInstance , clazz ) ) ;
@ Test public void inject_mocks_even_in_declared_spy ( ) throws Exception { assertNotNull ( spiedReceiver.antena ) ; assertNotNull ( spiedReceiver.tuner ) ; }
new InjectMocksScanner ( testClassInstance , clazz ) . addTo ( mockDependentFields ) ;
{ return ( MockHandlerInterface ) getInterceptor ( mock ) . getHandler () ; }
String canThrowException ( ) throws ChangedCharSetException , CharacterCodingException ;
MockSettingsImpl mockSettings
MockSettingsImpl settings
MockSettingsImpl settings
MockSettingsImpl settings
public void setTheField ( final File theField ) { setTheFieldWasUsed = true ; this . theField = theField ; }
Class configClass = null ;
private void misplacedBooleanArgumentMatcher () { anyBoolean () ; }
private void misplacedIntArgumentMatcher () { anyInt () ; }
private void misplacedArgumentMatcher () { anyObject () ; }
List < Matcher > pullMatchers ( ) ;
Set < Object > mocks = new HashSet < Object > () ;
Set < Object > mocks = new HashSet < Object > () ;
{ this . delegatedInstance = delegatedInstance ; return defaultAnswer ( new ReturnsDelegate ( this . delegatedInstance ) ) ; }
public Integer getSequenceNumber () { return sequenceNumber ; }
int expectedMatchersSize = invocation . getArgumentsCount () ;
if ( isDeclaredOnInterface () ) { new Reporter () . cannotCallRealMethodOnInterface () ; }
List matchers = i . argumentsToMatchers () ;
public String toString () { return invocation . toString ( matchers , new PrintSettings () ) ; }
{ this . matchers = invocation . argumentsToMatchers () ; }
{ this . matchers = Invocation . argumentsToMatchers ( invocation . getArguments () ) ; }
public String print ( Invocation invocation ) { return print ( Invocation . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
public String toString () { return new PrintSettings () . print ( argumentsToMatchers ( getArguments () ) , this ) ; }
this . arguments = expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
List matchers = Invocation . argumentsToMatchers ( i . getArguments () ) ;
throw new NoInteractionsWanted ( join ( STRING_CONSTANT , new Location () , STRING_CONSTANT , undesired . getLocation () , scenario ) ) ;
Location lastActualLocation
Location lastActualLocation
Location firstUndesired
Location firstUndesired
join ( STRING_CONSTANT , STRING_CONSTANT , wanted . toString () , new Location () , STRING_CONSTANT , previous . toString () , previous . getLocation () , STRING_CONSTANT )
new Location ()
Location location
Location location
public Localized ( T object ) { this . object = object ; location = new Location () ; }
Location lastLocation = finder . getLastLocation ( chunk ) ;
Location actualLocation
public Location getLocation () { return invocation . getLocation () ; }
Location last = finder . getLastLocation ( invocations ) ;
this . location = new Location () ;
String loc = new Location ( filterReturningEmptyArray ) . toString () ;
Location lastLocation = null ;
{ this . actualMatcher = actualMatcher ; this . location = new Location () ; }
Location lastLocation = finder . getLastLocation ( actualInvocations ) ;
Location actualLocation
Location firstUndesired
Location firstUndesired
Location lastActualLocation
{ Location location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { Location temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
invocation . markStubbed ( new StubInfo ( stubbedInvocation ) ) ;
{ out += line ( STRING_CONSTANT + i . stubInfo () . stubbedAt () ) ; }
{ s . markStubUsed ( invocation ) ; invocation . markStubbed ( new StubInfo ( s ) ) ; return s ; }
isMultiline () || ( ! matchers . isEmpty () && invocationString . length () > Invocation.MAX_LINE_LENGTH )
public void stubbingCompleted ( Invocation invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation undesired
Invocation undesired
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
Mockito . verify ( handler , never () ) . handle ( any ( Invocation . class ) ) ;
public void foundUnusedStub ( Invocation unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
Invocation unused
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
Invocation invocation = new InvocationBuilder () . toInvocation () ;
public void markVerified ( Invocation i ) { verified . add ( i ) ; }
public boolean isVerified ( Invocation invocation ) { return verified . contains ( invocation ) ; }
List < Invocation > getAllInvocations ( ) ;
Invocation invocationOnInterface = new InvocationBuilder () . toInvocation () ;
List < Invocation > unusedStubs
Invocation actual
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
assertNull ( finder . getLastLocation ( Collections . < Invocation > emptyList () ) ) ;
Invocation invocationOnClass = getLastInvocation () ;
Invocation i
Invocation candidate
Invocation candidate
Invocation actual
public Invocation getInvocation () { return this . invocation ; }
public InvocationMatcher ( Invocation invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
Invocation invocation
WarningsFinder finder = new WarningsFinder ( Arrays . < Invocation > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
public boolean isOut ( Invocation invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return ! wanted . matches ( invocation ) ; }
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( Invocation invocation ) { invocations . add ( invocation ) ; }
Invocation invocation = new InvocationBuilder () . toInvocation () ;
public ExposedInvocation ( Invocation toBeExposed ) { methodProxy = ( ( HasCGLIBMethodProxy ) toBeExposed.realMethod ) . getMethodProxy () ; }
Invocation i = new InvocationBuilder () . toInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation = getLastInvocation () ;
Invocation invocation
List < Invocation > getAllInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocation
public void markVerified ( Invocation i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( Invocation i ) { return inOrderContext . isVerified ( i ) ; }
List < Invocation > getInvocations ( ) ;
Invocation invocation
Invocation invocation
Invocation invocation
List < Invocation > allInvocations
Invocation invocation
given ( handler.invocationContainerImpl . findAnswerFor ( any ( Invocation . class ) ) ) . willReturn ( value ) ;
Invocation previous = new InvocationBuilder () . toInvocation () ;
Invocation actual = new InvocationBuilder () . toInvocation () ;
public String print ( Invocation invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
Invocation invocation
Invocation invocation
Object answerTo ( Invocation invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
Invocation invocation = invocationForStubbing . getInvocation () ;
Invocation actualInvocation = new InvocationBuilder () . toInvocation () ;
Invocation actual
Invocation actual
Invocation invocation
Invocation invocation
Invocation invocation
List < Invocation > unusedStubs
List < Invocation > unusedStubs
Invocation nullDereference
Invocation compareTo = this . getLastInvocation () ;
public MethodInfo ( PublicInvocation theInvocation ) { this . method = theInvocation . getMethod () ; }
PublicInvocation theInvocation
InvocationImpl compareTo = this . getLastInvocation () ;
List < InvocationImpl > allInvocations
InvocationImpl previous = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl actual = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > getAllInvocations ( ) ;
List < InvocationImpl > getAllInvocations ( ) ;
public String print ( InvocationImpl invocation ) { return print ( ArgumentsProcessor . argumentsToMatchers ( invocation . getArguments () ) , invocation ) ; }
InvocationImpl invocation
InvocationImpl i
InvocationImpl candidate
InvocationImpl candidate
InvocationImpl actual
public InvocationImpl getInvocation () { return this . invocation ; }
public InvocationMatcher ( InvocationImpl invocation ) { this ( invocation , Collections . < Matcher > emptyList () ) ; }
InvocationImpl invocation
List < InvocationImpl > invocations
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
public void stubbingCompleted ( InvocationImpl invocation ) { threadSafely () . stubbingCompleted ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { inOrderContext . markVerified ( i ) ; }
public boolean isVerified ( InvocationImpl i ) { return inOrderContext . isVerified ( i ) ; }
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
public void foundUnusedStub ( InvocationImpl unused ) { logger . log ( STRING_CONSTANT + unused . getLocation () + STRING_CONSTANT ) ; }
InvocationImpl unused
List < InvocationImpl > getInvocations ( ) ;
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocationOnInterface = new InvocationBuilder () . toInvocation () ;
InvocationImpl actual
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
List < InvocationImpl > unusedStubs
{ public InvocationMatcher bindMatchers ( ArgumentMatcherStorage argumentMatcherStorage , InvocationImpl invocation ) { throw new InvalidUseOfMatchersException () ; } }
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
public boolean isOut ( InvocationImpl invocation ) { return ! orderingContext . isVerified ( invocation ) ; }
public boolean isOut ( InvocationImpl invocation ) { return ! wanted . matches ( invocation ) ; }
InvocationImpl undesired
InvocationImpl undesired
List < InvocationImpl > chunk
InvocationImpl invocation
List < InvocationImpl > unusedStubs
List < InvocationImpl > unusedStubs
InvocationImpl invocationOnClass = getLastInvocation () ;
public boolean isOut ( InvocationImpl invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
public void add ( InvocationImpl invocation ) { invocations . add ( invocation ) ; }
public void markVerified ( InvocationImpl i ) { verified . add ( i ) ; }
public boolean isVerified ( InvocationImpl invocation ) { return verified . contains ( invocation ) ; }
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl actualInvocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = invocationForStubbing . getInvocation () ;
InvocationImpl actual
InvocationImpl actual
InvocationImpl i = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
InvocationImpl invocation = getLastInvocation () ;
public LocationImpl getLocation () { return invocation . getLocation () ; }
LocationImpl lastLocation = finder . getLastLocation ( chunk ) ;
LocationImpl lastLocation = null ;
LocationImpl actualLocation
{ LocationImpl location = verificationMode . getLocation () ; verificationMode = null ; reporter . unfinishedVerificationException ( location ) ; }
if ( stubbingInProgress != null ) { LocationImpl temp = stubbingInProgress ; stubbingInProgress = null ; reporter . unfinishedStubbing ( temp ) ; }
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl lastActualLocation
LocationImpl lastLocation = finder . getLastLocation ( actualInvocations ) ;
LocationImpl location
LocationImpl lastActualLocation
LocationImpl lastActualLocation
LocationImpl lastActualInvocation
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl firstUndesired
LocationImpl actualLocation
LocationImpl location
LocationImpl location
LocationImpl last = finder . getLastLocation ( invocations ) ;
LocationImpl actualLocation
InvocationImpl invocation = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
InvocationImpl invocation
for ( InvocationImpl i : unusedStubs ) { findingsListener . foundUnusedStub ( i ) ; }
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl invocation
InvocationImpl previousInOrder = finder . findPreviousVerifiedInOrder ( invocations , context ) ;
InvocationImpl invocation
Object answerTo ( InvocationImpl invocation ) throws Throwable { return findAnswerFor ( invocation ) . answer ( invocation ) ; }
InvocationImpl nullDereference
InvocationImpl invocation
InvocationImpl previous = new InvocationBuilder () . toInvocation () ;
InvocationImpl invocation
{ markVerified ( chunk , wanted ) ; for ( InvocationImpl i : chunk ) { context . markVerified ( i ) ; } }
InvocationImpl invocation
return new LinkedList < InvocationImpl > ( invocationsInOrder ) ;
assertNull ( finder . getLastLocation ( Collections . < InvocationImpl > emptyList () ) ) ;
synchronized ( invocations ) { copiedList = new LinkedList < InvocationImpl > ( invocations ) ; }
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList ( stub ) , Arrays . < InvocationMatcher > asList ( wrongArg ) ) ;
WarningsFinder finder = new WarningsFinder ( Arrays . < InvocationImpl > asList () , Arrays . < InvocationMatcher > asList ( unstubbedInvocation ) ) ;
{ new Reporter () . tooLittleActualInvocations ( new Discrepancy ( NUMBER_CONSTANT , NUMBER_CONSTANT ) , new InvocationBuilder () . toInvocation () , null ) ; }
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
Discrepancy discrepancy
STRING_CONSTANT + Pluralizer . pluralize ( wantedCount ) + STRING_CONSTANT
@ Override public void wantedButNotInvoked ( PrintableInvocation wanted ) { this . wanted = wanted ; }
PrintableInvocation invocation
public StubInfoImpl ( PrintableInvocation stubbedAt ) { this . stubbedAt = stubbedAt ; }
public void markStubUsed ( PrintableInvocation usedAt ) { this . usedAt = usedAt ; }
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
PrintableInvocation wanted
public void wantedButNotInvoked ( PrintableInvocation wanted ) { throw new WantedButNotInvoked ( createWantedButNotInvokedMessage ( wanted ) ) ; }
{ return new MockingDetails ( toInspect , new MockUtil () ) ; }
Invocation invocationOnClass = getLastInvocation () ;
InvocationTest . class
MockitoAnnotations.Mock annotation
{ return ( Answer < T > ) new ReturnsIdentity ( position ) ; }
new ReturnsIdentity ( NUMBER_CONSTANT )
{ validator . validate ( new ReturnsIdentity ( ReturnsIdentity.LAST_ARGUMENT ) , new InvocationBuilder () . simpleMethod () . toInvocation () ) ; fail () ; }
validator . validate ( new ReturnsIdentity ( NUMBER_CONSTANT ) , new InvocationBuilder () . method ( STRING_CONSTANT ) . arg ( STRING_CONSTANT ) . toInvocation () ) ;
{ ( ( Factory ) mock ) . setCallback ( NUMBER_CONSTANT , new MethodInterceptorFilter ( newHandler , settings ) ) ; }
MockitoInvocationHandler handler
InvocationNotifierHandler oldHandler = ( InvocationNotifierHandler ) mockMaker . getHandler ( mock ) ;
Class < > [] extraInterfaces
public MockSettingsImpl getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsImpl settings
Class < > [] extraInterfaces
if ( isMockOrSpy ( instance ) ) { mockUtil . redefineMockNameIfSurrogate ( instance , field . getName () ) ; return instance ; }
MockSettingsImpl settings = oldHandler . getMockSettings () ;
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
mockUtil . redefineMockNameIfSurrogate ( mock , STRING_CONSTANT ) ;
public void validateExtraInterfaces ( Class classToMock , Class . . . interfaces ) { extraInterfacesValidated = true ; }
MockSettingsImpl mockSettings
@ SuppressWarnings ( STRING_CONSTANT ) MockHandler < > handler = new MockHandler () ;
T mock = mockUtil . createMock ( classToMock , ( MockSettingsImpl ) mockSettings ) ;
Class . . . extraInterfaces
name . isSurrogate ()
{ this . mockName = toInstanceName ( classToMock ) ; this . surrogate = true ; }
{ if ( getMockName ( mock ) . isSurrogate () ) { getMockHandler ( mock ) . getMockSettings () . redefineMockName ( newName ) ; } }
IMethods methods = mock ( IMethods . class , withSettings () . forwardTo ( new MethodsImpl () ) ) ;
List < String > mockedList = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
List < String > mock = mock ( List . class , withSettings () . forwardTo ( delegatedList ) ) ;
MockSettingsInfo settings = oldHandler . getMockSettings () ;
MockSettingsInfo mockSettings
public MockSettingsInfo getMockSettings () { return mockHandler . getMockSettings () ; }
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo settings
MockSettingsInfo mockSettings
{ mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null , null ) ; }
mockingProgress . mockingStarted ( mock , typeToMock , settings ) ;
MockHandler < T > mockHandler
MockHandlerTest . class
newHandler = new InvocationNotifierHandler < T > ( new MockHandler < T > ( settings ) , settings )
MockHandlerInterface mockitoHandler = cast ( handler ) ;
MockHandlerInterface handler
MockitoInvocationHandler newHandler
MockitoInvocationHandler handler
MockitoInvocationHandler newHandler
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAtPosition ( NUMBER_CONSTANT ) ) ;
MockHandlerImpl < T > mockHandler
{ return primitiveOf ( type ) ; }
result = NUMBER_CONSTANT * result + ( onClass != null ? onClass . hashCode () : NUMBER_CONSTANT ) ;
registerTypeVariablesOn ( clazz ) ;
return typeVariable . equals ( ( ( BoundedType ) o ) . typeVariable ) ;
< O extends K > O typeVarWithTypeParams ( ) ;
< S , T extends S > T twoTypeParams ( ) ;
List < ? super Integer > returningWildcard ( ) ;
public void setMockitoGenericMetadata ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; }
public MockSettings parameterizedInfo ( MockitoGenericMetadata mockitoGenericMetadata ) { this . mockitoGenericMetadata = mockitoGenericMetadata ; return this ; }
MockitoGenericMetadata returnTypeGenericMetadata
{ VerificationDataImpl data = new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; verificationMode . verify ( data ) ; return null ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockingProgress ) ;
RegisteredInvocationsTest . class
RegisteredInvocationsAllTest . class
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new RegisteredInvocationsAll () ; }
{ return mockSettings . isStubOnly () ? new RegisteredInvocationsStubOnly () : new DefaultRegisteredInvocations () ; }
catch ( NotAMockException e ) {}
@ After public void yesIKnowSomeMatchersAreMisplaced () { resetState () ; }
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseWrongStubbingSyntaxInConfigurationMethod . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectStubbingSyntax . class ) ;
TestNG testNG = new_TestNG_with_failure_recorder_for ( FailingBecauseIncorrectAnnotationUsage . class ) ;
{ if ( mockitoGenericMetadata == null ) { this . mockitoGenericMetadata = GenericMetadataSupport . from ( typeToMock ) ; } return mockitoGenericMetadata ; }
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( StringBuilder . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , StringBuilder . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericMetadataSupport genericMetadata = from ( GenericsNest . class ) . resolveGenericReturnType ( firstNamedMethod ( STRING_CONSTANT , GenericsNest . class ) ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
GenericsNest < > mock = mock ( GenericsNest . class , new ReturnsGenericDeepStubs () ) ;
return recordDeepStubMock ( returnTypeGenericMetadata . toMock ( this ) , container ) ;
static MockMaker findPlatformMockMaker () { return findPluginImplementation ( MockMaker . class , new CglibMockMaker () ) ; }
if ( ! ClassImposterizer.INSTANCE . canImposterise ( clazz ) ) { return null ; }
{ if ( ! isTypeMockable ( classToMock ) ) { new Reporter () . cannotMockFinalClass ( classToMock ) ; } }
{ return mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
if ( ! new MockCreationValidator () . isTypeMockable ( rawType ) ) { return delegate . returnValueFor ( rawType ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + pluginType , e ) ; }
NotSerializableToBeMocked ( Observable o ) { super ( o ) ; }
MockCreationSettings mockSettings = new MockUtil () . getMockHandler ( mockitoMock ) . getMockSettings () ;
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
{ if ( Factory . class . isAssignableFrom ( cl ) ) { return STRING_CONSTANT ; } else { return STRING_CONSTANT ; } }
{ return ! STRING_CONSTANT . equals ( marker ) ; }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock ; }
public boolean isSpy ( Object mock ) { return mock instanceof MockitoSpy && isMock ( mock ) ; }
public boolean isMock ( Object mock ) { return mock != null && isMockitoMock ( mock ) ; }
catch ( ObjectStreamException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
{ SimpleSerializationUtil . serializeAndBack ( mockWithPrivateConstructor ) ; }
AClassToBeMockedInThisTestOnlyAndInCallablesOnly mock = Mockito . mock ( AClassToBeMockedInThisTestOnlyAndInCallablesOnly . class , Mockito . withSettings () . serializable () ) ;
this . serializable = copy.serializable ;
{ if ( mockUtil . isMock ( cl ) ) { return MOCKITO_PROXY_MARKER ; } else { return NOTHING ; } }
public boolean isMock ( Object mock ) { return mock instanceof MockitoMock && isMockitoMock ( mock ) ; }
verify ( mock , timeout ( NUMBER_CONSTANT ) . never () ) . clear () ;
public VerificationMode never () { new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
{ new Reporter () . atMostShouldNotBeUsedWithTimeout () ; return null ; }
verify ( target , timeout ( TEST_MILLIS ) . times ( TIMES * nThreads ) ) . targetMethod ( STRING_CONSTANT ) ;
public int getTreshhold () { return pollingPeriod ; }
{ return new After ( wrappedVerification . getDelay () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getTimeout () , newVerificationMode ) ; }
{ super ( new VerificationWithTimeoutImpl ( pollingPeriod , millis , delegate ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDelay () , verificationMode ) ; }
{ super ( new VerificationAfterDelayImpl ( pollingPeriod , delayMillis , verificationMode ) ) ; }
assertEquals ( expectedTimeout , ( ( Timeout ) t ) . wrappedVerification . getTimeout () ) ;
{ if ( canRecoverFromFailure ( delegate ) ) { error = e ; sleep ( pollingPeriod ) ; } else { throw e ; } }
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( STRING_CONSTANT ) . withPrivateCopyOf ( STRING_CONSTANT ) . build () ;
{ cl . loadClass ( STRING_CONSTANT ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
{ cl . loadClass ( CLASS_NAME_USING_INTERFACE ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( typeParameter , actualType ) ; }
return wildCardBoundedType ;
return new TypeVarBoundedType ( typeParameter ) ;
{ for ( TypeVariable typeParameter : typeParameters ) { contextualActualTypeParameters . put ( typeParameter , boundsOf ( typeParameter ) ) ; } }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = new SerializableTypeVariable ( typeVariable ) ; }
{ Type actualType = getActualTypeArgumentFor ( typeParameter ) ; actualTypeArguments . put ( new SerializableTypeVariable ( typeParameter ) , actualType ) ; }
return new SerializableBoundedType ( wildCardBoundedType ) ;
return new SerializableBoundedType ( new TypeVarBoundedType ( typeParameter ) ) ;
{ return mockitoCore . mock ( returnTypeGenericMetadata . rawType () , withSettingsUsing ( returnTypeGenericMetadata ) ) ; }
private ReturnsDeepStubs returnsDeepStubsAnswerUsing ( final GenericMetadataSupport returnTypeGenericMetadata ) { return new NotSerializableGenericsAwareReturnsDeepStubs ( returnTypeGenericMetadata ) ; }
return makeDeepMock ( invocation , returnTypeGenericMetadata ) ;
{ return verify ( mock , mode ) ; }
public T should () { return verify ( mock ) ; }
{ return Mockito . verify ( mock , mode ) ; }
public T should () { return Mockito . verify ( mock ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
if ( isEquals == false ) { return this ; }
{ return ( T ) primitiveOrWrapperDefaultValues . get ( primitiveOrWrapperType ) ; }
{ return primitiveOrWrapperDefaultValues . containsKey ( type ) ; }
{ if ( clazz . isPrimitive () ) { return clazz ; } return ( Class < T > ) primitiveTypes . get ( clazz ) ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportNot () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . < T > returnNull () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return mockingProgress . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
if ( ! cleaner . isOut ( unfilteredStackTrace . get ( i ) ) ) { continue; }
T extends Object
int delayMillis
int millis
int millis
public int getDuration () { return durationMillis ; }
public int getPollingPeriod () { return pollingPeriodMillis ; }
int sleep
{ verifyNoMoreInteractions ( null ) ; }
{ verifyNoMoreInteractions ( null ) ; }
{ inOrder ( null ) ; }
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
String expectedCause = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
@ Override public int hashCode () { return method != null ? method . hashCode () : NUMBER_CONSTANT ; }
durationChecker . isVerificationStillInProgress ( startTime )
this . durationChecker = new DurationCheckerImpl ( durationMillis ) ;
when ( timer . isUp ( anyLong () ) ) . thenReturn ( true , true , true , true , true , false ) ;
public void reset () { mockingProgress . reset () ; }
Mockito . when ( clazzMock . isValid () ) . thenReturn ( true ) ;
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( MockitoLimitations.NON_PUBLIC_PARENT ) ; }
{ return type == null ? STRING_CONSTANT : type . getCanonicalName () + STRING_CONSTANT + type . getClassLoader () + STRING_CONSTANT ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) ;
return new ClassImposterizer ( new CachingObjenesisInstanceFactory () ) . imposterise ( new MethodInterceptorFilter ( mockitoHandler , settings ) , settings . getTypeToMock () , settings . getExtraInterfaces () ) ;
imposterizer = new ClassImposterizer ( new ConstructorInstanceFactory () ) ;
Factory proxy = instanceFactory . newInstance ( proxyClass ) ;
STRING_CONSTANT + instanceFactory . getClass () . getSimpleName ()
new ClassImposterizer ( new CachingObjenesisInstantiator () )
ClassImposterizer imposterizer = new ClassImposterizer ( new CachingObjenesisInstantiator () ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
ClassImposterizerTest . class
DefaultClassImposterizerTest . class
new DefaultClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
CglibClassImposterizerTest . class
new CglibClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
cglibHacker . setMockitoNamingPolicy ( mockitoMethodProxy ) ;
{ return methodProxy . invokeSuper ( target , arguments ) ; }
FilteredCGLIBProxyRealMethod realMethod = new FilteredCGLIBProxyRealMethod ( mockitoMethodProxy ) ;
{ sourceJarComparator . addPair ( left , right ) ; }
boolean jars = sourceJarComparator . areEqual () ;
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeListWithWrongMethods <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
mock = mock ( List . class , delegatesTo ( new FakeList <> () ) )
{ return new ArrayList <> () ; }
{ return new ArrayList <> () ; }
BinaryComparator.Result result = binaryComparator . compareFiles () ;
{ binaryComparator . setPair ( left , right ) ; }
ClassImposterizer imposterizer = new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () ) ;
new ClassImposterizer ( new InstantiatorProvider () . getInstantiator () )
{ if ( settings . isUsingConstructor () ) { return new ConstructorInstantiator () ; } else { return INSTANCE ; } }
imposterizer = new ClassImposterizer ( new ConstructorInstantiator () ) ;
catch ( InstantationException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public String toString () { return author + STRING_CONSTANT + commits . size () ; }
{ email = commit . getEmail () ; author = commit . getAuthor () ; commits . add ( commit ) ; }
public String getEmail () { return email ; }
GitCommit commit
GitCommit commit
{ return new GitContributionsProvider ( runner ) ; }
{ return new GitContributionsProvider ( new GitLogProvider ( runner ) ) ; }
DefaultContributionSet contributions = new DefaultContributionSet () ;
if ( commit . getMessage () . contains ( STRING_CONSTANT ) ) { return; }
Map.Entry < String , DefaultContribution > entry
if ( ! m . matches () ) { throw new ReleaseNotesException ( STRING_CONSTANT + releaseNotesContent ) ; }
if ( out == null ) { throw new ReleaseNotesException ( STRING_CONSTANT + envVariableName + STRING_CONSTANT ) ; }
int id
public GitHubImprovementsProvider ( GitHubAuthToken authToken ) { this . authToken = authToken ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return new GloballyConfiguredAnswer () . answer ( invocation ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.CALLS_REAL_METHODS . get () . answer ( invocation ) ; }
String content = IOUtil . readStream ( response ) ;
catch ( NoSuchMethodException noDefaultConstructor ) { throw new MockitoException ( STRING_CONSTANT + type ) ; }
{ return new Then < T > ( mock ) ; }
try { closeable . close () ; } catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + closeable ) ; }
catch ( IOException e ) { throw new MockitoException ( STRING_CONSTANT + reader ) ; }
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + output ) ; }
assertEquals ( asList ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) , IOUtil . readLines ( new FileReader ( file ) ) ) ;
if ( ! pluginSwitcher . isEnabled ( pluginClassName ) ) { continue; }
String foundPluginClass = new PluginFinder ( pluginSwitcher ) . findPluginClass ( Iterables . toIterable ( resources ) ) ;
LinkedList < ReleaseStep > targets = new LinkedList < ReleaseStep > () ;
{ jUnitRule . apply ( new ExceptionStatement () , Description.EMPTY ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ injectTestCase = new InjectTestCase () ; jUnitRule = new JUnitRule ( injectTestCase ) ; }
if ( Modifier . isAbstract ( invocation . getMethod () . getModifiers () ) ) { return Answers.RETURNS_DEFAULTS . get () . answer ( invocation ) ; }
mockSettings . defaultAnswer ( annotation . answer () . get () ) ;
Operation getStep ( int stepNumber ) ;
return new DefaultGitAuthor ( currentLocalUser , currentLocalEmail ) ;
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ return ( T ) reportMatcher ( new InstanceOf ( clazz ) ) . returnFor ( clazz ) ; }
{ return ( T ) reportMatcher ( new InstanceOf ( Object . class ) ) . returnNull () ; }
String expectedMessage = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ;
public static VersionTool getVersionTool () { return new DefaultVersionTool () ; }
int millis
public ClassLoader build () { return new InMemoryClassLoader ( inMemoryClassObjects ) ; }
catch ( ArgumentsAreDifferent e ) { error = handleVerifyException ( e ) ; }
if ( paramsMatch ( types , params ) ) { return ( T ) constructor . newInstance ( params ) ; }
catch ( InstantationException e ) { throw new MockitoException ( STRING_CONSTANT + proxyClass . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
int result = mockType . hashCode () ;
if ( ! mockType . equals ( mockKey.mockType ) ) return false ;
Class < > mockedType
{ return ( Class < ? extends T > ) previousClasses . get ( mockKey ) ; }
@ Origin Method method
@ Origin Method method
@ Origin Method method
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces , true ) ;
{ return ( Class < ? extends T > ) PREVIOUS_CLASSES . get ( mockKey ) ; }
PREVIOUS_CLASSES . put ( mockKey , mockType ) ;
T mock = silentConstructor . instantiate ( mockedType ) ;
if ( ! ( handler instanceof InternalMockHandler ) ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
Class < > proxyClass = new ByteBuddyMockMaker () . getOrMakeMock ( typeToMock , extraInterfaces ) ;
Class < > proxyClass = new CachingBytecodeGenerator () . get ( typeToMock , extraInterfaces ) ;
assumeTrue ( cache . size () == NUMBER_CONSTANT ) ;
assumeTrue ( cachingMockBytecodeGenerator.avoidingClassLeakageCache . size () == NUMBER_CONSTANT ) ;
byteBuddy . subclass ( mockedType , ConstructorStrategy.Default.NO_CONSTRUCTORS ) . name ( nameFor ( mockedType ) )
{ return thiz . getMockitoInterceptor () . getAcrossJVMSerializationFeature () . writeReplace ( thiz ) ; }
{ this . handler = handler ; this . mockCreationSettings = mockCreationSettings ; acrossJVMSerializationFeature = new AcrossJVMSerializationFeature () ; }
ClassImposterizerTest . class
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( unsortedFields , new PropertyAndSetterInjection.FieldTypeAndNameComparator () ) ;
Collections . sort ( unsortedFields , cmp ) ;
Collections . sort ( declaredFields , superTypesLast ) ;
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + mockMethod + STRING_CONSTANT + new MockUtil () . getMockName ( mock )
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
STRING_CONSTANT + new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () + STRING_CONSTANT
@ Before public void setup () { mock = Mockito . mock ( IMethods . class ) ; }
try { validator . validate ( new CallsRealMethods () , invocationOnInterface ) ; fail () ; } catch ( MockitoException e ) {}
catch ( MockitoException e ) {}
{ try { Thread . sleep ( sleep ) ; } catch ( InterruptedException ie ) {} }
{ this ( pollingPeriodMillis , durationMillis , delegate , returnOnSuccess , new Timer ( durationMillis ) ) ; }
{ return new After ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , verificationMode ) ; }
{ return new Timeout ( wrappedVerification . getPollingPeriod () , wrappedVerification . getDuration () , newVerificationMode ) ; }
{ super ( new VerificationOverTimeImpl ( pollingPeriodMillis , millis , delegate , true ) ) ; }
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
@ Origin ( cacheMethod = true ) Method invokedMethod
ArrayList < Improvement > pagedImprovements = new ArrayList <> () ;
try { argument . getValue () ; fail () ; } catch ( MockitoException e ) {}
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
CapturesArgumensFromInvocation wanted
Mockito . verify ( c.invocationMarker ) . markVerified ( eq ( asList ( invocation ) ) , any ( CapturesArgumensFromInvocation . class ) ) ;
{ injectionOccurred |= injectMockCandidates ( fieldClass , newMockSafeHashSet ( mockCandidates ) , fieldInstanceNeedingInjection ) ; fieldClass = fieldClass . getSuperclass () ; }
{ ( ( MockMethodInterceptor.MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
MockMethodInterceptor.MockAccess mockAccess = ( MockMethodInterceptor.MockAccess ) mockInstance ;
if ( interceptor == null ) { return null ; }
{ return StringDescription . toString ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsExtraTypeInformation equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsExtraTypeInformation equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) . withExtraTypeInfo () ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertSame ( m , m . withExtraTypeInfo () ) ; }
ContainsExtraTypeInformation equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ return new MatchersPrinter () . print ( m ) . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
Class classToMock
Class classToMock
Class classToMock
Class classToMock
the_mock_type = cachingMockBytecodeGenerator . get ( withMockFeatures ( classloader_with_life_shorter_than_cache . loadClass ( STRING_CONSTANT ) , Collections . < Class > emptySet () , false ) )
Set < Class > extraInterfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > interfaces
Set < Class > extraInterfaces
{ byteBuddy = new ByteBuddy ( ClassFileVersion.JAVA_V5 ) . withDefaultMethodAttributeAppender ( MethodAttributeAppender.ForInstrumentedMethod.INSTANCE ) . withAttribute ( TypeAttributeAppender.ForSuperType.INSTANCE ) ; random = new Random () ; }
Matcher m
Matcher m = matchers . get ( position ) ;
List < Matcher > matchers
Matcher m
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( describe ( m ) , m . getTypedDescription () ) ; }
if ( actualMatcher instanceof ContainsTypedDescription ) { return ( ( ContainsTypedDescription ) actualMatcher ) . getTypedDescription () ; } else { return HamcrestPrinter . print ( actualMatcher ) ; }
Matcher actualMatcher
List < Matcher > matchers
{ for ( Matcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < Matcher > matchers ) { this . matchers = matchers ; }
InvocationMatcher invocationWithMatchers = new InvocationMatcher ( invocation , ( List < Matcher > ) ( List ) lastMatchers ) ;
Matcher matcher
{ for ( Matcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < Matcher > matchers ) { this . matchers = matchers ; }
private static HandyReturnValues reportMatcher ( ArgumentMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
private static HandyReturnValues reportMatcher ( Matcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
Matcher < Double > matcher
Matcher < Float > matcher
Matcher < Long > matcher
Matcher < Integer > matcher
Matcher < Short > matcher
Matcher < Byte > matcher
Matcher < Boolean > matcher
Matcher < Character > matcher
assertEquals ( name + STRING_CONSTANT , describe ( compareTo ) ) ;
public Not ( Matcher first ) { this . first = first ; }
{ String descStr = describe ( new Equals ( null ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( NUMBER_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( CHAR_CONS ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = describe ( new Equals ( STRING_CONSTANT ) ) ; assertEquals ( STRING_CONSTANT , descStr ) ; }
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , describe ( new Matches ( STRING_CONSTANT ) ) ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , describe ( new Find ( STRING_CONSTANT ) ) ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , describe ( new Contains ( STRING_CONSTANT ) ) ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new EndsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , describe ( new StartsWith ( STRING_CONSTANT ) ) ) ; }
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , describe ( new Not ( new Equals ( NUMBER_CONSTANT ) ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Equals ( o ) ) ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( CHAR_CONS ) ) ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Equals ( STRING_CONSTANT ) ) ) ; }
assertEquals ( STRING_CONSTANT , describe ( new Same ( o ) ) ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , describe ( new Same ( CHAR_CONS ) ) ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , describe ( new Same ( STRING_CONSTANT ) ) ) ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
{ LocalizedMatcher m = new LocalizedMatcher ( Any.ANY ) ; assertEquals ( m . describe () , m . getTypedDescription () ) ; }
ContainsTypedDescription equals10 = new Equals ( NUMBER_CONSTANT ) ;
{ ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ; assertFalse ( equals . typeMatches ( null ) ) ; }
{ ContainsTypedDescription equals = new Equals ( null ) ; assertFalse ( equals . typeMatches ( NUMBER_CONSTANT ) ) ; }
ContainsTypedDescription equals = new Equals ( NUMBER_CONSTANT ) ;
{ String descStr = new Equals ( null ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( CHAR_CONS ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . describe () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( STRING_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
{ String descStr = new Equals ( NUMBER_CONSTANT ) . getTypedDescription () ; assertEquals ( STRING_CONSTANT , descStr ) ; }
Equals matcherWithBadDescription = new Equals ( NUMBER_CONSTANT ) { public String describe () { return STRING_CONSTANT ; } } ;
{ return reportMatcher ( new Find ( regex ) ) . < String > returnNull () ; }
public String describe () { return describe ( wanted ) ; }
assertEquals ( name + STRING_CONSTANT , compareTo . describe () ) ;
@ Test public void matchesToString () { assertEquals ( STRING_CONSTANT , new Matches ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void findToString () { assertEquals ( STRING_CONSTANT , new Find ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void containsToString () { assertEquals ( STRING_CONSTANT , new Contains ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void endsWithToString () { assertEquals ( STRING_CONSTANT , new EndsWith ( STRING_CONSTANT ) . describe () ) ; }
@ Test public void startsWithToString () { assertEquals ( STRING_CONSTANT , new StartsWith ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new And ( matchers ) . describe () ) ;
@ Test public void notToString () { assertEquals ( STRING_CONSTANT , new Not ( new Equals ( NUMBER_CONSTANT ) ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Or ( matchers ) . describe () ) ;
assertEquals ( STRING_CONSTANT , new Equals ( o ) . describe () ) ;
@ Test public void equalsToStringWithChar () { assertEquals ( STRING_CONSTANT , new Equals ( CHAR_CONS ) . describe () ) ; }
@ Test public void equalsToStringWithString () { assertEquals ( STRING_CONSTANT , new Equals ( STRING_CONSTANT ) . describe () ) ; }
assertEquals ( STRING_CONSTANT , new Same ( o ) . describe () ) ;
@ Test public void sameToStringWithChar () { assertEquals ( STRING_CONSTANT , new Same ( CHAR_CONS ) . describe () ) ; }
@ Test public void sameToStringWithString () { assertEquals ( STRING_CONSTANT , new Same ( STRING_CONSTANT ) . describe () ) ; }
{ return m . describe () . equals ( arg == null ? STRING_CONSTANT : arg . toString () ) ; }
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
out . append ( new Equals ( array [ i ] ) . describe () ) ;
public String describe () { return STRING_CONSTANT ; }
public String describe () { return STRING_CONSTANT ; }
{ out . add ( new FormattedText ( matcher . toString () ) ) ; }
{ for ( MockitoMatcher matcher : matchers ) { if ( matcher . matches ( actual ) ) { return true ; } } return false ; }
public Or ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
List < MockitoMatcher > matchers
List < MockitoMatcher > matchers
MockitoMatcher m
MockitoMatcher m
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher < Double > matcher
MockitoMatcher < Float > matcher
MockitoMatcher < Long > matcher
MockitoMatcher < Integer > matcher
MockitoMatcher < Short > matcher
MockitoMatcher < Byte > matcher
MockitoMatcher < Boolean > matcher
MockitoMatcher < Character > matcher
MockitoMatcher matcher
MockitoMatcher m
MockitoMatcher m = matchers . get ( position ) ;
List < MockitoMatcher > matchers
private static HandyReturnValues reportMatcher ( MockitoMatcher < > matcher ) { return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( matcher ) ; }
MockitoMatcher matcher
MockitoMatcher matcher
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , Arrays . < MockitoMatcher > asList ( new Equals ( NUMBER_CONSTANT ) , m ) ) ;
{ for ( MockitoMatcher matcher : matchers ) { if ( ! matcher . matches ( actual ) ) { return false ; } } return true ; }
public And ( List < MockitoMatcher > matchers ) { this . matchers = matchers ; }
List < MockitoMatcher > matchers
public Not ( MockitoMatcher first ) { this . first = first ; }
@ After public void resetState () { super . resetState () ; }
{ return MOCKITO_CORE . doAnswer ( new Returns ( toBeReturned ) ) ; }
{ return MOCKITO_CORE . doAnswer ( new DoesNothing () ) ; }
{ return MOCKITO_CORE . doAnswer ( answer ) ; }
{ return MOCKITO_CORE . doAnswer ( new CallsRealMethods () ) ; }
if ( throwables == null ) { thenThrow ( ( Throwable ) null ) ; }
assertEquals ( expectedMock , returnedMock ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
assertEquals ( STRING_CONSTANT , dog . bark () ) ;
public ThrowsExceptionClass ( Class < ? extends Throwable > throwableClass ) { this . throwableClass = throwableClass ; }
verify ( mock ) . simpleMethod ( anyObject () ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( anyObject () ) ) . thenReturn ( STRING_CONSTANT ) ;
when ( mock . oneArg ( any () ) ) . thenReturn ( STRING_CONSTANT ) ;
Instantiator instantiator = new InstantiatorProvider () . getInstantiator ( settings ) ;
byteBuddy = new ByteBuddy () . withDefaultMethodAttributeAppender ( new MethodAttributeAppender.ForInstrumentedMethod ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) . withAttribute ( new TypeAttributeAppender.ForSuperType ( AnnotationAppender.ValueFilter.AppendDefaults.INSTANCE ) ) ;
for ( AllTestsRunner t : threads ) { t . join () ; failed = failed ? true : t . isFailed () ; }
{ pomComparator . setPair ( left , right ) ; }
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec . getProcessRunner ( workDir ) ) ;
ContributionsProvider contributionsProvider = Vcs . getGitProvider ( Exec.INSTANCE . getProcessRunner ( workDir ) ) ;
public MockBytecodeGenerator () { byteBuddy = new ByteBuddy () ; random = new Random () ; }
runner . addListener ( new TextListener ( System.out ) ) ;
{ return invocation . getMock () == invocation . getArguments () [ NUMBER_CONSTANT ] ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
String arg = ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
int secondArgument = invocationOnInterface . getArgumentAt ( NUMBER_CONSTANT , int . class ) ;
{ validateIndexWithinInvocationRange ( invocation ) ; return invocation . getArguments () [ actualArgumentPosition ( invocation ) ] ; }
ImportLogBean bean = ( ImportLogBean ) invocation . getArguments () [ NUMBER_CONSTANT ] ;
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
{ return ( String ) invocation . getArguments () [ NUMBER_CONSTANT ] ; }
runner = new MockitoJUnit44Runner ( DummyTest . class ) ;
ArgumentCaptor < Person > argument = new ArgumentCaptor < Person > () ;
{ try { new ReturnsElementsOf ( null ) ; fail () ; } catch ( MockitoException e ) {} }
{ this . jUnitRule = new JUnitRule () ; }
{ assertEquals ( STRING_CONSTANT , e . getMessage () ) ; assertTrue ( logger . getLoggedInfo () . startsWith ( STRING_CONSTANT ) ) ; }
assertEquals ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , listener . getStubbingInfo () ) ;
{ ( ( CapturesArguments ) m ) . captureFrom ( invocation . getArgumentAt ( position , Object . class ) ) ; }
assertThat ( mock , is ( List . class ) ) ;
{ return CoreMatchers . is ( type ) ; }
assertThat ( runner , is ( JUnit45AndHigherRunnerImpl . class ) ) ;
assertThat ( runner , is ( JUnit44RunnerImpl . class ) ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
public void reportOngoingStubbing ( IOngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
stubVoid ( mock ) . toAnswer ( recordCall ) . on () . voidMethod () ;
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( new RuntimeException () ) . on () . clone () ;
stubVoid ( mock ) . toThrow ( expected ) . on () . clear () ;
{ return CoreMatchers . isA ( ( Class ) type ) ; }
{ jUnitRule . apply ( new UnfinishedStubbingStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
{ jUnitRule . apply ( new ExceptionStatement () , injectTestCase ) . evaluate () ; fail ( STRING_CONSTANT ) ; }
jUnitRule . apply ( new DummyStatement () , injectTestCase ) . evaluate () ;
{ return new MockitoJUnitRule () ; }
public VerificationCollectorImpl () { this . resetBuilder () ; }
collector . verify ( methods ) . simpleMethod () ;
{ IMethods methods = mock ( IMethods . class ) ; collector . verify ( methods ) . simpleMethod () ; }
MockHandler newHandler = new MockHandlerFactory () . create ( settings ) ;
MockHandler mockHandler = new MockHandlerFactory () . create ( settings ) ;
{ new FieldSetter ( testClass , field ) . set ( mock ) ; }
new FieldSetter ( descInstance , classNameField ) . set ( proxyClass . getCanonicalName () ) ;
{ new FieldSetter ( instance , field ) . set ( value ) ; }
{ new FieldSetter ( testInstance , field ) . set ( mock ) ; }
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
new FieldSetter ( testClass , field ) . set ( newFieldInstance ) ;
if ( ! new BeanPropertySetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ) { new FieldSetter ( injectee , candidateFieldToBeInjected ) . set ( matchingMock ) ; }
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
InternalMockHandler handler = new MockHandlerFactory () . create ( settings ) ;
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
catch ( Throwable listenerThrowable ) { new Reporter () . invocationListenerThrewException ( listener , listenerThrowable ) ; }
public NumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( expectedMatchersSize != recordedMatchersSize ) { new Reporter () . invalidUseOfMatchers ( expectedMatchersSize , lastMatchers ) ; }
{ if ( ! superMethod . isInvokable () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return superMethod . invoke () ; }
{ if ( argumentPosition != LAST_ARGUMENT && argumentPosition < NUMBER_CONSTANT ) { new Reporter () . invalidArgumentRangeAtIdentityAnswerCreationTime () ; } return argumentPosition ; }
if ( unverified != null ) { new Reporter () . noMoreInteractionsWantedInOrder ( unverified ) ; }
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new Reporter () , new InvocationMarker () ) ; }
{ if ( mocks == null || mocks.length == NUMBER_CONSTANT ) { reporter . mocksHaveToBePassedToVerifyNoMoreInteractions () ; } }
if ( stubbing == null ) { mockingProgress . reset () ; reporter . missingMethodInvocation () ; }
{ this . defaultAnswer = defaultAnswer ; if ( defaultAnswer == null ) { new Reporter () . defaultAnswerDoesNotAcceptNullParameter () ; } return this ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
if ( o . isToString ( wanted . getMethod () ) ) { new Reporter () . cannotVerifyToString () ; }
catch ( RuntimeException e ) { new Reporter () . cannotInjectDependency ( candidateFieldToBeInjected , matchingMock , e ) ; }
{ if ( alreadyAssigned ) { new Reporter () . moreThanOneAnnotationNotAllowed ( field . getName () ) ; } }
{ if ( usingConstructor && mode == SerializableMode.ACROSS_CLASSLOADERS ) { new Reporter () . usingConstructorWithFancySerializable ( mode ) ; } }
if ( delegatedInstance . getClass () . isAssignableFrom ( classToMock ) ) { new Reporter () . mockedTypeIsInconsistentWithDelegatedInstanceType ( classToMock , delegatedInstance ) ; }
if ( ! classToMock . equals ( spiedInstance . getClass () ) ) { new Reporter () . mockedTypeIsInconsistentWithSpiedInstanceType ( classToMock , spiedInstance ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { new Reporter () . extraInterfacesCannotContainMockedType ( classToMock ) ; } }
{ if ( mockSettings . isStubOnly () ) { new Reporter () . stubPassedToVerify () ; } return new VerificationDataImpl ( invocationContainerImpl , invocationMatcher ) ; }
if ( ! invocationContainerImpl . hasInvocationForPotentialStubbing () ) { new Reporter () . incorrectUseOfApi () ; }
{ if ( ! methodInfo . isVoid () ) { reporter . onlyVoidMethodsCanBeSetToDoNothing () ; } }
{ if ( methodInfo . isAbstract () ) { reporter . cannotCallAbstractRealMethod () ; } }
if ( foundSize > maxNumberOfInvocations ) { new Reporter () . wantedAtMostX ( maxNumberOfInvocations , foundSize ) ; }
{ if ( method . isAbstract () ) { new Reporter () . cannotCallAbstractRealMethod () ; } return realMethod . invoke ( mock , rawArguments ) ; }
public MissingInvocationChecker () { this ( new InvocationsFinder () , new Reporter () ) ; }
if ( throwableClass == null || ! Throwable . class . isAssignableFrom ( throwableClass ) ) { new Reporter () . notAnException () ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { new Reporter () . invocationListenerDoesNotAcceptNullParameters () ; }
for ( StackTraceElement element : target ) { if ( CLEANER . apply ( element ) ) { filtered . add ( element ) ; } }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isFalse () ; }
{ assertThat ( cleaner . apply ( type ( className ) ) ) . describedAs ( STRING_CONSTANT , className ) . isTrue () ; }
invocationMarker . markVerified ( actualInvocations , wanted ) ;
marker . markVerified ( next , wanted ) ;
public NonGreedyNumberOfInvocationsInOrderChecker () { this ( new InvocationsFinder () , new InvocationMarker () ) ; }
marker . markVerified ( chunk . get ( NUMBER_CONSTANT ) , wantedMatcher ) ;
invocationMarker . markVerifiedInOrder ( chunk , wanted , context ) ;
invocationMarker . markVerifiedInOrder ( chunk , wanted , orderingContext ) ;
invocationMarker . markVerified ( actualInvocations , wanted ) ;
invocationMarker . markVerified ( found , wanted ) ;
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
HandyReturnValues reportMatcher ( ArgumentMatcher matcher ) ;
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnZero () ; }
{ return reportMatcher ( matcher ) . returnFalse () ; }
{ return reportMatcher ( matcher ) . returnChar () ; }
{ return reportMatcher ( matcher ) . < T > returnNull () ; }
{ return reportMatcher ( new StartsWith ( prefix ) ) . returnString () ; }
{ return reportMatcher ( new EndsWith ( suffix ) ) . returnString () ; }
{ return reportMatcher ( new Matches ( regex ) ) . returnString () ; }
{ return reportMatcher ( new Contains ( substring ) ) . returnString () ; }
{ return ( T ) reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return reportMatcher ( NotNull.NOT_NULL ) . returnNull () ; }
{ return ( T ) reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( Null.NULL ) . returnNull () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnChar () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnZero () ; }
{ return reportMatcher ( new Equals ( value ) ) . returnFalse () ; }
{ return ( T ) reportMatcher ( AnyVararg.ANY_VARARG ) . returnNull () ; }
{ return ( T ) reportMatcher ( Any.ANY ) . returnNull () ; }
{ Mockito . argThat ( capturingMatcher ) ; return handyReturnValues . returnFor ( clazz ) ; }
{ return Primitives . defaultValueForPrimitiveOrWrapper ( type ) ; }
assertNull ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) ;
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () . returnFalse () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnChar () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnZero () ; }
{ return MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () . returnFalse () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new ArrayEquals ( value ) ) . returnNull () ; }
{ return reportMatcher ( new Find ( regex ) ) . returnNull () ; }
{ if ( ENABLED && candidate . getMethodName () . contains ( STRING_CONSTANT ) ) { return false ; } return defaultCleaner . isOut ( candidate ) ; }
Object argument
Object argument
new ArgumentMatcher < String > () { public boolean matches ( Object argument ) { return true ; } }
public void setAnswersForStubbing ( List < Answer > answers ) { answersForStubbing . addAll ( answers ) ; }
Class clazz
public InOrderImpl ( List < Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Map map () { return null ; }
LinkedList linkedList () { return null ; }
List list () { return null ; }
List < Answer > answers
public void setAnswersForStubbing ( List < Answer > answers ) { mockHandler . setAnswersForStubbing ( answers ) ; }
MockCreationSettings settings
assertEquals ( ( Double ) NUMBER_CONSTANT , captor . getValue () ) ;
Long longPretendingAnInt = new Long ( NUMBER_CONSTANT ) ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher ( matcher ) ) ; }
assertFalse ( mockUtil . isSpy ( ( Class ) null ) ) ;
void setAnswersForStubbing ( List < Answer > answers ) ;
public int compareTo ( HasCompare redHerring ) ;
public int foo ( HasCompare other ) ;
public int compareTo ( HasCompareToButDoesNotImplementComparable other ) ;
Assert . assertNotNull ( readObject ) ;
public NullResultGuardian ( InternalMockHandler delegate ) { this . delegate = delegate ; }
verify ( mock ) . simpleMethod ( ( Object ) anyObject () ) ;
catch ( Exception e ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + pluginType , e ) ; }
Class classToMock
int secondArgument = invocationOnInterface . getArgument ( NUMBER_CONSTANT ) ;
void reportMatcher ( ArgumentMatcher matcher ) ;
void mockingStarted ( Object mock , Class classToMock ) ;
void mockingStarted ( Object mock , Class classToMock ) ;
OngoingStubbing pullOngoingStubbing ( ) ;
void reportOngoingStubbing ( OngoingStubbing ongoingStubbing ) ;
Class classToMock
public void reportOngoingStubbing ( OngoingStubbing iOngoingStubbing ) { threadSafely () . reportOngoingStubbing ( iOngoingStubbing ) ; }
public ArgumentMatcher getMatcher () { return matcher ; }
ArgumentMatcher matcher
createdMocks = new LinkedList () ;
public void mockingStarted ( Object mock , Class classToMock ) { toBeFilled . add ( mock ) ; }
public CollectCreatedMocks ( List toBeFilled ) { this . toBeFilled = toBeFilled ; }
Class expected
{ copy ( from , to , from . getClass () , to . getClass () ) ; }
Class actualType
Class lhsClass = lhs . getClass () ;
Class reflectUpToClass
Class typeToMock
Iterable < String > lines
new SerializableMethod ( type . getMethod ( methodName , new Class [ NUMBER_CONSTANT ] ) )
Class classToMock
Class mockedType
Class type
Class [] argTypes
{ mock ( IMethods . class , withSettings () . extraInterfaces ( ( Class [] ) null ) ) ; }
for ( Class anInterface : interfaces ) { types . add ( anInterface . getName () ) ; }
for ( Class i : extraInterfaces ) { if ( classToMock == i ) { throw extraInterfacesCannotContainMockedType ( classToMock ) ; } }
Class currentExploredClass = clazz
Class type
{ mock . add ( String . valueOf ( i ) ) ; }
Answer answer
Answer answer
public BDDStubber will ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
public BDDStubber willAnswer ( Answer answer ) { return new BDDStubberImpl ( mockitoStubber . doAnswer ( answer ) ) ; }
Answer answer
Answer answer
return ( List ) matchers ;
HoldingAReference ( WeakReference < Class > a ) { this . a = a ; }
Class . . . extraInterfaces
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
List < Invocation > chunk = finder . findMatchingChunk ( invocations , new InvocationMatcher ( simpleMethodInvocation ) , NUMBER_CONSTANT , context ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedDifferentMethod ) ) ;
Invocation found = finder . findSimilarInvocation ( invocations , new InvocationMatcher ( overloadedSimpleMethod ) ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverifiedInOrder ( data . getOrderingContext () , invocations ) ;
Invocation unverified = new InvocationsFinder () . findFirstUnverified ( data . getAllInvocations () ) ;
Invocation next = finder . findFirstMatchingUnverifiedInvocation ( invocations , wanted , context ) ;
public int size ( Collection collection ) { return collection . size () ; }
public int size ( Map map ) { return map . size () ; }
verify ( ( Iterable ) iterable ) . iterator () ;
Assert . assertNotNull ( ( ( Iterable ) iterable ) . iterator () ) ;
notifier . setAnswersForStubbing ( new ArrayList < Answer > () ) ;
FailingConstructor ( Set set ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
public Set getHistogram2 () { return histogram2 ; }
public Set getHistogram1 () { return histogram1 ; }
public TreeSet getSearchTree () { return searchTree ; }
public List getAList () { return aList ; }
ConstructorInjection.SimpleArgumentResolver resolver = new ConstructorInjection.SimpleArgumentResolver ( newSetOf ( new HashSet () , new ByteArrayOutputStream () ) ) ;
public some_class_with_parametered_constructor ( List collaborator ) { constructor_instantiation ++ ; }
public ByteBuddyMockMaker () { cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator () ; }
public LessThan ( Comparable < T > value ) { super ( value ) ; }
public LessOrEqual ( Comparable < T > value ) { super ( value ) ; }
public GreaterOrEqual ( Comparable < T > value ) { super ( value ) ; }
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
Comparable < T > value
public CompareTo ( Comparable < T > value ) { this . wanted = value ; }
public GreaterThan ( Comparable < T > value ) { super ( value ) ; }
public CompareEqual ( Comparable < T > value ) { super ( value ) ; }
UnmockableHashCodeAndEquals mock = mock ( UnmockableHashCodeAndEquals . class ) ;
MethodTransformer.Simple . withModifiers ( SynchronizationState.PLAIN )
public VerificationMode only ( ) ;
public VerificationMode atLeastOnce ( ) ;
public VerificationMode never ( ) ;
@ Before public void initialize_dependencies () { underTest = new ConstructorInjection ( resolver ) ; }
public Method getJavaMethod ( ) ;
public Class < > [] getExceptionTypes ( ) ;
public Class < > [] getParameterTypes ( ) ;
public Class < > getReturnType ( ) ;
public String getName ( ) ;
{ return o1 == null && o2 == null ; }
Object writeReplace ( ) throws ObjectStreamException ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportMatcher ( new HamcrestArgumentMatcher < T > ( matcher ) ) ; }
mockingProgress . validateState () ;
mockingProgress . validateState () ;
mockingProgress . mockingStarted ( mock , typeToMock ) ;
ThreadSafeMockingProgress p = new ThreadSafeMockingProgress () ;
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportNot () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportOr () ; return false ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return null ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return NUMBER_CONSTANT ; }
{ MOCKING_PROGRESS . getArgumentMatcherStorage () . reportAnd () ; return false ; }
assertThat ( new ThreadSafeMockingProgress () . pullOngoingStubbing () ) . isNull () ;
mockingProgress . stubbingCompleted ( invocation ) ;
InvocationContainerImpl invocations = new InvocationContainerImpl ( new ThreadSafeMockingProgress () , new MockSettingsImpl () ) ;
mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ;
{ mockingProgress . setVerificationStrategy ( MockingProgressImpl . getDefaultVerificationStrategy () ) ; }
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( null ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
InvocationMatcher invocationMatcher = new InvocationMatcher ( invocation , ( List ) asList ( new Equals ( NUMBER_CONSTANT ) , AnyVararg.ANY_VARARG ) ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
assertTrue ( result . wasSuccessful () ) ;
{ return runnerProvider . newInstance ( STRING_CONSTANT , klass ) ; }
public void filter ( Filter filter ) throws NoTestsRemainException { runner . filter ( filter ) ; }
notifier . fireTestFailure ( new Failure ( unnecessaryStubbings , new Reporter () . formatUnncessaryStubbingException ( testClass , stubbings . values () ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
assertThat ( notifier.addedListeners , contains ( clazz ( FrameworkUsageValidator . class ) ) ) ;
public void filter ( Filter filter ) throws NoTestsRemainException { filterRequested = true ; runner . filter ( filter ) ; }
MockitoJUnitListener listener = new MockitoJUnitListener ( notifier ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
boolean match = comparator . argumentsMatch ( invocationMatcher , invocation ) ;
{ try { return new ArgumentsComparator () . argumentsMatch ( this , actualArgs ) ; } catch ( Throwable t ) { return false ; } }
return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && new ArgumentsComparator () . argumentsMatch ( this , actual ) ;
! new TestMethodsFinder () . hasTestMethods ( klass )
MockCreationSettings < > settings
MockCreationSettings mockSettings
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new LinkedList () ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap () ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet () ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new LinkedList () ; }
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( invocation . toString () , endsWith ( STRING_CONSTANT ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo , simpleMethodInvocationThree ) ) ;
assertThat ( chunk , hasExactlyInOrder ( simpleMethodInvocation , simpleMethodInvocationTwo ) ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , MyAssertionError . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnnecessaryStubbingException . class ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( filtered , hasOnlyThoseClasses ( STRING_CONSTANT ) ) ;
assertThat ( result ) . isSuccessful () ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , UnfinishedStubbingException . class ) ;
assertThat ( result ) . fails ( NUMBER_CONSTANT , TooLittleActualInvocations . class ) ;
{ Result result = runner . run ( SomeFeature . class ) ; assertThat ( result ) . isSuccessful () ; }
catch ( RuntimeException e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( VerificationInOrderFailure e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( MockitoException expected ) { assertThat ( expected , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( NoInteractionsWanted e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
catch ( WantedButNotInvoked e ) { assertThat ( e , hasFirstMethodInStackTrace ( STRING_CONSTANT ) ) ; }
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT ) ) ;
assertThat ( t , hasOnlyThoseClassesInStackTrace ( STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( filtered , hasExactlyInOrder ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertThat ( timer . isCounting () , is ( false ) ) ;
assertThat ( timer . isCounting () , is ( true ) ) ;
{ reportMatcher ( new InstanceOf ( Iterable . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Collection . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Map . class ) ) ; return new HashMap ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( Set . class ) ) ; return new HashSet ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( List . class ) ) ; return new ArrayList ( NUMBER_CONSTANT ) ; }
{ reportMatcher ( new InstanceOf ( String . class ) ) ; return STRING_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Short . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Double . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Float . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Long . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Integer . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Character . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Byte . class ) ) ; return NUMBER_CONSTANT ; }
{ reportMatcher ( new InstanceOf ( Boolean . class ) ) ; return false ; }
public void save ( Person capture ) ;
public String targetMethod ( String arg ) ;
public Integer getValue ( Integer param ) ;
public Object otherMethod ( Object param ) ;
public Object someMethod ( Object param ) ;
public MyIterator < T > iterator ( ) ;
public void setSpy ( List spy ) { this . spy = spy ; }
public List getList () { return list ; }
assertContainsIgnoringCase ( STRING_CONSTANT , log ) ;
catch ( NeverWantedButInvoked e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertNotContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( AssertionError e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( org.mockito.exceptions.verification.junit.ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ String expected = STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ; assertContains ( expected , e . getMessage () ) ; }
catch ( NoInteractionsWanted e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
{ assertContains ( STRING_CONSTANT , e . getMessage () ) ; e . getCause () . getMessage () . equals ( STRING_CONSTANT ) ; }
assertContains ( STRING_CONSTANT , out ) ;
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( VerificationInOrderFailure e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
assertContains ( STRING_CONSTANT , name ) ;
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NeverWantedButInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( InvalidUseOfMatchersException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( Exception e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( SmartNullPointerException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( UnfinishedVerificationException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
catch ( InstantiationException e ) { assertContains ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( WantedButNotInvoked e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( ArgumentsAreDifferent e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertContains ( STRING_CONSTANT , failure . getException () . getMessage () ) ;
assertContains ( STRING_CONSTANT , STRING_CONSTANT + mockTwo ) ;
assertContains ( STRING_CONSTANT , mockTwo . toString () ) ;
catch ( MockitoException e ) { assertContains ( STRING_CONSTANT , e . getMessage () ) ; }
assertNotNull ( mockUtil . getMockSettings ( mock ) ) ;
assertNotNull ( mockUtil . getMockHandler ( mock ) ) ;
if ( new MockUtil () . isMock ( throwable ) ) { throw throwable ; }
{ assertNotNull ( notInitializedSpy ) ; assertNotNull ( notInitializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( notInitializedSpy ) ) ; }
@ Test public void should_inject_mocks_in_spy () { assertNotNull ( initializedSpy . getAList () ) ; assertTrue ( mockUtil . isMock ( initializedSpy ) ) ; }
Class < > mockType = mockUtil . getMockHandler ( mock ) . getMockSettings () . getTypeToMock () ;
new MockUtil () . isMock ( instance )
new MockUtil () . isMock ( instance )
if ( isMockOrSpy ( instance ) ) { mockUtil . maybeRedefineMockName ( instance , field . getName () ) ; return instance ; }
MockCreationSettings < > mockSettings = new MockUtil () . getMockSettings ( mockitoMock ) ;
MockCreationSettings parentMockSettings = new MockUtil () . getMockSettings ( parentMock ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( invocation . getMock () ) ;
assertTrue ( isMock ( subClass.list ) ) ;
assertTrue ( new MockUtil () . isMock ( classMock ) ) ;
assertTrue ( new MockUtil () . isMock ( interfaceMock ) ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
public MockingDetails mockingDetails ( Object toInspect ) { return new DefaultMockingDetails ( toInspect , new MockUtil () ) ; }
InvocationContainer invocationContainer = new MockUtil () . getMockHandler ( m ) . getInvocationContainer () ;
{ if ( mock == null ) { throw nullPassedWhenCreatingInOrder () ; } if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedWhenCreatingInOrder () ; } }
InvocationContainer invocations = mockUtil . getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { mockUtil . getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
for ( T m : mocks ) { mockUtil . resetMock ( m ) ; }
if ( ! mockUtil . isMock ( mock ) ) { throw notAMockPassedToVerify ( mock . getClass () ) ; }
T mock = mockUtil . createMock ( creationSettings ) ;
InternalMockHandler < Object > handler = new MockUtil () . getMockHandler ( mock ) ;
TypeMockability typeMockability = mockUtil . typeMockabilityOf ( classToMock ) ;
{ if ( mockUtil . typeMockabilityOf ( aClass ) . mockable () ) { constructorMockableParamsSize ++ ; } }
String mockName = mockUtil . getMockName ( mocks . iterator () . next () ) . toString () ;
{ if ( candidateFieldToBeInjected . getName () . equals ( mockUtil . getMockName ( mock ) . toString () ) ) { mockNameMatches . add ( mock ) ; } }
String qualifiedName = new MockUtil () . getMockName ( invocation . getMock () ) + STRING_CONSTANT + invocation . getMethod () . getName () ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockOne , mockOne ) ) ;
List < Invocation > invocations = finder . find ( asList ( mockOne , mockTwo ) ) ;
List < Invocation > all = new AllInvocationsFinder () . find ( createdMocks ) ;
List < Invocation > invocations = new VerifiableInvocationsFinder () . find ( inOrder . getMocksToBeVerifiedInOrder () ) ;
List < Invocation > invocations = allInvocationsFinder . find ( asList ( mocks ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forCurrentJavaVersion () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
verify ( mockHandler ) . setAnswersForStubbing ( anyList () ) ;
when ( sorter . sort ( anyList () ) ) . thenReturn ( null ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
checker . check ( invocations , wanted ) ;
{ results . add ( new SuperTypesLastSorter () . sort ( Arrays . asList ( o ) ) ) ; }
List < Field > sortedFields = new SuperTypesLastSorter () . sort ( unsortedFields ) ;
List < Field > l = new SuperTypesLastSorter () . sort ( Arrays . asList ( o1 , o2 ) ) ;
return new SuperTypesLastSorter () . sort ( declaredFields ) ;
new ArrayUtils () . isEmpty ( args )
public InvocationMatcher getWanted () { return wanted ; }
public boolean isOut ( Invocation invocation ) { return new ObjectMethodsGuru () . isToString ( invocation . getMethod () ) ; }
if ( new ObjectMethodsGuru () . isToString ( currentInvocation . getMethod () ) ) { return STRING_CONSTANT + unstubbedInvocation . toString () ; }
if ( ! filterRequested && listener . isSussessful () ) { reporter . report ( testClass , notifier ) ; }
mockingProgress () . mockingStarted ( mock , typeToMock ) ;
@ Test public void shouldNotifyListenerSafely ( ) throws Exception { mockingProgress . setListener ( null ) ; mockingProgress . mockingStarted ( null , null ) ; }
List < > mocks
throw cannotInitializeForInjectMocksAnnotation ( field . getName () , e ) ;
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
@ Test ( expected = NullPointerException . class )
{ if ( value == null ) { throw new NullPointerException ( checkedValue + STRING_CONSTANT ) ; } return value ; }
public TypeVariable typeVariable () { return typeVariable ; }
public TypeVarBoundedType ( TypeVariable typeVariable ) { this . typeVariable = typeVariable ; }
TypeVariable [] typeParameters
if ( type instanceof TypeVariable ) { return new TypeVariableReturnType ( this , method . getTypeParameters () , ( TypeVariable ) type ) ; }
if ( wildCardBoundedType . firstBound () instanceof TypeVariable ) { return boundsOf ( ( TypeVariable ) wildCardBoundedType . firstBound () ) ; }
TypeVariable typeVariable
assertNotEquals ( NUMBER_CONSTANT , to.privateTransientField ) ;
assertNotEquals ( NUMBER_CONSTANT , to.finalField ) ;
Class classToMock
int size () { return unused . size () ; }
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
assumeTrue ( ClassFileVersion . forThisVm () . isAtLeast ( ClassFileVersion.JAVA_V8 ) ) ;
String getAuthor ( ) ;
String getAuthorId ( ) ;
public String toText () { return commits . size () + STRING_CONSTANT + author ; }
public String getAuthor () { return author ; }
public String getAuthorId () { return email ; }
UnusedStubbings ( Collection < Stubbing > unused ) { this . unused = unused ; }
if ( type instanceof Class ) { return new NotGenericReturnTypeSupport ( type ) ; }
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
DelayedExecution delayedExecution = new DelayedExecution ( executor , mock , NUMBER_CONSTANT ) ;
generatedMockClass = generate ( features ) ;
@ Test public void shouldRunInMultipleThreads ( ) throws Exception { assertFalse ( STRING_CONSTANT , runInMultipleThreads ( NUMBER_CONSTANT ) ) ; }
Class < ? extends T > mockedProxyType = createProxyClass ( mockWithFeaturesFrom ( settings ) ) ;
Class < ? extends T > type = bytecodeGenerator . mockClass ( mockWithFeaturesFrom ( settings ) ) ;
dispatcher == null || ! dispatcher . isMocked ( mock )
public AbstractByteBuddyMockMakerTest ( MockMaker mockMaker ) { this . mockMaker = mockMaker ; }
generatedMockClass = generate ( features ) ;
{ return invocation . getMock () . equals ( actual . getMock () ) && hasSameMethod ( actual ) && argumentsMatch ( this , actual ) ; }
given ( mock ( ConstructorArgumentResolver . class ) . resolveTypeInstances ( any ( Class [] . class ) ) )
withModifiers ( SynchronizationState.PLAIN )
{ addStep ( task , config . get ( STRING_CONSTANT ) ) ; return this ; }
InvocationMatcher wanted
InvocationMatcher wantedMatcher = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
public String print ( InvocationMatcher invocationMatcher ) { return print ( invocationMatcher . getMatchers () , invocationMatcher . getInvocation () ) ; }
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted = data . getWanted () ;
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher getWanted ( ) ;
private RemoveNotMatching ( InvocationMatcher wanted ) { this . wanted = wanted ; }
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
InvocationMatcher wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
CapturesArgumentsFromInvocation wanted
VerificationDataInOrderImpl dataInOrder = new VerificationDataInOrderImpl ( inOrder , invocations , data . getWanted () ) ;
MatchableInvocation wanted = data . getWanted () ;
{ assertNotNull ( listener ) ; mockingProgress () . removeListener ( listener ) ; return this ; }
{ assertNotNull ( listener ) ; mockingProgress () . addListener ( listener ) ; return this ; }
@ Before public void setUp () { executor = newSingleThreadScheduledExecutor () ; stopWatch = createNotStarted () ; }
@ Advice.BoxedReturn ( readOnly = false ) Object returned
@ Advice.BoxedArguments Object [] arguments
private ExcludeHandler ( RootDoc root ) { this . root = root ; }
public Invocation getInvocation () { return invocation ; }
{ return isMockitoMock ( mock ) && getMockSettings ( mock ) . getDefaultAnswer () == Mockito.CALLS_REAL_METHODS ; }
isMockitoMock ( mock )
mockingProgress () . stubbingCompleted ( invocation ) ;
AnnotationEngine customizedEngine = new DefaultAnnotationEngine () {} ;
AnnotationEngine annotationEngine = new GlobalConfiguration () . getAnnotationEngine () ;
ClassLoader cl = isolatedClassLoader () . withCurrentCodeSourceUrls () . withPrivateCopyOf ( CLASS_NAME_USING_INTERFACE ) . withPrivateCopyOf ( INTERFACE_NAME ) . build () ;
{ throw new IllegalArgumentException ( String . format ( STRING_CONSTANT , classLoader ) ) ; }
public ExcludingURLClassLoaderBuilder without ( String . . . privatePrefixes ) { privateCopyPrefixes . addAll ( asList ( privatePrefixes ) ) ; return this ; }
Statement statement
mock . simpleMethod ( NUMBER_CONSTANT ) ;
public void doAssert ( Throwable throwable ) { Assertions . assertThat ( throwable ) . isInstanceOf ( expected ) . hasMessage ( expectedMessage ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
public void beforeTest ( Object testClassInstance , String testMethodName ) { MockitoAnnotations . initMocks ( testClassInstance ) ; }
public JUnitRule silent () { return new JUnitRule ( logger , true ) ; }
{ return new JUnitRule ( new ConsoleMockitoLogger () , false ) ; }
void doAssert ( Throwable throwable ) ;
@ Test public void rule_validates_mockito_usage ( ) throws Throwable { rule . expectThrowable ( UnfinishedVerificationException . class ) ; verify ( mock ) ; }
rule . expectThrowable ( PotentialStubbingProblem . class ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( UnnecessaryStubbingException . class ) ;
rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ;
{ rule . expectThrowable ( UnfinishedStubbingException . class ) ; when ( mock . simpleMethod () ) ; }
{ rule . expectThrowable ( RuntimeException . class , STRING_CONSTANT ) ; throw new RuntimeException ( STRING_CONSTANT ) ; }
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
rule . expectThrowable ( AssertionError . class , STRING_CONSTANT ) ;
notifyStubbedAnswerLookUp ( invocation , stubbedInvocation ) ;
List < StubbingLookUpListener > getStubbingLookUpListeners ( ) ;
{ return new JUnitRule ( new ConsoleMockitoLogger () , JUnitRule.Strictness.WARN ) ; }
public MockitoRule silent () { return new JUnitRule ( logger , Strictness.SILENT ) ; }
case SILENT :
settings . getStubbingLookupListeners ()
mockingProgress . verificationStarted ( new MockAwareVerificationMode ( mock , actualMode ) ) ;
public int wantedArgumentPosition () { return wantedArgumentPosition ; }
new AnswersValidator () . validateDefaultAnswerReturnedValue ( invocation , ret ) ;
public boolean returnsNull () { return value == null ; }
public void reportMatcher ( ArgumentMatcher matcher ) { matcherStack . push ( new LocalizedMatcher ( matcher ) ) ; }
{ this ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
{ super ( new StrictRunner ( new RunnerFactory () . create ( klass ) , klass ) ) ; }
RunnerImpl runner = provider . newInstance ( STRING_CONSTANT , this . getClass () ) ;
MockitoJUnitRunner ( RunnerImpl runner ) throws InvocationTargetException { this . runner = runner ; }
RunnerImpl runner
ClassLoadingStrategy.Default.INJECTION . with ( features.mockedType . getProtectionDomain () )
assertThat ( MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = MockMethodAdvice . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
@ Override public boolean mockable () { return instrumentation . isModifiableClass ( type ) && ! EXCLUDES . contains ( type ) ; }
if ( i != successCount ) { throw new AssertionError ( STRING_CONSTANT + successCount + STRING_CONSTANT + i + STRING_CONSTANT ) ; }
Result result = runner . run ( StubbingArgMismatchTest . class ) ;
Result result = runner . run ( UnnecessaryStubbingTest . class ) ;
{ return mock ( classToMock , withSettings () . defaultAnswer ( RETURNS_DEFAULTS ) ) ; }
return new AndroidClassLoadingStrategy ( target ) ;
MockSettings settings = withSettings () . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) ;
Mockito . mock ( instance . getClass () , withSettings () . spiedInstance ( instance ) . defaultAnswer ( Mockito.CALLS_REAL_METHODS ) . name ( field . getName () ) )
NestedClassWithNoArgConstructor ( String f ) {}
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
catch ( MockitoException e ) { Assertions . assertThat ( e . getMessage () ) . contains ( STRING_CONSTANT ) ; }
throw paramsException ( cls , null ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
checker . check ( invocations , wanted , NUMBER_CONSTANT , context ) ;
if ( ! argMismatchStubbings . isEmpty () ) { mismatchesReported = true ; Reporter . potentialStubbingProblemByJUnitRule ( invocation , argMismatchStubbings ) ; }
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { throw new UnfinishedMockingException ( STRING_CONSTANT ) ; }
Failure f = result . getFailures () . iterator () . next () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
mocking . finishMocking () ;
{ mock . simpleMethod ( NUMBER_CONSTANT ) ; mock . otherMethod () ; mocking . finishMocking () ; logger . assertEmpty () ; }
assertThat ( new Runnable () { public void run () { mocking . finishMocking () ; } } ) . throwsException ( UnnecessaryStubbingException . class )
{ this . currentStrictness = strictness ; this . stubbingLookupListener . currentStrictness = strictness ; }
event . getFailure () == null && ! stubbingLookupListener.mismatchesReported
try { Mockito . framework () . addListener ( listener ) ; } catch ( RedundantListenerException e ) { Reporter . unfinishedMocking () ; }
JUnitResultAssert . assertThat ( result ) . fails ( UnfinishedMockingSessionException . class , STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . succeeds ( NUMBER_CONSTANT ) ;
JUnitResultAssert . assertThat ( result ) . fails ( NUMBER_CONSTANT , PotentialStubbingProblem . class ) ;
return Decamelizer . decamelizeMatcher ( matcher . getClass () . getSimpleName () ) ;
return JUnitTool . createArgumentsAreDifferentException ( message , wanted , actual ) ;
withModifiers ( SynchronizationState.PLAIN , Visibility.PUBLIC )
assertThat ( InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ) . isSameAs ( throwable ) ;
throwable = InlineByteBuddyMockMaker . hideRecursiveCall ( throwable , NUMBER_CONSTANT , SampleInterface . class ) ;
if ( paramsMatch ( types , params ) ) { matchingConstructors . add ( constructor ) ; }
assertEquals ( STRING_CONSTANT , mock . forObject ( ( Object ) null ) ) ;
catch ( Throwable throwable ) { return null ; }
if ( unused . size () == NUMBER_CONSTANT ) { return; }
return method . getName () . equals ( STRING_CONSTANT ) ;
method . getName () . equals ( STRING_CONSTANT )
m . getName () . equals ( STRING_CONSTANT )
Type genericInterface = findGenericInteface ( match , targetBaseInterface ) ;
public Class < > [] getParameterTypes () { return method . getParameterTypes () ; }
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , args ) ;
this . arguments = ArgumentsProcessor . expandVarArgs ( mockitoMethod . isVarArgs () , arguments ) ;
parameterTypes = method . getParameterTypes () ;
{ if ( ! wantedArgumentPositionIsValidForInvocation ( invocation , argumentPosition ) ) { throw Reporter . invalidArgumentPositionRangeAtInvocationTime ( invocation , wantedArgumentPosition == LAST_ARGUMENT , wantedArgumentPosition ) ; } }
validateArgumentTypeCompatibility ( invocation , argumentPosition ) ;
public InOrderImpl ( List < ? extends Object > mocksToBeVerifiedInOrder ) { this . mocksToBeVerifiedInOrder . addAll ( mocksToBeVerifiedInOrder ) ; }
Assertions . assertThat ( m . getAllValues () ) . containsSequence ( STRING_CONSTANT , STRING_CONSTANT ) ;
Iterable < Object > mocks
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
StubbingArgMismatches mismatches = finder . getStubbingArgMismatches ( ( List ) asList ( mock1 , mock2 ) ) ;
given ( iMethods . varargsObject ( eq ( NUMBER_CONSTANT ) , anyVararg () ) ) . will ( returnsArgAt ( NUMBER_CONSTANT ) ) ;
public String foo () { return STRING_CONSTANT ; }
UnusedStubbings stubbings = new UnusedStubbings ( ( List ) asList () ) ;
List < StubbedInvocationMatcher > getStubbedInvocations ( ) ;
InternalMockHandler handler
public NullResultGuardian ( InternalMockHandler < T > delegate ) { this . delegate = delegate ; }
{ ( ( MockAccess ) mock ) . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( newHandler ) , settings ) ) ; }
mockAccess . setMockitoInterceptor ( new MockMethodInterceptor ( asInternalMockHandler ( handler ) , settings ) ) ;
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler < > handler = createMockHandler ( settings ) ;
InternalMockHandler < T > mockHandler
InvocationMatcher invocation
public void setAnswersForStubbing ( List < Answer < > > answers ) { invocationContainerImpl . setAnswersForStubbing ( answers ) ; }
this . invocationContainerImpl = new InvocationContainerImpl ( mockSettings ) ;
@ SuppressWarnings ( STRING_CONSTANT ) public < M > M getMock () { return ( M ) invocationContainerImpl . invokedMock () ; }
MockUtil . getMockHandler ( mock ) . setAnswersForStubbing ( answers ) ;
List < ? extends Stubbing > stubbings = mockHandler () . getInvocationContainer () . getStubbedInvocations () ;
InvocationContainer invocations
InvocationContainer invocations = getMockHandler ( mock ) . getInvocationContainer () ;
for ( T m : mocks ) { getMockHandler ( m ) . getInvocationContainer () . clearInvocations () ; }
MockUtil . getMockHandler ( mock ) . getInvocationContainer () . setAnswersForStubbing ( answers ) ;
InvocationContainer invocationContainer
MockCreationSettings < T > creationSettings = impl . confirm ( typeToMock ) ;
private MockHandler < Object > mockHandler () { assertGoodMock () ; return getMockHandler ( toInspect ) ; }
given ( handler.invocationContainer . findAnswerFor ( any ( InvocationImpl . class ) ) ) . willReturn ( value ) ;
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.SuperMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.SuperMethod.FromCallable ( superCall ) ) ;
Mockito . verify ( mock ) ;
{ InterceptedInvocation.RealMethod.FromCallable superMethod = new InterceptedInvocation.RealMethod.FromCallable ( realMethod ) ; return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
{ if ( interceptor == null ) { return stubValue ; } return interceptor . doIntercept ( mock , invokedMethod , arguments , InterceptedInvocation.RealMethod.IsIllegal.INSTANCE ) ; }
return interceptor . doIntercept ( mock , invokedMethod , arguments , new InterceptedInvocation.RealMethod.FromCallable ( superCall ) ) ;
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod
InterceptedInvocation.RealMethod realMethod ;
return ! node . getSort () . isResolved () || ! node . getRepresentative () . represents ( origin ) ;
if ( ! MockUtil . isMock ( mock ) ) { throw notAMockPassedToWhenMethod () ; }
UnusedStubbings stubbings = new UnusedStubbings ( Arrays . < Stubbing > asList () ) ;
{ this . verificationStartedListeners . addAll ( Arrays . asList ( listeners ) ) ; return this ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . invocationListenerDoesNotAcceptNullParameters () ; }
catch ( MockitoException e ) { assertEquals ( STRING_CONSTANT + STRING_CONSTANT , e . getMessage () ) ; }
@ Test ( expected = MockitoException . class ) public void should_throw_correct_exception_for_null_invocation_listener ( ) throws Exception { throw Reporter . methodDoesNotAcceptNullParameters ( STRING_CONSTANT , STRING_CONSTANT ) ; }
{ if ( mock == null ) { throw new MockitoException ( STRING_CONSTANT + STRING_CONSTANT ) ; } this . mock = mock ; }
VerificationStartedEvent event = new DefaultVerificationStartedEvent () ;
mock = ( T ) VerificationStartedNotifier . notifyVerificationStarted ( handler . getMockSettings () . getVerificationStartedListeners () , mock ) ;
public static MockitoMock getMockitoMock ( Object mock ) { return new MockitoMock ( mockMaker . getHandler ( mock ) ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event () ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , null ) ; }
catch ( Exception e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
VerificationStartedNotifier.Event event = new VerificationStartedNotifier.Event ( mockitoMock ) ;
@ Test public void does_not_do_anything_when_list_is_empty ( ) throws Exception { VerificationStartedNotifier . notifyVerificationStarted ( ( List ) emptyList () , mockitoMock ) ; }
assertEquals ( NUMBER_CONSTANT , captor . getValue () ) ;
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( NotAMockException e ) { TestCase . assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
public Object getOuterClassInstance () { return outerClassInstance ; }
public Object getSpiedInstance () { return spiedInstance ; }
public MockName getMockName () { return mockName ; }
public Object getOuterClassInstance () { return outerClassInstance ; }
public SerializableMode getSerializableMode () { return serializableMode ; }
public MockName getMockName () { return mockName ; }
public Object getSpiedInstance () { return spiedInstance ; }
SerializableClass proxy = mockMaker . createMock ( serializableSettingsFor ( SerializableClass . class , SerializableMode.BASIC ) , dummyH () ) ;
OtherClass mock = mockMaker . createMock ( settingsWithConstructorFor ( OtherClass . class ) , dummyH () ) ;
SomeClass mock = mockMaker . createMock ( settingsFor ( SomeClass . class , SomeInterface . class ) , dummyH () ) ;
ClassWithDodgyConstructor mock = mockMaker . createMock ( settingsFor ( ClassWithDodgyConstructor . class ) , dummyH () ) ;
ClassWithoutConstructor proxy = mockMaker . createMock ( settingsFor ( ClassWithoutConstructor . class ) , dummyH () ) ;
SomeInterface proxy = mockMaker . createMock ( settingsFor ( SomeInterface . class ) , dummyH () ) ;
new SerializationFeatureKey ( params.mockedType , params.interfaces , params.serializableMode )
{ this . bytecodeGenerator = bytecodeGenerator ; typeCache = new TypeCache.WithInlineExpunction < SerializationFeatureKey > ( weak ? TypeCache.Sort.WEAK : TypeCache.Sort.SOFT ) ; }
{ return selfCallInfo . checkSuperCall ( instance ) && isMock ( instance ) ; }
Assert . assertEquals ( STRING_CONSTANT , mock . getFoo () ) ;
{ verify ( mock , after ( NUMBER_CONSTANT ) . atLeast ( NUMBER_CONSTANT ) ) . oneArg ( CHAR_CONS ) ; Assert . fail ( STRING_CONSTANT ) ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
if ( ! threads . awaitTermination ( NUMBER_CONSTANT , TimeUnit.MILLISECONDS ) ) { Assert . fail () ; }
Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ;
{ TestedObject mock = mock ( TestedObject . class , CALLS_REAL_METHODS ) ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
Assert . assertEquals ( STRING_CONSTANT , mock.value ) ;
{ when ( mock . getValue () ) . thenCallRealMethod () ; Assert . assertEquals ( STRING_CONSTANT , mock . getValue () ) ; }
sb . append ( STRING_CONSTANT + mock ) . append ( STRING_CONSTANT ) ;
classLoader == null ? BOOTSTRAP_LOCK : classLoader
{ return ! selfCallInfo . isSelfInvocation ( instance ) && isMock ( instance ) ; }
@ Override public boolean isMock ( Object instance ) { return interceptors . containsKey ( instance ) ; }
public Throwable getFailure () { return testFailure ; }
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
assertEquals ( filterLineNo ( STRING_CONSTANT + STRING_CONSTANT ) , filterLineNo ( logger . getLoggedInfo () ) ) ;
String getTestMethodName ( ) ;
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + type . getSimpleName () + STRING_CONSTANT , e ) ; }
catch ( InstantiationException e ) { assertThat ( e ) . hasMessageContaining ( STRING_CONSTANT + STRING_CONSTANT ) ; }
@ Test ( expected = InstantiationException . class )
catch ( org.mockito.internal.creation.instance.InstantiationException e ) { throw new MockitoException ( STRING_CONSTANT + mockedProxyType . getSuperclass () . getSimpleName () + STRING_CONSTANT , e ) ; }
if ( explosive . get () != null ) { throw new RuntimeException ( STRING_CONSTANT ) ; }
return pluginType . cast ( new InstantiatorProvider2Wrapper ( create ( InstantiatorProvider2 . class , className ) ) ) ;
{ instantiatorProvider = new InstantiatorProviderWrapper ( ( InstantiatorProvider ) impl ) ; }
{ return MockMethodInterceptor . createInvocation ( target , method , args , superMethod , settings ) ; }
this . mock . equals ( other.mock )
public String returnA () { return STRING_CONSTANT ; }
if ( ref == null ) { throw new IllegalStateException ( STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT + STRING_CONSTANT ) ; }
this . instanceRef = new SerializeableWeakReference < Object > ( instance ) ;
T ref = super . get () ;
this . instanceRef = new WeakReference < Object > ( instance ) ;
{ if ( throwableType == null ) { mockingProgress () . reset () ; throw notAnException () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
{ new ThrowsException ( new IOException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
{ new ThrowsException ( new CharacterCodingException () ) . validateFor ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ; }
new ThrowsException ( throwableToRaise ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( mock ( Exception . class ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
new ThrowsException ( new IllegalStateException ( STRING_CONSTANT ) ) . answer ( new InvocationBuilder () . method ( STRING_CONSTANT ) . toInvocation () ) ;
{ if ( throwableType == null ) { return abortNullExceptionType () ; } return thenThrow ( newInstance ( throwableType ) ) ; }
List < Object > testInstances
{ if ( field . isAnnotationPresent ( u ) ) { throw unsupportedCombinationOfAnnotations ( annotation . getSimpleName () , annotation . getClass () . getSimpleName () ) ; } }
if ( isPrimitiveOrWrapper ( valueClass ) && isPrimitiveOrWrapper ( referenceType ) ) { return Primitives . primitiveTypeOf ( valueClass ) . isAssignableFrom ( referenceType ) ; }
for ( Annotation firstParamAnnotation : firstParamAnnotations ) { if ( annotationClass . isAssignableFrom ( firstParamAnnotation . getClass () ) ) { return ( T ) firstParamAnnotation ; } }
assertThat ( subList . isEmpty () ) ;
@ SuppressWarnings ( STRING_CONSTANT )
assumeFalse ( System . getProperty ( STRING_CONSTANT ) . startsWith ( STRING_CONSTANT ) ) ;
if ( isComingFromJDK ( type ) || isComingFromSignedJar ( type ) || isComingFromSealedPackage ( type ) ) { typeName = STRING_CONSTANT + typeName ; }
{ super ( Opcodes.ASM5 , cv ) ; this . typeDescription = typeDescription ; }
@ SuppressWarnings ( STRING_CONSTANT ) private MockitoExtension () { this ( Strictness.STRICT_STUBS ) ; }
if ( rawArguments == matcherCount && isLastMatcherVargargMatcher ( matchers ) ) { return MATCH_EACH_VARARGS_WITH_LAST_MATCHER ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . radiusGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . radiusGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . radiusGridlinesVisible != visible ) { this . radiusGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . angleGridlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . angleGridlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . angleGridlinesVisible != visible ) { this . angleGridlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . angleLabelsVisible != visible ) { this . angleLabelsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . cornerTextItems . clear () ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( removed ) { this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
this . notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionDepth = sectionDepth ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . outerSeparatorExtension = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . innerSeparatorExtension = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . separatorsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . drawBorder = status ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . labelType != type ) { this . labelType = type ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ super . setFixedRangeAxisSpace ( space ) ; setFixedRangeAxisSpaceForSubplots ( space ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . intervals . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . dialOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . drawBorder = draw ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . dialBackgroundPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . tickLabelPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . tickLabelFont = font ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . tickLabelsVisible != visible ) { this . tickLabelsVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . units = units ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . legendLabelURLGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . legendLabelToolTipGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . urlGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . simpleLabels = simple ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . labelShadowPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelBackgroundPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . labelLinkMargin = margin ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelLinksVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . maximumLabelWidth = width ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelGap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . labelGenerator = generator ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . shadowYOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . shadowXOffset = offset ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . shadowPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionOutlineStrokeMap . put ( key , stroke ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionOutlinePaintMap . put ( key , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionOutlinesVisible = visible ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . sectionPaintMap . put ( key , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . sectionPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . ignoreZeroValues = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . ignoreNullValues = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . circular = circular ; if ( notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . startAngle = angle ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . rangeCrosshairValue = value ; if ( isRangeCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . rangeCrosshairLockedOnData != flag ) { this . rangeCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . rangeCrosshairVisible != flag ) { this . rangeCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . domainCrosshairValue = value ; if ( isDomainCrosshairVisible () && notify ) { notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
if ( this . domainCrosshairLockedOnData != flag ) { this . domainCrosshairLockedOnData = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . domainCrosshairVisible != flag ) { this . domainCrosshairVisible = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . annotations != null ) { this . annotations . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . rangeMarkers != null ) { this . rangeMarkers . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
if ( this . domainMarkers != null ) { this . domainMarkers . clear () ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . colorBar = axis ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . colorBarLocation = edge ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . urlGenerator = generator ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . toolTipGenerator = generator ; this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesOutlineStrokeList . setStroke ( series , stroke ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesOutlineStroke = stroke ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesOutlinePaintList . setPaint ( series , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesOutlinePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . seriesPaintList . setPaint ( series , paint ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . seriesPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . axisLabelGap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . interiorGap != percent ) { this . interiorGap = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . maxValue = value ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . startAngle = angle ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . headPercent = percent ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . webFilled = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . darkerSides = darker ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . depthFactor = factor ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . gap = gap ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . columnRadius = r ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . bulbRadius = r ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . useSubrangePaint = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . followDataInSubranges = flag ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . subrangePaint [ range ] = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . showValueLines = b ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . valuePaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . valueFont = f ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . axisLocation = location ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . valueLocation = location ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
if ( this . units != u ) { this . units = u ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ if ( paint != null ) { this . thermometerPaint = paint ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
{ if ( s != null ) { this . thermometerStroke = s ; notifyListeners ( new PlotChangeEvent ( this ) ) ; } }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . limit = limit ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
{ this . renderingHints . put ( RenderingHints.KEY_TEXT_ANTIALIASING , val ) ; this . notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ this . notifyListeners ( new PlotChangeEvent ( this ) ) ; }
{ this . datasetToScaleMap . set ( index , new Integer ( scaleIndex ) ) ; notifyListeners ( new PlotChangeEvent ( this ) ) ; }
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
notifyListeners ( new PlotChangeEvent ( this ) ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ result = iterateXYRangeBounds ( dataset ) ; }
{ result = iterateCategoryRangeBounds ( dataset , includeInterval ) ; }
public void datasetChanged ( DatasetChangeEvent event ) { this . notifyListeners ( event ) ; }
double gap = Math . max ( NUMBER_CONSTANT , height - sumOfLabelHeights ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
Range r = DatasetUtilities . findRangeBounds ( d , false ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
double delta = NUMBER_CONSTANT ;
XYSeries series = new XYSeries ( STRING_CONSTANT ) ;
{ if ( stroke instanceof BasicStroke ) { this . setData ( stroke ) ; } else { throw new RuntimeException ( STRING_CONSTANT ) ; } }
double maxWidth = space * getMaxItemWidth () ;
{ super(); setBaseToolTipGenerator ( toolTipGenerator ) ; setURLGenerator ( urlGenerator ) ; setShapesVisible ( false ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public Date getUpperDate () { return this . upperDate ; }
public Date getLowerDate () { return this . lowerDate ; }
public long getSerialIndex () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getMiddleMillisecond () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getLastMillisecond () { return this . time . getTime () ; }
{ return this . time . getTime () ; }
public long getFirstMillisecond () { return this . time . getTime () ; }
difference = this . time . getTime () - t1.time . getTime () ;
public int hashCode () { return this . time . hashCode () ; }
{ FixedMillisecond m = ( FixedMillisecond ) object ; return this . time . equals ( m . getTime () ) ; }
long t = this . time . getTime () ;
long t = this . time . getTime () ;
public Date getTime () { return this . time ; }
{ this . time = time ; }
entities != null && dataArea . contains ( xx , yy )
public Date getEnd () { return this . end ; }
public Date getStart () { return this . start ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
RelativeDateFormat rdf = new RelativeDateFormat ( c0 . getTimeInMillis () ) ;
{ throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
final long skip
if ( pointCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( periodCount < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
this . setChart ( chart ) ;
this . setLayout ( layout ) ;
this . setLayout ( layout ) ;
this . setLayout ( layout ) ;
{ this ( parent , style ) ; this . setColor ( color ) ; }
if ( dataset != null ) { this . setDataset ( dataset ) ; }
Paint paint = lookupSectionPaint ( key , true ) ;
Paint paint = lookupSectionPaint ( key , true ) ;
Paint paint = lookupSectionPaint ( key , true ) ;
SWTEventListener listener
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( Color.white ) ; }
if ( currentGridBandIsDark ) { g2 . setPaint ( this . gridBandPaint ) ; } else { g2 . setPaint ( Color.white ) ; }
this . autoPopulateSeriesStroke = false ;
g2 . setPaint ( Color.gray ) ;
Paint paint = renderer . getItemPaint ( row , column ) ;
g2 . setPaint ( Color.gray ) ;
new Object [] { new Integer ( - s ) , new Double ( negBase ) }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
final TimeZone zone
{ if ( this . year < SerialDate.MAXIMUM_YEAR_SUPPORTED ) { return new Year ( this . year + NUMBER_CONSTANT ) ; } else { return null ; } }
if ( ( year < SerialDate.MINIMUM_YEAR_SUPPORTED ) || ( year > SerialDate.MAXIMUM_YEAR_SUPPORTED ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + year + STRING_CONSTANT ) ; }
{ return createStandardDateTickUnits ( TimeZone . getDefault () ) ; }
Calendar calendar = Calendar . getInstance ( this . timeZone ) ;
Calendar calendar = Calendar . getInstance ( this . timeZone ) ;
assertEquals ( false , r . getAutoPopulateSeriesStroke () ) ;
if ( item == dataset . getItemCount ( series ) - NUMBER_CONSTANT ) { drawFirstPassShape ( g2 , pass , series , item , s.seriesPath ) ; }
this . minorTickCount = NUMBER_CONSTANT ;
{ this . minorTickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . tickMarkStroke = stroke ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . tickMarksVisible ) { this . tickMarksVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . tickLabelInsets = insets ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . tickLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . minorTickMarksVisible ) { this . minorTickMarksVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . tickLabelsVisible ) { this . tickLabelsVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . axisLineVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . labelAngle = angle ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . labelInsets = insets ; if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; } }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ this . labelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( flag != this . visible ) { this . visible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
public static Test suite () { return new TestSuite ( CategoryAxisTests . class ) ; }
catch ( Exception e ) { success = false ; }
catch ( Exception e ) { success = false ; }
renderer1 . setToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
ResourceBundle resources = ResourceBundle . getBundle ( baseResourceClass ) ;
this . shell . setText ( ResourceBundle . getBundle ( STRING_CONSTANT ) . getString ( STRING_CONSTANT ) ) ;
ResourceBundle resources = ResourceBundle . getBundle ( baseName ) ;
result = NUMBER_CONSTANT * result + this . unit ;
TimeSeries overwritten = new TimeSeries ( STRING_CONSTANT + getKey () , series . getTimePeriodClass () ) ;
{ throw new SeriesException ( STRING_CONSTANT ) ; }
{ this ( name , DEFAULT_DOMAIN_DESCRIPTION , DEFAULT_RANGE_DESCRIPTION , Day . class ) ; }
drawZoomRectangle ( g2 ) ;
if ( ! useBuffer ) { drawZoomRectangle ( g2 , true ) ; }
{ return zoomFillPaint ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; System.err . println ( STRING_CONSTANT ) ; }
return new Color ( g , g , g ) ;
this . shadowsVisible = true ;
this . shadowsVisible = true ;
if ( dataset == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
Calendar calendar = Calendar . getInstance ( zone ) ;
catch ( CloneNotSupportedException e ) { System.err . println ( STRING_CONSTANT ) ; }
Paint paint = renderer . getItemPaint ( row , column ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( null , this . availableStrokeSamples ) ;
StrokeChooserPanel panel = new StrokeChooserPanel ( null , this . availableStrokeSamples ) ;
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( label , first , last , TimeZone . getDefault () ) ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
TimeSeries result = new TimeSeries ( name , source . getTimePeriodClass () ) ;
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT , Month . class ) ;
calendar . add ( unit . getCalendarField () , unit . getCount () ) ;
public boolean isOutlineVisible () { return outlineVisible ; }
{ return maxY ; }
{ return minY ; }
{ return maxX ; }
{ return minX ; }
clone.zValues = DataUtilities . clone ( zValues ) ;
public Stroke getLabelOutlineStroke () { return labelOutlineStroke ; }
s1 . updateByIndex ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
s1 . updateByIndex ( NUMBER_CONSTANT , - NUMBER_CONSTANT ) ;
rangeAxis . resizeRange ( factor , anchorY ) ;
rangeAxis . resizeRange ( factor , anchorY ) ;
domainAxis . resizeRange ( factor , anchorX ) ;
{ return STRING_CONSTANT + ImageMapUtilities . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
{ if ( ! Double . isNaN ( hiY ) ) { result = Math . min ( result , hiY ) ; } }
this . domainAxis . resizeRange ( factor , anchorX ) ;
{ super ( renderer ) ; this . renderer = renderer ; }
this . rangePannable = true ;
( mods & InputEvent.CTRL_MASK ) == InputEvent.CTRL_MASK
if ( entities != null ) { addItemEntity ( entities , dataset , row , column , hotspot ) ; }
public NumberAxis3D ( String label ) { super ( label ) ; setAxisLineVisible ( false ) ; }
this . stripOutlineVisible = false ;
TimeSeries series = new TimeSeries ( name , start . getClass () ) ;
catch ( Exception e ) { success = false ; }
Line2D line = new Line2D.Double ( startX , startY , endX , endY ) ;
if ( this . showBase ) { result . append ( this . baseLabel ) ; result . append ( STRING_CONSTANT ) ; }
{ this . legendShape . setShape ( series , shape ) ; fireChangeEvent () ; }
{ return this . legendShape . getShape ( series ) ; }
return super . hashCode () ;
double ol = getTickMarkOutsideLength () ;
double transY0 = restrictValueToDataArea ( getRangeBase () , plot , dataArea ) ;
Paint seriesPaint = getFirstBarPaint () ;
double value = Double.NaN ;
Rectangle2D titleArea = new Rectangle2D.Double () ;
double x0 = dataArea . getX () ;
TimeSeriesDataItem item = series . getDataItem ( i ) ;
{ return getDataItem ( index ) . getValue () ; }
{ return getDataItem ( index ) . getPeriod () ; }
XYDataItem item = getDataItem ( index ) ;
{ return getDataItem ( index ) . getY () ; }
{ return getDataItem ( index ) . getX () ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
{ return this . coefficients . clone () ; }
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
double maxRadius = plot . getMaxRadius () ;
{ return this . dataset ; }
notifyListeners ( new DatasetChangeEvent ( this , this ) ) ;
catch ( Exception e ) { System.out . println ( e . toString () ) ; }
Line2D line = new Line2D.Double ( startX , startY , endX , endY ) ;
{ super ( info ) ; this . area = new Polygon () ; this . line = new Line2D.Double () ; }
{ this . shapesVisible = shapesVisible ; }
JPopupMenu result = new JPopupMenu ( STRING_CONSTANT ) ;
String text = STRING_CONSTANT ;
public boolean isCounterClockwise () { return counterClockwise ; }
public double getAngleOffset () { return angleOffset ; }
outlinePaint != null && outlineStroke != null
{ XYSeriesCollection c1 = new XYSeriesCollection () ; assertTrue ( c1 instanceof PublicCloneable ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e . getMessage () , e ) ; }
this . shadowGenerator = new DefaultShadowGenerator () ;
this . shadowGenerator = new DefaultShadowGenerator () ;
this . maxY = minIgnoreNaN ( this . maxY , yy ) ;
if ( ! file . exists () ) { throw new ServletException ( STRING_CONSTANT + file . getAbsolutePath () + STRING_CONSTANT ) ; }
public boolean isRadiusMinorGridlinesVisible () { return radiusMinorGridlinesVisible ; }
assertTrue ( plot != null ) ;
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( Exception e ) { fail ( e . toString () ) ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; System.err . println ( STRING_CONSTANT ) ; }
result = Range . combine ( result , r ) ;
boolean include = true ;
{ setItemLabelsVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setBaseItemLabelsVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesItemLabelsVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesShapesFilled ( series , BooleanUtilities . valueOf ( flag ) ) ; }
{ setShapesFilled ( BooleanUtilities . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setShapesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setLinesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return c . getTime () . getTime () - NUMBER_CONSTANT ;
return c . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
return calendar . getTime () . getTime () ;
if ( dimension > NUMBER_CONSTANT ) { space . ensureAtLeast ( dimension , edge ) ; }
return c . getTimeInMillis () ;
if ( counterClockwise ) angleDegrees = - angleDegrees ;
if ( sectionKeys . size () == NUMBER_CONSTANT ) { return; }
{ this . stepped = stepped ; return; }
{ this . paletteName = paletteName ; return; }
catch ( Exception e ) { e . printStackTrace () ; }
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
LegendItem result = null ;
if ( this . data . size () == NUMBER_CONSTANT ) { return; }
ValueAxis valueAxis = null ;
double dim = NUMBER_CONSTANT ;
Line2D line = null ;
Line2D line = null ;
boolean paintLine = false ;
ValueAxis valueAxis = null ;
ValueAxis valueAxis = null ;
Range adjusted = null ;
AxisState state = null ;
Rectangle2D bounds = null ;
CategoryToolTipGenerator result = null ;
try { clone = super . clone () ; } catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
Range adjusted = null ;
EntityBlockParams ebp = null ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null ;
int result = NUMBER_CONSTANT ;
catch ( CloneNotSupportedException e ) { e . printStackTrace () ; }
public void valueBound ( HttpSessionBindingEvent event ) { return; }
public void init ( ) throws ServletException { return; }
float l = NUMBER_CONSTANT ;
double result = NUMBER_CONSTANT ;
catch ( Exception e ) { e . printStackTrace () ; }
catch ( PropertyVetoException e ) { throw new IllegalArgumentException ( e ) ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
double result = Double.NaN ;
{ this . labelInfo = info ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkOutsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarkInsideLength = length ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . minorTickMarksVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
this . dateFormat = dateFormat ;
{ this . categoryLabelToolTips . clear () ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . maximumCategoryLabelWidthRatio = ratio ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . maximumCategoryLabelLines = lines ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . categoryMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . upperMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . lowerMargin = margin ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
Range adjusted = null ;
{ this . minorTickCount = count ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . standardTickUnits = source ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . autoTickUnitSelection = flag ; if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; } }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . inverted != flag ) { this . inverted = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . negativeArrowVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . positiveArrowVisible = visible ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . verticalTickLabels != flag ) { this . verticalTickLabels = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( this . gridBandsVisible != flag ) { this . gridBandsVisible = flag ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ this . numberFormatOverride = formatter ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
if ( notify ) { notifyListeners ( new AxisChangeEvent ( this ) ) ; }
notifyListeners ( new AxisChangeEvent ( this ) ) ;
notifyListeners ( new AxisChangeEvent ( this ) ) ;
Date result = null ;
@ Override public int hashCode () { return super . hashCode () ; }
assertTrue ( url2 == url1 ) ;
assertTrue ( tt2 == tt ) ;
assertTrue ( url2 == url1 ) ;
assertTrue ( tt2 == tt ) ;
{ return ChartFactory . createPieChart3D ( STRING_CONSTANT , dataset , true , true , false ) ; }
return ChartFactory . createPieChart ( STRING_CONSTANT , data , true , true , false ) ;
{ return createXYAreaChart ( title , xAxisLabel , yAxisLabel , dataset ) ; }
try { series2 . setKey ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException e ) {}
this . maxY = minIgnoreNaN ( this . maxY , yy ) ;
double gap = hh * getInteriorGap () ;
Date result = null ;
Line2D line = null ;
Line2D line = null ;
boolean paintLine = false ;
CategoryAxis axis = null ;
RectangleEdge result = null ;
ItemLabelPosition position = null ;
ItemLabelPosition position = null ;
( float ) regions [ NUMBER_CONSTANT ] . getMaxX ()
double result = NUMBER_CONSTANT ;
StringBuffer tag = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer sb = new StringBuffer () ;
ToolTipTagFragmentGenerator toolTipTagFragmentGenerator = null ;
ItemLabelPosition position = null ;
Shape box = null ;
Shape box = null ;
ItemLabelPosition position = null ;
double space = NUMBER_CONSTANT ;
int historyIdx = NUMBER_CONSTANT ;
Range result = null ;
String result = null ;
double startX = NUMBER_CONSTANT ;
BlockContainer result = null ;
DrawingSupplier result = null ;
String label = null ;
Arc2D notch = null ;
int izV = NUMBER_CONSTANT ;
int izV = NUMBER_CONSTANT ;
boolean paintLine = false ;
boolean include = true ;
double space = NUMBER_CONSTANT ;
double yyAverage = NUMBER_CONSTANT ;
double aRadius = NUMBER_CONSTANT ;
int series = NUMBER_CONSTANT ;
int series = NUMBER_CONSTANT ;
double rectWidth = NUMBER_CONSTANT ;
double rectHeight = NUMBER_CONSTANT ;
Line2D line = null ;
Line2D line = null ;
Paint p = null ;
boolean visible = false ;
@ Test
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.DESCENDING ; } } ;
DefaultXYDataset d = new DefaultXYDataset () { public DomainOrder getDomainOrder () { return DomainOrder.ASCENDING ; } } ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
boolean success = false ;
new Rectangle2D.Double ( Math . min ( x1 , x2 ) , dataArea . getMinY () , Math . abs ( x2 - x1 ) , dataArea . getWidth () )
return DIRECTIONS [ index ] ;
{ if ( y <= this . minY || y >= this . maxY ) { findBoundsByIteration () ; } }
findBoundsByIteration () ;
if ( removed ) { findBoundsByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
if ( removed ) { findBoundsByIteration () ; if ( notify ) { fireSeriesChanged () ; } }
{ findBoundsByIteration () ; }
{ findBoundsByIteration () ; }
Line2D extendedSeparator = extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
setRange ( calculateValue ( log1 ) , calculateValue ( log2 ) ) ;
{ this . attributedLabels . set ( section , label ) ; }
{ super ( labelFormat , numberFormat , percentFormat ) ; this . attributedLabels = new ObjectList () ; }
CategoryPlot p2 = null ;
CategoryPlot p2 = null ;
CategoryPlot p2 = null ;
this . datasets . set ( index , dataset ) ;
this . rangeAxisLocations . set ( index , location ) ;
int result = this . rangeAxes . indexOf ( axis ) ;
this . rangeAxes . set ( index , axis ) ;
this . domainAxisLocations . set ( index , location ) ;
this . domainAxes . set ( index , axis ) ;
{ this . toolTipGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( XYToolTipGenerator ) this . toolTipGeneratorList . get ( series ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( XYItemLabelGenerator ) this . itemLabelGeneratorList . get ( series ) ; }
{ this . legendTextFont . set ( series , font ) ; fireChangeEvent () ; }
{ return ( Font ) this . legendTextFont . get ( series ) ; }
{ this . negativeItemLabelPositionList . set ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . positiveItemLabelPositionList . set ( series , position ) ; if ( notify ) { fireChangeEvent () ; } }
{ this . itemLabelFontList . set ( series , font ) ; if ( notify ) { fireChangeEvent () ; } }
{ return ( Font ) this . itemLabelFontList . get ( series ) ; }
{ this . itemURLGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ this . toolTipGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
{ return ( CategoryToolTipGenerator ) this . toolTipGeneratorList . get ( series ) ; }
{ this . itemLabelGeneratorList . set ( series , generator ) ; fireChangeEvent () ; }
int result = this . rangeAxes . indexOf ( axis ) ;
int result = this . domainAxes . indexOf ( axis ) ;
this . renderers . set ( index , renderer ) ;
this . datasets . set ( index , dataset ) ;
this . rangeAxisLocations . set ( index , location ) ;
this . rangeAxes . set ( index , axis ) ;
this . rangeAxes . set ( NUMBER_CONSTANT , axis ) ;
this . domainAxisLocations . set ( index , location ) ;
this . domainAxes . set ( index , axis ) ;
try { copy . add ( clone ) ; } catch ( SeriesException e ) { e . printStackTrace () ; }
if ( nDataPoints > this . valueHistory . length ) { throw new IllegalArgumentException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
try { copy . add ( clone ) ; } catch ( SeriesException e ) { System.err . println ( STRING_CONSTANT ) ; }
{ super ( null , null , rangeAxis , null ) ; this . subplots = new java.util.ArrayList () ; }
{ super ( null , domainAxis , null , null ) ; this . subplots = new java.util.ArrayList () ; }
double adj = - percent * length ;
{ return this . fmImage . createGraphics () . getFontRenderContext () ; }
ChartPanel chartPanel = new ChartPanel ( chart ) ;
public FixedMillisecond ( long millisecond ) { this ( new Date ( millisecond ) ) ; }
int response = JOptionPane . showConfirmDialog ( this , fileExists , STRING_CONSTANT , JOptionPane.OK_CANCEL_OPTION ) ;
int response = JOptionPane . showConfirmDialog ( this , fileExists , STRING_CONSTANT , JOptionPane.OK_CANCEL_OPTION ) ;
XYDataset data
ChartPanel panel = new ChartPanel ( chart ) ;
ChartPanel panel = new ChartPanel ( chart ) ;
this . panel = new ChartPanel ( this . chart ) ;
r1 . setBaseLegendTextPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
g2 . draw ( new Line2D.Double ( xxMin , yymid - halfW , xxMin , yy + halfW ) ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . remove ( listener ) ; }
if ( ! this . hasUniqueID ( handler ) ) { throw new IllegalArgumentException ( STRING_CONSTANT + handler . getID () + STRING_CONSTANT ) ; }
viewer . hideZoomRectangle () ;
viewer . showZoomRectangle ( x , y , w , h ) ;
ValueAxis xAxis = this . getDomainAxisForDataset ( datasetIndex ) ;
updateCrosshairValues ( crosshairState , x , y , datasetIndex , block . getCenterX () , block . getCenterX () , orientation ) ;
if ( entities != null ) { addEntity ( entities , block , dataset , series , item , NUMBER_CONSTANT , NUMBER_CONSTANT ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ; }
if ( ! ObjectUtilities . equal ( this . additionalItemLabelGenerator , that.additionalItemLabelGenerator ) ) { return false ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . defaultGroup , that.defaultGroup ) ) { return false ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . bounds = ( Rectangle2D ) SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . bounds , stream ) ; }
clone.bounds = ( Rectangle2D ) ShapeUtilities . clone ( this . bounds ) ;
if ( ! ObjectUtilities . equal ( this . id , that.id ) ) { return false ; }
{ ValueDataset vd = ( ValueDataset ) obj ; return ObjectUtilities . equal ( this . value , vd . getValue () ) ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
clone.items = ( List ) ObjectUtilities . deepClone ( this . items ) ;
{ StandardEntityCollection that = ( StandardEntityCollection ) obj ; return ObjectUtilities . equal ( this . entities , that.entities ) ; }
Object toAdd = ObjectUtilities . deepClone ( entry ) ;
{ anchor = ShapeUtilities . getPointInRectangle ( anchor . getX () , anchor . getY () , dataArea ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ;
{ setShapesFilled ( BooleanUtilities . valueOf ( filled ) ) ; }
RefineryUtilities . centerFrameOnScreen ( demo ) ;
if ( ! ObjectUtilities . equal ( this . seriesKey , that.seriesKey ) ) { return false ; }
clone.legendItemShape = ShapeUtilities . clone ( this . legendItemShape ) ;
if ( ! ObjectUtilities . equal ( this . seriesShapesFilled , that.seriesShapesFilled ) ) { return false ; }
{ this . seriesShapesFilled . setBoolean ( series , BooleanUtilities . valueOf ( filled ) ) ; fireChangeEvent () ; }
if ( ! ObjectUtilities . equal ( this . drawable , that.drawable ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
Paint paint = SerialUtilities . readPaint ( stream ) ;
SerialUtilities . writePaint ( paint , stream ) ;
if ( ! PaintUtilities . equal ( p1 , p2 ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendArea , that.legendArea ) ) { return false ; }
clone.legendArea = ShapeUtilities . clone ( this . legendArea ) ;
{ this . drawShapes = BooleanUtilities . valueOf ( this . drawShapesCheckBox . isSelected () ) ; }
{ this . drawLines = BooleanUtilities . valueOf ( this . drawLinesCheckBox . isSelected () ) ; }
clone.bins = ( List ) ObjectUtilities . deepClone ( this . bins ) ;
if ( this . data != null ) { clone.data = ArrayUtilities . clone ( this . data ) ; }
{ if ( ! ShapeUtilities . equal ( s1 [ i ] , s2 [ i ] ) ) { return false ; } }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
{ DefaultBoxAndWhiskerCategoryDataset dataset = ( DefaultBoxAndWhiskerCategoryDataset ) obj ; return ObjectUtilities . equal ( this . data , dataset.data ) ; }
Shape shadowArc = ShapeUtilities . createTranslatedShape ( path , ( float ) shadowXOffset , ( float ) shadowYOffset ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
if ( ! PaintUtilities . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . image , that.image ) ) { return false ; }
{ stream . defaultReadObject () ; this . shadowPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . shadowPaint , stream ) ; }
hash = NUMBER_CONSTANT * hash + ObjectUtilities . hashCode ( this . seriesKey ) ;
{ stream . defaultReadObject () ; this . subLabelPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . subLabelPaint , stream ) ; }
clone.rows = ( List ) ObjectUtilities . deepClone ( this . rows ) ;
if ( ! ObjectUtilities . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
{ stream . defaultReadObject () ; this . backgroundPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . backgroundPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . backgroundPaint , that.backgroundPaint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
return ObjectUtilities . equal ( this . data , that.data ) ;
final Shape shape = ShapeUtilities . createTranslatedShape ( getItemShape ( seriesIndex , i ++ ) , x , y ) ;
{ this . seriesFilled . setBoolean ( series , BooleanUtilities . valueOf ( filled ) ) ; }
if ( ! ObjectUtilities . equal ( this . y , that.y ) ) { return false ; }
{ setSeriesShapesFilled ( series , BooleanUtilities . valueOf ( filled ) ) ; }
{ setSeriesShapesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setShapesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
{ setSeriesLinesVisible ( series , BooleanUtilities . valueOf ( visible ) ) ; }
{ setLinesVisible ( BooleanUtilities . valueOf ( visible ) ) ; }
clone.seriesList = ( List ) ObjectUtilities . deepClone ( this . seriesList ) ;
{ MatrixSeriesCollection c = ( MatrixSeriesCollection ) obj ; return ObjectUtilities . equal ( this . seriesList , c.seriesList ) ; }
if ( ! PaintUtilities . equal ( p1 , p2 ) ) { return false ; }
Paint paint = SerialUtilities . readPaint ( in ) ;
Shape rotatedBox = ShapeUtilities . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
Shape rotatedBox = ShapeUtilities . rotateShape ( box , position . getAngle () , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
if ( ! ObjectUtilities . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . formatter , that.formatter ) ) { return false ; }
clone.rangeAxis = ( ValueAxis ) ObjectUtilities . clone ( this . rangeAxis ) ;
if ( ! PaintUtilities . equal ( this . groupPaint , that.groupPaint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . indexParamName , that.indexParamName ) ) { return false ; }
clone.tasks = ( List ) ObjectUtilities . deepClone ( this . tasks ) ;
if ( ! ObjectUtilities . equal ( this . formatter , that.formatter ) ) { return false ; }
{ addEntity ( info , ShapeUtilities . createLineRegion ( line , NUMBER_CONSTANT ) , rendererIndex , toolTip , url ) ; }
clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ;
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
clone.legendItemShape = ShapeUtilities . clone ( this . legendItemShape ) ;
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
if ( ! ObjectUtilities . equal ( getDescription () , that . getDescription () ) ) { return false ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultReadObject () ; this . sublabelPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . sublabelPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . sublabelPaint , that.sublabelPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . chartArea = ( Rectangle2D ) SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . chartArea , stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendArea , stream ) ; }
{ stream . defaultReadObject () ; this . legendArea = SerialUtilities . readShape ( stream ) ; }
clone.legendArea = ShapeUtilities . clone ( this . legendArea ) ;
if ( ! ShapeUtilities . equal ( this . legendArea , that.legendArea ) ) { return false ; }
{ stream . defaultReadObject () ; this . defaultPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . defaultPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . defaultPaint , that.defaultPaint ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . title , that.title ) ) { return false ; }
{ result . put ( key , ObjectUtilities . clone ( value ) ) ; }
{ result . add ( ObjectUtilities . clone ( obj ) ) ; }
if ( ! ObjectUtilities . equal ( this . arrowStroke , that.arrowStroke ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . wallPaint , stream ) ; }
{ stream . defaultReadObject () ; this . wallPaint = SerialUtilities . readPaint ( stream ) ; }
if ( ! PaintUtilities . equal ( this . wallPaint , that.wallPaint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendBar , stream ) ; }
{ stream . defaultReadObject () ; this . legendBar = SerialUtilities . readShape ( stream ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendShape , stream ) ; }
{ stream . defaultReadObject () ; this . legendShape = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendShape , that.legendShape ) ) { return false ; }
if ( ! ObjectUtilities . equal ( this . gradientPaintTransformer , that.gradientPaintTransformer ) ) { return false ; }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , BooleanUtilities . valueOf ( v0 < getBase () ) }
{ new Integer ( series ) , faces [ NUMBER_CONSTANT ] . getBounds2D () , BooleanUtilities . valueOf ( v0 < getBase () ) }
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
if ( ! ObjectUtilities . equal ( this . data , that.data ) ) { return false ; }
{ stream . defaultReadObject () ; setArea ( SerialUtilities . readShape ( stream ) ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( getArea () , stream ) ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
Stroke stroke = SerialUtilities . readStroke ( stream ) ;
SerialUtilities . writeStroke ( stroke , stream ) ;
if ( ! ObjectUtilities . equal ( s1 , s2 ) ) { return false ; }
{ stream . defaultReadObject () ; this . area = SerialUtilities . readShape ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . area , stream ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
if ( ! ObjectUtilities . equal ( this . obj , that.obj ) ) { return false ; }
result = NUMBER_CONSTANT * result + ObjectUtilities . hashCode ( this . fillPaint ) ;
if ( ! ObjectUtilities . equal ( this . date , that.date ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
result.subplots = ( List ) ObjectUtilities . deepClone ( this . subplots ) ;
if ( ! ObjectUtilities . equal ( this . subplots , that.subplots ) ) { return false ; }
{ stream . defaultReadObject () ; this . artifactPaint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . artifactPaint , stream ) ; }
if ( ! PaintUtilities . equal ( this . artifactPaint , that.artifactPaint ) ) { return false ; }
{ stream . defaultWriteObject () ; SerialUtilities . writeShape ( this . legendLine , stream ) ; }
{ stream . defaultReadObject () ; this . legendLine = SerialUtilities . readShape ( stream ) ; }
if ( ! ShapeUtilities . equal ( this . legendLine , that.legendLine ) ) { return false ; }
if ( this . legendLine != null ) { clone.legendLine = ShapeUtilities . clone ( this . legendLine ) ; }
clone.data = ( List ) ObjectUtilities . deepClone ( this . data ) ;
return ObjectUtilities . equal ( this . data , that.data ) ;
if ( ! ObjectUtilities . equal ( this . key , that.key ) ) { return false ; }
{ stream . defaultReadObject () ; this . paint = SerialUtilities . readPaint ( stream ) ; }
{ stream . defaultWriteObject () ; SerialUtilities . writePaint ( this . paint , stream ) ; }
if ( ! PaintUtilities . equal ( this . paint , that.paint ) ) { return false ; }
TimeSeries series1 = new TimeSeries ( STRING_CONSTANT , Day . class ) ;
TimeSeries series = new TimeSeries ( STRING_CONSTANT , Day . class ) ;
TimeSeries s1 = new TimeSeries ( STRING_CONSTANT , Year . class ) ;
Week w = new Week ( gc . getTime () , zone ) ;
boolean interval = includeInterval || this . domainIsPointsInTime ;
{ this ( label , TimeZone . getDefault () ) ; }
DateTickUnit a1 = new DateTickUnit ( DateTickUnit.DAY , NUMBER_CONSTANT ) ;
axis . setTickUnit ( new DateTickUnit ( DateTickUnit.MONTH , NUMBER_CONSTANT , sdf ) ) ;
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ this ( time , TimeZone . getDefault () ) ; }
{ setMaxItemWidth ( percent ) ; }
public double getMaximumItemWidth () { return getMaxItemWidth () ; }
setBaseToolTipGenerator ( toolTipGenerator ) ;
r1 . setBaseItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
setBaseToolTipGenerator ( labelGenerator ) ;
r1 . setBasePaint ( Color.red ) ;
r1 . setBaseItemLabelGenerator ( new StandardCategoryItemLabelGenerator () ) ;
if ( result == null ) { result = this . baseLegendTextPaint ; }
if ( result == null ) { result = this . baseLegendTextFont ; }
if ( result == null ) { result = this . baseLegendShape ; }
if ( position == null ) { position = this . baseNegativeItemLabelPosition ; }
if ( position == null ) { position = this . basePositiveItemLabelPosition ; }
if ( result == null ) { result = this . baseItemLabelPaint ; }
if ( result == null ) { result = this . baseShape ; }
if ( result == null ) { result = this . baseOutlineStroke ; }
if ( result == null ) { result = this . baseStroke ; }
if ( seriesOutlinePaint == null ) { seriesOutlinePaint = this . baseOutlinePaint ; }
if ( seriesFillPaint == null ) { seriesFillPaint = this . baseFillPaint ; }
if ( generator == null ) { generator = this . baseToolTipGenerator ; }
if ( generator == null ) { generator = this . baseItemLabelGenerator ; }
setBaseToolTipGenerator ( toolTipGenerator ) ;
setBaseToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( new BoxAndWhiskerToolTipGenerator () ) ;
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYZToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setBaseToolTipGenerator ( new HighLowItemLabelGenerator () ) ;
renderer . setBaseToolTipGenerator ( toolTipGenerator ) ;
if ( tooltips ) { renderer . setBaseToolTipGenerator ( new StandardXYToolTipGenerator () ) ; }
renderer . setBaseToolTipGenerator ( tt ) ;
renderer . setBaseToolTipGenerator ( toolTipGenerator ) ;
setBaseToolTipGenerator ( new BoxAndWhiskerXYToolTipGenerator () ) ;
setBaseLegendShape ( this . legendLine ) ;
renderer1 . setBaseToolTipGenerator ( StandardXYToolTipGenerator . getTimeSeriesInstance () ) ;
setBaseToolTipGenerator ( toolTipGenerator ) ;
if ( generator == null ) { generator = this . baseItemURLGenerator ; }
if ( result == null ) { result = this . baseToolTipGenerator ; }
if ( generator == null ) { generator = this . baseItemLabelGenerator ; }
assertEquals ( Color.GRAY , r . getBaseOutlinePaint () ) ;
assertEquals ( Color.WHITE , r . getBaseFillPaint () ) ;
assertEquals ( Color.BLUE , r . getBasePaint () ) ;
if ( ! dataAreaHotspot . isEmpty () ) { addEntity ( entities , dataAreaHotspot , dataset , series , item , transX1 , transY1 ) ; }
if ( entities != null ) { addEntity ( entities , hotspot , dataset , series , item , transX , transY ) ; }
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
r1 . setErrorPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
{ this ( new RectangleInsets ( top , left , bottom , right ) , Color.black ) ; }
chart . setBackgroundPaint ( Color.white ) ;
this . noDataMessagePaint = Color.black ;
public DialBackground () { this ( Color.white ) ; }
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) , new BasicStroke ( NUMBER_CONSTANT ) )
m1 = new CategoryMarker ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) , new BasicStroke ( NUMBER_CONSTANT ) )
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.black ) ;
public StandardDialRange () { this ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ; }
g2 . setPaint ( Color.gray ) ;
p1 . setSubrangePaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
baseline . setPaint ( Color.black ) ;
{ this ( label , Color.black ) ; }
this . arrowPaint = Color.black ;
{ this ( x0 , y0 , x1 , y1 , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
{ this ( x1 , y1 , x2 , y2 , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
this . arrowPaint = Color.black ;
a1 . setAxisLinePaint ( Color.red ) ;
this . outlinePaint = Color.black ;
{ this ( shape , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
{ this ( polygon , new BasicStroke ( NUMBER_CONSTANT ) , Color.black ) ; }
g2 . setPaint ( Color.black ) ;
this . sublabelPaint = Color.black ;
this . labelPaint = Color.black ;
public Crosshair ( double value ) { this ( value , Color.black , new BasicStroke ( NUMBER_CONSTANT ) ) ; }
LegendGraphic g1 = new LegendGraphic ( r , Color.black ) ;
LegendGraphic g1 = new LegendGraphic ( r , Color.black ) ;
g2 . setColor ( Color.black ) ;
this . defaultSectionPaint = Color.gray ;
this . paint = Color.black ;
g2 . setPaint ( Color.blue ) ;
{ super ( datasetIndex ) ; this . paint = Color.red ; this . stroke = new BasicStroke ( NUMBER_CONSTANT , BasicStroke.CAP_ROUND , BasicStroke.JOIN_BEVEL ) ; }
this . axisLinePaint = Color.black ;
this . shadowPaint = Color.gray ;
this . artifactPaint = Color.black ;
final ObjectInputStream stream
final ObjectOutputStream stream
final Graphics2D g2
final TextBlock block
final double offset
final double offset
final Paint paint
final Paint paint
final RectangleInsets gap
final Stroke stroke
final Paint paint
final ObjectInputStream stream
final ObjectOutputStream stream
this . boxPaint = Color.green ;
final Graphics2D g2
TextUtilities . drawAlignedString ( valueStr , g2 , x , y , TextAnchor.TOP_CENTER ) ;
Rectangle2D tickLabelBounds = TextUtilities . getTextBounds ( tickLabel , g2 , fm ) ;
{ FontMetrics fm = g2 . getFontMetrics ( getLabelFont () ) ; bounds = TextUtilities . getTextBounds ( axisLabel , g2 , fm ) ; }
Rectangle2D bounds = TextUtilities . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( getText () , g2 , fm ) ;
Rectangle2D r = TextUtilities . getTextBounds ( text , g2 , fm ) ;
if ( tick . getText () != null ) { labelBounds = TextUtilities . getTextBounds ( tick . getText () , g2 , fm ) ; }
if ( tick . getText () != null ) { labelBounds = TextUtilities . getTextBounds ( tick . getText () , g2 , fm ) ; }
this . label = TextUtilities . createTextBlock ( this . text , font , this . paint ) ;
this . label = TextUtilities . createTextBlock ( text , font , this . paint ) ;
Rectangle2D r = TextUtilities . getTextBounds ( this . internalMarkerCycleBoundTick . getText () , g2 , fm ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( this . text , g2 , fm ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( tickLabel , g2 , g2 . getFontMetrics () ) ;
TextUtilities . drawRotatedString ( label , g2 , xx , yy , TextAnchor.CENTER , NUMBER_CONSTANT , TextAnchor.CENTER ) ;
Rectangle2D bounds = TextUtilities . getTextBounds ( label , g2 , fm ) ;
Rectangle2D bounds = TextUtils . getTextBounds ( text , g2 , fm ) ;
public DefaultShadowGenerator () { this ( NUMBER_CONSTANT , Color.black , NUMBER_CONSTANT , NUMBER_CONSTANT , - Math.PI / NUMBER_CONSTANT ) ; }
final Paint paint
renderer . setSeriesPaint ( NUMBER_CONSTANT , Color.black ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
f1 . setBackgroundPaint ( Color.blue ) ;
r1 . setDefaultPaint ( Color.red ) ;
a1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
p1 . setAggregatedItemsPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ) ;
new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow )
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
this . gridPaintSample = new PaintSample ( Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.red , Color.blue , false ) ;
XYDifferenceRenderer r1 = new XYDifferenceRenderer ( Color.red , Color.blue , false ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red ) ;
a1 . setSubLabelPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
Color defaultColor = ( p instanceof Color ? ( Color ) p : Color.blue ) ;
a1 . setTickLabelPaint ( STRING_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
r1 . setShapePaint ( Color.red ) ;
this . downPaint = Color.red ;
t1 . setBackgroundPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
this . paint = Color.red ;
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
c1 = new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.BLUE ) , new BasicStroke ( NUMBER_CONSTANT ) )
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
b1 . setPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.green ) ) ;
a1 . setOutlinePaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
XYLineAnnotation a1 = new XYLineAnnotation ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , stroke , Color.blue ) ;
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
o1 . addRangeCrosshair ( new Crosshair ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) , new BasicStroke ( NUMBER_CONSTANT ) ) )
new BlockBorder ( new RectangleInsets ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) )
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
GradientPaint gp = new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.blue ) ;
r1 . setSeriesPaint ( NUMBER_CONSTANT , new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.yellow ) ) ;
{ this ( label , range , Color.yellow , new BasicStroke ( NUMBER_CONSTANT ) , null ) ; }
g2 . setPaint ( Color.blue ) ;
c = JColorChooser . showDialog ( this , localizationResources . getString ( STRING_CONSTANT ) , Color.blue ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
s1 . setMajorTickPaint ( new GradientPaint ( NUMBER_CONSTANT , NUMBER_CONSTANT , Color.red , NUMBER_CONSTANT , NUMBER_CONSTANT , Color.white ) ) ;
this . incompletePaint = Color.red ;
this . zoomOutlinePaint = Color.blue ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
@ Override public int hashCode () { return HashUtilities . hashCodeForDoubleArray ( this . coefficients ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . radius ) ; return result ; }
{ return HashUtilities . hashCode ( super . hashCode () , this . stepPoint ) ; }
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . visible ) ; return result ; }
result = result * NUMBER_CONSTANT + HashUtilities . hashCodeForPaint ( this . arrowPaint ) ;
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . formatPattern ) ; return result ; }
{ int result = NUMBER_CONSTANT ; result = HashUtilities . hashCode ( result , this . formatPattern ) ; return result ; }
{ int result = super . hashCode () ; result = HashUtilities . hashCode ( result , this . isArrowAtTop ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
{ int result = super . hashCode () ; result = HashUtilities . hashCode ( result , this . key ) ; return result ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . arrowPaint ) ;
{ int hash = super . hashCode () ; hash = HashUtilities . hashCode ( hash , this . errorIndicatorPaint ) ; return hash ; }
result = NUMBER_CONSTANT * result + HashUtilities . hashCodeForPaint ( this . paint ) ;
ChartUtilities . saveChartAsJPEG ( tempFile , chart , width , height , info ) ;
ChartUtilities . saveChartAsPNG ( tempFile , chart , width , height , info ) ;
{ return STRING_CONSTANT + ImageMapUtilities . javascriptEscape ( toolTipText ) + STRING_CONSTANT ; }
{ return ImageMapUtilities . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ; }
{ writer . println ( ImageMapUtilities . getImageMap ( name , info , toolTipTagFragmentGenerator , urlTagFragmentGenerator ) ) ; }
ImageMapUtilities . writeImageMap ( writer , name , info , toolTipTagFragmentGenerator , new StandardURLTagFragmentGenerator () ) ;
{ return STRING_CONSTANT + ImageMapUtilities . htmlEscape ( toolTipText ) + STRING_CONSTANT ; }
Line2D extendedSeparator = LineUtilities . extendLine ( separator , this . innerSeparatorExtension , this . outerSeparatorExtension ) ;
visible = LineUtilities . clipLine ( state.workingLine , dataArea ) ;
boolean visible = LineUtilities . clipLine ( line , dataArea ) ;
boolean visible = LineUtilities . clipLine ( line , dataArea ) ;
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( dataset , getBase () ) ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( dataset ) ; }
! DatasetUtilities . isEmptyOrNull ( dataset )
Range range = DatasetUtilities . findDomainBounds ( this . dataset , false ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DatasetUtilities . calculateStackTotal ( ( TableXYDataset ) dataset , item ) ; value = value / total ; }
if ( this . renderAsPercentages ) { return new Range ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ; } else { return DatasetUtilities . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; }
{ if ( dataset != null ) { return DatasetUtilities . findRangeBounds ( dataset , true ) ; } else { return null ; } }
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtilities . iterateDomainBounds ( this , includeInterval ) ; } }
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
boolean hasData = ! DatasetUtilities . isEmptyOrNull ( currentDataset ) ;
Range r = DatasetUtilities . findRangeBounds ( d , true ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ final XYDataset dataset = plot . getDataset ( i ) ; if ( ! DatasetUtilities . isEmptyOrNull ( dataset ) ) { return false ; } }
! DatasetUtilities . isEmptyOrNull ( this . dataset )
double total = DatasetUtilities . calculatePieDatasetTotal ( dataset ) ;
double totalValue = DatasetUtilities . calculatePieDatasetTotal ( this . dataset ) ;
! DatasetUtilities . isEmptyOrNull ( this . dataset )
if ( this . dataset != null ) { state . setTotal ( DatasetUtilities . calculatePieDatasetTotal ( plot . getDataset () ) ) ; }
{ if ( dataset != null ) { return DatasetUtilities . findZBounds ( dataset ) ; } else { return null ; } }
Range r = DatasetUtilities . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtilities . findDomainBounds ( dataset , false ) ;
{ if ( dataset != null ) { return DatasetUtilities . findStackedRangeBounds ( ( TableXYDataset ) dataset ) ; } else { return null ; } }
Range r = DatasetUtilities . findStackedRangeBounds ( dataset , this . seriesToGroupMap ) ;
if ( d != null ) { result = Range . combine ( result , DatasetUtilities . findRangeBounds ( d ) ) ; }
! DatasetUtilities . isEmptyOrNull ( dataset )
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
Range r = DatasetUtilities . findRangeBounds ( dataset , false ) ;
Range r = DatasetUtilities . findDomainBounds ( dataset , false ) ;
{ if ( includeInterval ) { return this . intervalDelegate . getDomainBounds ( includeInterval ) ; } else { return DatasetUtilities . iterateDomainBounds ( this , includeInterval ) ; } }
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset newData = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
CategoryDataset dataset = DatasetUtilities . createCategoryDataset ( STRING_CONSTANT , STRING_CONSTANT , data ) ;
{ total = DataUtilities . calculateColumnTotal ( dataset , column , state . getVisibleSeriesArray () ) ; value = value / total ; }
{ this ( DataUtilities . createNumberArray2D ( starts ) , DataUtilities . createNumberArray2D ( ends ) ) ; }
clone.zValues = DataUtilities . clone ( this . zValues ) ;
if ( ! DataUtilities . equal ( this . zValues , that.zValues ) ) { return false ; }
double total = DataUtilities . calculateColumnTotal ( dataset , column ) ;
if ( this . renderAsPercentages ) { total = DataUtilities . calculateColumnTotal ( dataset , index , validRows ) ; }
OHLCItem item2 = ( OHLCItem ) TestUtilities . serialised ( item1 ) ;
XYLineAnnotation a2 = ( XYLineAnnotation ) TestUtilities . serialised ( a1 ) ;
Hour h2 = ( Hour ) TestUtilities . serialised ( h1 ) ;
CustomXYToolTipGenerator g2 = ( CustomXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
BoxAndWhiskerToolTipGenerator g2 = ( BoxAndWhiskerToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
StandardCategoryToolTipGenerator g2 = ( StandardCategoryToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtilities . serialised ( r1 ) ;
XYTaskDataset d2 = ( XYTaskDataset ) TestUtilities . serialised ( d1 ) ;
ClusteredXYBarRenderer r2 = ( ClusteredXYBarRenderer ) TestUtilities . serialised ( r1 ) ;
YInterval i2 = ( YInterval ) TestUtilities . serialised ( i1 ) ;
XYBubbleRenderer r2 = ( XYBubbleRenderer ) TestUtilities . serialised ( r1 ) ;
WindItemRenderer r2 = ( WindItemRenderer ) TestUtilities . serialised ( r1 ) ;
LineNeedle n2 = ( LineNeedle ) TestUtilities . serialised ( n1 ) ;
SpiderWebPlot p2 = ( SpiderWebPlot ) TestUtilities . serialised ( p1 ) ;
assertFalse ( TestUtilities . containsInstanceOf ( ec . getEntities () , XYItemEntity . class ) ) ;
StandardXYItemRenderer r2 = ( StandardXYItemRenderer ) TestUtilities . serialised ( r1 ) ;
DateTickMarkPosition p2 = ( DateTickMarkPosition ) TestUtilities . serialised ( p1 ) ;
DialValueIndicator i2 = ( DialValueIndicator ) TestUtilities . serialised ( i1 ) ;
XIntervalSeriesCollection c2 = ( XIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
CategoryAxis a2 = ( CategoryAxis ) TestUtilities . serialised ( a1 ) ;
PiePlot p2 = ( PiePlot ) TestUtilities . serialised ( p1 ) ;
NumberTickUnit t2 = ( NumberTickUnit ) TestUtilities . serialised ( t1 ) ;
XYDrawableAnnotation a2 = ( XYDrawableAnnotation ) TestUtilities . serialised ( a1 ) ;
IntervalCategoryItemLabelGenerator g2 = ( IntervalCategoryItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
ItemLabelAnchor a2 = ( ItemLabelAnchor ) TestUtilities . serialised ( a1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtilities . serialised ( p1 ) ;
MeterPlot p2 = ( MeterPlot ) TestUtilities . serialised ( p1 ) ;
TimePeriodValues s2 = ( TimePeriodValues ) TestUtilities . serialised ( s1 ) ;
CategoryToPieDataset d2 = ( CategoryToPieDataset ) TestUtilities . serialised ( d1 ) ;
Vector v2 = ( Vector ) TestUtilities . serialised ( v1 ) ;
WaterfallBarRenderer r2 = ( WaterfallBarRenderer ) TestUtilities . serialised ( r1 ) ;
XYIntervalSeries s2 = ( XYIntervalSeries ) TestUtilities . serialised ( s1 ) ;
XYInterval i2 = ( XYInterval ) TestUtilities . serialised ( i1 ) ;
HighLowRenderer r2 = ( HighLowRenderer ) TestUtilities . serialised ( r1 ) ;
CombinedDomainCategoryPlot plot2 = ( CombinedDomainCategoryPlot ) TestUtilities . serialised ( plot1 ) ;
LabelBlock b2 = ( LabelBlock ) TestUtilities . serialised ( b1 ) ;
DeviationRenderer r2 = ( DeviationRenderer ) TestUtilities . serialised ( r1 ) ;
PowerFunction2D f2 = ( PowerFunction2D ) TestUtilities . serialised ( f1 ) ;
StandardTickUnitSource t2 = ( StandardTickUnitSource ) TestUtilities . serialised ( t1 ) ;
Minute m2 = ( Minute ) TestUtilities . serialised ( m1 ) ;
PieSectionEntity e2 = ( PieSectionEntity ) TestUtilities . serialised ( e1 ) ;
CombinedRangeCategoryPlot plot2 = ( CombinedRangeCategoryPlot ) TestUtilities . serialised ( plot1 ) ;
StandardXYZToolTipGenerator g2 = ( StandardXYZToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtilities . serialised ( m1 ) ;
ValueMarker m2 = ( ValueMarker ) TestUtilities . serialised ( m1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
CategoryPlot p2 = ( CategoryPlot ) TestUtilities . serialised ( p1 ) ;
DefaultKeyedValues v2 = ( DefaultKeyedValues ) TestUtilities . serialised ( v1 ) ;
LayeredBarRenderer r2 = ( LayeredBarRenderer ) TestUtilities . serialised ( r1 ) ;
BoxAndWhiskerXYToolTipGenerator g2 = ( BoxAndWhiskerXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
TimeTableXYDataset d2 = ( TimeTableXYDataset ) TestUtilities . serialised ( d1 ) ;
Quarter q2 = ( Quarter ) TestUtilities . serialised ( q1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
JFreeChart c2 = ( JFreeChart ) TestUtilities . serialised ( c1 ) ;
PlumNeedle n2 = ( PlumNeedle ) TestUtilities . serialised ( n1 ) ;
SlidingCategoryDataset d2 = ( SlidingCategoryDataset ) TestUtilities . serialised ( d1 ) ;
GanttRenderer r2 = ( GanttRenderer ) TestUtilities . serialised ( r1 ) ;
LongNeedle n2 = ( LongNeedle ) TestUtilities . serialised ( n1 ) ;
StackedXYAreaRenderer r2 = ( StackedXYAreaRenderer ) TestUtilities . serialised ( r1 ) ;
BorderArrangement b2 = ( BorderArrangement ) TestUtilities . serialised ( b1 ) ;
StandardDialFrame f2 = ( StandardDialFrame ) TestUtilities . serialised ( f1 ) ;
ItemLabelPosition p2 = ( ItemLabelPosition ) TestUtilities . serialised ( p1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtilities . serialised ( b1 ) ;
CategoryAnchor a2 = ( CategoryAnchor ) TestUtilities . serialised ( a1 ) ;
XYShapeRenderer r2 = ( XYShapeRenderer ) TestUtilities . serialised ( r1 ) ;
XYBarDataset bd2 = ( XYBarDataset ) TestUtilities . serialised ( bd1 ) ;
VectorRenderer r2 = ( VectorRenderer ) TestUtilities . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtilities . serialised ( r1 ) ;
XYBarRenderer r2 = ( XYBarRenderer ) TestUtilities . serialised ( r1 ) ;
CategoryLabelEntity e2 = ( CategoryLabelEntity ) TestUtilities . serialised ( e1 ) ;
PlotOrientation orientation2 = ( PlotOrientation ) TestUtilities . serialised ( orientation1 ) ;
CategoryLabelWidthType w2 = ( CategoryLabelWidthType ) TestUtilities . serialised ( w1 ) ;
XYIntervalSeriesCollection c2 = ( XYIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
StandardXYURLGenerator g2 = ( StandardXYURLGenerator ) TestUtilities . serialised ( g1 ) ;
XYIntervalDataItem item2 = ( XYIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
CategoryItemEntity e2 = ( CategoryItemEntity ) TestUtilities . serialised ( e1 ) ;
PolynomialFunction2D f2 = ( PolynomialFunction2D ) TestUtilities . serialised ( f1 ) ;
StatisticalLineAndShapeRenderer r2 = ( StatisticalLineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultPieDataset d2 = ( DefaultPieDataset ) TestUtilities . serialised ( d1 ) ;
DateTick t2 = ( DateTick ) TestUtilities . serialised ( t1 ) ;
ShipNeedle n2 = ( ShipNeedle ) TestUtilities . serialised ( n1 ) ;
XYDataItem i2 = ( XYDataItem ) TestUtilities . serialised ( i1 ) ;
GradientBarPainter p2 = ( GradientBarPainter ) TestUtilities . serialised ( p1 ) ;
StandardDialRange r2 = ( StandardDialRange ) TestUtilities . serialised ( r1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtilities . serialised ( m1 ) ;
StrokeMap m2 = ( StrokeMap ) TestUtilities . serialised ( m1 ) ;
LogFormat f2 = ( LogFormat ) TestUtilities . serialised ( f1 ) ;
StackedBarRenderer r2 = ( StackedBarRenderer ) TestUtilities . serialised ( r1 ) ;
OHLCSeries s2 = ( OHLCSeries ) TestUtilities . serialised ( s1 ) ;
DefaultIntervalCategoryDataset d2 = ( DefaultIntervalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
MyComparableObjectSeries s2 = ( MyComparableObjectSeries ) TestUtilities . serialised ( s1 ) ;
VectorSeriesCollection c2 = ( VectorSeriesCollection ) TestUtilities . serialised ( c1 ) ;
IntervalBarRenderer r2 = ( IntervalBarRenderer ) TestUtilities . serialised ( r1 ) ;
KeyedValuesDataset d2 = ( KeyedValuesDataset ) TestUtilities . serialised ( d1 ) ;
DialCap c2 = ( DialCap ) TestUtilities . serialised ( c1 ) ;
PointerNeedle n2 = ( PointerNeedle ) TestUtilities . serialised ( n1 ) ;
DateAxis a2 = ( DateAxis ) TestUtilities . serialised ( a1 ) ;
IntervalCategoryToolTipGenerator g2 = ( IntervalCategoryToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
XYItemEntity e2 = ( XYItemEntity ) TestUtilities . serialised ( e1 ) ;
FixedMillisecond m2 = ( FixedMillisecond ) TestUtilities . serialised ( m1 ) ;
DefaultOHLCDataset d2 = ( DefaultOHLCDataset ) TestUtilities . serialised ( d1 ) ;
SymbolicXYItemLabelGenerator g2 = ( SymbolicXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
LevelRenderer r2 = ( LevelRenderer ) TestUtilities . serialised ( r1 ) ;
PeriodAxis a2 = ( PeriodAxis ) TestUtilities . serialised ( a1 ) ;
DatasetGroup g2 = ( DatasetGroup ) TestUtilities . serialised ( g1 ) ;
Axis a2 = ( Axis ) TestUtilities . serialised ( a1 ) ;
VectorDataItem v2 = ( VectorDataItem ) TestUtilities . serialised ( v1 ) ;
StandardCategoryItemLabelGenerator g2 = ( StandardCategoryItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
KeyToGroupMap m2 = ( KeyToGroupMap ) TestUtilities . serialised ( m1 ) ;
MatrixSeriesCollection c2 = ( MatrixSeriesCollection ) TestUtilities . serialised ( c1 ) ;
Year y2 = ( Year ) TestUtilities . serialised ( y1 ) ;
XYStepRenderer r2 = ( XYStepRenderer ) TestUtilities . serialised ( r1 ) ;
SimpleTimePeriod p2 = ( SimpleTimePeriod ) TestUtilities . serialised ( p1 ) ;
DefaultMultiValueCategoryDataset d2 = ( DefaultMultiValueCategoryDataset ) TestUtilities . serialised ( d1 ) ;
XYSeries s2 = ( XYSeries ) TestUtilities . serialised ( s1 ) ;
CombinedRangeXYPlot plot2 = ( CombinedRangeXYPlot ) TestUtilities . serialised ( plot1 ) ;
CategoryTableXYDataset d2 = ( CategoryTableXYDataset ) TestUtilities . serialised ( d1 ) ;
YIntervalRenderer r2 = ( YIntervalRenderer ) TestUtilities . serialised ( r1 ) ;
TaskSeriesCollection c2 = ( TaskSeriesCollection ) TestUtilities . serialised ( c1 ) ;
SimpleHistogramBin b2 = ( SimpleHistogramBin ) TestUtilities . serialised ( b1 ) ;
DefaultCategoryDataset d2 = ( DefaultCategoryDataset ) TestUtilities . serialised ( d1 ) ;
BubbleXYItemLabelGenerator g2 = ( BubbleXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
PaintScaleLegend l2 = ( PaintScaleLegend ) TestUtilities . serialised ( l1 ) ;
OHLCDataItem i2 = ( OHLCDataItem ) TestUtilities . serialised ( i1 ) ;
AreaRendererEndType t2 = ( AreaRendererEndType ) TestUtilities . serialised ( t1 ) ;
BoxAndWhiskerRenderer r2 = ( BoxAndWhiskerRenderer ) TestUtilities . serialised ( r1 ) ;
HistogramDataset d2 = ( HistogramDataset ) TestUtilities . serialised ( d1 ) ;
MiddlePinNeedle n2 = ( MiddlePinNeedle ) TestUtilities . serialised ( n1 ) ;
CombinedDomainXYPlot plot2 = ( CombinedDomainXYPlot ) TestUtilities . serialised ( plot1 ) ;
IntervalXYDelegate d2 = ( IntervalXYDelegate ) TestUtilities . serialised ( d1 ) ;
XYDifferenceRenderer r2 = ( XYDifferenceRenderer ) TestUtilities . serialised ( r1 ) ;
StandardCategoryURLGenerator g2 = ( StandardCategoryURLGenerator ) TestUtilities . serialised ( g1 ) ;
StandardPieURLGenerator g2 = ( StandardPieURLGenerator ) TestUtilities . serialised ( g1 ) ;
Millisecond m2 = ( Millisecond ) TestUtilities . serialised ( m1 ) ;
TimeSeriesDataItem item2 = ( TimeSeriesDataItem ) TestUtilities . serialised ( item1 ) ;
YIntervalDataItem item2 = ( YIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
XYTextAnnotation a2 = ( XYTextAnnotation ) TestUtilities . serialised ( a1 ) ;
SubCategoryAxis a2 = ( SubCategoryAxis ) TestUtilities . serialised ( a1 ) ;
GrayPaintScale g2 = ( GrayPaintScale ) TestUtilities . serialised ( g1 ) ;
YIntervalSeriesCollection c2 = ( YIntervalSeriesCollection ) TestUtilities . serialised ( c1 ) ;
StandardXYBarPainter p2 = ( StandardXYBarPainter ) TestUtilities . serialised ( p1 ) ;
LineBorder b2 = ( LineBorder ) TestUtilities . serialised ( b1 ) ;
XYAreaRenderer r2 = ( XYAreaRenderer ) TestUtilities . serialised ( r1 ) ;
XYDotRenderer r2 = ( XYDotRenderer ) TestUtilities . serialised ( r1 ) ;
GradientXYBarPainter p2 = ( GradientXYBarPainter ) TestUtilities . serialised ( p1 ) ;
MatrixSeries m2 = ( MatrixSeries ) TestUtilities . serialised ( m1 ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
JFreeChart chart2 = ( JFreeChart ) TestUtilities . serialised ( chart ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
XYPlot p2 = ( XYPlot ) TestUtilities . serialised ( p1 ) ;
CustomCategoryURLGenerator g2 = ( CustomCategoryURLGenerator ) TestUtilities . serialised ( g1 ) ;
StandardXYToolTipGenerator g2 = ( StandardXYToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
XIntervalDataItem item2 = ( XIntervalDataItem ) TestUtilities . serialised ( item1 ) ;
MarkerAxisBand a2 = ( MarkerAxisBand ) TestUtilities . serialised ( a1 ) ;
HistogramBin b2 = ( HistogramBin ) TestUtilities . serialised ( b1 ) ;
TimeSeriesCollection c2 = ( TimeSeriesCollection ) TestUtilities . serialised ( c1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtilities . serialised ( p1 ) ;
ThermometerPlot p2 = ( ThermometerPlot ) TestUtilities . serialised ( p1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtilities . serialised ( f1 ) ;
CategoryTick t2 = ( CategoryTick ) TestUtilities . serialised ( t1 ) ;
ArrowNeedle n2 = ( ArrowNeedle ) TestUtilities . serialised ( n1 ) ;
ArcDialFrame f2 = ( ArcDialFrame ) TestUtilities . serialised ( f1 ) ;
XYBlockRenderer r2 = ( XYBlockRenderer ) TestUtilities . serialised ( r1 ) ;
AxisLocation location2 = ( AxisLocation ) TestUtilities . serialised ( location1 ) ;
FlowArrangement f2 = ( FlowArrangement ) TestUtilities . serialised ( f1 ) ;
XYBoxAnnotation a2 = ( XYBoxAnnotation ) TestUtilities . serialised ( a1 ) ;
GroupedStackedBarRenderer r2 = ( GroupedStackedBarRenderer ) TestUtilities . serialised ( r1 ) ;
NormalDistributionFunction2D f2 = ( NormalDistributionFunction2D ) TestUtilities . serialised ( f1 ) ;
SimpleHistogramDataset d2 = ( SimpleHistogramDataset ) TestUtilities . serialised ( d1 ) ;
KeyedObjects2D ko2D2 = ( KeyedObjects2D ) TestUtilities . serialised ( ko2D1 ) ;
PolarPlot p2 = ( PolarPlot ) TestUtilities . serialised ( p1 ) ;
DomainOrder d2 = ( DomainOrder ) TestUtilities . serialised ( d1 ) ;
VectorSeries s2 = ( VectorSeries ) TestUtilities . serialised ( s1 ) ;
ColorBlock b2 = ( ColorBlock ) TestUtilities . serialised ( b1 ) ;
PieLabelRecord p2 = ( PieLabelRecord ) TestUtilities . serialised ( p1 ) ;
DefaultPolarItemRenderer r2 = ( DefaultPolarItemRenderer ) TestUtilities . serialised ( r1 ) ;
XYPointerAnnotation a2 = ( XYPointerAnnotation ) TestUtilities . serialised ( a1 ) ;
LegendItemEntity e2 = ( LegendItemEntity ) TestUtilities . serialised ( e1 ) ;
TaskSeries s2 = ( TaskSeries ) TestUtilities . serialised ( s1 ) ;
DefaultCategoryItemRenderer r2 = ( DefaultCategoryItemRenderer ) TestUtilities . serialised ( r1 ) ;
Range r2 = ( Range ) TestUtilities . serialised ( r1 ) ;
ExtendedCategoryAxis a2 = ( ExtendedCategoryAxis ) TestUtilities . serialised ( a1 ) ;
DefaultDrawingSupplier r2 = ( DefaultDrawingSupplier ) TestUtilities . serialised ( r1 ) ;
Month m2 = ( Month ) TestUtilities . serialised ( m1 ) ;
PinNeedle n2 = ( PinNeedle ) TestUtilities . serialised ( n1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtilities . serialised ( r1 ) ;
XYErrorRenderer r2 = ( XYErrorRenderer ) TestUtilities . serialised ( r1 ) ;
CustomXYURLGenerator g2 = ( CustomXYURLGenerator ) TestUtilities . serialised ( g1 ) ;
LineFunction2D f2 = ( LineFunction2D ) TestUtilities . serialised ( f1 ) ;
XYSeriesCollection c2 = ( XYSeriesCollection ) TestUtilities . serialised ( c1 ) ;
StandardPieSectionLabelGenerator g2 = ( StandardPieSectionLabelGenerator ) TestUtilities . serialised ( g1 ) ;
Second s2 = ( Second ) TestUtilities . serialised ( s1 ) ;
BarRenderer r2 = ( BarRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtilities . serialised ( d1 ) ;
CompassPlot p2 = ( CompassPlot ) TestUtilities . serialised ( p1 ) ;
DefaultTableXYDataset d2 = ( DefaultTableXYDataset ) TestUtilities . serialised ( d1 ) ;
MultipleXYSeriesLabelGenerator g2 = ( MultipleXYSeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
CategoryTextAnnotation a2 = ( CategoryTextAnnotation ) TestUtilities . serialised ( a1 ) ;
StandardCategorySeriesLabelGenerator g2 = ( StandardCategorySeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
CategoryMarker m2 = ( CategoryMarker ) TestUtilities . serialised ( m1 ) ;
Day d2 = ( Day ) TestUtilities . serialised ( d1 ) ;
DateTitle t2 = ( DateTitle ) TestUtilities . serialised ( t1 ) ;
Week w2 = ( Week ) TestUtilities . serialised ( w1 ) ;
AreaRenderer r2 = ( AreaRenderer ) TestUtilities . serialised ( r1 ) ;
TickUnits t2 = ( TickUnits ) TestUtilities . serialised ( t1 ) ;
BoxAndWhiskerItem i2 = ( BoxAndWhiskerItem ) TestUtilities . serialised ( i1 ) ;
TimePeriodAnchor a2 = ( TimePeriodAnchor ) TestUtilities . serialised ( a1 ) ;
PaintMap m2 = ( PaintMap ) TestUtilities . serialised ( m1 ) ;
PaintMap m2 = ( PaintMap ) TestUtilities . serialised ( m1 ) ;
RingPlot p2 = ( RingPlot ) TestUtilities . serialised ( p1 ) ;
StandardBarPainter p2 = ( StandardBarPainter ) TestUtilities . serialised ( p1 ) ;
LegendItemCollection c2 = ( LegendItemCollection ) TestUtilities . serialised ( c1 ) ;
RangeType r2 = ( RangeType ) TestUtilities . serialised ( r1 ) ;
StatisticalBarRenderer r2 = ( StatisticalBarRenderer ) TestUtilities . serialised ( r1 ) ;
DefaultKeyedValue v2 = ( DefaultKeyedValue ) TestUtilities . serialised ( v1 ) ;
OHLC i2 = ( OHLC ) TestUtilities . serialised ( i1 ) ;
StandardXYItemLabelGenerator g2 = ( StandardXYItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
BlockContainer c2 = ( BlockContainer ) TestUtilities . serialised ( c1 ) ;
NumberAxis a2 = ( NumberAxis ) TestUtilities . serialised ( a1 ) ;
LogAxis a2 = ( LogAxis ) TestUtilities . serialised ( a1 ) ;
CategoryStepRenderer r2 = ( CategoryStepRenderer ) TestUtilities . serialised ( r1 ) ;
CustomPieURLGenerator g2 = ( CustomPieURLGenerator ) TestUtilities . serialised ( g1 ) ;
PeriodAxisLabelInfo info2 = ( PeriodAxisLabelInfo ) TestUtilities . serialised ( info1 ) ;
DefaultHighLowDataset d2 = ( DefaultHighLowDataset ) TestUtilities . serialised ( d1 ) ;
DialPointer i2 = ( DialPointer ) TestUtilities . serialised ( i1 ) ;
DialPointer i2 = ( DialPointer ) TestUtilities . serialised ( i1 ) ;
KeyedObject ko2 = ( KeyedObject ) TestUtilities . serialised ( ko1 ) ;
BlockBorder b2 = ( BlockBorder ) TestUtilities . serialised ( b1 ) ;
MultiplePiePlot p2 = ( MultiplePiePlot ) TestUtilities . serialised ( p1 ) ;
XYSplineRenderer r2 = ( XYSplineRenderer ) TestUtilities . serialised ( r1 ) ;
XYShapeAnnotation a2 = ( XYShapeAnnotation ) TestUtilities . serialised ( a1 ) ;
YWithXInterval i2 = ( YWithXInterval ) TestUtilities . serialised ( i1 ) ;
DefaultBoxAndWhiskerCategoryDataset d2 = ( DefaultBoxAndWhiskerCategoryDataset ) TestUtilities . serialised ( d1 ) ;
CompositeTitle t2 = ( CompositeTitle ) TestUtilities . serialised ( t1 ) ;
CategoryPointerAnnotation a2 = ( CategoryPointerAnnotation ) TestUtilities . serialised ( a1 ) ;
XYPolygonAnnotation a2 = ( XYPolygonAnnotation ) TestUtilities . serialised ( a1 ) ;
Task t2 = ( Task ) TestUtilities . serialised ( t1 ) ;
DialPlot p2 = ( DialPlot ) TestUtilities . serialised ( p1 ) ;
XYTitleAnnotation a2 = ( XYTitleAnnotation ) TestUtilities . serialised ( a1 ) ;
DefaultKeyedValues2D kv2D2 = ( DefaultKeyedValues2D ) TestUtilities . serialised ( kv2D1 ) ;
StackedAreaRenderer r2 = ( StackedAreaRenderer ) TestUtilities . serialised ( r1 ) ;
TimePeriodValue tpv2 = ( TimePeriodValue ) TestUtilities . serialised ( tpv1 ) ;
DefaultHeatMapDataset d2 = ( DefaultHeatMapDataset ) TestUtilities . serialised ( d1 ) ;
XYLineAndShapeRenderer r2 = ( XYLineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
XYStepAreaRenderer r2 = ( XYStepAreaRenderer ) TestUtilities . serialised ( r1 ) ;
YIntervalSeries s2 = ( YIntervalSeries ) TestUtilities . serialised ( s1 ) ;
GridArrangement f2 = ( GridArrangement ) TestUtilities . serialised ( f1 ) ;
XYAreaRenderer2 r2 = ( XYAreaRenderer2 ) TestUtilities . serialised ( r1 ) ;
WindNeedle n2 = ( WindNeedle ) TestUtilities . serialised ( n1 ) ;
HighLowItemLabelGenerator g2 = ( HighLowItemLabelGenerator ) TestUtilities . serialised ( g1 ) ;
DefaultBoxAndWhiskerXYDataset d2 = ( DefaultBoxAndWhiskerXYDataset ) TestUtilities . serialised ( d1 ) ;
TimeSeriesURLGenerator g2 = ( TimeSeriesURLGenerator ) TestUtilities . serialised ( g1 ) ;
LogarithmicAxis a2 = ( LogarithmicAxis ) TestUtilities . serialised ( a1 ) ;
StandardPieToolTipGenerator g2 = ( StandardPieToolTipGenerator ) TestUtilities . serialised ( g1 ) ;
CyclicNumberAxis a2 = ( CyclicNumberAxis ) TestUtilities . serialised ( a1 ) ;
KeyedObjects ko2 = ( KeyedObjects ) TestUtilities . serialised ( ko1 ) ;
CandlestickRenderer r2 = ( CandlestickRenderer ) TestUtilities . serialised ( r1 ) ;
MonthDateFormat mf2 = ( MonthDateFormat ) TestUtilities . serialised ( mf1 ) ;
XYBoxAndWhiskerRenderer r2 = ( XYBoxAndWhiskerRenderer ) TestUtilities . serialised ( r1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtilities . serialised ( i1 ) ;
ChartRenderingInfo i2 = ( ChartRenderingInfo ) TestUtilities . serialised ( i1 ) ;
XYCoordinate v2 = ( XYCoordinate ) TestUtilities . serialised ( v1 ) ;
StandardEntityCollection c2 = ( StandardEntityCollection ) TestUtilities . serialised ( c1 ) ;
CrosshairOverlay o2 = ( CrosshairOverlay ) TestUtilities . serialised ( o1 ) ;
PiePlot3D p2 = ( PiePlot3D ) TestUtilities . serialised ( p1 ) ;
FastScatterPlot p2 = ( FastScatterPlot ) TestUtilities . serialised ( p1 ) ;
DefaultKeyedValueDataset d2 = ( DefaultKeyedValueDataset ) TestUtilities . serialised ( d1 ) ;
TextTitle t2 = ( TextTitle ) TestUtilities . serialised ( t1 ) ;
ComparableObjectItem item2 = ( ComparableObjectItem ) TestUtilities . serialised ( item1 ) ;
TimeSeries s2 = ( TimeSeries ) TestUtilities . serialised ( s1 ) ;
TimePeriodValuesCollection c2 = ( TimePeriodValuesCollection ) TestUtilities . serialised ( c1 ) ;
LegendItem item2 = ( LegendItem ) TestUtilities . serialised ( item1 ) ;
item2 = ( LegendItem ) TestUtilities . serialised ( item1 ) ;
LineAndShapeRenderer r2 = ( LineAndShapeRenderer ) TestUtilities . serialised ( r1 ) ;
EmptyBlock b2 = ( EmptyBlock ) TestUtilities . serialised ( b1 ) ;
StackedXYBarRenderer r2 = ( StackedXYBarRenderer ) TestUtilities . serialised ( r1 ) ;
MinMaxCategoryRenderer r2 = ( MinMaxCategoryRenderer ) TestUtilities . serialised ( r1 ) ;
StandardChartTheme t2 = ( StandardChartTheme ) TestUtilities . serialised ( t1 ) ;
SlidingGanttCategoryDataset d2 = ( SlidingGanttCategoryDataset ) TestUtilities . serialised ( d1 ) ;
QuarterDateFormat qf2 = ( QuarterDateFormat ) TestUtilities . serialised ( qf1 ) ;
StackedXYAreaRenderer2 r2 = ( StackedXYAreaRenderer2 ) TestUtilities . serialised ( r1 ) ;
IntervalMarker m2 = ( IntervalMarker ) TestUtilities . serialised ( m1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
DefaultStatisticalCategoryDataset d2 = ( DefaultStatisticalCategoryDataset ) TestUtilities . serialised ( d1 ) ;
MeterInterval m2 = ( MeterInterval ) TestUtilities . serialised ( m1 ) ;
LegendTitle t2 = ( LegendTitle ) TestUtilities . serialised ( t1 ) ;
ScatterRenderer r2 = ( ScatterRenderer ) TestUtilities . serialised ( r1 ) ;
OHLCSeriesCollection c2 = ( OHLCSeriesCollection ) TestUtilities . serialised ( c1 ) ;
PlotRenderingInfo p2 = ( PlotRenderingInfo ) TestUtilities . serialised ( p1 ) ;
ModuloAxis a2 = ( ModuloAxis ) TestUtilities . serialised ( a1 ) ;
MeanAndStandardDeviation m2 = ( MeanAndStandardDeviation ) TestUtilities . serialised ( m1 ) ;
DateTickUnit a2 = ( DateTickUnit ) TestUtilities . serialised ( a1 ) ;
CategoryLabelPositions p2 = ( CategoryLabelPositions ) TestUtilities . serialised ( p1 ) ;
CategoryLabelPosition p2 = ( CategoryLabelPosition ) TestUtilities . serialised ( p1 ) ;
ShortTextTitle t2 = ( ShortTextTitle ) TestUtilities . serialised ( t1 ) ;
DateRange r2 = ( DateRange ) TestUtilities . serialised ( r1 ) ;
XIntervalSeries s2 = ( XIntervalSeries ) TestUtilities . serialised ( s1 ) ;
CategoryLineAnnotation a2 = ( CategoryLineAnnotation ) TestUtilities . serialised ( a1 ) ;
StandardXYSeriesLabelGenerator g2 = ( StandardXYSeriesLabelGenerator ) TestUtilities . serialised ( g1 ) ;
Crosshair c2 = ( Crosshair ) TestUtilities . serialised ( c1 ) ;
LegendGraphic g2 = ( LegendGraphic ) TestUtilities . serialised ( g1 ) ;
SymbolAxis a2 = ( SymbolAxis ) TestUtilities . serialised ( a1 ) ;
DefaultKeyedValues2DDataset d2 = ( DefaultKeyedValues2DDataset ) TestUtilities . serialised ( d1 ) ;
TickLabelEntity e2 = ( TickLabelEntity ) TestUtilities . serialised ( e1 ) ;
entities != null && isPointInRect ( dataArea , xx , yy )
entities != null && isPointInRect ( dataArea , xx , yy )
final Rectangle2D area
final float s
final float s
final float s
final Shape shape
entities != null && AbstractXYItemRenderer . isPointInRect ( dataArea , x , y )
final ObjectInputStream stream
final ObjectOutputStream stream
final Graphics2D g2
final TextFragment fragment
final TextFragment fragment
public TextLine ( final String text ) { this ( text , TextFragment.DEFAULT_FONT ) ; }
final int month
final int code
final boolean shortened
final int weekday
final String title
final Object o
final String name
final Font font
final Font font
final Font font
final Font font
final Font font
final double height
final double height
final double width
final double width
final double width
final double width
final double width
final double width
final double height
final double height
final double height
final double height
final int d
final int serial
final String name
final String name
final Dialog dialog
final Window frame
final Window frame
final String name
final double height
final double width
final int maxrows
final TextLine line
final String name
final int index
final ObjectOutputStream stream
final int index
public ObjectList ( final int initialCapacity ) { super ( initialCapacity ) ; }
final String name
final Object object
final String classLoaderSource
final RectangleEdge edge
final String name
final int targetDOW
final int targetDOW
final int targetDOW
final int serial
final int relative
final int count
final String name
final int index
final int index
final String name
final Number value
final String name
final ObjectInputStream stream
final ObjectOutputStream stream
final Object object
protected AbstractObjectList ( final int initialCapacity ) { this ( initialCapacity , initialCapacity ) ; }
final String name
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( file , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( fillType , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( type , STRING_CONSTANT ) ; this . type = type ; fireDatasetChanged () ; }
ParamChecks . nullNotPermitted ( group , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( defaultGroup , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category2 = category ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category1 = category ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . remove ( RendererChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . listenerList . add ( RendererChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . defaultLegendTextFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultNegativeItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . defaultPositiveItemLabelPosition = position ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultItemLabelPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; setDefaultItemLabelFont ( font , true ) ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . defaultShape = shape ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultOutlineStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultStroke = stroke ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultOutlinePaint = paint ; if ( notify ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultFillPaint = paint ; if ( notify ) { fireChangeEvent () ; } }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( marker , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . domainGridlinePosition = position ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . rowRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . columnRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . renderingOrder = order ; fireChangeEvent () ; }
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ; this . orientation = orientation ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; this . value = value ; }
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( renderer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( supplier , STRING_CONSTANT ) ; this . drawingSupplier = supplier ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . errorIndicatorPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . thermometerPaint = paint ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . xyBarPainter = painter ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLabelPaint = paint ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . crosshairPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baselinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; }
{ ParamChecks . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotOutlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . plotBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendItemPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . legendBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . chartBackgroundPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subtitlePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . titlePaint = paint ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . smallFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . regularFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . largeFont = font ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . extraLargeFont = font ; }
ParamChecks . nullNotPermitted ( name , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ; this . chart = chart ; }
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandAlternatePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . gridBandPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . data . getValue ( key ) ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . shapeLocation = location ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . shapeAnchor = anchor ; }
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . obj = y ; }
ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . baseFormatter = formatter ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . separatorPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . separatorStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ; this . centerTextColor = color ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . centerTextFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . centerTextFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( mode , STRING_CONSTANT ) ; this . centerTextMode = mode ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateToFindZBounds ( dataset , visibleSeriesKeys , xRange , includeInterval ) ; return result ; }
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; Range result = iterateZBounds ( dataset , includeInterval ) ; return result ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativeBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positiveBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . lastBarPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . firstBarPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( radialAxis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( composite , STRING_CONSTANT ) ; this . fillComposite = composite ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . guideLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . guideLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . paintScale = scale ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . minIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . maxIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( icon , STRING_CONSTANT ) ; this . objectIcon = icon ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . groupStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . groupPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . xPosition = position ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( interval , STRING_CONSTANT ) ; this . intervals . add ( interval ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . valuePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . valueFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . tickLabelFormat = format ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . needlePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( polygon , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( thresholdType , STRING_CONSTANT ) ; this . gapThresholdType = thresholdType ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( name , STRING_CONSTANT ) ; this . name = name ; }
ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . key = key ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ; this . tickMarkPosition = position ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( maximumDate , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( date , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . chartMouseListeners . add ( ChartMouseListener . class , listener ) ; }
ParamChecks . nullNotPermitted ( file , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( overlay , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . zoomFillPaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . incompletePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . completePaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( values , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelTextAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( adj , STRING_CONSTANT ) ; this . labelOffsetType = adj ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . labelOffset = offset ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . labelAnchor = anchor ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ; this . labelBackgroundColor = color ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new MarkerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( arrangement , STRING_CONSTANT ) ; this . arrangement = arrangement ; }
ParamChecks . nullNotPermitted ( arrangement , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ; this . period = period ; this . value = value ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . categoryAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . category = category ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( subtask , STRING_CONSTANT ) ; this . subtasks . add ( subtask ) ; }
{ ParamChecks . nullNotPermitted ( description , STRING_CONSTANT ) ; this . description = description ; }
ParamChecks . nullNotPermitted ( description , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stripOutlineStroke = stroke ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . stripOutlinePaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . axisLocation = location ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ; this . scale = scale ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( serialDate , STRING_CONSTANT ) ; this . serialDate = serialDate ; peg ( Calendar . getInstance () ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . arrowPaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . arrowStroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . rangeAxis = axis ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . domainAxis = axis ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . cornerTextItems . add ( text ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . angleLabelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . angleLabelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ; this . angleTickUnit = unit ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( type , STRING_CONSTANT ) ; this . endType = type ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . sortOrder = order ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . itemLabelPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . itemPaint = paint ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . itemFont = font ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . legendItemGraphicPadding = padding ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . legendItemGraphicAnchor = anchor ; }
{ ParamChecks . nullNotPermitted ( edge , STRING_CONSTANT ) ; this . legendItemGraphicEdge = edge ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( sources , STRING_CONSTANT ) ; this . sources = sources ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( title , STRING_CONSTANT ) ; this . title = title ; }
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . volumePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( ChartChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( ChartChangeListener . class , listener ) ; }
ParamChecks . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subtitle , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; notifyListeners ( new ChartChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( renderingHints , STRING_CONSTANT ) ; this . renderingHints = renderingHints ; fireChartChanged () ; }
ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , stroke ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Stroke ) this . store . get ( key ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( t , STRING_CONSTANT ) ; this . gradientPaintTransformer = t ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . gradientTransformer = transformer ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ; this . dataset = dataset ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . anchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( label , STRING_CONSTANT ) ; this . label = label ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( label , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( edge , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( drawable , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ; this . textAlignment = alignment ; notifyListeners ( new TitleChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( alignment , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( position , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( rectangle , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . area = area ; }
ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( hour , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . artifactPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( coefficients , STRING_CONSTANT ) ; this . coefficients = ( double [] ) coefficients . clone () ; }
ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . subLabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . subLabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( subCategory , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( f , STRING_CONSTANT ) ; factory = f ; }
{ ParamChecks . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; }
{ ParamChecks . nullNotPermitted ( container , STRING_CONSTANT ) ; this . container = container ; this . backgroundPaint = null ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . remove ( OverlayChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( listener , STRING_CONSTANT ) ; this . changeListeners . add ( OverlayChangeListener . class , listener ) ; }
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; setRange ( Range . expand ( range , getLowerMargin () , getUpperMargin () ) , turnOffAutoRange , notify ) ; }
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ; this . defaultAutoRange = range ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . rightArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . leftArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . downArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( arrow , STRING_CONSTANT ) ; this . upArrow = arrow ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . rotationAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; fireAnnotationChanged () ; }
{ ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ; this . text = text ; fireAnnotationChanged () ; }
ParamChecks . nullNotPermitted ( text , STRING_CONSTANT ) ;
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ ParamChecks . nullNotPermitted ( x , STRING_CONSTANT ) ; this . x = x ; this . y = y ; }
ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( tickType , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeCrosshairStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainCrosshairPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainCrosshairStroke = stroke ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( axisIndex , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( origin , STRING_CONSTANT ) ; this . quadrantOrigin = origin ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainZeroBaselinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainZeroBaselineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rangeGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . rangeGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainMinorGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . domainGridlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainMinorGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . domainGridlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . seriesRenderingOrder = order ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . datasetRenderingOrder = order ; fireChangeEvent () ; }
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
ParamChecks . requireNonNegative ( index , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . axisOffset = offset ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . mercuryPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . valueFormat = formatter ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( f , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . store . put ( key , paint ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return ( Paint ) this . store . get ( key ) ; }
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( chart , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempOneTimeFilePrefix = prefix ; }
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; ServletUtilities.tempFilePrefix = prefix ; }
ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendShape = shape ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( period , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . labelGenerator = generator ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . baseSeriesOutlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesOutlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . baseSeriesPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( extract , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . aggregatedItemsPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; this . aggregatedItemsKey = key ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ; this . dataExtractOrder = order ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( pieChart , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( directions , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( array , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return getCategoryIndex ( columnKey ) ; }
ParamChecks . nullNotPermitted ( categoryKeys , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( seriesKeys , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . contentAlignmentPoint = anchor ; }
ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . advanceLineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . advanceLinePaint = paint ; }
ParamChecks . nullNotPermitted ( day , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( categories , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelURLs . remove ( category ) != null ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelURLs . get ( category ) ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelURLs . put ( category , url ) ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; if ( this . categoryLabelToolTips . remove ( category ) != null ) { fireChangeEvent () ; } }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; return ( String ) this . categoryLabelToolTips . get ( category ) ; }
{ ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ; this . categoryLabelToolTips . put ( category , tooltip ) ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( category , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( positions , STRING_CONSTANT ) ; this . categoryLabelPositions = positions ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ; return this . keys . indexOf ( columnKey ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . stroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . foregroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( bar , STRING_CONSTANT ) ; this . legendBar = bar ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; XYBarRenderer.defaultBarPainter = painter ; }
ParamChecks . nullNotPermitted ( columnKey , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( rowKey , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( color , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( hotspot , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendItemLabelGenerator = generator ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( plot , STRING_CONSTANT ) ; this . plot = plot ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . textAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . valueAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ; this . insets = insets ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . backgroundPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . paint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . font = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( value , STRING_CONSTANT ) ; this . templateValue = value ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( anchor , STRING_CONSTANT ) ; this . frameAnchor = anchor ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ super ( area , toolTipText , urlText ) ; ParamChecks . nullNotPermitted ( axis , STRING_CONSTANT ) ; this . axis = axis ; }
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . noDataMessagePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . noDataMessageFont = font ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( subplot , STRING_CONSTANT ) ;
{ super ( source ) ; ParamChecks . nullNotPermitted ( annotation , STRING_CONSTANT ) ; this . annotation = annotation ; }
{ ParamChecks . nullNotPermitted ( transformer , STRING_CONSTANT ) ; this . fillPaintTransformer = transformer ; }
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . line = line ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . outlineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . outlinePaint = paint ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . linePaint = paint ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . lineStroke = stroke ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . fillPaint = paint ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . shape = shape ; }
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatter = format ; }
{ ParamChecks . nullNotPermitted ( area , STRING_CONSTANT ) ; this . legendArea = area ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . sublabelPaint = paint ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . sublabelFont = font ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
ParamChecks . nullNotPermitted ( image , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( crosshair , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . prefix = prefix ; }
ParamChecks . nullNotPermitted ( defaultPaint , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseHighlightPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . roseCenterPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . rosePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( entity , STRING_CONSTANT ) ; this . entities . add ( entity ) ; }
ParamChecks . nullNotPermitted ( rect , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( scale , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( pointer , STRING_CONSTANT ) ; return this . pointers . indexOf ( pointer ) ; }
ParamChecks . nullNotPermitted ( pointer , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( layer , STRING_CONSTANT ) ; return this . layers . indexOf ( layer ) ; }
ParamChecks . nullNotPermitted ( layer , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( frame , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( task , STRING_CONSTANT ) ; this . tasks . add ( task ) ; fireSeriesChanged () ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . secondFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . secondSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . minuteSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . minuteFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . hourSuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . hourFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( suffix , STRING_CONSTANT ) ; this . daySuffix = suffix ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . dayFormatter = formatter ; }
{ ParamChecks . nullNotPermitted ( prefix , STRING_CONSTANT ) ; this . positivePrefix = prefix ; }
{ ParamChecks . nullNotPermitted ( map , STRING_CONSTANT ) ; this . seriesToGroupMap = map ; fireChangeEvent () ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zDateFormat = zFormat ; }
{ super ( formatString , xFormat , yFormat ) ; ParamChecks . nullNotPermitted ( zFormat , STRING_CONSTANT ) ; this . zFormat = zFormat ; }
{ ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . tickLabelFormatter = formatter ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . tickLabelFont = font ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . majorTickStroke = stroke ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . majorTickPaint = paint ; notifyListeners ( new DialLayerChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . columnKeys . indexOf ( key ) ; }
{ ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ; return this . rowKeys . indexOf ( key ) ; }
ParamChecks . nullNotPermitted ( item , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( date , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . shadowPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; this . barPainter = painter ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( painter , STRING_CONSTANT ) ; BarRenderer.defaultBarPainter = painter ; }
ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( bounds , STRING_CONSTANT ) ; this . bounds = bounds ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . padding = padding ; }
{ ParamChecks . nullNotPermitted ( frame , STRING_CONSTANT ) ; this . frame = frame ; }
{ ParamChecks . nullNotPermitted ( margin , STRING_CONSTANT ) ; this . margin = margin ; }
ParamChecks . nullNotPermitted ( unit , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( rangeType , STRING_CONSTANT ) ; this . rangeType = rangeType ; notifyListeners ( new AxisChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( group , STRING_CONSTANT ) ; this . group = group ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( orientation , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( order , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( theme , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( data , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( source , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( input , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( input , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( line , STRING_CONSTANT ) ; this . legendLine = line ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . negativePaint = paint ; notifyListeners ( new RendererChangeEvent ( this ) ) ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . positivePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( id , STRING_CONSTANT ) ; this . id = id ; }
ParamChecks . nullNotPermitted ( locale , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( tasks , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( state , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickMarkPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . tickLabelPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . axisLineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . axisLinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( location , STRING_CONSTANT ) ; this . labelLocation = location ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( insets , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ; return this . data . indexOf ( series ) ; }
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . minorTickMarkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . minorTickMarkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . minorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . majorTickTimePeriodClass = c ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( c , STRING_CONSTANT ) ; this . autoRangeTimePeriodClass = c ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( zone , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( last , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( first , STRING_CONSTANT ) ;
{ super ( size , minorTickCount ) ; ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ super ( size ) ; ParamChecks . nullNotPermitted ( formatter , STRING_CONSTANT ) ; this . formatter = formatter ; }
{ ParamChecks . nullNotPermitted ( seriesKey , STRING_CONSTANT ) ; this . seriesKey = seriesKey ; this . itemIndex = itemIndex ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( format , STRING_CONSTANT ) ; this . formatPattern = format ; }
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( dataset , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( record , STRING_CONSTANT ) ; this . labels . add ( record ) ; }
ParamChecks . nullNotPermitted ( base , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( base , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( range , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
ParamChecks . nullNotPermitted ( series , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( generator , STRING_CONSTANT ) ; this . legendLabelGenerator = generator ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( shape , STRING_CONSTANT ) ; this . legendItemShape = shape ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( distributor , STRING_CONSTANT ) ; this . labelDistributor = distributor ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( offset , STRING_CONSTANT ) ; this . simpleLabelOffset = offset ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( padding , STRING_CONSTANT ) ; this . labelPadding = padding ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( font , STRING_CONSTANT ) ; this . labelFont = font ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . labelLinkStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . labelLinkPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( style , STRING_CONSTANT ) ; this . labelLinkStyle = style ; fireChangeEvent () ; }
ParamChecks . nullNotPermitted ( key , STRING_CONSTANT ) ;
{ ParamChecks . nullNotPermitted ( stroke , STRING_CONSTANT ) ; this . defaultSectionOutlineStroke = stroke ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionOutlinePaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( paint , STRING_CONSTANT ) ; this . defaultSectionPaint = paint ; fireChangeEvent () ; }
{ ParamChecks . nullNotPermitted ( direction , STRING_CONSTANT ) ; this . direction = direction ; fireChangeEvent () ; }
String name
Point2D anchorPoint = RectangleAnchor . coordinates ( titleRect , this . anchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
Point2D pt2 = RectangleAnchor . coordinates ( bounds , this . valueAnchor ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( area , position . getCategoryAnchor () ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
return RectangleAnchor . coordinates ( anchorRect , anchor ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( shape . getBounds2D () , anchor ) ;
Point2D pt = RectangleAnchor . coordinates ( area , this . textAnchor ) ;
Point2D anchorPoint = RectangleAnchor . coordinates ( imageRect , this . anchor ) ;
g2 . setXORMode ( Color.orange ) ;
g2 . setXORMode ( Color.orange ) ;
if ( xor ) { g2 . setXORMode ( Color.gray ) ; }
this . overlays = new java.util.ArrayList () ;
if ( mep > NUMBER_CONSTANT ) { ep = getExplodePercent ( section ) / mep ; }
if ( ! isOrsonPDFAvailable () ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
chart.subtitles = new ArrayList () ;
return ( Title ) this . subtitles . get ( index ) ;
this . subtitles = new ArrayList () ;
this . chartPanel = new ChartPanel ( chart ) ;
Null () {}
public ObjectUtils () {}
public BooleanUtils () {}
public CharUtils () {}
public ClassUtils () {}
public NumberUtils () {}
public ArrayUtils () {}
public Validate () {}
public WordUtils () {}
public StringEscapeUtils () {}
public CharSetUtils () {}
public RandomStringUtils () {}
public EnumUtils () {}
private Entry () {}
public ExceptionUtils () {}
private Entry () {}
public EnumUtils () {}
public NumberUtils () {}
public DateFormatUtils () {}
public DateUtils () {}
public StopWatch () {}
public RandomStringUtils () { ; }
public StringEscapeUtils () { ; }
public WordUtils () { ; }
public CharSetUtils () { ; }
public CharUtils () { ; }
public NumberUtils () { ; }
public EnumUtils () { ; }
public ObjectUtils () { ; }
public BooleanUtils () { ; }
public ArrayUtils () { ; }
public ClassUtils () { ; }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) {} }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) {} }
{ try { return createLong ( numeric ) ; } catch ( NumberFormatException nfe ) {} return createBigInteger ( numeric ) ; }
if ( last == CHAR_CONS ) {} else { lastIdx ++ ; }
public StringUtils () {}
public SystemUtils () {}
{ try { if ( in != null ) { in . close () ; } } catch ( IOException ex ) { ; } }
{ try { if ( out != null ) { out . close () ; } } catch ( IOException ex ) { ; } }
public DateFormatUtils () { ; }
Null () { ; }
public DateUtils () { ; }
TwoDigitMonthField () { ; }
TwoDigitYearField () { ; }
UnpaddedMonthField () { ; }
public ExceptionUtils () { ; }
public NumberUtils () { ; }
public EnumUtils () { ; }
suite . addTestSuite ( VariableFormatTest . class ) ;
{ Object result = replaceObject ( source ) ; return ( result == null ) ? null : result . toString () ; }
sb . appendFixedWidthPadRight ( null , NUMBER_CONSTANT , CHAR_CONS ) ;
noPrimitives = new Class [] { String . class , ClassUtils . class }
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new DoubleRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new IntRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new LongRange ( nonComparable ) ;
assertEquals ( true , tenToTwenty . containsFloat ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsDouble ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsInteger ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsLong ( nonComparable ) ) ;
assertEquals ( true , tenToTwenty . containsNumber ( nonComparable ) ) ;
Range r = new FloatRange ( nonComparable ) ;
{ return ( StrTokenizer ) TSV_TOKENIZER_PROTOTYPE . clone () ; }
{ return ( StrTokenizer ) CSV_TOKENIZER_PROTOTYPE . clone () ; }
int removeLen = endIndex = startIndex ;
{ return lastIndexOf ( str , size ) ; }
{ return lastIndexOf ( ch , NUMBER_CONSTANT ) ; }
{ return new String ( buf , size - length , size ) ; }
{ return new StringBuffer ( size ) . append ( buf , NUMBER_CONSTANT , size ) ; }
{ return new String ( buf , NUMBER_CONSTANT , size ) ; }
{ if ( str . charAt ( j ) != buf [ i + j ] ) { continue outer ; } }
{ if ( buf [ i ] == ch ) { return i ; } }
char [] thisBuf = buf ;
char [] thisBuf = buf ;
char [] thisBuf = buf ;
{ endIndex = validateRange ( startIndex , endIndex ) ; return new String ( buf , startIndex , endIndex - startIndex ) ; }
{ if ( buf [ pos ] != str . charAt ( i ) ) { return false ; } }
{ if ( buf [ i ] != str . charAt ( i ) ) { return false ; } }
if ( len > NUMBER_CONSTANT ) { System . arraycopy ( buf , endIndex , buf , startIndex , size - endIndex ) ; size -= len ; }
for ( int i = NUMBER_CONSTANT ; i < length ; i ++ ) { buf [ size ++ ] = padChar ; }
buf [ size ++ ] = ch ;
System . arraycopy ( chars , startIndex , buf , len , length ) ;
System . arraycopy ( chars , NUMBER_CONSTANT , buf , len , strLen ) ;
System . arraycopy ( str.buf , NUMBER_CONSTANT , buf , len , strLen ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
str . getChars ( NUMBER_CONSTANT , strLen , buf , len ) ;
System . arraycopy ( buf , startIndex , destination , destinationIndex , endIndex - startIndex ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , destination , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , startIndex , chars , NUMBER_CONSTANT , len ) ;
System . arraycopy ( buf , NUMBER_CONSTANT , chars , NUMBER_CONSTANT , size ) ;
buf [ index ] = ch ;
{ if ( index < NUMBER_CONSTANT || index >= length () ) { throw new StringIndexOutOfBoundsException ( index ) ; } return buf [ index ] ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buf [ i ] = CHAR_CONS ; }
{ super(); if ( initialCapacity <= NUMBER_CONSTANT ) { initialCapacity = CAPACITY ; } buf = new char [ initialCapacity ] ; }
assertEquals ( true , sb.buf.length >= NUMBER_CONSTANT ) ;
if ( pos + len >= textLen ) { return NUMBER_CONSTANT ; }
{ return ( boolean [] ) add ( array , index , new Boolean ( element ) , Boolean.TYPE ) ; }
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . setLength ( - NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
try { sb . deleteCharAt ( NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( StringIndexOutOfBoundsException e ) {}
{ if ( startPos < getPos () ) { getTokenList () . addLast ( Token . newTextToken ( startPos , getPos () - startPos ) ) ; } }
if ( last == CharUtils.CR ) { ; } else { lastIdx ++ ; }
private void setVarStartMatcher ( StrTokenizer.Matcher varStartMatcher ) { this . varStartMatcher = varStartMatcher ; }
private void setVarEndMatcher ( StrTokenizer.Matcher varEndMatcher ) { this . varEndMatcher = varEndMatcher ; }
private void setEscVarMatcher ( StrTokenizer.Matcher escVarMatcher ) { this . escVarMatcher = escVarMatcher ; }
Matcher trimmer
{ setIgnoredMatcher ( new CharMatcher ( ignored ) ) ; }
Matcher ignored
{ setQuoteMatcher ( new CharMatcher ( quote ) ) ; }
Matcher quote
start == len && delim . isMatch ( chars , len , start - NUMBER_CONSTANT ) == NUMBER_CONSTANT
Matcher delim
Matcher delim
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.NONE_MATCHER ) ;
tok . setIgnoredMatcher ( StrTokenizer.TRIM_MATCHER ) ;
sb . replaceAll ( CHAR_CONS , CHAR_CONS ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
assertTrue ( tokens.length == expected.length ) ;
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars ; }
if ( cloned.chars != null ) { cloned.chars = cloned.chars ; }
public boolean isEmptyTokenAsNull () { return emptyAsNull ; }
{ if ( trimmer != null ) { this . trimmer = trimmer ; } return this ; }
public StrMatcher getTrimmerMatcher () { return trimmer ; }
{ if ( ignored != null ) { this . ignored = ignored ; } return this ; }
public StrMatcher getIgnoredMatcher () { return ignored ; }
{ if ( quote != null ) { this . quote = quote ; } return this ; }
public StrMatcher getQuoteMatcher () { return quote ; }
public StrMatcher getDelimiterMatcher () { return delim ; }
{ assertTrue ( ! bf_multi . isAllSet ( j ) ) ; assertTrue ( ! bf_zero . isAllSet ( j ) ) ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; this . cause = cause ; }
{ super ( STRING_CONSTANT ) ; this . cause = cause ; }
{ super ( msg == null ? STRING_CONSTANT : msg ) ; }
public NotImplementedException () { super ( STRING_CONSTANT ) ; }
private void tokenize () { if ( tokens == null ) { this . tokens = readTokens () ; } }
sb . append ( true ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT ) } ) ;
assertLocaleLookupList ( LOCALE_EN_US_ZZZZ , null , new Locale [] { LOCALE_EN_US_ZZZZ , LOCALE_EN_US , new Locale ( STRING_CONSTANT , STRING_CONSTANT ) } ) ;
{ return str != null && str . length () > NUMBER_CONSTANT ; }
List list = new LinkedList () ;
List list = new LinkedList () ;
{ append ( str , off , len ) ; }
{ append ( cbuf , off , len ) ; }
public void write ( char [] cbuf ) { append ( cbuf ) ; }
public void write ( int c ) { append ( ( char ) c ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
if ( index == - NUMBER_CONSTANT ) { return clone ( array ) ; }
{ return indexOf ( array , valueToFind , NUMBER_CONSTANT , tolerance ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , valueToFind ) != - NUMBER_CONSTANT ; }
{ return indexOf ( array , objectToFind ) != - NUMBER_CONSTANT ; }
{ return reflectionEquals ( lhs , rhs , testTransients , null ) ; }
{ return reflectionEquals ( lhs , rhs , false , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null ) ; }
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , false , null ) ; }
{ return reflectionCompare ( lhs , rhs , compareTransients , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null ) ; }
HashCodeBuilder . reflectionHashCode ( x , null )
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
String tokens [] = tok . getAllTokens () ;
public boolean hasPrevious () { tokenize () ; return tokenPos > NUMBER_CONSTANT ; }
public boolean hasNext () { tokenize () ; return tokenPos < tokens.length ; }
tokenize () ;
{ tokenize () ; return ( String [] ) tokens . clone () ; }
public int size () { tokenize () ; return tokens.length ; }
assertSame ( input , tok . getContent () ) ;
{ if ( ready () == false ) { return - NUMBER_CONSTANT ; } return charAt ( pos ++ ) ; }
String varValue = resolveVariable ( varName ) ;
if ( substitute ( buf , NUMBER_CONSTANT , length ) == false ) { return source . substring ( offset , length ) ; }
VariableResolver variableResolver
{ this ( new MapVariableResolver ( valueMap ) , prefix , suffix , escape ) ; }
{ this ( valueMap , prefix , suffix , DEFAULT_ESCAPE ) ; }
{ this ( new MapVariableResolver ( valueMap ) , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return new StrSubstitutor ( System . getProperties () ) . replace ( source ) ; }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
return ( Enum ) entry.map . get ( getName () ) ;
private Entry () { super(); }
sub . replace ( builder ) ;
assertEquals ( NUMBER_CONSTANT , ExceptionUtils . getThrowableCount ( recursiveCause ) ) ;
recursiveCause = null ;
recursiveCause = new ExceptionWithCause ( a ) ;
private DefaultToStringStyle () { super(); }
protected DefaultToStringStyle () { super(); }
public Object getValue () { return new Boolean ( this . value ) ; }
public Object getValue () { return Boolean . valueOf ( this . value ) ; }
public Object getValue () { return new Boolean ( this . value ) ; }
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
this . validateEmptyReflectionRegistry () ;
{ StringWriter stringWriter = newStringWriter ( str ) ; this . unescape ( stringWriter , str ) ; return stringWriter . toString () ; }
{ StringWriter stringWriter = newStringWriter ( str ) ; this . escape ( stringWriter , str ) ; return stringWriter . toString () ; }
assertSame ( CharSet.EMPTY , CharSet . getInstance ( null ) ) ;
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
CharSet chars = evaluateSet ( set ) ;
stopTime = System . currentTimeMillis () ;
stopTime = - NUMBER_CONSTANT ;
stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { stopTime = System . currentTimeMillis () ; }
protected void setUp ( ) throws Exception { super . setUp () ; }
if ( ! containsCsvChars ( str ) ) { return str ; }
MessageFormat f = createMessageFormat ( pattern ) ;
subformats . put ( INTEGER , NumberFormat . getIntegerInstance ( getLocale () ) ) ;
NumberFormat . getIntegerInstance ( Locale.US )
{ return splitByWholeSeparator ( str , separator , - NUMBER_CONSTANT ) ; }
{ clazz = Class . forName ( toProperClassName ( className ) , initialize , classLoader ) ; }
if ( StringUtils . containsAny ( quoteless , CSV_SEARCH_CHARS ) ) { str = StringUtils . replace ( quoteless , STRING_CONSTANT + CSV_QUOTE + CSV_QUOTE , CSV_QUOTE_STR ) ; }
catch ( IllegalArgumentException e ) {}
if ( replaceChars == null ) { replaceChars = STRING_CONSTANT ; }
{ if ( isEmpty ( str ) || isEmpty ( remove ) ) { return str ; } return replace ( str , remove , STRING_CONSTANT , - NUMBER_CONSTANT ) ; }
{ return new ExtendedMessageFormat ( pattern , locale , ExtendedMessageFormat . createDefaultMetaFormat ( locale ) ) ; }
assertEquals ( pattern , emf . toPattern () ) ;
assertEquals ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
int mid = ( low + high ) > > NUMBER_CONSTANT ;
osName . toLowerCase () . startsWith ( STRING_CONSTANT )
{ return Integer . toHexString ( ch ) . toUpperCase () ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
catch ( IOException ioe ) { ioe . printStackTrace () ; return null ; }
{ getRegistry () . remove ( toIdentityHashCodeInteger ( value ) ) ; }
{ getRegistry () . add ( toIdentityHashCodeInteger ( value ) ) ; }
{ return getRegistry () . contains ( toIdentityHashCodeInteger ( value ) ) ; }
roundUp = offset > NUMBER_CONSTANT ;
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTime ; }
this . startTime += ( System . currentTimeMillis () - this . stopTime ) ;
this . stopTime = System . currentTimeMillis () ;
this . stopTime = System . currentTimeMillis () ;
if ( this . runningState == STATE_RUNNING ) { this . stopTime = System . currentTimeMillis () ; }
public static Test suite () { return new TestSuite ( NestableErrorTestCase . class ) ; }
public static Test suite () { return new TestSuite ( NestableExceptionTestCase . class ) ; }
public static Test suite () { return new TestSuite ( NestableRuntimeExceptionTestCase . class ) ; }
public ExceptionUtilsTestCase ( String name ) { super ( name ) ; }
public String toString () { return STRING_CONSTANT ; }
{ return ( ( Boolean ) IS_SYNTHETIC . invoke ( m , null ) ) . booleanValue () ; }
objects [ NUMBER_CONSTANT ] = ( Object ) simple ;
objectsLevel2 [ NUMBER_CONSTANT ] = ( Object ) objects ;
{ if ( array == null ) { return null ; } return ( boolean [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( float [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( double [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( byte [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( char [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( short [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( int [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( long [] ) array . clone () ; }
{ if ( array == null ) { return null ; } return ( Object [] ) array . clone () ; }
if ( cloned.chars != null ) { cloned.chars = ( char [] ) cloned.chars . clone () ; }
{ checkTokenized () ; return ( String [] ) tokens . clone () ; }
public Throwable getCause () { return cause ; }
public String toString () { return toString ; }
sb . appendln ( ( Object ) FOO ) ;
{ super ( msg ) ; }
{ super ( msg ) ; }
{ super ( msg ) ; }
String [] splitOnNullResults = StringUtils . splitByWholeSeparator ( STRING_CONSTANT , null ) ;
{ ObjectUtils . appendIdentityToString ( this . getStringBuffer () , object ) ; return this ; }
{ ObjectUtils . appendIdentityToString ( buffer , value ) ; }
String pBaseStr = p . getClass () . getName () ;
{ super ( DEFAULT_MESSAGE ) ; this . cause = cause ; }
final Nestable n = new UnhandledException ( t ) ;
catch ( NumberFormatException nfe ) { throw new NestableRuntimeException ( STRING_CONSTANT + unicode , nfe ) ; }
String entityValue = Entities.ISO8859_1_ARRAY [ i % Entities.ISO8859_1_ARRAY.length ] [ NUMBER_CONSTANT ] ;
String entityValue = Entities.HTML40_ARRAY [ i % Entities.HTML40_ARRAY.length ] [ NUMBER_CONSTANT ] ;
Collection collection
Collection collection
Iterator iterator
Iterator iterator
Iterator it
Iterator it
List tokens
List tokens
List list
public Byte toByte () { return new Byte ( byteValue () ) ; }
public Object getValue () { return new Byte ( this . value ) ; }
{ mutNum . compareTo ( new Byte ( ( byte ) NUMBER_CONSTANT ) ) ; fail () ; }
{ return ( byte [] ) add ( array , index , new Byte ( element ) , Byte.TYPE ) ; }
{ result [ i ] = new Byte ( array [ i ] ) ; }
Class type
Class type
Class type
Class clazz
Class clazz
List list = getCauseMethodNameList () ;
List list = getCauseMethodNameList () ;
Class clazz
Map registry
Map registry
Object obj
Object obj
Class lhsClass = lhs . getClass () ;
Class clazz
Class reflectUpToClass
Collection excludeFields
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls = target . getClass () ;
Class cls = target . getClass () ;
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
Class cls
Class clazz
Class clazz
Class reflectUpToClass
Collection collection
Collection excludeFieldNames
Class reflectUpToClass
List priorVariables
Class cls
Class cls
Class cls
Class cls
Class cls
Class clss
Class clss = null ;
Class newArrayComponentType
Class cls
Class expected
Class clazz
Class reflectUpToClass
Collection excludeFields
Collection excludeFields
Class reflectUpToClass
Class clazz
Class cls
Class cls
if ( methodNames == null ) { synchronized ( CAUSE_METHOD_NAMES ) { methodNames = CAUSE_METHOD_NAMES ; } }
{ synchronized ( CAUSE_METHOD_NAMES ) { return getCause ( throwable , CAUSE_METHOD_NAMES ) ; } }
if ( list . remove ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
if ( list . add ( methodName ) ) { synchronized ( CAUSE_METHOD_NAMES ) { CAUSE_METHOD_NAMES = toArray ( list ) ; } }
Iterator it
Iterator it
Iterator it
assertTrue ( ObjectUtils.NULL != null ) ;
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , obj , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ style . append ( buffer , fieldName , array , BooleanUtils . toBooleanObject ( fullDetail ) ) ; return this ; }
{ return ( boolean [] ) add ( array , index , BooleanUtils . toBooleanObject ( element ) , Boolean.TYPE ) ; }
public Object getValue () { return BooleanUtils . toBooleanObject ( this . value ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return getPackageName ( cls . getName () ) ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
{ if ( comparison != NUMBER_CONSTANT ) { return this ; } comparison = NumberUtils . compare ( lhs , rhs ) ; return this ; }
return NumberUtils . compare ( value , anotherVal ) ;
return NumberUtils . compare ( value , anotherVal ) ;
int compare = ( ( Comparable ) num1 ) . compareTo ( num2 ) ;
Map map
Collection collection
Comparator comparator
Class < > clazz
Object object
Object object
Object object
Object object
Object object
Object object
Map map
public String [] getExcludeFieldNames () { return this . excludeFieldNames ; }
{ unescapeJava ( out , str ) ; }
{ return unescapeJava ( str ) ; }
{ escapeJavaStyleString ( out , str , true , true ) ; }
{ return escapeJavaStyleString ( str , true , true ) ; }
{ escapeJavaStyleString ( out , str , false , false ) ; }
{ return escapeJavaStyleString ( str , false , false ) ; }
{ return UnescapeUtils.UNESCAPE_CSV . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_CSV . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_XML . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_XML . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_HTML4 . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_HTML4 . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return UnescapeUtils.UNESCAPE_JAVA . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_ECMASCRIPT . translate ( str ) ; }
{ return EscapeUtils.ESCAPE_JAVA . translate ( str ) ; }
void setValue ( Object value ) ;
Object getValue ( ) ;
Object value
Object value
String str
String str
String str
String str
modify ( truncated , field , false ) ;
modify ( gval , field , false ) ;
modify ( rounded , field , true ) ;
modify ( gval , field , true ) ;
{ throw new NullArgumentException ( STRING_CONSTANT ) ; }
if ( target == null ) { throw new NullArgumentException ( STRING_CONSTANT ) ; }
catch ( NumberFormatException nfe ) { throw new UnhandledException ( STRING_CONSTANT + unicode , nfe ) ; }
assertGetClassThrowsIllegalArgument ( null ) ;
catch ( IOException ioe ) { throw new UnhandledException ( ioe ) ; }
buffer = new char [ capacity ] ;
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( message + value ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( getMessage ( message , value ) ) ; } }
{ result [ i ] = new Float ( array [ i ] ) ; }
{ result [ i ] = new Double ( array [ i ] ) ; }
{ result [ i ] = new Short ( array [ i ] ) ; }
{ result [ i ] = new Integer ( array [ i ] ) ; }
{ result [ i ] = new Long ( array [ i ] ) ; }
{ result [ i ] = new Character ( array [ i ] ) ; }
double [] array2
float [] array2
long [] array2
int [] array2
short [] array2
byte [] array2
char [] array2
boolean [] array2
object instanceof Map.Entry
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
Iterator it = collection . iterator ()
if ( num1 instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
if ( num instanceof Comparable == false ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
oos . writeObject ( new ClassNotFoundSerializationTest () ) ;
{ if ( object == null ) { return valueIfNull ; } return getPackageName ( object . getClass () . getName () ) ; }
{ if ( object == null ) { return valueIfNull ; } return getShortClassName ( object . getClass () . getName () ) ; }
{ if ( cls == null ) { return StringUtils.EMPTY ; } return cls . getPackage () . getName () ; }
isEscapingPlus ()
uu . setEscapingPlus ( true ) ;
uu = new UnicodeUnescaper ( UnicodeUnescaper.PARAM.escapePlus ) ;
isSet ( PARAM.escapePlus )
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer result = new StringBuffer () ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer canonicalClassNameBuffer = new StringBuffer ( className ) ;
StringBuffer classNameBuffer = new StringBuffer () ;
StringBuffer arrayPrefix = new StringBuffer () ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer ( strLen ) ;
new StringBuffer ( strLen ) . append ( Character . toLowerCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
new StringBuffer ( strLen ) . append ( Character . toTitleCase ( str . charAt ( NUMBER_CONSTANT ) ) ) . append ( str . substring ( NUMBER_CONSTANT ) )
StringBuffer buf = new StringBuffer ( outputLength ) ;
StringBuffer buf = new StringBuffer ( strLength ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( bufSize ) ;
StringBuffer buf = new StringBuffer ( NUMBER_CONSTANT ) ;
StringBuffer buffer = new StringBuffer ( NUMBER_CONSTANT ) ;
toString = new StringBuffer ( NUMBER_CONSTANT ) . append ( getNumerator () ) . append ( CHAR_CONS ) . append ( getDenominator () ) . toString () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer buf = new StringBuffer () ;
CharRange range = new CharRange ( CHAR_CONS ) ;
Collection collection
Collection collection
Class cls
Map map
Collection coll
Class cls
Class cls
Class [] parameterTypes
Class [] parameterTypes
assertEquals ( null , StringUtils . join ( ( Collection ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Collection ) null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , null ) ) ;
assertEquals ( null , StringUtils . join ( ( Iterator ) null , CHAR_CONS ) ) ;
Class exceptionType
Class c
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null , true ) ) ;
assertFalse ( ClassUtils . isAssignable ( ( Class ) null , null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getPackageName ( ( Class ) null ) ) ;
iMap = new HashMap () ;
Class [] c
sb . appendWithSeparators ( ( Iterator ) null , STRING_CONSTANT ) ;
sb . appendWithSeparators ( ( Collection ) null , STRING_CONSTANT ) ;
sb . appendAll ( ( Iterator ) null ) ;
sb . appendAll ( ( Collection ) null ) ;
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
public String getFormattedExceptionMessage ( String baseMessage ) { return this . exceptionContext . getFormattedExceptionMessage ( baseMessage ) ; }
Serializable value
Serializable value
StringBuilder buffer = new StringBuilder () ;
Class [] c
values = new HashMap () ;
List list = tok . getTokenList () ;
Map map = null ;
Map < String , FormatFactory > registry
Map registry
Map registry
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , ( Collection ) null ) ;
String toString = ReflectionToStringBuilder . toStringExclude ( new TestFixture () , new ArrayList () ) ;
T object
T object
T object
T object
T object
T object
{ this ( object , getDefaultStyle () , null ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( this . getMinimum () , element ) < NUMBER_CONSTANT ; }
StringEscapeUtils . unescapeCsv ( writer , value ) ;
StringEscapeUtils . escapeCsv ( writer , value ) ;
StringEscapeUtils . unescapeJava ( writer , original ) ;
StringEscapeUtils . escapeJava ( writer , original ) ;
Comparator c
{ try { return initialize () ; } finally { if ( executor != null ) { executor . shutdown () ; } } }
{ executor = exec ; }
{ this . translators = translators ; }
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , index ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , index ) ; }
Object [] values2 = ArrayUtils . addAll ( values , i ) ;
Object [] values2 = ArrayUtils . add ( values , i ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , value ) ) ; } }
{ calendar . getTime () ; calendar = ( Calendar ) calendar . clone () ; calendar . setTimeZone ( mTimeZone ) ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMaximum () ) > NUMBER_CONSTANT ; }
{ if ( element == null ) { return false ; } return this . comparator . compare ( element , getMinimum () ) < NUMBER_CONSTANT ; }
return getCauseUsingFieldName ( throwable , STRING_CONSTANT ) ;
{ return validIndex ( chars , index , DEFAULT_VALID_INDEX_CHAR_SEQUENCE_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( collection , index , DEFAULT_VALID_INDEX_COLLECTION_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return validIndex ( array , index , DEFAULT_VALID_INDEX_ARRAY_EXCEPTION_MESSAGE , Integer . valueOf ( index ) ) ; }
{ return noNullElements ( iterable , DEFAULT_NO_NULL_ELEMENTS_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return noNullElements ( array , DEFAULT_NO_NULL_ELEMENTS_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notBlank ( chars , DEFAULT_NOT_BLANK_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( chars , DEFAULT_NOT_EMPTY_CHAR_SEQUENCE_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( map , DEFAULT_NOT_EMPTY_MAP_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( collection , DEFAULT_NOT_EMPTY_COLLECTION_EXCEPTION_MESSAGE ) ; }
{ return notEmpty ( array , DEFAULT_NOT_EMPTY_ARRAY_EXCEPTION_MESSAGE ) ; }
{ return notNull ( object , DEFAULT_IS_NULL_EXCEPTION_MESSAGE ) ; }
StrLookup variableResolver
StrLookup resolver = getVariableResolver () ;
StrLookup variableResolver
StrLookup variableResolver
StrLookup variableResolver
public StrSubstitutor () { this ( ( StrLookup ) null , DEFAULT_PREFIX , DEFAULT_SUFFIX , DEFAULT_ESCAPE ) ; }
{ return m != null && Modifier . isPublic ( m . getModifiers () ) && ! isSynthetic ( m ) ; }
validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
this . validateEmptyToStringStyleRegistry () ;
{ return registry . get () ; }
String str
if ( str == null || suffix == null ) { return ( str == null && suffix == null ) ; }
{ if ( str == null ) { return null ; } return new StringBuilder ( str ) . reverse () . toString () ; }
if ( ( str == null ) || ( searchStrs == null ) ) { return - NUMBER_CONSTANT ; }
smallestIndexOfDiff == - NUMBER_CONSTANT
if ( at == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( isEmpty ( str ) || str . indexOf ( remove ) == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
if ( pos == - NUMBER_CONSTANT ) { return EMPTY ; }
if ( pos == - NUMBER_CONSTANT ) { return str ; }
return indexOfAnyBut ( cs , valid ) == - NUMBER_CONSTANT ;
{ if ( isEmpty ( cs ) || isEmpty ( searchChars ) ) { return - NUMBER_CONSTANT ; } return indexOfAny ( cs , searchChars . toCharArray () ) ; }
if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchStr ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar , startPos ) ; }
{ if ( isEmpty ( str ) ) { return - NUMBER_CONSTANT ; } return str . lastIndexOf ( searchChar ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr , startPos ) ; }
{ if ( str == null || searchStr == null ) { return - NUMBER_CONSTANT ; } return str . indexOf ( searchStr ) ; }
( start != strLen ) && ( stripChars . indexOf ( str . charAt ( start ) ) != - NUMBER_CONSTANT )
{ if ( str == null ) { return null ; } return CharSequenceUtils . reverse ( str ) . toString () ; }
char searchChar
char searchChar
char searchChar
char searchChar
char searchChar
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
Object [] args
Object [] args
String [] parsePatterns
String [] parsePatterns
String [] strs
CharSequence [] css
Boolean [] array
boolean [] array
char [] delimiters
char [] delimiters
char [] delimiters
char [] delimiters
Class < > [] parameterTypes
Class < > [] parameterTypes
Object [] args
Object [] args
String [] searchStrings
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( STRING_CONSTANT ) . floatValue () , NUMBER_CONSTANT ) ;
{ return reflectionCompare ( lhs , rhs , false , reflectUpToClass , null ) ; }
isAssignable ( midClass , superClass ) && isAssignable ( ( Type ) genericInterface , ( Type ) midClass )
listeners . fire () . propertyChange ( new PropertyChangeEvent ( this , STRING_CONSTANT , STRING_CONSTANT , property ) ) ;
{ Validate . notNull ( listener , STRING_CONSTANT ) ; listeners . add ( NUMBER_CONSTANT , listener ) ; }
{ final String [] array = ArrayUtilsTest . < String > toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . < String > toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtilsTest . toArrayPropagatingType () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
{ final String [] array = ArrayUtils . toArray () ; assertEquals ( NUMBER_CONSTANT , array.length ) ; }
assertEquals ( - NUMBER_CONSTANT , StringUtils . indexOfDifference ( null ) ) ;
String [] results = null ;
String [] results = null ;
assertEquals ( null , StringUtils . concatWith ( null , null ) ) ;
assertEquals ( null , StringUtils . concat ( null ) ) ;
{ DateUtils . parseDate ( dateStr , null ) ; fail () ; }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
return new StringBuilder ( annotationType == null ? null : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT )
{ return isAssignable ( cls , toClass , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
{ return isAssignable ( classArray , toClassArray , SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) ; }
boolean atLeastJava14 = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
{ return isJavaVersionMatch ( JAVA_VERSION_TRIMMED , versionPrefix ) ; }
if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( STRING_CONSTANT , new BigDecimal ( STRING_CONSTANT ) , NumberUtils . createNumber ( STRING_CONSTANT ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ;
{ if ( SystemUtils . isJavaVersionAtLeast ( NUMBER_CONSTANT ) ) { assertEquals ( message , expected , actual ) ; } }
static JavaVersion getJavaVersion ( final String nom ) { return getJavaVersion ( nom ) ; }
{ return ( options == null ) ? false : options . contains ( opt ) ; }
assertEquals ( true , StringUtils . isNumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlphanumeric ( STRING_CONSTANT ) ) ;
assertEquals ( true , StringUtils . isAlpha ( STRING_CONSTANT ) ) ;
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , locale ) ; }
{ return format ( date , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
{ return format ( new Date ( millis ) , pattern , DateUtils.UTC_TIME_ZONE , null ) ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair.right , pair.left ) ;
{ return isEquals () ; }
public Integer build () { return toHashCode () ; }
{ return toComparison () ; }
HashCodeBuilder . class
HashCodeBuilder . class
new StringBuilder ( strLen ) . append ( Character . toLowerCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
new StringBuilder ( strLen ) . append ( Character . toTitleCase ( cs . charAt ( NUMBER_CONSTANT ) ) ) . append ( CharSequenceUtils . subSequence ( cs , NUMBER_CONSTANT ) )
String cs
return sequenceToString ( str . subSequence ( start , end ) ) ;
return sequenceToString ( str . subSequence ( start , str . length () ) ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
String [] set
Object [] array
Class < > parameterTypes []
Class < > [] classes
Class < > [] classes
Class < > [] toClassArray
char [] chars
char [] chars
return types . toArray ( new Type [ NUMBER_CONSTANT ] ) ;
return frames . toArray ( new String [ NUMBER_CONSTANT ] ) ;
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
String [] searchStrs
String [] searchStrs
char [] searchChars
String [] strs
CharSequence input
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; }
( idx = indexOfSequence ( str , sub , idx ) ) != INDEX_NOT_FOUND
tmp = lastIndexOfSequence ( str , search , str . length () ) ;
tmp = indexOfSequence ( str , search , NUMBER_CONSTANT ) ;
{ if ( searchChars == null ) { return false ; } return containsAny ( cs , toCharArraySequence ( searchChars ) ) ; }
{ if ( regionMatchesSequence ( str , true , i , searchStr , NUMBER_CONSTANT , len ) ) { return true ; } }
return indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ;
{ if ( isEmpty ( seq ) ) { return false ; } return indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) >= NUMBER_CONSTANT ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchSeq , startPos ) ; }
return StringUtils . lastIndexOfSequence ( seq , searchSeq , seq . length () ) ;
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . lastIndexOfSequence ( seq , searchChar , seq . length () ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , startPos ) ; }
{ if ( seq == null || searchSeq == null ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchSeq , NUMBER_CONSTANT ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , startPos ) ; }
{ if ( isEmpty ( seq ) ) { return INDEX_NOT_FOUND ; } return StringUtils . indexOfSequence ( seq , searchChar , NUMBER_CONSTANT ) ; }
{ return value == NUMBER_CONSTANT ? false : true ; }
{ if ( bool == null ) { return valueIfNull ; } return bool . booleanValue () ? true : false ; }
{ if ( bool == null ) { return null ; } return ( bool . booleanValue () ? Boolean.FALSE : Boolean.TRUE ) ; }
if ( sunAvailable ) { result = removeAccentsSUN ( input ) ; } else { throw new UnsupportedOperationException ( STRING_CONSTANT + STRING_CONSTANT ) ; }
if ( lastWasGap ) { buf [ count ++ ] = ch ; lastWasGap = false ; } else {}
String [] excludeFields
{ return reflectionCompare ( lhs , rhs , compareTransients , null , null ) ; }
{ return reflectionCompare ( lhs , rhs , false , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( NUMBER_CONSTANT , NUMBER_CONSTANT , object , testTransients , null , null ) ; }
String [] excludeFields
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , testTransients , null , null ) ; }
{ return reflectionHashCode ( initialNonZeroOddNumber , multiplierNonZeroOddNumber , object , false , null , null ) ; }
String [] excludeFieldNames
String [] excludeFields
{ return reflectionEquals ( lhs , rhs , testTransients , null , null ) ; }
String [] excludeFields
{ this . excludeFieldNames = excludeFieldNamesParam . clone () ; Arrays . sort ( this . excludeFieldNames ) ; }
StringBuilder builder = new StringBuilder ( ClassUtils . getShortClassName ( this , null ) ) ;
char [] chars
@ Override public R getRightElement () { return rightElement ; }
@ Override public L getLeftElement () { return leftElement ; }
Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeftElement () , pair . getRightElement () ) ;
{ R result = getRightElement () ; setRightElement ( value ) ; return result ; }
public R getValue () { return getRightElement () ; }
public final L getKey () { return getLeftElement () ; }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return ( null ) ; } }
Calendar c = new GregorianCalendar ( mTimeZone ) ;
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ return getDateTimeInstance ( dateStyle , timeStyle , null , locale ) ; }
{ return getDateTimeInstance ( dateStyle , timeStyle , null , null ) ; }
{ return getTimeInstance ( style , timeZone , null ) ; }
{ return getTimeInstance ( style , null , locale ) ; }
{ return getTimeInstance ( style , null , null ) ; }
{ return getDateInstance ( style , timeZone , null ) ; }
{ return getDateInstance ( style , null , locale ) ; }
{ return getDateInstance ( style , null , null ) ; }
{ return getInstance ( pattern , null , locale ) ; }
{ return getInstance ( pattern , timeZone , null ) ; }
{ return getInstance ( pattern , null , null ) ; }
CharSequence _ellipsis = ObjectUtils . defaultIfNull ( ellipsis , STRING_CONSTANT ) ;
return padding ( pads , padChar ) . concat ( str ) ;
return str . concat ( padding ( pads , padChar ) ) ;
if ( inputLength == NUMBER_CONSTANT && repeat <= PAD_LIMIT ) { return padding ( repeat , str . charAt ( NUMBER_CONSTANT ) ) ; }
return pad ( pads , padChar ) . concat ( str ) ;
return str . concat ( pad ( pads , padChar ) ) ;
assertSame ( Locale.GERMANY , format1 . getLocale () ) ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count ; }
{ R result = getRight () ; setRightElement ( value ) ; return result ; }
{ if ( isSet ( OPTION.semiColonRequired ) ) { return NUMBER_CONSTANT ; } else if ( isSet ( OPTION.errorIfNoSemiColon ) ) { throw new RuntimeException ( STRING_CONSTANT ) ; } }
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
@ Override
@ Test ( expected = IllegalArgumentException . class )
@ Test ( expected = IllegalArgumentException . class )
if ( timeToLive < NUMBER_CONSTANT ) { throw new IllegalStateException ( STRING_CONSTANT + timeToLive + STRING_CONSTANT + text ) ; }
{ if ( StringUtils . isEmpty ( str ) ) { return null ; } return toCharacterObject ( str . charAt ( NUMBER_CONSTANT ) ) ; }
try { FieldUtils . writeField ( field , publicChild , new Integer ( Integer.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Integer val = new Integer ( NUMBER_CONSTANT ) ;
Integer val = new Integer ( NUMBER_CONSTANT ) ;
sb . appendln ( new Integer ( NUMBER_CONSTANT ) ) ;
iInteger = new Integer ( NUMBER_CONSTANT ) ;
Integer value = new Integer ( NUMBER_CONSTANT ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
coll . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( false , sb1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Integer ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , numA . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableInt ( new Integer ( NUMBER_CONSTANT ) ) . intValue () ) ;
assertEquals ( false , f1 . equals ( new Integer ( NUMBER_CONSTANT ) ) ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
Integer i = new Integer ( NUMBER_CONSTANT ) ;
DurationFormatUtils.Token numToken = new DurationFormatUtils.Token ( new Integer ( NUMBER_CONSTANT ) , NUMBER_CONSTANT ) ;
mutNum . subtract ( new Integer ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Integer ( NUMBER_CONSTANT ) ) ;
map . put ( STRING_CONSTANT , new Integer ( NUMBER_CONSTANT ) ) ;
public Integer getValue () { return new Integer ( this . value ) ; }
mutNum . subtract ( new Long ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Long ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Long ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Long ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableLong ( new Long ( NUMBER_CONSTANT ) ) . longValue () ) ;
public Long getValue () { return new Long ( this . value ) ; }
public Short getValue () { return new Short ( this . value ) ; }
mutNum . subtract ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
mutNum . add ( new Short ( ( short ) NUMBER_CONSTANT ) ) ;
{ if ( expression == false ) { throw new IllegalArgumentException ( String . format ( message , new Double ( value ) ) ) ; } }
public Float getValue () { return new Float ( this . value ) ; }
public Double getValue () { return new Double ( this . value ) ; }
try { FieldUtils . writeField ( field , publicChild , new Double ( Double.MAX_VALUE ) ) ; } catch ( IllegalAccessException e ) {}
Object [] args = new Object [] { new Double ( STRING_CONSTANT ) } ;
args = new Object [] { STRING_CONSTANT , cal . getTime () , new Double ( STRING_CONSTANT ) }
mutNum . subtract ( new Float ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Float ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Float ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Float ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableFloat ( new Float ( NUMBER_CONSTANT ) ) . floatValue () , NUMBER_CONSTANT ) ;
mutNum . subtract ( new Double ( NUMBER_CONSTANT ) ) ;
mutNum . add ( new Double ( NUMBER_CONSTANT ) ) ;
assertEquals ( true , mutNumA . hashCode () == new Double ( NUMBER_CONSTANT ) . hashCode () ) ;
assertEquals ( false , mutNumA . equals ( new Double ( NUMBER_CONSTANT ) ) ) ;
assertEquals ( NUMBER_CONSTANT , new MutableDouble ( new Double ( NUMBER_CONSTANT ) ) . doubleValue () , NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , new MutableObject < Double > ( new Double ( NUMBER_CONSTANT ) ) . toString () ) ;
{ throw new UnsupportedOperationException ( STRING_CONSTANT , new UnsupportedOperationException ( java6Exception ) ) ; }
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparatorPreserveAllTokens ( null , STRING_CONSTANT , - NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . splitByWholeSeparator ( null , STRING_CONSTANT ) ) ;
assertEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . split ( null ) ) ;
public synchronized void delete () { listField . removeFirstOccurrence ( Integer . valueOf ( random . nextInt ( N ) ) ) ; }
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = ( separator == null ? STRING_CONSTANT : separator ) ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
separator = separator == null ? STRING_CONSTANT : separator ;
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ ( bits > > > NUMBER_CONSTANT ) ) ; }
for ( E constant : values ) { total |= ( NUMBER_CONSTANT < < constant . ordinal () ) ; }
int remainder = ( len - pos ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT
assertEquals ( ( NUMBER_CONSTANT * NUMBER_CONSTANT ) * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( obj ) . toHashCode () ) ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
root = ( root == null ? th : root ) ;
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
dev = ( observed [ i ] - expected [ i ] ) ;
( pos + i ) >= len || chars [ pos + i ] != chars [ quoteStart + i ]
{ return ( options == null ) ? false : options . contains ( option ) ; }
return ( result != null ) ? result : value ;
{ return ( initializer != null ) ? initializer . get () : null ; }
{ return ( schedFuture != null ) ? schedFuture : super . startTimer () ; }
int d2 = ( tmodd1 == NUMBER_CONSTANT ) ? d1 : greatestCommonDivisor ( tmodd1 , d1 ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
long m = ( ( long ) x ) * ( ( long ) y ) ;
( power % NUMBER_CONSTANT ) == NUMBER_CONSTANT
{ return ( ( double ) numerator ) / ( ( double ) denominator ) ; }
{ return ( ( float ) numerator ) / ( ( float ) denominator ) ; }
{ return ( obj == null ) ? NUMBER_CONSTANT : obj . hashCode () ; }
if ( ( object1 == null ) || ( object2 == null ) ) { return false ; }
assertEquals ( bf_zero . setShortValue ( ( short ) NUMBER_CONSTANT , ( short ) j ) , ( short ) ( NUMBER_CONSTANT ) ) ;
if ( str == null || prefix == null ) { return ( str == null && prefix == null ) ; }
if ( allStringsNull || ( longestStrLen == NUMBER_CONSTANT && ! anyStringNull ) ) { return INDEX_NOT_FOUND ; }
if ( length >= str . length () || length < ( middle . length () + NUMBER_CONSTANT ) ) { return str ; }
int noOfItems = ( endIndex - startIndex ) ;
int noOfItems = ( endIndex - startIndex ) ;
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( match || ( preserveAllTokens && lastMatch ) ) { list . add ( str . substring ( start , i ) ) ; }
if ( ( separator == null ) || ( EMPTY . equals ( separator ) ) ) { return splitWorker ( str , null , max , preserveAllTokens ) ; }
pos < ( strLen - closeLen )
if ( pos == INDEX_NOT_FOUND || pos == ( str . length () - separator . length () ) ) { return EMPTY ; }
if ( str . length () <= ( pos + len ) ) { return str . substring ( pos ) ; }
return ( ret == Integer.MAX_VALUE ) ? INDEX_NOT_FOUND : ret ;
startPos > ( str . length () - searchStr . length () )
int endLimit = ( str . length () - searchStr . length () ) + NUMBER_CONSTANT ;
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
int delimLen = ( delimiters == null ? - NUMBER_CONSTANT : delimiters.length ) ;
( inputLineLength - offset ) > wrapLength
return super . equals ( o ) && ( b == rhs.b ) ;
return ( a == rhs.a ) ;
if ( cls == null ) { return ! ( toClass . isPrimitive () ) ; }
{ boolean b = ( ch >= CHAR_CONS && ch <= CHAR_CONS ) ; t += b ? NUMBER_CONSTANT : NUMBER_CONSTANT ; }
if ( coll == null || coll . size () == NUMBER_CONSTANT ) { return false ; }
assertTrue ( triple . getRight () ) ;
assertFalse ( triple . getRight () ) ;
assertEquals ( STRING_CONSTANT , flag , t . isDaemon () ) ;
triple2 = Triple . of ( null , STRING_CONSTANT , NUMBER_CONSTANT )
Object [] original = new Object [] { true , false } ;
fdf = getInstance ( STRING_CONSTANT ) ;
@ Override public Locale getLocale () { return mLocale ; }
@ Override public TimeZone getTimeZone () { return mTimeZone ; }
@ Override public String getPattern () { return mPattern ; }
@ Override public Locale getLocale () { return locale ; }
@ Override public TimeZone getTimeZone () { return timeZone ; }
@ Override public String getPattern () { return pattern ; }
DateFormatSymbols symbols = DateFormatSymbols . getInstance ( locale ) ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
validateNullToStringStyleRegistry () ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return STRING_CONSTANT ; }
if ( cls != null ) return cls ; else throw cnfe ;
public Locale getLocale () { return locale ; }
public TimeZone getTimeZone () { return timeZone ; }
public String getPattern () { return pattern ; }
public Locale getLocale () { return mLocale ; }
public TimeZone getTimeZone () { return mTimeZone ; }
public String getPattern () { return mPattern ; }
new Runnable () { public void run () { endOfPeriod () ; } }
public Object getValue () { return null ; }
public Locale getLocale ( ) ;
public Locale getLocale ( ) ;
@ Override
@ Override public void setUp ( ) throws Exception { exceptionContext = new DefaultExceptionContext () ; super . setUp () ; }
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( true , rangea . isNegated () ) ;
assertEquals ( false , rangea . isNegated () ) ;
assertEquals ( false , new BitField ( NUMBER_CONSTANT ) . isSet ( clearedBit ) ) ;
assertEquals ( true , hc2a != NUMBER_CONSTANT ) ;
assertEquals ( true , sb.buffer.length >= NUMBER_CONSTANT ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
assertEquals ( false , tok . hasNext () ) ;
@ Override public int hashCode () { return b * NUMBER_CONSTANT + t ; }
{ return parseDateWithLeniency ( str , parsePatterns , false ) ; }
{ return parseDateWithLeniency ( str , parsePatterns , true ) ; }
DateParser parser = getInstance ( STRING_CONSTANT , TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
DateFormatSymbols symbols = new DateFormatSymbols ( locale ) ;
if ( eraBC && format . equals ( SHORT_FORMAT ) && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
if ( year < NUMBER_CONSTANT && locale . toString () . equals ( STRING_CONSTANT ) ) { continue; }
assertEquals ( locale . toString () + STRING_CONSTANT + formattedDate , expectedTime , actualTime ) ;
Strategy strategy = cache . get ( field ) ;
{ return getInstance ( FormatCache . getPatternForStyle ( dateStyle , null , locale ) , TimeZone . getDefault () , Locale . getDefault () ) ; }
return ++ initializeCalls ;
return REPEAT ;
return initializeCalls ;
this . value instanceof StringBuffer
StringBuffer buffer = new StringBuffer () ;
StringBuffer expected = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer buffer = new StringBuffer () ;
StringBuffer result = new StringBuffer () ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
StringBuffer sb = new StringBuffer ( dstInit ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
throw new java.lang.IllegalArgumentException ( STRING_CONSTANT + nibble ) ;
HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( values.length ) ;
{ System.out . println ( STRING_CONSTANT ) ; }
{ System.out . println ( STRING_CONSTANT ) ; }
{ output = ( int [] ) removeAll ( array , toRemove ) ; }
return ( boolean [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( double [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( float [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( long [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( char [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( int [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( short [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
return ( byte [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) ) ;
result = ( T [] ) removeAll ( ( Object ) array , extractIndices ( toRemove ) )
{ return format ( new Date ( millis ) ) ; }
Calendar c = new GregorianCalendar ( mTimeZone , mLocale ) ;
{ if ( str == null ) { return null ; } return WHITESPACE_BLOCK . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
{ if ( str == null ) { return null ; } return WHITESPACE_PATTERN . matcher ( trim ( str ) ) . replaceAll ( STRING_CONSTANT ) ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
if ( isEmpty ( padStr ) ) { padStr = STRING_CONSTANT ; }
{ out . write ( STRING_CONSTANT + hex ( codepoint ) ) ; }
MutableDouble other
Object obj
Number operand
double operand
Number operand
double operand
Number value
double value
String value
Number value
double value
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
boolean [] array
Boolean [] array
float [] array
Float [] array
double [] array
Double [] array
byte [] array
Byte [] array
short [] array
Short [] array
int [] array
Integer [] array
long [] array
Long [] array
char [] array
Character [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
Object [] array
Object array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Boolean [] array
Float [] array
Double [] array
Byte [] array
Character [] array
Short [] array
Integer [] array
Long [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
String [] array
Object [] array
boolean [] array
float [] array
double [] array
byte [] array
char [] array
short [] array
int [] array
long [] array
T [] array
Object [] array
Object array
Object array
MutableByte other
Object obj
Number operand
byte operand
Number operand
byte operand
Number value
byte value
String value
Number value
byte value
Object obj
@ Override public char charAt ( int index ) { return seq . charAt ( index ) ; }
public CustomCharSequence ( CharSequence seq ) { this . seq = seq ; }
int codepoint
CharSequenceTranslator . . . translators
CharSequence input
@ Override public char charAt ( int arg0 ) { return value . charAt ( arg0 ) ; }
String value
MutableInt other
Object obj
Number operand
int operand
Number operand
int operand
Number value
int value
String value
Number value
int value
String msg
DateParser getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
boolean flag
BasicThreadFactory factory
Callable < T > call
Callable < T > call
DatePrinter getInstance ( String format ) { return getInstance ( format , TimeZone . getDefault () , Locale . getDefault () ) ; }
Formattable formattable
Collection < > coll
String language
char [] str
StrBuilder str
StringBuilder str
StringBuffer str
String str
String str
Throwable cause
String msg
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
Boolean . . . array
boolean . . . array
boolean bool
boolean bool
boolean bool
Boolean bool
Boolean bool
Boolean bool
String str
String str
Boolean bool
boolean bool
boolean bool
Integer value
int value
int value
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Boolean bool
Object obj2
Object value
String format
long durationMillis
long durationMillis
boolean expression
T iterable
T [] array
T chars
T chars
T map
T collection
T [] array
T object
boolean expression
int nibble
int nibble
boolean [] src
boolean [] src
boolean [] src
char hexDigit
char hexDigit
char hexDigit
char hexDigit
ObjectStreamClass desc
byte [] objectData
InputStream inputStream
Serializable obj
T object
char ch
char ch
char ch
char ch
char ch
char ch
char ch
char ch
Character ch
char ch
Character ch
char ch
Character ch
char ch
String str
Character ch
String str
char ch
Class < > clazz
String . . . excludeFieldNamesParam
boolean appendTransients
boolean appendStatics
Object array
Field field
Class < > clazz
Field field
Object object
Object [] array
Collection < String > collection
Object object
R right
M middle
L left
Throwable cause
@ Override public boolean cancel ( boolean mayInterruptIfRunning ) { return false ; }
T value
T value
ConcurrentInitializer < T > initializer
ConcurrentInitializer < T > initializer
ExecutionException ex
Throwable ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
ExecutionException ex
OPTION option
OPTION . . . options
JavaVersion requiredVersion
String property
String osNamePrefix
String versionPrefix
CollectionHolder ( T collection ) { this . collection = collection ; }
String replaceTemplate
public void testTwo ( ChildInterface obj ) {}
public void testTwo ( GrandParentObject obj ) {}
public void testTwo ( Object obj ) {}
public void testOne ( ParentObject obj ) {}
public void testOne ( GrandParentObject obj ) {}
public void testOne ( Object obj ) {}
Class < > c
Class < > [] c
@ Override public void setValue ( Object value ) {}
public void oneParameter ( String s ) {}
public String foo ( Object o ) { return STRING_CONSTANT ; }
public String foo ( String s ) { return STRING_CONSTANT ; }
public String foo ( double d ) { return STRING_CONSTANT ; }
public String foo ( Integer i ) { return STRING_CONSTANT ; }
public String foo ( int i ) { return STRING_CONSTANT ; }
public static String bar ( Object o ) { return STRING_CONSTANT ; }
public static String bar ( String s ) { return STRING_CONSTANT ; }
public static String bar ( Integer i ) { return STRING_CONSTANT ; }
String canonicalName
Class < > cls
String canonicalName
Class < > cls
Object . . . array
String className
Class < > cls
Class < > . . . classes
Class < > cls
Class < > . . . classes
Class < > cls
Class < > type
Class < > type
boolean autoboxing
List < Class < > > classes
List < String > classNames
HashSet < Class < > > interfacesFound
Class < > cls
Class < > cls
Class < > cls
Class < > cls
Class < > cls
int superHashCode
short [] array
short value
Object [] array
Object object
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object value
Object value
Object value
String summaryObjectEndText
String summaryObjectStartText
String sizeEndText
String sizeStartText
String nullText
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
String fieldSeparator
String fieldNameValueSeparator
String contentEnd
String contentStart
String arraySeparator
String arrayEnd
String arrayStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
String format
Object obj
Pair < L , R > other
void warn ( String msg ) { System.err . println ( msg ) ; }
BitSet coll
HashSet < Integer > coll
int count
int count
int count
int count
int count
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj ) ; }
public void setObjectReference ( TestObjectReference reference ) { this . reference = reference ; }
public TestObjectReference ( int one ) { this . one = new TestObject ( one ) ; }
Object o
public TestBCanEqualA ( int b ) { this . b = b ; }
Object o
public TestACanEqualB ( int a ) { this . a = a ; }
boolean testTransients
public void setT ( int t ) { this . t = t ; }
public void setB ( int b ) { this . b = b ; }
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
String name
boolean enableSubstitutionInVariables
StrLookup < > variableResolver
String suffix
char suffix
StrMatcher suffixMatcher
String prefix
char prefix
StrMatcher prefixMatcher
char escapeCharacter
StrBuilder source
StringBuffer source
Object source
StrBuilder source
StringBuffer source
char [] source
String source
StrLookup < > variableResolver
Map < String , V > valueMap
Object source
boolean isEquals
boolean superEquals
String toString
String superToString
Object object
short [] array
short value
Object [] array
Object obj
long [] array
long value
int [] array
int value
float [] array
float value
double [] array
double value
char [] array
char value
byte [] array
byte value
boolean [] array
boolean value
Object object
Object object
Object object
ToStringStyle style
MutableFloat other
Object obj
Number operand
float operand
Number operand
float operand
Number value
float value
String value
Number value
float value
int limit
JavaVersion requiredVersion
Object obj
char ch
String str
String . . . set
String . . . setStrs
Object obj
@ Override public Date parse ( String source ) throws ParseException { return parser . parse ( source ) ; }
Calendar calendar
Date date
long millis
int style
int style
String pattern
String str
char [] cbuf
int c
@ Override public void mark ( int readAheadLimit ) { mark = pos ; }
int index
int startIndex
Object obj
StrBuilder other
StrBuilder other
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
StrMatcher matcher
String str
char ch
int length
int length
int length
int startIndex
int start
String str
String str
StrMatcher matcher
StrMatcher matcher
String str
String str
char ch
char ch
int startIndex
boolean value
int index
char separator
String separator
Iterator < > it
Iterable < > iterable
Object [] array
Iterator < > it
Iterable < > iterable
T . . . array
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
Object obj
double value
float value
long value
int value
char ch
boolean value
char [] chars
StrBuilder str
StringBuilder str
StringBuffer str
String str
CharSequence seq
Object obj
int startIndex
int index
int index
int capacity
int length
String newLine
String str
private void readObject ( ObjectInputStream in ) throws ClassNotFoundException { throw new ClassNotFoundException ( SerializationUtilsTest.CLASS_NOT_FOUND_MESSAGE ) ; }
{ @ Override public void write ( int arg0 ) throws IOException { throw new IOException ( SERIALIZE_IO_EXCEPTION_MESSAGE ) ; } }
String baseMessage
String label
String label
Throwable cause
String message
MutableShort other
Object obj
Number operand
short operand
Number operand
short operand
Number value
short value
String value
Number value
short value
String str
String str
Object array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
float [] array
double [] array
byte [] array
short [] array
int [] array
long [] array
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
String str
Field field
String languageCode
String countryCode
Locale locale
Locale locale
String baseMessage
String label
String label
Throwable cause
String message
ObjectInputStream objectInputStream
ObjectOutputStream objectOutputStream
L listener
L listener
Class < L > listenerInterface
Class < T > listenerInterface
protected String toUtf16Escape ( int codepoint ) { return STRING_CONSTANT + hex ( codepoint ) ; }
int codepoint
int codepoint
public NestableException ( Throwable t ) { super ( t ) ; }
public void setCause ( Throwable cause ) { this . cause = cause ; }
public ExceptionWithCause ( Throwable cause ) { super(); setCause ( cause ) ; }
String [] eventTypes
void warn ( String msg ) { System.err . println ( msg ) ; }
private void assertSupportedEncoding ( String name ) { assertTrue ( STRING_CONSTANT + name , CharEncoding . isSupported ( name ) ) ; }
public AClass ( AAClass < String > enclosingInstance ) { enclosingInstance . super ( ) ; }
public InspectingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
public MutatingClient ( TestFixture testFixture ) { this . testFixture = testFixture ; }
String [] strings
MutableBoolean other
Object obj
Boolean value
boolean value
Boolean value
boolean value
CharRange r
Object obj
CharRange range
char ch
char ch
char ch
boolean negated
Throwable th
Throwable th
Throwable t
String stackTrace
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
Throwable throwable
int codepoint
int codepoint
int codepoint
StrTokenizer tokenizer
StrTokenizer tokenizer
String data
StrTokenizer tokenizer
int loopCount
int loopCount
int loopCount
public static void main ( String [] args ) { new CharUtilsPerfRun () . run () ; }
MutableLong other
Object obj
Number operand
long operand
Number operand
long operand
Number value
long value
String value
Number value
long value
Object obj
T obj
Object other
Object _value
T . . . items
T . . . items
T . . . values
T . . . values
Object obj
Object object
Object . . . objects
Object obj
T . . . values
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue % NUMBER_CONSTANT ; }
@ Override int modify ( int iValue ) { return iValue - NUMBER_CONSTANT ; }
Locale locale
int modify ( int iValue ) { return iValue ; }
NumberStrategy ( int field ) { this . field = field ; }
CopyQuotedStrategy ( String formatField ) { this . formatField = formatField ; }
int field
Calendar definingCalendar
int twoDigitYear
String source
@ Override public Object parseObject ( String source ) throws ParseException { return parse ( source ) ; }
ObjectInputStream in
Object obj
byte holder
short holder
int holder
byte holder
short holder
int holder
int holder
int holder
short holder
int holder
short holder
int holder
int mask
Annotation a
java.lang.Class < > cls
String formattedDate
String input
boolean ignoreEmptyTokens
boolean emptyAsNull
StrMatcher trimmer
char ignored
StrMatcher ignored
char quote
StrMatcher quote
String delim
char delim
StrMatcher delim
List < String > list
String obj
String obj
char [] input
String input
char [] input
String input
char [] input
String input
char [] input
String input
int codepoint
int codepoint
CollectionHolder ( T collection ) { this . collection = collection ; }
Object obj
T value
T value
CharSequence [] . . . lookup
R value
int unit
Date date
Object o
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
R value
R right
L left
String toString
String toString
String toString
Type type
Type type
ParameterizedType parameterizedType
WildcardType wildcardType
WildcardType wildcardType
TypeVariable < > typeVariable
Type [] bounds
ParameterizedType type
c = new Comparable () { @ Override public int compareTo ( Object other ) { return NUMBER_CONSTANT ; } }
Constructor < T > ctor
Class < T > cls
Class < T > cls
Class < T > cls
Class < T > cls
String str
String str
String str
char . . . delimiters
String str
String str
CharSequenceTranslator . . . translators
String [] [] array
boolean testTransients
boolean testTransients
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
Class < E > enumClass
CharSequence cs
String val
String str
String str
String str
String str
String str
String str
float [] array
double [] array
float [] array
double [] array
String str
CharMatcher ( char ch ) { super(); this . ch = ch ; }
char chars []
String str
String chars
char . . . chars
char ch
String name
String name
String name
String name
String name
ExecutorService exec
String format
Object obj
Range < T > other
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
Range < T > otherRange
T element
T element
T element
T element
T element
T element
T element
String str
int threshold
String . . . strs
CharSequence . . . css
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
String str
String str
String str
String str
String str
int size
CharSequence cs
String str
String str
String str
String str
T . . . elements
String str
String str
String str
String str
String str
String str
CharSequence seq
String input
String . . . strs
String stripChars
String str
String str
String str
String str
String str
CharSequence cs
CharSequence cs
CharSequence cs
CharSequence cs
String format
Object obj
ExecutorService exec
ExecutorService execDestroy
ExecutorService externalExecutor
ExecutorService exec
Throwable cause
Class < > c
Class < > [] c
public TestBean ( Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( String s ) { toString = STRING_CONSTANT ; }
public TestBean ( double d ) { toString = STRING_CONSTANT ; }
public TestBean ( Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( int i ) { toString = STRING_CONSTANT ; }
public SimpleReflectionTestFixture ( Object o ) { this . o = o ; }
Object o
Collection < > coll
ParsePosition pos
String desc
Object obj
String pattern
String pattern
Object obj
Object . . . keys
String pattern
int count
int count
int count
int count
int count
int superCompareTo
Fraction other
Object obj
Fraction fraction
Fraction fraction
Fraction fraction
Fraction fraction
int power
public BackgroundInitializerTestImpl ( ExecutorService exec ) { super ( exec ) ; }
BackgroundInitializerTestImpl init
boolean fieldSeparatorAtEnd
boolean fieldSeparatorAtStart
boolean arrayContentDetail
boolean defaultFullDetail
boolean useFieldNames
boolean useIdentityHashCode
boolean useShortClassName
boolean useClassName
Class < > cls
Boolean fullDetailRequest
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
StringBuffer buffer
Object value
Object value
Object value
Object o
TestObject rhs
public void setA ( int a ) { this . a = a ; }
Object o
public TestObject ( int a ) { this . a = a ; }
private void assertGetClassThrowsClassNotFound ( String className ) throws Exception { assertGetClassThrowsException ( className , ClassNotFoundException . class ) ; }
private void assertGetClassThrowsNullPointerException ( String className ) throws Exception { assertGetClassThrowsException ( className , NullPointerException . class ) ; }
Class < > c
public void removePropertyChangeListener ( PropertyChangeListener listener ) { listeners . removeListener ( listener ) ; }
public void addPropertyChangeListener ( PropertyChangeListener listener ) { listeners . addListener ( listener ) ; }
protected void addVetoableChangeListener ( VetoableChangeListener listener ) {}
String property
public void addPropertyChangeListener ( PropertyChangeListener listener ) { throw new RuntimeException () ; }
public void addMultipleEventListener ( MultipleEventListener listener ) { listeners . addListener ( listener ) ; }
String eventName
Class < L > listenerType
public void eventOccurred ( PropertyChangeEvent e ) { count ++ ; }
new PropertyChangeListener () { @ Override public void propertyChange ( PropertyChangeEvent e ) {} }
Object obj
boolean colon
NumberRule rule
NumberRule rule
TwoDigitNumberField ( int field ) { mField = field ; }
UnpaddedNumberField ( int field ) { mField = field ; }
String value
CharacterLiteral ( char value ) { mValue = value ; }
ObjectInputStream in
Object obj
Calendar calendar
Date date
Calendar c
long millis
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { calledListeners . add ( this ) ; } }
{ @ Override public void vetoableChange ( PropertyChangeEvent e ) { listenerSupport . removeListener ( this ) ; } }
listenerSupport . addListener ( new VetoableChangeListener () { @ Override public void vetoableChange ( PropertyChangeEvent e ) {} } ) ;
String key
Map < String , V > map
Map < String , V > map
String baseMessage
String label
String label
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
String input
boolean [] src
Class < > destClass
Member m
int modifiers
AccessibleObject o
Thread.UncaughtExceptionHandler handler
int prio
boolean f
String pattern
ThreadFactory factory
Thread t
Runnable r
Builder builder
{ for ( String s : strings ) { if ( StringUtils . isNotEmpty ( s ) ) { return false ; } } }
long total = System . currentTimeMillis () - start ;
char c = Character . forDigit ( nibble , NUMBER_CONSTANT ) ;
{ try { return cloneReset () ; } catch ( CloneNotSupportedException ex ) { return null ; } }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getTSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
{ StrTokenizer tok = getCSVClone () ; tok . reset ( input ) ; return tok ; }
IDKey idKey = ( IDKey ) other ;
catch ( InterruptedException iex ) { Thread . currentThread () . interrupt () ; }
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
int index = indexOf ( array , element ) ;
Boolean b = array [ i ] ;
Float b = array [ i ] ;
Double b = array [ i ] ;
Byte b = array [ i ] ;
Short b = array [ i ] ;
Integer b = array [ i ] ;
Long b = array [ i ] ;
Character b = array [ i ] ;
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
CharSequence tmp = s ;
int smallestIndexOfDiff = indexOfDifference ( strs ) ;
int at = indexOfDifference ( str1 , str2 ) ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int sz = cs . length () ;
int pads = size - str . length () ;
int pads = size - str . length () ;
char [] chars = str . toCharArray () ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . lastIndexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int pos = str . indexOf ( separator ) ;
int strLen = seq . length () ;
{ String ts = trim ( str ) ; return isEmpty ( ts ) ? null : ts ; }
short anotherVal = other.value ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
MutableLong mutNum = new MutableLong ( NUMBER_CONSTANT ) ;
ScheduledThreadPoolExecutor s = new ScheduledThreadPoolExecutor ( THREAD_POOL_SIZE ) ;
StringBuilder canonicalClassNameBuffer = new StringBuilder ( className ) ;
int i = className . lastIndexOf ( PACKAGE_SEPARATOR_CHAR ) ;
for ( Object name : coll ) { if ( name != null ) { return true ; } }
char [] buffer = pattern . toCharArray () ;
ExtendedMessageFormat rhs = ( ExtendedMessageFormat ) obj ;
String toString = AnnotationUtils . toString ( testAnno ) ;
byte anotherVal = other.value ;
{ boolean anotherVal = other.value ; return value == anotherVal ? NUMBER_CONSTANT : ( value ? NUMBER_CONSTANT : - NUMBER_CONSTANT ) ; }
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
Date lastTruncateDate = dateTimeParser . parse ( STRING_CONSTANT ) ;
OctalUnescaper oue = new OctalUnescaper () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
ToStringStyle style = new ToStringStyleImpl () ;
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
EqualsBuilder equalsBuilder = new EqualsBuilder () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
String str = f . toProperString () ;
String str = f . toString () ;
try { f1 . compareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException ex ) {}
try { f = f . abs () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
try { f = f . negate () ; fail ( STRING_CONSTANT ) ; } catch ( ArithmeticException ex ) {}
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
MutableInt mutNum = new MutableInt ( NUMBER_CONSTANT ) ;
{ ExecutorService exec = Executors . newSingleThreadExecutor () ; new CallableBackgroundInitializer < Integer > ( null , exec ) ; }
StrTokenizer tkn = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer ( STRING_CONSTANT ) ;
StrTokenizer tok = new StrTokenizer () ;
String input = STRING_CONSTANT ;
try { tokenizer . next () ; fail () ; } catch ( NoSuchElementException ex ) {}
{ float anotherVal = other.value ; return Float . compare ( value , anotherVal ) ; }
int len = chars.length ;
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . isException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getException ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getResultObject ( STRING_CONSTANT ) ; }
{ MultiBackgroundInitializer.MultiBackgroundInitializerResults res = checkInitialize () ; res . getInitializer ( STRING_CONSTANT ) ; }
catch ( IllegalStateException istex ) { initializer . get () ; }
ExecutorService exec = Executors . newCachedThreadPool () ;
MultiBackgroundInitializer.MultiBackgroundInitializerResults res = initializer . get () ;
Object item = array [ i ] ;
for ( char delimiter : delimiters ) { if ( ch == delimiter ) { return true ; } }
for ( BackgroundInitializer < > bi : childInitializers . values () ) { result += bi . getTaskCount () ; }
Integer i = Integer . valueOf ( NUMBER_CONSTANT ) ;
long millisPerUnit = getMillisPerUnit ( unit ) ;
Calendar calendar = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
Calendar gval = Calendar . getInstance () ;
{ Calendar c = Calendar . getInstance () ; c . setTime ( date ) ; return c ; }
Calendar c = Calendar . getInstance () ;
Calendar c = Calendar . getInstance () ;
try { result = neu . translate ( input ) ; fail ( STRING_CONSTANT ) ; } catch ( IllegalArgumentException iae ) {}
NumericEntityUnescaper neu = new NumericEntityUnescaper () ;
{ DateParser parser = getInstance ( yMdHmsSZ , REYKJAVIK ) ; assertEquals ( REYKJAVIK , parser . getTimeZone () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ , SWEDEN ) ; assertEquals ( SWEDEN , parser . getLocale () ) ; }
{ DateParser parser = getInstance ( yMdHmsSZ ) ; assertEquals ( yMdHmsSZ , parser . getPattern () ) ; }
{ DateParser parser = getInstance ( YMD_SLASH ) ; assertTrue ( parser . toString () . startsWith ( STRING_CONSTANT ) ) ; }
Calendar cal = Calendar . getInstance () ;
int gmt = msg . indexOf ( STRING_CONSTANT ) ;
Object object = getObject () ;
int part1 = name . hashCode () * NUMBER_CONSTANT ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
MutableDouble mutNum = new MutableDouble ( NUMBER_CONSTANT ) ;
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
{ BasicThreadFactory factory = new BasicThreadFactory ( this ) ; reset () ; return factory ; }
{ try { return getAccessibleConstructor ( cls . getConstructor ( parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
CustomCharSequence other = ( CustomCharSequence ) obj ;
{ BasicThreadFactory factory = builder . build () ; checkFactoryDefaults ( factory ) ; }
StrLookup < > resolver = getVariableResolver () ;
StrBuilder buf = new StrBuilder ( NUMBER_CONSTANT ) ;
StrBuilder buf = new StrBuilder ( source ) ;
int sz = cs . length () ;
int sz = cs . length () ;
T value
T value
StringBuffer buffer = new StringBuffer () ;
{ for ( Object object : objects ) { hash = hash * NUMBER_CONSTANT + ObjectUtils . hashCode ( object ) ; } }
if ( values != null ) { for ( T val : values ) { if ( val != null ) { return val ; } } }
StrBuilder buf = new StrBuilder () ;
StrSubstitutor sub = new StrSubstitutor () ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
{ StrSubstitutor sub = new StrSubstitutor () ; assertEquals ( STRING_CONSTANT , sub . replace ( STRING_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ; }
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
StrSubstitutor sub = new StrSubstitutor ( values ) ;
FastDateFormat other = ( FastDateFormat ) obj ;
Object obj = map . get ( key ) ;
catch ( NoSuchMethodException e ) {}
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
String src = STRING_CONSTANT ;
{ for ( short element : array ) { append ( element ) ; } }
{ for ( Object element : array ) { append ( element ) ; } }
{ for ( long element : array ) { append ( element ) ; } }
{ for ( int element : array ) { append ( element ) ; } }
{ for ( float element : array ) { append ( element ) ; } }
{ for ( double element : array ) { append ( element ) ; } }
{ for ( char element : array ) { append ( element ) ; } }
{ for ( byte element : array ) { append ( element ) ; } }
{ for ( boolean element : array ) { append ( element ) ; } }
Object key
CompareToBuilder compareToBuilder = new CompareToBuilder () ;
Type rawType = parameterizedType . getRawType () ;
Type replacementType = typeVarAssigns . get ( type ) ;
Type bound
catch ( Exception e ) { assertTrue ( exceptionType . isAssignableFrom ( e . getClass () ) ) ; }
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
boolean autoboxing = SystemUtils . isJavaVersionAtLeast ( JAVA_1_5 ) ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
{ R result = getRight () ; setRight ( value ) ; return result ; }
int properNumerator = getProperNumerator () ;
Fraction other = ( Fraction ) obj ;
Fraction f = this . multiplyBy ( this ) ;
int gcd = greatestCommonDivisor ( numerator , denominator ) ;
E value
E constant
try { return Enum . valueOf ( enumClass , enumName ) ; } catch ( IllegalArgumentException ex ) { return null ; }
try { Enum . valueOf ( enumClass , enumName ) ; return true ; } catch ( IllegalArgumentException ex ) { return false ; }
TimeZoneDisplayKey other = ( TimeZoneDisplayKey ) obj ;
TimeZone zone = calendar . getTimeZone () ;
{ int len = mValues [ i ] . length () ; if ( len > max ) { max = len ; } }
FastDatePrinter other = ( FastDatePrinter ) obj ;
{ for ( Rule rule : mRules ) { rule . appendTo ( buf , calendar ) ; } return buf ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRules ( c , buf ) ; }
{ Calendar c = newCalendar () ; c . setTime ( date ) ; return applyRulesToString ( c ) ; }
{ Calendar c = newCalendar () ; c . setTimeInMillis ( millis ) ; return applyRulesToString ( c ) ; }
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . stringMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charSetMatcher ( STRING_CONSTANT ) ;
StrMatcher matcher = StrMatcher . charMatcher ( CHAR_CONS ) ;
StrMatcher matcher = StrMatcher . noneMatcher () ;
StrMatcher matcher = StrMatcher . quoteMatcher () ;
StrMatcher matcher = StrMatcher . doubleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . singleQuoteMatcher () ;
StrMatcher matcher = StrMatcher . trimMatcher () ;
StrMatcher matcher = StrMatcher . splitMatcher () ;
StrMatcher matcher = StrMatcher . spaceMatcher () ;
StrMatcher matcher = StrMatcher . tabMatcher () ;
StrMatcher matcher = StrMatcher . commaMatcher () ;
String oldValue = this . property ;
{ Integer count = eventCounts . get ( eventName ) ; return count == null ? NUMBER_CONSTANT : count . intValue () ; }
catch ( RuntimeException e ) {}
char pad = CHAR_CONS ;
Token tok2 = ( Token ) obj2 ;
int sz = tokens.length ;
String str = super . getContent () ;
char buf [] = buffer ;
int strLen = str . length () ;
char [] thisBuf = buffer ;
char [] thisBuf = buffer ;
int len = str . length () ;
int len = str . length () ;
char [] buf = buffer ;
int newSize = size - removeLen + insertLen ;
int len = endIndex - startIndex ;
int len = chars.length ;
{ if ( iterable != null ) { for ( Object o : iterable ) { append ( o ) ; } } return this ; }
{ for ( Object element : array ) { append ( element ) ; } }
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
int len = length () ;
char [] old = buffer ;
char [] old = buffer ;
for ( String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
FastDateParser other = ( FastDateParser ) obj ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.YEAR ) ;
long testResult = DateUtils . getFragmentInHours ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInHours ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MONTH ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MONTH ) ;
long expectedValue = hours ;
long expectedValue = hours ;
{ long testResult = DateUtils . getFragmentInMinutes ( aCalendar , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
{ long testResult = DateUtils . getFragmentInMinutes ( aDate , Calendar.HOUR_OF_DAY ) ; assertEquals ( minutes , testResult ) ; }
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.HOUR_OF_DAY ) ;
long testResult = DateUtils . getFragmentInSeconds ( aCalendar , Calendar.MINUTE ) ;
{ long testResult = DateUtils . getFragmentInSeconds ( aDate , Calendar.MINUTE ) ; assertEquals ( seconds , testResult ) ; }
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.MINUTE ) ;
long testResult = DateUtils . getFragmentInMilliseconds ( aCalendar , Calendar.SECOND ) ;
{ long testResult = DateUtils . getFragmentInMilliseconds ( aDate , Calendar.SECOND ) ; assertEquals ( millis , testResult ) ; }
CharRange rangea = CharRange . isNot ( CHAR_CONS ) ;
CharRange rangea = CharRange . is ( CHAR_CONS ) ;
boolean element
for ( boolean element : array ) { if ( element ) { return true ; } }
for ( boolean element : array ) { if ( ! element ) { return false ; } }
try { intRange . elementCompareTo ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
{ String str = intRange . toString ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , str ) ; }
String str = intRange . toString () ;
{ DatePrinter printer = getInstance ( YYYY_MM_DD , NEW_YORK ) ; assertEquals ( NEW_YORK , printer . getTimeZone () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD , SWEDEN ) ; assertEquals ( SWEDEN , printer . getLocale () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertEquals ( YYYY_MM_DD , printer . getPattern () ) ; }
{ DatePrinter printer = getInstance ( YYYY_MM_DD ) ; assertTrue ( printer . toString () . startsWith ( STRING_CONSTANT ) ) ; }
try { NumberUtils . createNumber ( STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; } catch ( NumberFormatException nfe ) {}
String osName = System . getProperty ( STRING_CONSTANT ) ;
String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
File dir = SystemUtils . getUserHome () ;
File dir = SystemUtils . getUserDir () ;
File dir = SystemUtils . getJavaIoTmpDir () ;
File dir = SystemUtils . getJavaHome () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertFalse ( STRING_CONSTANT , init . isStarted () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . get () ; }
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ;
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; assertNull ( STRING_CONSTANT , init . getActiveExecutor () ) ; }
{ BackgroundInitializerTestImpl init = new BackgroundInitializerTestImpl () ; init . start () ; checkInitialize ( init ) ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( IllegalArgumentException ex ) {}
try { CharUtils . toChar ( ( Character ) null ) ; } catch ( IllegalArgumentException ex ) {}
{ double anotherVal = other.value ; return Double . compare ( value , anotherVal ) ; }
{ long bits = Double . doubleToLongBits ( value ) ; return ( int ) ( bits ^ bits > > > NUMBER_CONSTANT ) ; }
String o1 = STRING_CONSTANT ;
String o1 = STRING_CONSTANT ;
{ TestObject o1 = new TestObject ( NUMBER_CONSTANT ) ; CompareToBuilder . reflectionCompare ( o1 , null ) ; }
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
long anotherVal = other.value ;
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
{ Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
catch ( NullPointerException ex ) {}
StringBuffer buf = new StringBuffer ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ; assertEquals ( STRING_CONSTANT , sb . toString () ) ; }
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
catch ( IndexOutOfBoundsException ex ) {}
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
StrBuilder sb = new StrBuilder () ;
{ for ( L listener : listeners ) { method . invoke ( listener , args ) ; } return null ; }
BitSet toRemove = new BitSet () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Locale dflt = Locale . getDefault () ;
Calendar testCalendar = Calendar . getInstance () ;
try { DateUtils . toCalendar ( null ) ; fail ( STRING_CONSTANT ) ; } catch ( NullPointerException npe ) {}
GregorianCalendar cal = new GregorianCalendar () ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
Date base = new Date ( MILLIS_TEST ) ;
catch ( IllegalArgumentException ex ) {}
catch ( IllegalArgumentException ex ) {}
{ try { return parentClass . getMethod ( methodName , parameterTypes ) ; } catch ( NoSuchMethodException e ) { return null ; } }
{ try { return getAccessibleMethod ( cls . getMethod ( methodName , parameterTypes ) ) ; } catch ( NoSuchMethodException e ) { return null ; } }
try { return Charset . isSupported ( name ) ; } catch ( IllegalCharsetNameException ex ) { return false ; }
catch ( SerializationException ex ) { return; }
{ Object test = SerializationUtils . clone ( null ) ; assertNull ( test ) ; }
try { SerializationUtils . deserialize ( new byte [ NUMBER_CONSTANT ] ) ; } catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( byte [] ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
catch ( SerializationException ex ) { return; }
catch ( SerializationException ex ) { return; }
try { SerializationUtils . deserialize ( ( InputStream ) null ) ; } catch ( IllegalArgumentException ex ) { return; }
{ try { SerializationUtils . serialize ( null , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
{ try { SerializationUtils . serialize ( iMap , null ) ; } catch ( IllegalArgumentException ex ) { return; } fail () ; }
Exception ex = new Exception () ;
catch ( IllegalStateException e ) {}
Object obj = new Object () ;
TestSubObject rhs = ( TestSubObject ) o ;
TestObject rhs = ( TestObject ) o ;
MessageFormat result = new MessageFormat ( pattern ) ;
for ( Locale locale : locales ) { checkBuiltInFormat ( pattern , registry , args , locale ) ; }
CharSet other = ( CharSet ) obj ;
{ for ( CharRange range : set ) { if ( range . contains ( ch ) ) { return true ; } } return false ; }
int sz = set.length ;
{ try { throw new ExceptionWithoutCause () ; } catch ( Throwable t ) { return t ; } }
try { mutNum . compareTo ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { mutNum . setValue ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
try { new MutableShort ( ( Number ) null ) ; fail () ; } catch ( NullPointerException ex ) {}
catch ( IllegalArgumentException expected ) {}
char cur = current ;
StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
CharRange other = ( CharRange ) obj ;
if ( start > end ) { char temp = start ; start = end ; end = temp ; }
catch ( SecurityException ex ) { System.err . println ( STRING_CONSTANT + property + STRING_CONSTANT ) ; return null ; }
catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
V value = map . get ( key ) ;
try { return initialize ( initializer ) ; } catch ( ConcurrentException cex ) { throw new ConcurrentRuntimeException ( cex . getCause () ) ; }
{ ConcurrentRuntimeException crex = extractCauseUnchecked ( ex ) ; if ( crex != null ) { throw crex ; } }
{ ConcurrentException cex = extractCause ( ex ) ; if ( cex != null ) { throw cex ; } }
{ ByteArrayOutputStream baos = new ByteArrayOutputStream ( NUMBER_CONSTANT ) ; serialize ( obj , baos ) ; return baos . toByteArray () ; }
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException e ) { assertEquals ( STRING_CONSTANT , e . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
catch ( IllegalArgumentException ex ) { assertEquals ( STRING_CONSTANT , ex . getMessage () ) ; }
Person p = new Person () ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
MutableFloat mutNum = new MutableFloat ( NUMBER_CONSTANT ) ;
{ Object [] array = null ; assertEquals ( NUMBER_CONSTANT , ObjectUtils . hashCodeMulti ( array ) ) ; }
int anotherVal = other.value ;
InheritedReflectionStaticFieldsFixture instance1 = new InheritedReflectionStaticFieldsFixture () ;
ReflectionStaticFieldsFixture instance1 = new ReflectionStaticFieldsFixture () ;
SimpleReflectionStaticFieldsFixture instance1 = new SimpleReflectionStaticFieldsFixture () ;
SelfInstanceTwoVarsReflectionTestFixture test = new SelfInstanceTwoVarsReflectionTestFixture () ;
SelfInstanceVarReflectionTestFixture test = new SelfInstanceVarReflectionTestFixture () ;
SimpleReflectionTestFixture simple = new SimpleReflectionTestFixture () ;
Outer outer = new Outer () ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
String baseStr = this . toBaseString ( array ) ;
Character c = new Character ( CHAR_CONS ) ;
{ try { coll . add ( null ) ; fail () ; } catch ( UnsupportedOperationException ex ) {} }
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( localeString ) ;
Locale locale = LocaleUtils . toLocale ( language ) ;
IllegalArgumentException ex
long seed = System . currentTimeMillis () ;
long seed = System . currentTimeMillis () ;
String message = exceptionContext . getMessage () ;
String trace = ExceptionUtils . getStackTrace ( exceptionContext ) ;
try { return Short . parseShort ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Byte . parseByte ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Double . parseDouble ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Float . parseFloat ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Long . parseLong ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
try { return Integer . parseInt ( str ) ; } catch ( NumberFormatException nfe ) { return defaultValue ; }
int start = index + NUMBER_CONSTANT ;
try { StrLookup . systemPropertiesLookup () . lookup ( null ) ; fail () ; } catch ( NullPointerException ex ) {}
{ final BigDecimal value = NumberUtils . createBigDecimal ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final BigInteger value = NumberUtils . createBigInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Long value = NumberUtils . createLong ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Integer value = NumberUtils . createInteger ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Double value = NumberUtils . createDouble ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ final Float value = NumberUtils . createFloat ( str ) ; fail ( STRING_CONSTANT + value ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( null , style , null , locale ) ; }
{ return cache . getDateTimeInstance ( null , style , null , null ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , timeZone , null ) ; }
{ return cache . getDateTimeInstance ( style , null , null , locale ) ; }
{ return cache . getDateTimeInstance ( style , null , null , null ) ; }
return org.apache.commons.lang3.SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} ) ;
exceptionContext = new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () ) ;
Strategy strategy = cache . get ( Integer . valueOf ( field ) ) ;
if ( nullText != null && nullText . length () == NUMBER_CONSTANT ) { nullText = null ; }
if ( str . length () == NUMBER_CONSTANT ) { return ArrayUtils.EMPTY_STRING_ARRAY ; }
if ( separator . length () == NUMBER_CONSTANT ) { return EMPTY ; }
return str . length () == NUMBER_CONSTANT ? null : str ;
if ( str . length () == NUMBER_CONSTANT || deepEmpty ( set ) ) { return StringUtils.EMPTY ; }
final Integer max = TypeUtilsTest . stub () ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
assertTrue ( empty != result ) ;
new ContextedRuntimeException ( TEST_MESSAGE_2 , new Exception ( TEST_MESSAGE ) , new DefaultExceptionContext () {} )
{ if ( this . runningState == STATE_UNSTARTED ) { throw new IllegalStateException ( STRING_CONSTANT ) ; } return this . startTimeMillis ; }
if ( this . splitState != STATE_SPLIT ) { throw new IllegalStateException ( STRING_CONSTANT ) ; }
{ return new GenericArrayTypeImpl ( componentType ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readDeclaredField ( ( Object ) null , STRING_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild , true ) ; fail ( STRING_CONSTANT ) ; }
{ FieldUtils . readField ( ( Field ) null , publicChild ) ; fail ( STRING_CONSTANT ) ; }
assertEquals ( null , LocaleUtils . toLocale ( ( String ) null ) ) ;
final Iterable < E > values
final Iterable < E > values
{ return new FastDateParser ( format , timeZone , locale ) ; }
assertEquals ( null , StringUtils . normalizeSpace ( null ) ) ;
assertEquals ( null , StringUtils . difference ( null , null ) ) ;
assertEquals ( null , StringUtils . abbreviate ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . reverseDelimited ( null , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . reverse ( null ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . leftPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . rightPad ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . repeat ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , StringUtils . replaceChars ( null , CHAR_CONS , CHAR_CONS ) ) ;
assertEquals ( null , StringUtils . deleteWhitespace ( null ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . splitPreserveAllTokens ( null ) ) ;
assertArrayEquals ( null , StringUtils . split ( null , CHAR_CONS ) ) ;
assertArrayEquals ( null , StringUtils . split ( null ) ) ;
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
assertEquals ( minutes + ( ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_MINUTE , testResult )
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( ( minutes * DateUtils.MILLIS_PER_MINUTE ) + ( hours * DateUtils.MILLIS_PER_HOUR ) + ( days * DateUtils.MILLIS_PER_DAY ) ) / DateUtils.MILLIS_PER_SECOND
( days * DateUtils.MILLIS_PER_DAY )
( days * DateUtils.MILLIS_PER_DAY )
assertEquals ( null , StringUtils . swapCase ( null ) ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
DiffList list = class1 . diff ( class2 ) ;
final Class context
final Class context
list0 = new ArrayList < Object > ( Arrays . asList () )
assertEquals ( STRING_CONSTANT , StringUtils . join () ) ;
return readField ( field , target ) ;
return readField ( field , target ) ;
writeField ( field , target , value ) ;
writeField ( field , target , value ) ;
writeField ( field , ( Object ) null , value ) ;
writeStaticField ( field , value ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toShort ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toDouble ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toFloat ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toLong ( ( String ) null ) == NUMBER_CONSTANT ) ;
assertTrue ( STRING_CONSTANT , NumberUtils . toInt ( ( String ) null ) == NUMBER_CONSTANT ) ;
{ return new DiffResult ( lhs , rhs , diffs , style ) ; }
{ super ( message , cause ) ; }
public NotImplementedException ( final Throwable cause ) { super ( cause ) ; }
{ super ( message ) ; }
return input . length () ;
{ pos += Character . charCount ( Character . codePointAt ( input , pt ) ) ; }
Date centuryStart
{ return getFragment ( calendar , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( calendar , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( calendar , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( calendar , fragment , Calendar.SECOND ) ; }
{ return getFragment ( calendar , fragment , Calendar.MILLISECOND ) ; }
{ return getFragment ( date , fragment , Calendar.DAY_OF_YEAR ) ; }
{ return getFragment ( date , fragment , Calendar.HOUR_OF_DAY ) ; }
{ return getFragment ( date , fragment , Calendar.MINUTE ) ; }
{ return getFragment ( date , fragment , Calendar.SECOND ) ; }
{ return getFragment ( date , fragment , Calendar.MILLISECOND ) ; }
return - NUMBER_CONSTANT ;
final Integer iVal = keyValues . get ( value ) ;
regex . append ( CHAR_CONS ) ;
final Integer iVal = lKeyValues . get ( value . toLowerCase () ) ;
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new TextStrategy ( field , definingCalendar , locale ) ;
for ( final String textKeyValue : keyValues . keySet () ) { sb . append ( textKeyValue ) . append ( CHAR_CONS ) ; }
for ( final String textKeyValue : keyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + srcPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
shift = i * NUMBER_CONSTANT + dstPos ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
StrBuilder sb = new StrBuilder ( STRING_CONSTANT ) ;
Interfaces interfacesBehavior
String [] zone
{ int trial = century + twoDigitYear ; return twoDigitYear >= startYear ? trial : trial + NUMBER_CONSTANT ; }
Calendar definingCalendar
SimpleClass obj
public SimpleClass ( boolean booleanField ) { this . booleanField = booleanField ; }
{ String pattern = STRING_CONSTANT ; FastDateFormat . getInstance ( pattern ) ; }
protected BooleanDiff ( String fieldName ) { super ( fieldName ) ; }
{ for ( Token token : tokens ) { if ( token . getValue () == value ) { return true ; } } return false ; }
Field field
Class < > cls
StringBuilder sb = new StringBuilder () ;
StringBuilder sb = new StringBuilder () ;
{ int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
GenericArrayType g
WildcardType w
ParameterizedType p
TypeVariable < > v
Class < > c
TypeVariable < > var
Type type
Object obj
Object obj
Object obj
Type componentType
Type . . . bounds
Type . . . bounds
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , Double.MAX_VALUE ) ;
float result = RandomUtils . nextFloat ( NUMBER_CONSTANT , Float.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , Long.MAX_VALUE ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , Integer.MAX_VALUE ) ;
long result = RandomUtils . nextLong ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextFloat ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
double result = RandomUtils . nextDouble ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
int result = RandomUtils . nextInt ( NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
@ Override public void consume ( String t ) { super . consume ( t ) ; }
@ Override public void consume ( T t ) {}
Calendar c = Calendar . getInstance () ;
Method m
Method m
char ch
char ch
Object obj
StringBuilder source
CharSequence source
T value
String fieldName
TypeTestClass class1 = new TypeTestClass () ;
@ Override public boolean equals ( Object obj ) { return EqualsBuilder . reflectionEquals ( this , obj , false ) ; }
TypeTestClass obj
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
char firstChar = str . charAt ( NUMBER_CONSTANT ) ;
CharSequence . . . css
CharSequence . . . css
Locale locale
Locale locale
Locale locale
String [] element
String [] element
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . endsWith ( string , searchString ) ) { return true ; } }
for ( final CharSequence searchString : searchStrings ) { if ( StringUtils . startsWith ( string , searchString ) ) { return true ; } }
{ return StringUtils . isEmpty ( str ) ? defaultStr : str ; }
{ return StringUtils . isBlank ( str ) ? defaultStr : str ; }
{ return ! StringUtils . isBlank ( cs ) ; }
{ return ! StringUtils . isEmpty ( cs ) ; }
{ return isDigits ( StringUtils . replaceOnce ( StringUtils . substring ( str , NUMBER_CONSTANT ) , STRING_CONSTANT , StringUtils.EMPTY ) ) ; }
modify ( ceiled , field , MODIFY_CEILING ) ;
modify ( gval , field , MODIFY_CEILING ) ;
modify ( truncated , field , MODIFY_TRUNCATE ) ;
modify ( gval , field , MODIFY_TRUNCATE ) ;
modify ( rounded , field , MODIFY_ROUND ) ;
modify ( gval , field , MODIFY_ROUND ) ;
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
class Named extends Object {}
{ type = array . getClass () ; }
appendQuotedString ( pattern , pos , sb , false ) ;
getQuotedString ( pattern , pos , false ) ;
appendQuotedString ( pattern , pos , stripCustom , true ) ;
{ regex . append ( PATTERN ) ; return true ; }
{ if ( value < NUMBER_CONSTANT ) { appendDigits ( buffer , value ) ; } else { buffer . append ( Integer . toString ( value ) ) ; } }
exec . awaitTermination ( Long.MAX_VALUE , TimeUnit.MILLISECONDS ) ;
{ System.out . println ( STRING_CONSTANT + osName ) ; }
return osName . startsWith ( osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
return isOSNameMatch ( osName , osNamePrefix ) && osVersion . startsWith ( osVersionPrefix ) ;
{ fail ( STRING_CONSTANT + osName ) ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return array == null || array.length == NUMBER_CONSTANT ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
{ return ( array != null && array.length != NUMBER_CONSTANT ) ; }
final int halflength = ( shorter . length () / NUMBER_CONSTANT ) + NUMBER_CONSTANT ;
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( field . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
( f . getName () . indexOf ( CHAR_CONS ) == - NUMBER_CONSTANT )
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = ( lhs == rhs ) ; return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } return append ( Float . floatToIntBits ( lhs ) , Float . floatToIntBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } return append ( Double . doubleToLongBits ( lhs ) , Double . doubleToLongBits ( rhs ) ) ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = lhs == rhs ; return this ; }
if ( isEquals == false ) { return this ; }
{ if ( isEquals == false ) { return this ; } isEquals = superEquals ; return this ; }
modType == ModifyType.CEILING || ( modType == ModifyType.ROUND && roundUp )
{ result = DateUtils . setMilliseconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setSeconds ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMinutes ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setHours ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setDays ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
{ result = DateUtils . setMonths ( BASE_DATE , NUMBER_CONSTANT ) ; fail ( STRING_CONSTANT ) ; }
try { date = DateUtils . parseDateStrictly ( dateStr , parsers ) ; fail () ; } catch ( final ParseException ex ) {}
{ regex . append ( validTimeZoneChars ) ; return true ; }
{ regex . append ( VALID_TZ ) ; return true ; }
{ regex . append ( validTimeZoneChars ) ; return true ; }
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
expected . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
cal . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
c . set ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ;
{ this ( pattern , timeZone , locale , null ) ; }
text = DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . format ( cal ) ;
{ return applyRules ( calendar , buf ) ; }
final String actualValue = FastDateFormat . getInstance ( PATTERN ) . format ( cal ) ;
if ( tokenLen == NUMBER_CONSTANT ) { rule = TimeZoneNumberRule.INSTANCE_ISO_8601 ; } else { rule = TimeZoneNumberRule.INSTANCE_COLON ; }
if ( ! threadGroup . isDestroyed () ) threadGroup . destroy () ;
this . typeArguments = typeArguments ;
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
super ( object , style , buffer ) ;
{ super ( object , style , buffer ) ; }
{ super ( object , style ) ; }
{ super ( object ) ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final Thread thread ) { return true ; }
@ Override public boolean test ( @ SuppressWarnings ( STRING_CONSTANT ) final ThreadGroup threadGroup ) { return true ; }
if ( threadGroups . isEmpty () ) { return Collections.EMPTY_LIST ; }
tz = tzNames . get ( value ) ;
{ regex . append ( VALID_TZ ) ; return true ; }
for ( final String textKeyValue : lKeyValues . keySet () ) { escapeRegex ( regex , textKeyValue , false ) . append ( CHAR_CONS ) ; }
@ SuppressWarnings ( STRING_CONSTANT ) final Map < String , String > propertiesMap = ( Map ) properties ;
ISO8601TimeZoneStrategy ( String pattern ) { this . pattern = pattern ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
{ this ( pattern , timeZone , locale , null , true ) ; }
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final String systemNewLine = System . getProperty ( STRING_CONSTANT ) ;
final DateParser fdp = FastDateFormat . getInstance ( STRING_CONSTANT , kst , Locale.KOREA ) ;
{ return applyRules ( c , new StringBuffer ( mMaxLengthEstimate ) ) . toString () ; }
assertTrue ( BooleanUtils . toBoolean ( new StringBuffer ( STRING_CONSTANT ) . append ( STRING_CONSTANT ) . toString () ) ) ;
final char newChar = Character . toUpperCase ( firstChar ) ;
{ try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . rethrow ( e ) ; } }
if ( count == NUMBER_CONSTANT ) { return STRING_CONSTANT ; } else if ( count < NUMBER_CONSTANT ) { throw new IllegalArgumentException ( STRING_CONSTANT + count + STRING_CONSTANT ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( STRING_CONSTANT ) ;
return new StringBuilder ( annotationType == null ? STRING_CONSTANT : annotationType . getName () ) . insert ( NUMBER_CONSTANT , CHAR_CONS ) . toString () ;
{ if ( summaryObjectEndText == null ) { summaryObjectEndText = STRING_CONSTANT ; } this . summaryObjectEndText = summaryObjectEndText ; }
{ if ( summaryObjectStartText == null ) { summaryObjectStartText = STRING_CONSTANT ; } this . summaryObjectStartText = summaryObjectStartText ; }
{ if ( sizeEndText == null ) { sizeEndText = STRING_CONSTANT ; } this . sizeEndText = sizeEndText ; }
{ if ( sizeStartText == null ) { sizeStartText = STRING_CONSTANT ; } this . sizeStartText = sizeStartText ; }
{ if ( nullText == null ) { nullText = STRING_CONSTANT ; } this . nullText = nullText ; }
{ if ( fieldSeparator == null ) { fieldSeparator = STRING_CONSTANT ; } this . fieldSeparator = fieldSeparator ; }
{ if ( fieldNameValueSeparator == null ) { fieldNameValueSeparator = STRING_CONSTANT ; } this . fieldNameValueSeparator = fieldNameValueSeparator ; }
{ if ( contentEnd == null ) { contentEnd = STRING_CONSTANT ; } this . contentEnd = contentEnd ; }
{ if ( contentStart == null ) { contentStart = STRING_CONSTANT ; } this . contentStart = contentStart ; }
{ if ( arraySeparator == null ) { arraySeparator = STRING_CONSTANT ; } this . arraySeparator = arraySeparator ; }
{ if ( arrayEnd == null ) { arrayEnd = STRING_CONSTANT ; } this . arrayEnd = arrayEnd ; }
{ if ( arrayStart == null ) { arrayStart = STRING_CONSTANT ; } this . arrayStart = arrayStart ; }
{ return obj == null ? STRING_CONSTANT : obj . toString () ; }
if ( pos >= count ) { addToken ( tokenList , STRING_CONSTANT ) ; }
if ( delimiters != null && delimiters.length == NUMBER_CONSTANT ) { return STRING_CONSTANT ; }
if ( th == null ) { return STRING_CONSTANT ; }
if ( locale . getCountry () . length () > NUMBER_CONSTANT ) { list . add ( new Locale ( locale . getLanguage () , STRING_CONSTANT ) ) ; }
if ( length <= NUMBER_CONSTANT || index >= size ) { return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
{ return STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
if ( str == null ) { str = STRING_CONSTANT ; }
appendDisplayNames ( definingCalendar , locale , field , regex , lKeyValues ) ;
{ return parseDateWithLeniency ( str , null , parsePatterns , false ) ; }
public TestBean ( final Object o ) { toString = STRING_CONSTANT ; }
public TestBean ( final String s ) { toString = STRING_CONSTANT ; }
public TestBean ( final double d ) { toString = STRING_CONSTANT ; }
public TestBean ( final Integer i ) { toString = STRING_CONSTANT ; }
public TestBean ( final int i ) { toString = STRING_CONSTANT ; }
public TestBean () { toString = STRING_CONSTANT ; }
{ return ( boolean [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( double [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( float [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( long [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( char [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( int [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( short [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( byte [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ return ( T [] ) removeAll ( ( Object ) array , clone ( indices ) ) ; }
{ assertEquals ( str , toString ) ; assertEquals ( args , varArgs ) ; }
{ return getCause ( throwable , CAUSE_METHOD_NAMES ) ; }
assertEquals ( STRING_CONSTANT , JAVA_1_9 , get ( STRING_CONSTANT ) ) ;
if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_8 ; } else if ( STRING_CONSTANT . equals ( nom ) ) { return JAVA_1_9 ; }
strategy = field == Calendar.ZONE_OFFSET ? new TimeZoneStrategy ( definingCalendar , locale ) : new CaseInsensitiveTextStrategy ( field , definingCalendar , locale ) ;
final boolean isValid = NumberUtils . isNumber ( val ) ;
if ( srcArgs.length < normalArgsLen ) return Float.MAX_VALUE ;
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
if ( lhs.length != rhs.length ) { comparison = ( lhs.length < rhs.length ) ? - NUMBER_CONSTANT : + NUMBER_CONSTANT ; return this ; }
final boolean hasSign = ( firstChar == CHAR_CONS || firstChar == CHAR_CONS ) ;
final String javaVersion = System . getProperty ( STRING_CONSTANT ) ;
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
if ( ArrayUtils . isEmpty ( css ) ) { return true ; }
{ return new ImmutablePair < L , R > ( left , right ) ; }
final Set < Locale > jdkLocaleSet = new HashSet < Locale > ( jdkLocaleList ) ;
final List < Field > allFieldsInteger = new ArrayList < Field > ( fieldsInteger ) ;
final CallableBackgroundInitializer < Integer > init = new CallableBackgroundInitializer < Integer > ( call ) ;
{ new CallableBackgroundInitializer < Object > ( null ) ; }
tasks = new ArrayList < Callable < Integer > > ()
this . diffs = new ArrayList < Diff < > > () ;
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > frames = new ArrayList < String > () ;
final List < Throwable > list = new ArrayList < Throwable > () ;
typeVarAssigns = new HashMap < TypeVariable < > , Type > ()
final List < Field > annotatedFields = new ArrayList < Field > () ;
final List < Field > allFields = new ArrayList < Field > () ;
final Map < String , E > map = new LinkedHashMap < String , E > () ;
final List < String > tokenList = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > ( tokens.length ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final Set < > set = Collections . unmodifiableSet ( new HashSet < Object > () ) ;
final List < Class < > > list = new ArrayList < Class < > > () ;
final List < String > list = new ArrayList < String > () ;
{ return new ConstantFuture < T > ( value ) ; }
{ return new MapStrLookup < V > ( map ) ; }
final HashMap < Boolean , MutableInt > occurrences = new HashMap < Boolean , MutableInt > ( NUMBER_CONSTANT ) ;
final HashMap < Double , MutableInt > occurrences = new HashMap < Double , MutableInt > ( values.length ) ;
final HashMap < Float , MutableInt > occurrences = new HashMap < Float , MutableInt > ( values.length ) ;
final HashMap < Long , MutableInt > occurrences = new HashMap < Long , MutableInt > ( values.length ) ;
final HashMap < Character , MutableInt > occurrences = new HashMap < Character , MutableInt > ( values.length ) ;
final HashMap < Integer , MutableInt > occurrences = new HashMap < Integer , MutableInt > ( values.length ) ;
final HashMap < Short , MutableInt > occurrences = new HashMap < Short , MutableInt > ( values.length ) ;
final Map < Byte , MutableInt > occurrences = new HashMap < Byte , MutableInt > ( values.length ) ;
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( values.length ) ;
final AtomicReference < InterruptedException > iex = new AtomicReference < InterruptedException > () ;
{ return new MutablePair < L , R > ( left , right ) ; }
if ( m == null ) { REGISTRY . set ( new WeakHashMap < Object , Object > () ) ; }
countries = new ArrayList < Locale > () ;
langs = new ArrayList < Locale > () ;
final List < Locale > list = new ArrayList < Locale > ( NUMBER_CONSTANT ) ;
final Set < Type > types = new HashSet < Type > ( bounds.length ) ;
{ priorVariables = new ArrayList < String > () ; priorVariables . add ( new String ( chars , offset , length ) ) ; }
final Map < String , String > valueMap = new HashMap < String , String > () ;
final Map < String , Object > map = new HashMap < String , Object > () ;
final Set < String > labels = new HashSet < String > () ;
final List < Object > values = new ArrayList < Object > () ;
{ contextValues . add ( new ImmutablePair < String , Object > ( label , value ) ) ; return this ; }
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
final ConcurrentMap < String , Integer > map = new ConcurrentHashMap < String , Integer > () ;
iMap = new HashMap < Object , Object > () ;
this . listeners = new CopyOnWriteArrayList < L > ( srcListeners ) ;
final ArrayList < L > serializableListeners = new ArrayList < L > () ;
{ return new EventListenerSupport < T > ( listenerInterface ) ; }
final List < VetoableChangeListener > calledListeners = new ArrayList < VetoableChangeListener > () ;
final List < Class < > > candidateClasses = new ArrayList < Class < > > () ;
final List < String > classNames = new ArrayList < String > ( classes . size () ) ;
final List < Class < > > classes = new ArrayList < Class < > > () ;
final HashMap < Integer , String > map = new HashMap < Integer , String > () ;
{ expectedSource = source ; changedValues = new ArrayList < Boolean > () ; }
final List < Object > list = new ArrayList < Object > () ;
final List < String > list = new ArrayList < String > ( array.length ) ;
final List < Method > annotatedMethods = new ArrayList < Method > () ;
final Set < Method > result = new LinkedHashSet < Method > () ;
this . eventTypes = new HashSet < String > ( Arrays . asList ( eventTypes ) ) ;
if ( registry == null ) { registry = new HashSet < IDKey > () ; REGISTRY . set ( registry ) ; }
final MutableObject < String > obj = new MutableObject < String > ( replaceTemplate ) ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
final Map < String , String > map = new HashMap < String , String > () ;
values = new HashMap < String , String > () ;
final HashMap < T , MutableInt > occurrences = new HashMap < T , MutableInt > ( items.length ) ;
final TreeSet < T > sort = new TreeSet < T > ( comparator ) ;
final TreeSet < T > sort = new TreeSet < T > () ;
final List < ThreadGroup > result = new ArrayList < ThreadGroup > ( count ) ;
final List < Thread > result = new ArrayList < Thread > ( count ) ;
final Collection < Thread > result = new ArrayList < Thread > () ;
{ return new ImmutablePair < L , R > ( left , right ) ; }
final Map < DateParser , Integer > map = new HashMap < DateParser , Integer > () ;
final Set < String > sorted = new TreeSet < String > ( LONGER_FIRST_LOWERCASE ) ;
{ caches [ field ] = new ConcurrentHashMap < Locale , Strategy > ( NUMBER_CONSTANT ) ; }
patterns = new ArrayList < StrategyAndWidth > () ;
final HashSet < Locale > testLocales = new HashSet < Locale > () ;
final String s = new ConstantInitializer < Object > ( null ) . toString () ;
checkEquals ( new ConstantInitializer < String > ( STRING_CONSTANT ) , false ) ;
@ Before public void setUp ( ) throws Exception { init = new ConstantInitializer < Integer > ( VALUE ) ; }
triple = new MutableTriple < Integer , String , Boolean > ()
pair = new MutablePair < Integer , String > ( NUMBER_CONSTANT , STRING_CONSTANT )
final MutablePair < Integer , String > pair = new MutablePair < Integer , String > () ;
{ return new Range < T > ( fromInclusive , toInclusive , comparator ) ; }
tasks = new ArrayList < Callable < Integer > > ()
List < TimeZone > timeZones = new ArrayList < TimeZone > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final ArrayList < String > substrings = new ArrayList < String > () ;
final List < String > list = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final List < String > excludeList = new ArrayList < String > () ;
final Collection < String > coll = new ArrayList < String > () ;
final Collection < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final List < String > coll = new ArrayList < String > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Map < String , Integer > map = new HashMap < String , Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
final Collection < Integer > coll = new ArrayList < Integer > () ;
final List < Rule > rules = new ArrayList < Rule > () ;
public CircuitBreakingException ( Throwable cause ) { super ( cause ) ; }
public CircuitBreakingException ( String message ) { super ( message ) ; }
public Customer ( String name ) { this . name = name ; }
public Bank ( String name ) { this . name = name ; }
Object object
Object object
FastDateParser parser
FastDateParser parser
FastDateParser parser
@ Override int modify ( FastDateParser parser , final int iValue ) { return iValue - NUMBER_CONSTANT ; }
int tokenLen
ISO8601TimeZoneStrategy ( String pattern ) { createPattern ( pattern ) ; }
FastDateParser parser
FastDateParser parser
void createPattern ( String regex ) { this . pattern = Pattern . compile ( regex ) ; }
void createPattern ( StringBuilder regex ) { createPattern ( regex . toString () ) ; }
char c
char c
ListIterator < StrategyAndWidth > lt
public FastDatePrinterTimeZonesTest ( TimeZone timeZone ) { this . timeZone = timeZone ; }
int . . . args
String . . . s
class LANG1261ParentObject { @ Override public boolean equals ( Object o ) { return true ; } }
Method method
SystemDefaults defaults
SystemDefaults defaults
int len
Constructor < > constructor
Method method
private static Executable of ( Constructor < > constructor ) { return new Executable ( constructor ) ; }
private static Executable of ( Method method ) { return new Executable ( method ) ; }
Number . . . args
String . . . args
Number . . . args
String . . . args
public static String numOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String numOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( String . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Object . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Number . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Long . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Integer . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Double . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Float . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Boolean . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Short . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Character . . . args ) { return STRING_CONSTANT ; }
public static String varOverload ( Byte . . . args ) { return STRING_CONSTANT ; }
public int [] unboxing ( int . . . values ) { return values ; }
PropertyChangeListener listener
PropertyChangeListener listener
State newState
State state
Boolean . . . values
PropertyChangeEvent evt
Object source
long time
TimeZone tz
String valueAsString
String valueAsString
int spaces
Long increment
long threshold
boolean [] array
char [] array
byte [] array
short [] array
long [] array
int [] array
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
int offset
TimeZone tz
int tokenLen
int value
Object obj
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getClosingInterval () ; }
@ Override protected long fetchCheckInterval ( EventCountCircuitBreaker breaker ) { return breaker . getOpeningInterval () ; }
int delta
State state
State newState
int increment
Integer increment
private NotVisibleException ( Throwable cause ) { this . cause = cause ; }
boolean allowDuplicate
Calendar calendar
Calendar calendar
Class < ? extends Throwable > type
Throwable throwable
Throwable throwable
Throwable throwable
String key
long nanos
int max
StringBuilder decomposed
int maxWidth
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
{ ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( zeroThreshold ) ; assertTrue ( STRING_CONSTANT , circuit . incrementAndCheckState ( NUMBER_CONSTANT ) ) ; }
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
ThresholdCircuitBreaker circuit = new ThresholdCircuitBreaker ( threshold ) ;
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
catch ( UnsupportedOperationException e ) {}
long randomResult = RandomUtils . nextLong () ;
float randomResult = RandomUtils . nextFloat () ;
double randomResult = RandomUtils . nextDouble () ;
int randomResult = RandomUtils . nextInt () ;
float result = mutableFloat . addAndGet ( NUMBER_CONSTANT ) ;
float result = mutableFloat . getAndAdd ( NUMBER_CONSTANT ) ;
float result = mutNum . getAndDecrement () ;
float result = mutNum . decrementAndGet () ;
float result = mutNum . getAndIncrement () ;
float result = mutNum . incrementAndGet () ;
Calendar cal = Calendar . getInstance () ;
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , TestThrowable . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , IOException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , RuntimeException . class ) ) ; }
catch ( Throwable t ) { Assert . assertTrue ( ExceptionUtils . hasCause ( t , Error . class ) ) ; }
try { throw new IOException () ; } catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
byte result = mutNum . getAndDecrement () ;
byte result = mutNum . decrementAndGet () ;
byte result = mutNum . getAndIncrement () ;
byte result = mutNum . incrementAndGet () ;
short result = mutNum . getAndDecrement () ;
short result = mutNum . decrementAndGet () ;
short result = mutNum . getAndIncrement () ;
short result = mutNum . incrementAndGet () ;
double result = mutableDouble . addAndGet ( - NUMBER_CONSTANT ) ;
double result = mutableDouble . getAndAdd ( NUMBER_CONSTANT ) ;
double result = mutNum . getAndDecrement () ;
double result = mutNum . decrementAndGet () ;
double result = mutNum . getAndIncrement () ;
double result = mutNum . incrementAndGet () ;
StringBuilder sb = new StringBuilder () ;
int result = mutNum . getAndDecrement () ;
int result = mutNum . decrementAndGet () ;
int result = mutNum . getAndIncrement () ;
int result = mutNum . incrementAndGet () ;
catch ( IllegalAccessException e ) { return null ; }
catch ( Exception e ) { return ExceptionUtils . < Integer > rethrow ( e ) ; }
catch ( Exception e ) { return ExceptionUtils . < Boolean > rethrow ( e ) ; }
Format fdf = FastDateFormat . getInstance ( pattern ) ;
{ StateStrategy strategy = STRATEGY_MAP . get ( state ) ; return strategy ; }
long time = now () ;
catch ( InterruptedException iex ) {}
StringBuilder regex = new StringBuilder () ;
int sIdx = idx + pos . getIndex () ;
char c = value . charAt ( i ) ;
ParsePosition pp = new ParsePosition ( NUMBER_CONSTANT ) ;
char c = pattern . charAt ( currentIdx ) ;
{ int last = value ; this . value += operand . intValue () ; return last ; }
{ int last = value ; this . value += operand ; return last ; }
{ int last = value ; value -- ; return last ; }
{ int last = value ; value ++ ; return last ; }
{ short last = value ; this . value += operand . shortValue () ; return last ; }
{ short last = value ; this . value += operand ; return last ; }
{ short last = value ; value -- ; return last ; }
{ short last = value ; value ++ ; return last ; }
{ long last = value ; this . value += operand . longValue () ; return last ; }
{ long last = value ; this . value += operand ; return last ; }
{ long last = value ; value -- ; return last ; }
{ long last = value ; value ++ ; return last ; }
Calendar calendar = Calendar . getInstance () ;
Calendar cal = Calendar . getInstance ( SWEDEN ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
{ float last = value ; this . value += operand . floatValue () ; return last ; }
{ float last = value ; this . value += operand ; return last ; }
{ float last = value ; value -- ; return last ; }
{ float last = value ; value ++ ; return last ; }
ExecutorService exec = Executors . newSingleThreadExecutor () ;
Locale save = Locale . getDefault () ;
TimeZone save = TimeZone . getDefault () ;
{ String date = STRING_CONSTANT ; DateFormatUtils.ISO_DATETIME_TIME_ZONE_FORMAT . parse ( date ) ; }
String encoding = STRING_CONSTANT ;
String methodStr = m . toString () ;
long result = mutNum . getAndDecrement () ;
long result = mutNum . decrementAndGet () ;
long result = mutNum . getAndIncrement () ;
long result = mutNum . incrementAndGet () ;
Exception ex
StringBuilder sb = new StringBuilder ( NUMBER_CONSTANT ) ;
int lastHold = start ;
int value = calendar . get ( Calendar.DAY_OF_WEEK ) ;
catch ( IOException ioe ) { ExceptionUtils . rethrow ( ioe ) ; }
StringBuilder sb = new StringBuilder () ;
for ( CharSequence searchCharSequence : searchCharSequences ) { if ( contains ( cs , searchCharSequence ) ) { return true ; } }
{ for ( CharSequence next : searchStrings ) { if ( equalsIgnoreCase ( string , next ) ) { return true ; } } }
{ for ( CharSequence next : searchStrings ) { if ( equals ( string , next ) ) { return true ; } } }
{ try { return System . getProperty ( key ) ; } catch ( SecurityException scex ) {} }
int [] clonedIndices = clone ( indices ) ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
int n_offset = n - offset ;
short aux = array [ offset1 ] ;
Object aux = array [ offset1 ] ;
long aux = array [ offset1 ] ;
int aux = array [ offset1 ] ;
float aux = array [ offset1 ] ;
double aux = array [ offset1 ] ;
char aux = array [ offset1 ] ;
byte aux = array [ offset1 ] ;
boolean aux = array [ offset1 ] ;
{ StopWatch sw = new StopWatch () ; sw . start () ; return sw ; }
Pattern patternToWrapOn = Pattern . compile ( wrapOn ) ;
TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ double balance = NUMBER_CONSTANT ; for ( Transaction tx : transactions ) { balance += tx.amount ; } return balance ; }
Calendar calendar = Calendar . getInstance () ;
DateParser parser = getInstance ( YMD_SLASH ) ;
Calendar cal = Calendar . getInstance ( tz ) ;
{ byte last = value ; this . value += operand . byteValue () ; return last ; }
{ byte last = value ; this . value += operand ; return last ; }
{ byte last = value ; value -- ; return last ; }
{ byte last = value ; value ++ ; return last ; }
{ double last = value ; this . value += operand . doubleValue () ; return last ; }
{ double last = value ; this . value += operand ; return last ; }
{ double last = value ; value -- ; return last ; }
{ double last = value ; value ++ ; return last ; }
Diff < > diff
methodName . equals ( method . getName () ) && ArrayUtils . isEquals ( parameterTypes , method . getParameterTypes () )
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
Memoizer < Integer , Integer > memoizer = new Memoizer < Integer , Integer > ( computable ) ;
if ( ! isEquals ) return this ;
final StrategyParser fm = new StrategyParser ( pattern , definingCalendar ) ;
public void setCycle ( TestRecursiveCycleObject cycle ) { this . cycle = cycle ; }
public TestRecursiveCycleObject ( int n ) { this . n = n ; this . cycle = this ; }
public TestRecursiveInnerObject ( int n ) { this . n = n ; }
int offset
boolean testRecursive
String . . . excludeFields
Class < > reflectUpToClass
boolean testRecursive
boolean testTransients
final Locale [] availableLocales = ChoiceFormat . getAvailableLocales () ;
{ mRule . appendTo ( buffer , CalendarReflection . getWeekYear ( calendar ) ) ; }
if ( b . compareTo ( BigDecimal . valueOf ( d ) ) == NUMBER_CONSTANT ) { return d ; }
{ spaceToWrapAt = matcher . start () ; }
@ SuppressWarnings ( STRING_CONSTANT ) final String [] sa = ArrayUtils . add ( stringArray , NUMBER_CONSTANT , aString ) ;
final T . . . array
assertPatternsEqual ( STRING_CONSTANT + locale , expectedPattern , emf . toPattern () ) ;
assertPatternsEqual ( STRING_CONSTANT , pattern , emf . toPattern () ) ;
{ assertEquals ( baseStr + STRING_CONSTANT + SystemUtils.LINE_SEPARATOR + STRING_CONSTANT , new ToStringBuilder ( base ) . toString () ) ; }
{ if ( newLine == null ) { append ( SystemUtils.LINE_SEPARATOR ) ; return this ; } return append ( newLine ) ; }
final String linebreak = SystemUtils.LINE_SEPARATOR ;
final String linebreak = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
final String systemNewLine = SystemUtils.LINE_SEPARATOR ;
if ( newLineStr == null ) { newLineStr = SystemUtils.LINE_SEPARATOR ; }
{ if ( fieldName == null ) { throw new UnsupportedOperationException ( STRING_CONSTANT ) ; } super . appendFieldStart ( buffer , FIELD_NAME_PREFIX + fieldName + FIELD_NAME_PREFIX ) ; }
assertFalse ( CharUtils . isAscii ( CHAR_COPY ) ) ;
final GenericDeclaration d = ( ( TypeVariable < > ) var ) . getGenericDeclaration () ;
{ DateUtils . isSameLocalTime ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameLocalTime ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameInstant ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameInstant ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameInstant ( ( Date ) null , new Date () ) ; }
{ DateUtils . isSameDay ( Calendar . getInstance () , ( Calendar ) null ) ; }
{ DateUtils . isSameDay ( ( Calendar ) null , Calendar . getInstance () ) ; }
{ DateUtils . isSameDay ( new Date () , ( Date ) null ) ; }
{ DateUtils . isSameDay ( ( Date ) null , new Date () ) ; }
assertNull ( LocaleUtils . toLocale ( ( String ) null ) ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( float ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( NUMBER_CONSTANT * NUMBER_CONSTANT , new HashCodeBuilder ( NUMBER_CONSTANT , NUMBER_CONSTANT ) . append ( ( double ) NUMBER_CONSTANT ) . toHashCode () ) ;
assertEquals ( BAR , ObjectUtils . toString ( ( Object ) null , BAR ) ) ;
assertEquals ( STRING_CONSTANT , ObjectUtils . toString ( ( Object ) null ) ) ;
intRange = Range . between ( ( int ) NUMBER_CONSTANT , ( int ) NUMBER_CONSTANT ) ;
assertEquals ( STRING_CONSTANT , BooleanUtils . toString ( ( Boolean ) null , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( ( Boolean ) null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotFalse ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isFalse ( ( Boolean ) null ) ) ;
assertTrue ( BooleanUtils . isNotTrue ( ( Boolean ) null ) ) ;
assertFalse ( BooleanUtils . isTrue ( ( Boolean ) null ) ) ;
assertEquals ( STRING_CONSTANT , ClassUtils . getSimpleName ( ( Class < > ) null ) ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
final MutableInt mutNum = new MutableInt ( ( int ) NUMBER_CONSTANT ) ;
assertSame ( StrMatcher . noneMatcher () , StrMatcher . stringMatcher ( ( String ) null ) ) ;
array = ArrayUtils . removeElement ( ( boolean [] ) null , true ) ;
array = ArrayUtils . removeElement ( ( Object [] ) null , STRING_CONSTANT ) ;
sb . replace ( NUMBER_CONSTANT , NUMBER_CONSTANT , ( String ) null ) ;
sb . setNullText ( ( String ) null ) ;
sb . setNewLineText ( ( String ) null ) ;
final StrBuilder sb5 = new StrBuilder ( ( String ) null ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables . get ( NUMBER_CONSTANT ) ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , throwables [ NUMBER_CONSTANT ] ) ;
assertSame ( ( ( ExceptionWithCause ) cyclicCause . getCause () ) . getCause () , ExceptionUtils . getRootCause ( cyclicCause ) ) ;
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value <= start || value >= end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
{ if ( value < start || value > end ) { throw new IllegalArgumentException ( String . format ( message ) ) ; } }
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
final MutableLong mutNum = new MutableLong ( ( long ) NUMBER_CONSTANT ) ;
longRange = Range . between ( ( long ) NUMBER_CONSTANT , ( long ) NUMBER_CONSTANT ) ;
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ Assert . assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
return parseLocale ( str , len ) ;
classes . add ( cls ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( TEST_MESSAGE ) >= NUMBER_CONSTANT ) ;
assertTrue ( trace . indexOf ( STRING_CONSTANT ) >= NUMBER_CONSTANT ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertTrue ( ! stackTrace . contains ( ExceptionUtils.WRAPPED_MARKER ) ) ;
assertTrue ( ! contextMessage . contains ( TEST_MESSAGE ) ) ;
final HashSet < Integer > toRemove = new HashSet < Integer > () ;
super . appendDetail ( buffer , fieldName , array ) ;
final List < Object > list = new ArrayList <> () ;
public static String getFieldName () { return STRING_CONSTANT ; }
public SelfInstanceTwoVarsReflectionTestFixture () { this . typeIsSelf = this ; }
public SelfInstanceVarReflectionTestFixture () { this . typeIsSelf = this ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
assertSame ( StrMatcher . noneMatcher () , StrMatcher . charSetMatcher ( new char [ NUMBER_CONSTANT ] ) ) ;
{ Validate . noNullElements ( values ) ; return generateBitVector ( enumClass , Arrays . < E > asList ( values ) ) ; }
{ return TypeUtils . < T > wrap ( ( Type ) type ) ; }
if ( typeArguments == null ) { typeArguments = Collections . < TypeVariable < > , Type > emptyMap () ; }
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertTrue ( StringUtils . containsOnly ( str , new char [] { CHAR_CONS } ) ) ;
assertNull ( ObjectUtils . firstNonNull ( new Object [ NUMBER_CONSTANT ] ) ) ;
public void event2 ( PropertyChangeEvent e ) ;
public void event1 ( PropertyChangeEvent e ) ;
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . < T > deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
final List < String > strColl = Arrays . asList ( new String [] { STRING_CONSTANT } ) ;
public TestEmptySubObject ( final int a ) { super ( a ) ; }
public TestSubObject () { super ( NUMBER_CONSTANT ) ; }
public BackgroundInitializerTestImpl () { super(); }
@ SuppressWarnings ( STRING_CONSTANT ) public NestableException () { super(); }
{ return options == null ? false : options . contains ( option ) ; }
final List < Object > list = new ArrayList <> ( NUMBER_CONSTANT ) ;
final List < Object > list = new ArrayList <> ( arraylistInitialCapacity ) ;
final List < Object > list = new ArrayList <> () ;
if ( isEmpty ( str ) || wrapChar == CHAR_CONS ) { return str ; }
if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; }
{ if ( isEmpty ( str ) || wrapWith == CHAR_CONS ) { return str ; } return wrapWith + str + wrapWith ; }
for ( int i = oldEnd ; i < newEnd ; i ++ ) { buffer [ i ] = CHAR_CONS ; }
assertNull ( StringUtils . unwrap ( null , CHAR_CONS ) ) ;
{ return ObjectUtils . equals ( object1 , object2 ) == false ; }
if ( obj instanceof TypeLiteral == false ) { return false ; }
public boolean isFalse () { return value == false ; }
public boolean isTrue () { return value == true ; }
{ if ( expression == false ) { throw new IllegalStateException ( DEFAULT_VALID_STATE_EX_MESSAGE ) ; } }
{ if ( expression == false ) { throw new IllegalArgumentException ( DEFAULT_IS_TRUE_EX_MESSAGE ) ; } }
if ( obj instanceof FastDateFormat == false ) { return false ; }
if ( obj instanceof Fraction == false ) { return false ; }
if ( obj instanceof FastDatePrinter == false ) { return false ; }
if ( toClass . isPrimitive () == false ) { return false ; }
{ if ( isAsciiNumeric ( ch ) == false ) { return defaultValue ; } return ch - NUMBER_CONSTANT ; }
if ( obj instanceof CharSet == false ) { return false ; }
final I arg
final Pair < IDKey , IDKey > swappedPair = Pair . of ( pair . getLeft () , pair . getRight () ) ;
if ( hasNext == false ) { throw new NoSuchElementException () ; }
if ( obj instanceof CharRange == false ) { return false ; }
try { CharUtils . toIntValue ( CHAR_CONS ) ; } catch ( final IllegalArgumentException ex ) {}
if ( tzId . equalsIgnoreCase ( STRING_CONSTANT ) ) { continue; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT + value ) ) ; }
{ cal . setTimeZone ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
{ return toAppendTo . append ( ( ( String ) obj ) . toUpperCase () ) ; }
expected . append ( args [ NUMBER_CONSTANT ] . toString () . toUpperCase () ) ;
assertFalse ( StringUtils . equalsAny ( FOO , FOO . toUpperCase () ) ) ;
{ return toAppendTo . append ( ( ( String ) obj ) . toLowerCase () ) ; }
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
TimeZone . setDefault ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final TimeZone utc = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ;
{ final TimeZone timeZone = TimeZone . getTimeZone ( STRING_CONSTANT ) ; assertFormats ( expectedValue , pattern , timeZone , createFebruaryTestDate ( timeZone ) ) ; }
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
final Calendar c = Calendar . getInstance ( TimeZone . getTimeZone ( STRING_CONSTANT ) ) ;
assertEquals ( null , StringUtils . substring ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , tok . getContent () ) ;
assertEquals ( null , tokenizer . nextToken () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , tok . next () ) ;
assertEquals ( null , ObjectUtils . identityToString ( null ) ) ;
assertEquals ( null , StringUtils . strip ( null ) ) ;
assertEquals ( null , StringUtils . trim ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringYesNo ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringOnOff ( null ) ) ;
assertEquals ( null , BooleanUtils . toStringTrueFalse ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT , STRING_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null , six , seven , null ) ) ;
assertEquals ( null , BooleanUtils . toIntegerObject ( null ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT , NUMBER_CONSTANT ) ) ;
assertEquals ( null , BooleanUtils . toBooleanObject ( ( Integer ) null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJson ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeCsv ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeEcmaScript ( null ) ) ;
assertEquals ( null , StringEscapeUtils . unescapeJava ( null ) ) ;
assertEquals ( null , StringEscapeUtils . escapeJava ( null ) ) ;
assertEquals ( null , new MutableObject <> () . getValue () ) ;
assertEquals ( null , StringUtils . getDigits ( null ) ) ;
assertEquals ( null , StringUtils . wrap ( null , null ) ) ;
assertEquals ( null , StringUtils . rotate ( null , NUMBER_CONSTANT ) ) ;
assertEquals ( null , ClassUtils . getAllInterfaces ( null ) ) ;
assertEquals ( null , ClassUtils . getAllSuperclasses ( null ) ) ;
assertEquals ( null , WordUtils . swapCase ( null ) ) ;
assertEquals ( null , WordUtils . initials ( null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . uncapitalize ( null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalizeFully ( null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null , null ) ) ;
assertEquals ( null , WordUtils . capitalize ( null ) ) ;
{ assertEquals ( null , CharUtils . unicodeEscaped ( null ) ) ; assertEquals ( STRING_CONSTANT , CharUtils . unicodeEscaped ( CHARACTER_A ) ) ; }
assertEquals ( null , CharUtils . toString ( null ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Double.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Float.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( l , Long.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
{ final Integer [] iArray = null ; assertEquals ( null , ArrayUtils . toPrimitive ( iArray , Integer.MIN_VALUE ) ) ; }
assertEquals ( null , ArrayUtils . toPrimitive ( l , Integer.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( s , Short.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Byte.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b , Character.MIN_VALUE ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( null , false ) ) ;
assertEquals ( null , ArrayUtils . toPrimitive ( b ) ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , array ) ;
assertEquals ( null , ArrayUtils . toMap ( null ) ) ;
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , NUMBER_CONSTANT ) ) ; }
{ assertEquals ( null , CharSequenceUtils . subSequence ( StringUtils.EMPTY , - NUMBER_CONSTANT ) ) ; }
{ Assert . assertTrue ( toString . indexOf ( SECRET_VALUE ) > NUMBER_CONSTANT ) ; this . validateNonSecretField ( toString ) ; }
{ Assert . assertEquals ( ArrayUtils.INDEX_NOT_FOUND , toString . indexOf ( SECRET_VALUE ) ) ; this . validateNonSecretField ( toString ) ; }
Assert . assertNotEquals ( summer . getTime () , standard . getTime () ) ;
Assert . assertEquals ( cal . getTime () , date ) ;
Assert . assertEquals ( value , SerializationUtils . deserialize ( serialized ) ) ;
{ watch . getStartTime () ; Assert . assertTrue ( watch . getStartTime () >= beforeStopWatch ) ; }
@ Test public void testUTC () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testZ () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testBareGmt () { Assert . assertEquals ( FastTimeZone . getGmtTimeZone () , FastTimeZone . getTimeZone ( STRING_CONSTANT ) ) ; }
@ Test public void testGetGmtTimeZone () { Assert . assertEquals ( NUMBER_CONSTANT , FastTimeZone . getGmtTimeZone () . getRawOffset () ) ; }
{ Assert . assertEquals ( REPEAT , future . get () . intValue () ) ; }
Assert . assertEquals ( STRING_CONSTANT , TypeUtils . toString ( method . getGenericReturnType () ) ) ;
Assert . assertTrue ( TypeUtils . isAssignable ( fromType , failingToType ) ) ;
Assert . assertArrayEquals ( expectedArray , TypeUtils . normalizeUpperBounds ( typeArray ) ) ;
@ Test public void testInvokeMethodForceAccessNoArgs ( ) throws Exception { Assert . assertEquals ( STRING_CONSTANT , MethodUtils . invokeMethod ( testBean , true , STRING_CONSTANT ) ) ; }
Assert . assertEquals ( expected , hostName ) ;
Assert . assertEquals ( isoForm , printer . format ( vulgar ) ) ;
Assert . assertEquals ( vulgar . getTime () , cal . getTime () ) ;
T object
{ super(); for ( String s : set ) { add ( s ) ; } }
boolean excludeNullValues
StringBuilder builder = new StringBuilder ( count ) ;
catch ( NoSuchMethodException expected ) {}
TimeZone tz = FastTimeZone . getGmtTimeZone ( timeZone ) ;
{ boolean result = RandomUtils . nextBoolean () ; assertTrue ( result == true || result == false ) ; }
Object other
@ Override public boolean inDaylightTime ( Date date ) { return false ; }
@ Override public void setRawOffset ( int offsetMillis ) { throw new UnsupportedOperationException () ; }
Class < > anInterface
ReflectionToStringBuilder oldBuilder = new ReflectionToStringBuilder ( BOTH_NULL ) ;
for ( char chr : chrs ) { if ( chars . contains ( chr ) == expect ) { buffer . append ( chr ) ; } }
String group
String group
double [] array
float [] array
long [] array
int [] array
short [] array
char [] array
byte [] array
boolean [] array
Object [] array
String . . . s
CharRange a = CharRange . is ( CHAR_CONS ) ;
CharSequence cs
String value
{ list . add ( throwable ) ; throwable = ExceptionUtils . getCause ( throwable ) ; }
assertTrue ( STRING_CONSTANT , delta < NUMBER_CONSTANT ) ;
{ return performStateCheck ( NUMBER_CONSTANT ) ; }
this . typeArguments = typeArguments . clone () ;
daemonFlag = null ;
{ daemonFlag = Boolean . valueOf ( f ) ; return this ; }
daemonFlag = builder.daemonFlag ;
public final Boolean getDaemonFlag () { return daemonFlag ; }
daemonFlag = builder.daemon ;
{ return valueAsString . startsWith ( getArrayStart () ) && valueAsString . startsWith ( getArrayEnd () ) ; }
{ return str == null ? EMPTY : str ; }
final String sanitizedSeparator = defaultString ( separator , StringUtils.EMPTY ) ;
if ( str == null || suffix == null ) { return str == null && suffix == null ; }
if ( str == null || prefix == null ) { return str == null && prefix == null ; }
{ bypassReflectionClasses = new ArrayList < Class < > > () ; bypassReflectionClasses . add ( String . class ) ; }
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
ArrayUtils . shuffle ( array1 ) ;
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
for ( Field field : allFields ) { if ( field . getName () . equals ( STRING_CONSTANT ) ) { expected ++ ; } }
{ buffer . append ( CHAR_CONS ) . append ( value ) . append ( CHAR_CONS ) ; }
super . appendFieldStart ( buffer , FIELD_NAME_QUOTE + fieldName + FIELD_NAME_QUOTE ) ;
if ( ! iterator . hasNext () ) { return Objects . toString ( first , STRING_CONSTANT ) ; }
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
final StringBuilder buf = new StringBuilder ( noOfItems * NUMBER_CONSTANT ) ;
int [] indexesToRemove = new int [] {} ;
return str . length () > NUMBER_CONSTANT ;
if ( diffs . size () == NUMBER_CONSTANT ) { return OBJECTS_SAME_STRING ; }
{ return SystemUtils.IS_OS_WINDOWS ? System . getenv ( STRING_CONSTANT ) : System . getenv ( STRING_CONSTANT ) ; }
private Object readResolve () { return ToStringStyle.JSON_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_CLASS_NAME_STYLE ; }
private Object readResolve () { return ToStringStyle.MULTI_LINE_STYLE ; }
private Object readResolve () { return ToStringStyle.SIMPLE_STYLE ; }
private Object readResolve () { return ToStringStyle.SHORT_PREFIX_STYLE ; }
private Object readResolve () { return ToStringStyle.NO_FIELD_NAMES_STYLE ; }
private Object readResolve () { return ToStringStyle.DEFAULT_STYLE ; }
return StrSubstitutor . replace ( source , valueMap ) ;
return Fraction . getFraction ( numerator / gcd , denominator / gcd ) ;
{ Validate . isTrue ( objectData != null , STRING_CONSTANT ) ; return SerializationUtils . deserialize ( new ByteArrayInputStream ( objectData ) ) ; }
{ return ( T ) SerializationUtils . deserialize ( SerializationUtils . serialize ( msg ) ) ; }
Throwable root = ExceptionUtils . getRootCause ( th ) ;
final Throwable [] throwables = ExceptionUtils . getThrowables ( throwable ) ;
final int srcLength = ArrayUtils . getLength ( array ) ;
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
if ( ArrayUtils . isEmpty ( array ) ) { return INDEX_NOT_FOUND ; }
private Object readResolve () { return ObjectUtils.NULL ; }
{ final int tmpHash = ObjectUtils . hashCode ( object ) ; hash = hash * NUMBER_CONSTANT + tmpHash ; }
{ return ! ObjectUtils . equals ( object1 , object2 ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return MemberUtils . isMatchingExecutable ( Executable . of ( method ) , parameterTypes ) ; }
{ return ClassUtils . getPackageName ( getCanonicalName ( canonicalName ) ) ; }
{ return ClassUtils . getShortClassName ( getCanonicalName ( canonicalName ) ) ; }
{ return TypeUtils . wrap ( ( Type ) type ) ; }
{ Validate . isTrue ( TypeUtils . isAssignable ( owner , raw . getEnclosingClass () ) , STRING_CONSTANT , owner , raw ) ; useOwner = owner ; }
{ parameterizedTypeArguments = new HashMap <> ( typeArguments ) ; parameterizedTypeArguments . putAll ( TypeUtils . getTypeArguments ( p ) ) ; }
Validate . notNull ( chars ) ;
Validate . notNull ( collection ) ;
Validate . notNull ( array ) ;
Validate . notNull ( iterable ) ;
Validate . notNull ( array ) ;
if ( StringUtils . isEmpty ( str ) ) { return str ; }
{ return replaceFirst ( text , regex , StringUtils.EMPTY ) ; }
return pattern . matcher ( decomposed ) . replaceAll ( StringUtils.EMPTY ) ;
{ return iValue != NUMBER_CONSTANT ? iValue + NUMBER_CONSTANT : Calendar.SUNDAY ; }
{ _mask = mask ; _shift_count = mask != NUMBER_CONSTANT ? Integer . numberOfTrailingZeros ( mask ) : NUMBER_CONSTANT ; }
mRule . appendTo ( buffer , value != Calendar.SUNDAY ? value - NUMBER_CONSTANT : NUMBER_CONSTANT ) ;
if ( lhs ) { comparison = + NUMBER_CONSTANT ; } else { comparison = - NUMBER_CONSTANT ; }
if ( rhs == null ) { comparison = + NUMBER_CONSTANT ; return this ; }
try { retDT = new DateTime ( s ) ; } catch ( ParseException pe ) {}
ParseException e
Object f
Object f
Object f
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
int minDigits
DateTimeField field
DateTimeField field
char c
Object element
DateTimeParser parser
DateTimeParser parser
DateTimePrinter printer
DateTimeFormatter formatter
Chronology chrono
DateTimeZone zone
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
int digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ;
{ digits = ( int ) ( Math . log ( value ) / LOG_10 ) + NUMBER_CONSTANT ; }
Chronology chrono = ISOChronology . getInstanceUTC () ;
public int getMinimumValue ( long millis ) { return NUMBER_CONSTANT ; }
int value
long millis
GJWeekyearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
ReadableInstant instant
public int get ( long millis ) { return BuddhistChronology.BE ; }
public String getNameKey ( long millis ) { return iNameKey ; }
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
ParseException pe
{ return add ( millis , value - get ( millis ) ) ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
public long add ( long millis , int value ) { return millis + value * iChronology.MILLIS_PER_DAY ; }
return ( getMillis () < readableInstant . getMillis () ) ;
{ Chronology chrono = getChronology () ; return chrono != null ? chrono . getDateTimeZone () : null ; }
public AbstractInstant () { super(); }
catch ( ParseException pe ) { pe . printStackTrace () ; }
try { retDT = new DateTime ( s , DateTimeZone.UTC ) ; } catch ( ParseException pe ) { pe . printStackTrace () ; }
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
int value
if ( zone == null ) { throw new IllegalArgumentException ( STRING_CONSTANT ) ; }
GJMonthOfYearDateTimeField ( ProlepticChronology chronology ) { super ( STRING_CONSTANT ) ; iChronology = chronology ; }
int value
public abstract boolean equals ( Object obj ) ;
public String print ( long millisUTC ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { throw unsupported () ; }
public String print ( ReadableInstant instant ) { return mPrinter . print ( instant ) ; }
char c
char style
char style
public RealMatrix copy () { return null ; }
seenNames . add ( nameNode . getQualifiedName () ) ;
{ if ( seenNames . contains ( nameNode . getQualifiedName () ) ) { return RemovalType.REMOVE_ALL ; } jsdocNode . setJSDocInfo ( getAllTypeJSDoc () ) ; return RemovalType.REMOVE_RHS ; }
NodeTraversal . traverseEs6 ( compiler , root , new RemoveCode ( compiler ) ) ;
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( StandardPieToolTipGenerator.DEFAULT_SECTION_LABEL_FORMAT ) ) ; }
if ( tooltips ) { plot . setToolTipGenerator ( new StandardPieToolTipGenerator ( StandardPieToolTipGenerator.DEFAULT_SECTION_LABEL_FORMAT ) ) ; }
public int getLength () { return NUMBER_CONSTANT ; }
