=================================================
Project : math_68	start : 18/01/14 03:25
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackFreudensteinRoth | 18/01/14 03:27
Sun Jan 14 03:28:56 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,381
Sun Jan 14 03:30:51 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Sun Jan 14 03:36:44 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,608
Sun Jan 14 03:36:47 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,510
Sun Jan 14 03:49:08 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,511
Sun Jan 14 03:49:12 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,512
Sun Jan 14 03:49:17 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,514
Sun Jan 14 04:02:43 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,515
Sun Jan 14 05:51:21 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,516
Sun Jan 14 05:51:26 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,517
Sun Jan 14 05:51:29 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,518
Sun Jan 14 05:51:33 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,519
Sun Jan 14 05:51:37 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,521
Sun Jan 14 05:51:41 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,522
Sun Jan 14 05:51:45 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,523
Sun Jan 14 05:51:49 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,525
Timeout time : 18/01/14 05:58
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson | 18/01/14 05:58
Sun Jan 14 06:00:05 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,381

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
costRelativeTolerance=0;
if((0.1*cost>=previousCost)||(tmp<0.1)){
tmp=0.1;
}

Time : 18/01/14 06:01
----------------------------------------
Sun Jan 14 06:02:41 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,606

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp<0){
paru=Math.min(paru,lmPar);
return ;
}

Time : 18/01/14 06:05
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=dxNorm-delta;
if(fp<0){
paru=Math.min(paru,lmPar);
return ;
}

Time : 18/01/14 06:06
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp<0){
lmPar*=0.5;
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:08
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=lmPar;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(delta>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:14
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:16
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=parl-fp;
if(fp>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:17
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(delta>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:18
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
return ;
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:20
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:22
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/14 06:23
----------------------------------------
Sun Jan 14 06:25:55 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Sun Jan 14 06:26:00 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,608
Sun Jan 14 06:26:04 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,510

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:27
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:28
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:32
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[j]/dxNorm;
}

Time : 18/01/14 06:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:35
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=orthoTolerance;
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:37
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}

Time : 18/01/14 06:39
----------------------------------------
Sun Jan 14 06:43:44 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,511
Sun Jan 14 06:43:49 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,512
Sun Jan 14 06:43:52 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,514

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:45
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:46
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:47
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[j]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:51
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:55
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[rank]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:57
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<=solvedCols-rank;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=0;

Time : 18/01/14 06:58
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]*=diag[pj]/dxNorm;
}
sum2=rank;

Time : 18/01/14 07:02
----------------------------------------
Sun Jan 14 07:04:29 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,515

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum++;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 18/01/14 07:06
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][j]*work1[permutation[i]];
}

Time : 18/01/14 07:07
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}

Time : 18/01/14 07:08
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 18/01/14 07:10
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=0;i<j;++i){
sum+=jacobian[i][permutation[pj]]*work1[permutation[i]];
}

Time : 18/01/14 07:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=pj;i<j;++i){
sum+=jacobian[i][permutation[pj]]*work1[permutation[i]];
}

Time : 18/01/14 07:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 18/01/14 07:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
sum*=orthoTolerance;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}

Time : 18/01/14 07:21
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 07:46
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][j]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 07:48
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 07:52
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=pj;i<j;++i){
sum+=jacobian[i][i]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 07:54
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=solvedCols;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:12
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=solvedCols;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
int sum=rank;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[pj];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:14
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[j];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:23
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<rank;++j){
int pj=permutation[j];
double sum=0;
for(int i=0;i<j;++i){
sum+=jacobian[i][pj]*work1[permutation[i]];
}
double s=(work1[pj]-sum)/diagR[j];
work1[pj]=s;
sum2+=s*s;
}

Time : 18/01/14 08:24
----------------------------------------
Timeout time : 18/01/14 08:30
