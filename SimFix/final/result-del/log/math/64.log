=================================================
Project : math_64	start : 18/01/15 16:10
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackFreudensteinRoth | 18/01/15 16:12
Mon Jan 15 16:15:20 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,402
Mon Jan 15 16:18:09 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,627
Mon Jan 15 16:26:36 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,628
Mon Jan 15 16:26:41 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,605
Mon Jan 15 16:50:43 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,606
Mon Jan 15 16:50:48 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Mon Jan 15 16:50:53 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,609
Mon Jan 15 18:05:10 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,610
Mon Jan 15 18:05:14 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,611
Mon Jan 15 18:05:19 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,612
Mon Jan 15 18:05:23 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,613
Mon Jan 15 18:05:30 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,614
Mon Jan 15 18:05:36 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,617
Timeout time : 18/01/15 18:45
Current failed test : org.apache.commons.math.optimization.general.MinpackTest::testMinpackJennrichSampson | 18/01/15 18:45
Mon Jan 15 18:46:40 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,402

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
costRelativeTolerance=0;
if((0.1*cost>=previousCost)||(tmp<0.1)){
tmp=0.1;
}

Time : 18/01/15 18:48
----------------------------------------
Mon Jan 15 18:49:50 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,627

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp<0){
lmPar*=0.5;
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 18:54
----------------------------------------
Mon Jan 15 18:57:54 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,628
Mon Jan 15 18:58:00 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,626

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=lmPar;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 18:59
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:01
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:03
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:04
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:06
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(fp>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:08
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
parl=Math.sqrt(dxNorm);
paru=parl-fp;
if(delta>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:09
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:11
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(fp>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:13
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
if(lmPar>0){
lmPar*=0.5;
parl=Math.max(parl,lmPar);
}else if(fp<0){
paru=Math.min(paru,lmPar);
}

Time : 18/01/15 19:15
----------------------------------------
Mon Jan 15 19:18:33 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,605

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[j]/dxNorm;
}

Time : 18/01/15 19:28
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=gNorm;
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 18/01/15 19:30
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
dxNorm*=gNorm;
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 18/01/15 19:31
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols-countdown;++j){
int pj=permutation[j];
work1[pj]=work3[pj]*diag[pj]/dxNorm;
}

Time : 18/01/15 19:33
----------------------------------------
Mon Jan 15 19:37:48 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,606
Mon Jan 15 19:37:54 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,607
Mon Jan 15 19:37:58 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,609

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:38
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<=j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:40
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:41
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
j++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:43
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp++;
j++;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:44
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][i]*tmp;
}

Time : 18/01/15 19:47
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
tmp=Math.round(sPar);
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:51
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<permutation[pj];++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:53
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<tmp-i;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 19:59
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][j]*tmp;
}

Time : 18/01/15 20:02
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
lmPar/=sPar;
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}

Time : 18/01/15 20:03
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:05
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:06
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<=j;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:07
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:09
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:15
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:18
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=rank;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:19
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][j]*tmp;
}
}

Time : 18/01/15 20:20
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols-i;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:26
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=solvedCols;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:32
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=countdown;j<solvedCols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[countdown];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:34
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<cols;++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[j];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:36
----------------------------------------

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<(solvedCols>>1);++j){
int pj=permutation[j];
work1[pj]/=work2[j];
double tmp=work1[pj];
for(int i=j+1;i<solvedCols;++i){
work1[permutation[i]]-=jacobian[i][pj]*tmp;
}
}

Time : 18/01/15 20:55
----------------------------------------
Mon Jan 15 21:04:37 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,610
Mon Jan 15 21:04:41 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,611
Mon Jan 15 21:04:46 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,612
Mon Jan 15 21:04:51 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,613
Mon Jan 15 21:04:55 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,614
Mon Jan 15 21:04:58 AEDT 2018 org.apache.commons.math.optimization.general.LevenbergMarquardtOptimizer,617

----------------------------------------
----------------------------------------
Pass Single Test : [=>0,0]
for(int j=0;j<solvedCols;++j){
++j;
double s=work1[permutation[j]];
sum2+=s*s;
}

Time : 18/01/15 21:08
----------------------------------------
Timeout time : 18/01/15 21:17
